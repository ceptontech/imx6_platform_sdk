/*
 * Copyright (C) 2012, Freescale Semiconductor, Inc. All Rights Reserved
 * THIS SOURCE CODE IS CONFIDENTIAL AND PROPRIETARY AND MAY NOT
 * BE USED OR DISTRIBUTED WITHOUT THE WRITTEN PERMISSION OF
 * Freescale Semiconductor, Inc.
 */

#ifndef __HW_CSU_REGISTERS_H__
#define __HW_CSU_REGISTERS_H__

#include "regs.h"

/*
 * i.MX6DQ CSU registers defined in this header file.
 *
 * - HW_CSU_CSL0 - Config security level register
 * - HW_CSU_CSL1 - Config security level register
 * - HW_CSU_CSL2 - Config security level register
 * - HW_CSU_CSL3 - Config security level register
 * - HW_CSU_CSL4 - Config security level register
 * - HW_CSU_CSL5 - Config security level register
 * - HW_CSU_CSL6 - Config security level register
 * - HW_CSU_CSL7 - Config security level register
 * - HW_CSU_CSL8 - Config security level register
 * - HW_CSU_CSL9 - Config security level register
 * - HW_CSU_CSL10 - Config security level register
 * - HW_CSU_CSL11 - Config security level register
 * - HW_CSU_CSL12 - Config security level register
 * - HW_CSU_CSL13 - Config security level register
 * - HW_CSU_CSL14 - Config security level register
 * - HW_CSU_CSL15 - Config security level register
 * - HW_CSU_CSL16 - Config security level register
 * - HW_CSU_CSL17 - Config security level register
 * - HW_CSU_CSL18 - Config security level register
 * - HW_CSU_CSL19 - Config security level register
 * - HW_CSU_CSL20 - Config security level register
 * - HW_CSU_CSL21 - Config security level register
 * - HW_CSU_CSL22 - Config security level register
 * - HW_CSU_CSL23 - Config security level register
 * - HW_CSU_CSL24 - Config security level register
 * - HW_CSU_CSL25 - Config security level register
 * - HW_CSU_CSL26 - Config security level register
 * - HW_CSU_CSL27 - Config security level register
 * - HW_CSU_CSL28 - Config security level register
 * - HW_CSU_CSL29 - Config security level register
 * - HW_CSU_CSL30 - Config security level register
 * - HW_CSU_CSL31 - Config security level register
 * - HW_CSU_CSL32 - Config security level register
 * - HW_CSU_CSL33 - Config security level register
 * - HW_CSU_CSL34 - Config security level register
 * - HW_CSU_CSL35 - Config security level register
 * - HW_CSU_CSL36 - Config security level register
 * - HW_CSU_CSL37 - Config security level register
 * - HW_CSU_CSL38 - Config security level register
 * - HW_CSU_CSL39 - Config security level register
 * - HW_CSU_HP0 - HP0 register
 * - HW_CSU_HP1 - HP1 register
 * - HW_CSU_SA - Secure access register
 * - HW_CSU_HPCONTROL0 - HPCONTROL0 register
 * - HW_CSU_HPCONTROL1 - HPCONTROL1 register
 *
 * - hw_csu_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_CSU_BASE
#define HW_CSU_INSTANCE_COUNT (1) //!< Number of instances of the CSU module.
#define REGS_CSU_BASE (0x021c0000) //!< Base address for CSU.
#endif
//@}

// Typecast macro for C or asm. In C, the cast is applied, while in asm it is excluded. This is
// used to simplify macro definitions below.
#ifndef __REG_VALUE_TYPE
#ifndef __LANGUAGE_ASM__
#define __REG_VALUE_TYPE(v, t) ((t)(v))
#else
#define __REG_VALUE_TYPE(v, t) (v)
#endif
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL0 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL0 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl0
{
    reg32_t U;
    struct _hw_csu_csl0_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl0_t;
#endif

/*
 * constants & macros for entire CSU_CSL0 register
 */
#define HW_CSU_CSL0_ADDR      (REGS_CSU_BASE + 0x0)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL0           (*(volatile hw_csu_csl0_t *) HW_CSU_CSL0_ADDR)
#define HW_CSU_CSL0_RD()      (HW_CSU_CSL0.U)
#define HW_CSU_CSL0_WR(v)     (HW_CSU_CSL0.U = (v))
#define HW_CSU_CSL0_SET(v)    (HW_CSU_CSL0_WR(HW_CSU_CSL0_RD() |  (v)))
#define HW_CSU_CSL0_CLR(v)    (HW_CSU_CSL0_WR(HW_CSU_CSL0_RD() & ~(v)))
#define HW_CSU_CSL0_TOG(v)    (HW_CSU_CSL0_WR(HW_CSU_CSL0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL0 bitfields
 */

/* --- Register HW_CSU_CSL0, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL0_SUR_S2      (0)      //!< Bit position for CSU_CSL0_SUR_S2.
#define BM_CSU_CSL0_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL0_SUR_S2.

//! @brief Get value of CSU_CSL0_SUR_S2 from a register value.
#define BG_CSU_CSL0_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_SUR_S2) >> BP_CSU_CSL0_SUR_S2)

//! @brief Format value for bitfield CSU_CSL0_SUR_S2.
#define BF_CSU_CSL0_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_SUR_S2) & BM_CSU_CSL0_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL0_SUR_S2(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_SUR_S2) | BF_CSU_CSL0_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL0, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL0_SSR_S2      (1)      //!< Bit position for CSU_CSL0_SSR_S2.
#define BM_CSU_CSL0_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL0_SSR_S2.

//! @brief Get value of CSU_CSL0_SSR_S2 from a register value.
#define BG_CSU_CSL0_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_SSR_S2) >> BP_CSU_CSL0_SSR_S2)

//! @brief Format value for bitfield CSU_CSL0_SSR_S2.
#define BF_CSU_CSL0_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_SSR_S2) & BM_CSU_CSL0_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL0_SSR_S2(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_SSR_S2) | BF_CSU_CSL0_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL0, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL0_NUR_S2      (2)      //!< Bit position for CSU_CSL0_NUR_S2.
#define BM_CSU_CSL0_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL0_NUR_S2.

//! @brief Get value of CSU_CSL0_NUR_S2 from a register value.
#define BG_CSU_CSL0_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_NUR_S2) >> BP_CSU_CSL0_NUR_S2)

//! @brief Format value for bitfield CSU_CSL0_NUR_S2.
#define BF_CSU_CSL0_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_NUR_S2) & BM_CSU_CSL0_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL0_NUR_S2(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_NUR_S2) | BF_CSU_CSL0_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL0, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL0_NSR_S2      (3)      //!< Bit position for CSU_CSL0_NSR_S2.
#define BM_CSU_CSL0_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL0_NSR_S2.

//! @brief Get value of CSU_CSL0_NSR_S2 from a register value.
#define BG_CSU_CSL0_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_NSR_S2) >> BP_CSU_CSL0_NSR_S2)

//! @brief Format value for bitfield CSU_CSL0_NSR_S2.
#define BF_CSU_CSL0_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_NSR_S2) & BM_CSU_CSL0_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL0_NSR_S2(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_NSR_S2) | BF_CSU_CSL0_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL0, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL0_SUW_S2      (4)      //!< Bit position for CSU_CSL0_SUW_S2.
#define BM_CSU_CSL0_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL0_SUW_S2.

//! @brief Get value of CSU_CSL0_SUW_S2 from a register value.
#define BG_CSU_CSL0_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_SUW_S2) >> BP_CSU_CSL0_SUW_S2)

//! @brief Format value for bitfield CSU_CSL0_SUW_S2.
#define BF_CSU_CSL0_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_SUW_S2) & BM_CSU_CSL0_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL0_SUW_S2(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_SUW_S2) | BF_CSU_CSL0_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL0, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL0_SSW_S2      (5)      //!< Bit position for CSU_CSL0_SSW_S2.
#define BM_CSU_CSL0_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL0_SSW_S2.

//! @brief Get value of CSU_CSL0_SSW_S2 from a register value.
#define BG_CSU_CSL0_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_SSW_S2) >> BP_CSU_CSL0_SSW_S2)

//! @brief Format value for bitfield CSU_CSL0_SSW_S2.
#define BF_CSU_CSL0_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_SSW_S2) & BM_CSU_CSL0_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL0_SSW_S2(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_SSW_S2) | BF_CSU_CSL0_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL0, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL0_NUW_S2      (6)      //!< Bit position for CSU_CSL0_NUW_S2.
#define BM_CSU_CSL0_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL0_NUW_S2.

//! @brief Get value of CSU_CSL0_NUW_S2 from a register value.
#define BG_CSU_CSL0_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_NUW_S2) >> BP_CSU_CSL0_NUW_S2)

//! @brief Format value for bitfield CSU_CSL0_NUW_S2.
#define BF_CSU_CSL0_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_NUW_S2) & BM_CSU_CSL0_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL0_NUW_S2(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_NUW_S2) | BF_CSU_CSL0_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL0, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL0_NSW_S2      (7)      //!< Bit position for CSU_CSL0_NSW_S2.
#define BM_CSU_CSL0_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL0_NSW_S2.

//! @brief Get value of CSU_CSL0_NSW_S2 from a register value.
#define BG_CSU_CSL0_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_NSW_S2) >> BP_CSU_CSL0_NSW_S2)

//! @brief Format value for bitfield CSU_CSL0_NSW_S2.
#define BF_CSU_CSL0_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_NSW_S2) & BM_CSU_CSL0_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL0_NSW_S2(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_NSW_S2) | BF_CSU_CSL0_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL0, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL0_LOCK_S2      (8)      //!< Bit position for CSU_CSL0_LOCK_S2.
#define BM_CSU_CSL0_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL0_LOCK_S2.

//! @brief Get value of CSU_CSL0_LOCK_S2 from a register value.
#define BG_CSU_CSL0_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_LOCK_S2) >> BP_CSU_CSL0_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL0_LOCK_S2.
#define BF_CSU_CSL0_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_LOCK_S2) & BM_CSU_CSL0_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL0_LOCK_S2(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_LOCK_S2) | BF_CSU_CSL0_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL0, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL0_SUR_S1      (16)      //!< Bit position for CSU_CSL0_SUR_S1.
#define BM_CSU_CSL0_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL0_SUR_S1.

//! @brief Get value of CSU_CSL0_SUR_S1 from a register value.
#define BG_CSU_CSL0_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_SUR_S1) >> BP_CSU_CSL0_SUR_S1)

//! @brief Format value for bitfield CSU_CSL0_SUR_S1.
#define BF_CSU_CSL0_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_SUR_S1) & BM_CSU_CSL0_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL0_SUR_S1(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_SUR_S1) | BF_CSU_CSL0_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL0, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL0_SSR_S1      (17)      //!< Bit position for CSU_CSL0_SSR_S1.
#define BM_CSU_CSL0_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL0_SSR_S1.

//! @brief Get value of CSU_CSL0_SSR_S1 from a register value.
#define BG_CSU_CSL0_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_SSR_S1) >> BP_CSU_CSL0_SSR_S1)

//! @brief Format value for bitfield CSU_CSL0_SSR_S1.
#define BF_CSU_CSL0_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_SSR_S1) & BM_CSU_CSL0_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL0_SSR_S1(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_SSR_S1) | BF_CSU_CSL0_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL0, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL0_NUR_S1      (18)      //!< Bit position for CSU_CSL0_NUR_S1.
#define BM_CSU_CSL0_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL0_NUR_S1.

//! @brief Get value of CSU_CSL0_NUR_S1 from a register value.
#define BG_CSU_CSL0_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_NUR_S1) >> BP_CSU_CSL0_NUR_S1)

//! @brief Format value for bitfield CSU_CSL0_NUR_S1.
#define BF_CSU_CSL0_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_NUR_S1) & BM_CSU_CSL0_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL0_NUR_S1(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_NUR_S1) | BF_CSU_CSL0_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL0, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL0_NSR_S1      (19)      //!< Bit position for CSU_CSL0_NSR_S1.
#define BM_CSU_CSL0_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL0_NSR_S1.

//! @brief Get value of CSU_CSL0_NSR_S1 from a register value.
#define BG_CSU_CSL0_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_NSR_S1) >> BP_CSU_CSL0_NSR_S1)

//! @brief Format value for bitfield CSU_CSL0_NSR_S1.
#define BF_CSU_CSL0_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_NSR_S1) & BM_CSU_CSL0_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL0_NSR_S1(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_NSR_S1) | BF_CSU_CSL0_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL0, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL0_SUW_S1      (20)      //!< Bit position for CSU_CSL0_SUW_S1.
#define BM_CSU_CSL0_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL0_SUW_S1.

//! @brief Get value of CSU_CSL0_SUW_S1 from a register value.
#define BG_CSU_CSL0_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_SUW_S1) >> BP_CSU_CSL0_SUW_S1)

//! @brief Format value for bitfield CSU_CSL0_SUW_S1.
#define BF_CSU_CSL0_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_SUW_S1) & BM_CSU_CSL0_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL0_SUW_S1(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_SUW_S1) | BF_CSU_CSL0_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL0, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL0_SSW_S1      (21)      //!< Bit position for CSU_CSL0_SSW_S1.
#define BM_CSU_CSL0_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL0_SSW_S1.

//! @brief Get value of CSU_CSL0_SSW_S1 from a register value.
#define BG_CSU_CSL0_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_SSW_S1) >> BP_CSU_CSL0_SSW_S1)

//! @brief Format value for bitfield CSU_CSL0_SSW_S1.
#define BF_CSU_CSL0_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_SSW_S1) & BM_CSU_CSL0_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL0_SSW_S1(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_SSW_S1) | BF_CSU_CSL0_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL0, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL0_NUW_S1      (22)      //!< Bit position for CSU_CSL0_NUW_S1.
#define BM_CSU_CSL0_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL0_NUW_S1.

//! @brief Get value of CSU_CSL0_NUW_S1 from a register value.
#define BG_CSU_CSL0_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_NUW_S1) >> BP_CSU_CSL0_NUW_S1)

//! @brief Format value for bitfield CSU_CSL0_NUW_S1.
#define BF_CSU_CSL0_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_NUW_S1) & BM_CSU_CSL0_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL0_NUW_S1(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_NUW_S1) | BF_CSU_CSL0_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL0, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL0_NSW_S1      (23)      //!< Bit position for CSU_CSL0_NSW_S1.
#define BM_CSU_CSL0_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL0_NSW_S1.

//! @brief Get value of CSU_CSL0_NSW_S1 from a register value.
#define BG_CSU_CSL0_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_NSW_S1) >> BP_CSU_CSL0_NSW_S1)

//! @brief Format value for bitfield CSU_CSL0_NSW_S1.
#define BF_CSU_CSL0_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_NSW_S1) & BM_CSU_CSL0_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL0_NSW_S1(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_NSW_S1) | BF_CSU_CSL0_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL0, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL0_LOCK_S1      (24)      //!< Bit position for CSU_CSL0_LOCK_S1.
#define BM_CSU_CSL0_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL0_LOCK_S1.

//! @brief Get value of CSU_CSL0_LOCK_S1 from a register value.
#define BG_CSU_CSL0_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL0_LOCK_S1) >> BP_CSU_CSL0_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL0_LOCK_S1.
#define BF_CSU_CSL0_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL0_LOCK_S1) & BM_CSU_CSL0_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL0_LOCK_S1(v)   (HW_CSU_CSL0_WR((HW_CSU_CSL0_RD() & ~BM_CSU_CSL0_LOCK_S1) | BF_CSU_CSL0_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL1 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL1 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl1
{
    reg32_t U;
    struct _hw_csu_csl1_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl1_t;
#endif

/*
 * constants & macros for entire CSU_CSL1 register
 */
#define HW_CSU_CSL1_ADDR      (REGS_CSU_BASE + 0x4)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL1           (*(volatile hw_csu_csl1_t *) HW_CSU_CSL1_ADDR)
#define HW_CSU_CSL1_RD()      (HW_CSU_CSL1.U)
#define HW_CSU_CSL1_WR(v)     (HW_CSU_CSL1.U = (v))
#define HW_CSU_CSL1_SET(v)    (HW_CSU_CSL1_WR(HW_CSU_CSL1_RD() |  (v)))
#define HW_CSU_CSL1_CLR(v)    (HW_CSU_CSL1_WR(HW_CSU_CSL1_RD() & ~(v)))
#define HW_CSU_CSL1_TOG(v)    (HW_CSU_CSL1_WR(HW_CSU_CSL1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL1 bitfields
 */

/* --- Register HW_CSU_CSL1, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL1_SUR_S2      (0)      //!< Bit position for CSU_CSL1_SUR_S2.
#define BM_CSU_CSL1_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL1_SUR_S2.

//! @brief Get value of CSU_CSL1_SUR_S2 from a register value.
#define BG_CSU_CSL1_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_SUR_S2) >> BP_CSU_CSL1_SUR_S2)

//! @brief Format value for bitfield CSU_CSL1_SUR_S2.
#define BF_CSU_CSL1_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_SUR_S2) & BM_CSU_CSL1_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL1_SUR_S2(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_SUR_S2) | BF_CSU_CSL1_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL1, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL1_SSR_S2      (1)      //!< Bit position for CSU_CSL1_SSR_S2.
#define BM_CSU_CSL1_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL1_SSR_S2.

//! @brief Get value of CSU_CSL1_SSR_S2 from a register value.
#define BG_CSU_CSL1_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_SSR_S2) >> BP_CSU_CSL1_SSR_S2)

//! @brief Format value for bitfield CSU_CSL1_SSR_S2.
#define BF_CSU_CSL1_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_SSR_S2) & BM_CSU_CSL1_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL1_SSR_S2(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_SSR_S2) | BF_CSU_CSL1_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL1, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL1_NUR_S2      (2)      //!< Bit position for CSU_CSL1_NUR_S2.
#define BM_CSU_CSL1_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL1_NUR_S2.

//! @brief Get value of CSU_CSL1_NUR_S2 from a register value.
#define BG_CSU_CSL1_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_NUR_S2) >> BP_CSU_CSL1_NUR_S2)

//! @brief Format value for bitfield CSU_CSL1_NUR_S2.
#define BF_CSU_CSL1_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_NUR_S2) & BM_CSU_CSL1_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL1_NUR_S2(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_NUR_S2) | BF_CSU_CSL1_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL1, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL1_NSR_S2      (3)      //!< Bit position for CSU_CSL1_NSR_S2.
#define BM_CSU_CSL1_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL1_NSR_S2.

//! @brief Get value of CSU_CSL1_NSR_S2 from a register value.
#define BG_CSU_CSL1_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_NSR_S2) >> BP_CSU_CSL1_NSR_S2)

//! @brief Format value for bitfield CSU_CSL1_NSR_S2.
#define BF_CSU_CSL1_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_NSR_S2) & BM_CSU_CSL1_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL1_NSR_S2(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_NSR_S2) | BF_CSU_CSL1_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL1, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL1_SUW_S2      (4)      //!< Bit position for CSU_CSL1_SUW_S2.
#define BM_CSU_CSL1_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL1_SUW_S2.

//! @brief Get value of CSU_CSL1_SUW_S2 from a register value.
#define BG_CSU_CSL1_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_SUW_S2) >> BP_CSU_CSL1_SUW_S2)

//! @brief Format value for bitfield CSU_CSL1_SUW_S2.
#define BF_CSU_CSL1_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_SUW_S2) & BM_CSU_CSL1_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL1_SUW_S2(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_SUW_S2) | BF_CSU_CSL1_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL1, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL1_SSW_S2      (5)      //!< Bit position for CSU_CSL1_SSW_S2.
#define BM_CSU_CSL1_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL1_SSW_S2.

//! @brief Get value of CSU_CSL1_SSW_S2 from a register value.
#define BG_CSU_CSL1_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_SSW_S2) >> BP_CSU_CSL1_SSW_S2)

//! @brief Format value for bitfield CSU_CSL1_SSW_S2.
#define BF_CSU_CSL1_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_SSW_S2) & BM_CSU_CSL1_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL1_SSW_S2(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_SSW_S2) | BF_CSU_CSL1_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL1, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL1_NUW_S2      (6)      //!< Bit position for CSU_CSL1_NUW_S2.
#define BM_CSU_CSL1_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL1_NUW_S2.

//! @brief Get value of CSU_CSL1_NUW_S2 from a register value.
#define BG_CSU_CSL1_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_NUW_S2) >> BP_CSU_CSL1_NUW_S2)

//! @brief Format value for bitfield CSU_CSL1_NUW_S2.
#define BF_CSU_CSL1_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_NUW_S2) & BM_CSU_CSL1_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL1_NUW_S2(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_NUW_S2) | BF_CSU_CSL1_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL1, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL1_NSW_S2      (7)      //!< Bit position for CSU_CSL1_NSW_S2.
#define BM_CSU_CSL1_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL1_NSW_S2.

//! @brief Get value of CSU_CSL1_NSW_S2 from a register value.
#define BG_CSU_CSL1_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_NSW_S2) >> BP_CSU_CSL1_NSW_S2)

//! @brief Format value for bitfield CSU_CSL1_NSW_S2.
#define BF_CSU_CSL1_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_NSW_S2) & BM_CSU_CSL1_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL1_NSW_S2(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_NSW_S2) | BF_CSU_CSL1_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL1, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL1_LOCK_S2      (8)      //!< Bit position for CSU_CSL1_LOCK_S2.
#define BM_CSU_CSL1_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL1_LOCK_S2.

//! @brief Get value of CSU_CSL1_LOCK_S2 from a register value.
#define BG_CSU_CSL1_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_LOCK_S2) >> BP_CSU_CSL1_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL1_LOCK_S2.
#define BF_CSU_CSL1_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_LOCK_S2) & BM_CSU_CSL1_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL1_LOCK_S2(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_LOCK_S2) | BF_CSU_CSL1_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL1, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL1_SUR_S1      (16)      //!< Bit position for CSU_CSL1_SUR_S1.
#define BM_CSU_CSL1_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL1_SUR_S1.

//! @brief Get value of CSU_CSL1_SUR_S1 from a register value.
#define BG_CSU_CSL1_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_SUR_S1) >> BP_CSU_CSL1_SUR_S1)

//! @brief Format value for bitfield CSU_CSL1_SUR_S1.
#define BF_CSU_CSL1_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_SUR_S1) & BM_CSU_CSL1_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL1_SUR_S1(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_SUR_S1) | BF_CSU_CSL1_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL1, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL1_SSR_S1      (17)      //!< Bit position for CSU_CSL1_SSR_S1.
#define BM_CSU_CSL1_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL1_SSR_S1.

//! @brief Get value of CSU_CSL1_SSR_S1 from a register value.
#define BG_CSU_CSL1_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_SSR_S1) >> BP_CSU_CSL1_SSR_S1)

//! @brief Format value for bitfield CSU_CSL1_SSR_S1.
#define BF_CSU_CSL1_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_SSR_S1) & BM_CSU_CSL1_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL1_SSR_S1(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_SSR_S1) | BF_CSU_CSL1_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL1, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL1_NUR_S1      (18)      //!< Bit position for CSU_CSL1_NUR_S1.
#define BM_CSU_CSL1_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL1_NUR_S1.

//! @brief Get value of CSU_CSL1_NUR_S1 from a register value.
#define BG_CSU_CSL1_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_NUR_S1) >> BP_CSU_CSL1_NUR_S1)

//! @brief Format value for bitfield CSU_CSL1_NUR_S1.
#define BF_CSU_CSL1_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_NUR_S1) & BM_CSU_CSL1_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL1_NUR_S1(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_NUR_S1) | BF_CSU_CSL1_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL1, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL1_NSR_S1      (19)      //!< Bit position for CSU_CSL1_NSR_S1.
#define BM_CSU_CSL1_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL1_NSR_S1.

//! @brief Get value of CSU_CSL1_NSR_S1 from a register value.
#define BG_CSU_CSL1_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_NSR_S1) >> BP_CSU_CSL1_NSR_S1)

//! @brief Format value for bitfield CSU_CSL1_NSR_S1.
#define BF_CSU_CSL1_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_NSR_S1) & BM_CSU_CSL1_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL1_NSR_S1(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_NSR_S1) | BF_CSU_CSL1_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL1, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL1_SUW_S1      (20)      //!< Bit position for CSU_CSL1_SUW_S1.
#define BM_CSU_CSL1_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL1_SUW_S1.

//! @brief Get value of CSU_CSL1_SUW_S1 from a register value.
#define BG_CSU_CSL1_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_SUW_S1) >> BP_CSU_CSL1_SUW_S1)

//! @brief Format value for bitfield CSU_CSL1_SUW_S1.
#define BF_CSU_CSL1_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_SUW_S1) & BM_CSU_CSL1_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL1_SUW_S1(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_SUW_S1) | BF_CSU_CSL1_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL1, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL1_SSW_S1      (21)      //!< Bit position for CSU_CSL1_SSW_S1.
#define BM_CSU_CSL1_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL1_SSW_S1.

//! @brief Get value of CSU_CSL1_SSW_S1 from a register value.
#define BG_CSU_CSL1_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_SSW_S1) >> BP_CSU_CSL1_SSW_S1)

//! @brief Format value for bitfield CSU_CSL1_SSW_S1.
#define BF_CSU_CSL1_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_SSW_S1) & BM_CSU_CSL1_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL1_SSW_S1(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_SSW_S1) | BF_CSU_CSL1_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL1, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL1_NUW_S1      (22)      //!< Bit position for CSU_CSL1_NUW_S1.
#define BM_CSU_CSL1_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL1_NUW_S1.

//! @brief Get value of CSU_CSL1_NUW_S1 from a register value.
#define BG_CSU_CSL1_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_NUW_S1) >> BP_CSU_CSL1_NUW_S1)

//! @brief Format value for bitfield CSU_CSL1_NUW_S1.
#define BF_CSU_CSL1_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_NUW_S1) & BM_CSU_CSL1_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL1_NUW_S1(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_NUW_S1) | BF_CSU_CSL1_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL1, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL1_NSW_S1      (23)      //!< Bit position for CSU_CSL1_NSW_S1.
#define BM_CSU_CSL1_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL1_NSW_S1.

//! @brief Get value of CSU_CSL1_NSW_S1 from a register value.
#define BG_CSU_CSL1_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_NSW_S1) >> BP_CSU_CSL1_NSW_S1)

//! @brief Format value for bitfield CSU_CSL1_NSW_S1.
#define BF_CSU_CSL1_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_NSW_S1) & BM_CSU_CSL1_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL1_NSW_S1(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_NSW_S1) | BF_CSU_CSL1_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL1, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL1_LOCK_S1      (24)      //!< Bit position for CSU_CSL1_LOCK_S1.
#define BM_CSU_CSL1_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL1_LOCK_S1.

//! @brief Get value of CSU_CSL1_LOCK_S1 from a register value.
#define BG_CSU_CSL1_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL1_LOCK_S1) >> BP_CSU_CSL1_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL1_LOCK_S1.
#define BF_CSU_CSL1_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL1_LOCK_S1) & BM_CSU_CSL1_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL1_LOCK_S1(v)   (HW_CSU_CSL1_WR((HW_CSU_CSL1_RD() & ~BM_CSU_CSL1_LOCK_S1) | BF_CSU_CSL1_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL2 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL2 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl2
{
    reg32_t U;
    struct _hw_csu_csl2_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl2_t;
#endif

/*
 * constants & macros for entire CSU_CSL2 register
 */
#define HW_CSU_CSL2_ADDR      (REGS_CSU_BASE + 0x8)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL2           (*(volatile hw_csu_csl2_t *) HW_CSU_CSL2_ADDR)
#define HW_CSU_CSL2_RD()      (HW_CSU_CSL2.U)
#define HW_CSU_CSL2_WR(v)     (HW_CSU_CSL2.U = (v))
#define HW_CSU_CSL2_SET(v)    (HW_CSU_CSL2_WR(HW_CSU_CSL2_RD() |  (v)))
#define HW_CSU_CSL2_CLR(v)    (HW_CSU_CSL2_WR(HW_CSU_CSL2_RD() & ~(v)))
#define HW_CSU_CSL2_TOG(v)    (HW_CSU_CSL2_WR(HW_CSU_CSL2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL2 bitfields
 */

/* --- Register HW_CSU_CSL2, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL2_SUR_S2      (0)      //!< Bit position for CSU_CSL2_SUR_S2.
#define BM_CSU_CSL2_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL2_SUR_S2.

//! @brief Get value of CSU_CSL2_SUR_S2 from a register value.
#define BG_CSU_CSL2_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_SUR_S2) >> BP_CSU_CSL2_SUR_S2)

//! @brief Format value for bitfield CSU_CSL2_SUR_S2.
#define BF_CSU_CSL2_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_SUR_S2) & BM_CSU_CSL2_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL2_SUR_S2(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_SUR_S2) | BF_CSU_CSL2_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL2, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL2_SSR_S2      (1)      //!< Bit position for CSU_CSL2_SSR_S2.
#define BM_CSU_CSL2_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL2_SSR_S2.

//! @brief Get value of CSU_CSL2_SSR_S2 from a register value.
#define BG_CSU_CSL2_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_SSR_S2) >> BP_CSU_CSL2_SSR_S2)

//! @brief Format value for bitfield CSU_CSL2_SSR_S2.
#define BF_CSU_CSL2_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_SSR_S2) & BM_CSU_CSL2_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL2_SSR_S2(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_SSR_S2) | BF_CSU_CSL2_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL2, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL2_NUR_S2      (2)      //!< Bit position for CSU_CSL2_NUR_S2.
#define BM_CSU_CSL2_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL2_NUR_S2.

//! @brief Get value of CSU_CSL2_NUR_S2 from a register value.
#define BG_CSU_CSL2_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_NUR_S2) >> BP_CSU_CSL2_NUR_S2)

//! @brief Format value for bitfield CSU_CSL2_NUR_S2.
#define BF_CSU_CSL2_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_NUR_S2) & BM_CSU_CSL2_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL2_NUR_S2(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_NUR_S2) | BF_CSU_CSL2_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL2, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL2_NSR_S2      (3)      //!< Bit position for CSU_CSL2_NSR_S2.
#define BM_CSU_CSL2_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL2_NSR_S2.

//! @brief Get value of CSU_CSL2_NSR_S2 from a register value.
#define BG_CSU_CSL2_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_NSR_S2) >> BP_CSU_CSL2_NSR_S2)

//! @brief Format value for bitfield CSU_CSL2_NSR_S2.
#define BF_CSU_CSL2_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_NSR_S2) & BM_CSU_CSL2_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL2_NSR_S2(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_NSR_S2) | BF_CSU_CSL2_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL2, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL2_SUW_S2      (4)      //!< Bit position for CSU_CSL2_SUW_S2.
#define BM_CSU_CSL2_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL2_SUW_S2.

//! @brief Get value of CSU_CSL2_SUW_S2 from a register value.
#define BG_CSU_CSL2_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_SUW_S2) >> BP_CSU_CSL2_SUW_S2)

//! @brief Format value for bitfield CSU_CSL2_SUW_S2.
#define BF_CSU_CSL2_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_SUW_S2) & BM_CSU_CSL2_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL2_SUW_S2(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_SUW_S2) | BF_CSU_CSL2_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL2, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL2_SSW_S2      (5)      //!< Bit position for CSU_CSL2_SSW_S2.
#define BM_CSU_CSL2_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL2_SSW_S2.

//! @brief Get value of CSU_CSL2_SSW_S2 from a register value.
#define BG_CSU_CSL2_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_SSW_S2) >> BP_CSU_CSL2_SSW_S2)

//! @brief Format value for bitfield CSU_CSL2_SSW_S2.
#define BF_CSU_CSL2_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_SSW_S2) & BM_CSU_CSL2_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL2_SSW_S2(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_SSW_S2) | BF_CSU_CSL2_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL2, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL2_NUW_S2      (6)      //!< Bit position for CSU_CSL2_NUW_S2.
#define BM_CSU_CSL2_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL2_NUW_S2.

//! @brief Get value of CSU_CSL2_NUW_S2 from a register value.
#define BG_CSU_CSL2_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_NUW_S2) >> BP_CSU_CSL2_NUW_S2)

//! @brief Format value for bitfield CSU_CSL2_NUW_S2.
#define BF_CSU_CSL2_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_NUW_S2) & BM_CSU_CSL2_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL2_NUW_S2(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_NUW_S2) | BF_CSU_CSL2_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL2, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL2_NSW_S2      (7)      //!< Bit position for CSU_CSL2_NSW_S2.
#define BM_CSU_CSL2_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL2_NSW_S2.

//! @brief Get value of CSU_CSL2_NSW_S2 from a register value.
#define BG_CSU_CSL2_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_NSW_S2) >> BP_CSU_CSL2_NSW_S2)

//! @brief Format value for bitfield CSU_CSL2_NSW_S2.
#define BF_CSU_CSL2_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_NSW_S2) & BM_CSU_CSL2_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL2_NSW_S2(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_NSW_S2) | BF_CSU_CSL2_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL2, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL2_LOCK_S2      (8)      //!< Bit position for CSU_CSL2_LOCK_S2.
#define BM_CSU_CSL2_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL2_LOCK_S2.

//! @brief Get value of CSU_CSL2_LOCK_S2 from a register value.
#define BG_CSU_CSL2_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_LOCK_S2) >> BP_CSU_CSL2_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL2_LOCK_S2.
#define BF_CSU_CSL2_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_LOCK_S2) & BM_CSU_CSL2_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL2_LOCK_S2(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_LOCK_S2) | BF_CSU_CSL2_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL2, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL2_SUR_S1      (16)      //!< Bit position for CSU_CSL2_SUR_S1.
#define BM_CSU_CSL2_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL2_SUR_S1.

//! @brief Get value of CSU_CSL2_SUR_S1 from a register value.
#define BG_CSU_CSL2_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_SUR_S1) >> BP_CSU_CSL2_SUR_S1)

//! @brief Format value for bitfield CSU_CSL2_SUR_S1.
#define BF_CSU_CSL2_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_SUR_S1) & BM_CSU_CSL2_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL2_SUR_S1(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_SUR_S1) | BF_CSU_CSL2_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL2, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL2_SSR_S1      (17)      //!< Bit position for CSU_CSL2_SSR_S1.
#define BM_CSU_CSL2_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL2_SSR_S1.

//! @brief Get value of CSU_CSL2_SSR_S1 from a register value.
#define BG_CSU_CSL2_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_SSR_S1) >> BP_CSU_CSL2_SSR_S1)

//! @brief Format value for bitfield CSU_CSL2_SSR_S1.
#define BF_CSU_CSL2_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_SSR_S1) & BM_CSU_CSL2_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL2_SSR_S1(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_SSR_S1) | BF_CSU_CSL2_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL2, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL2_NUR_S1      (18)      //!< Bit position for CSU_CSL2_NUR_S1.
#define BM_CSU_CSL2_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL2_NUR_S1.

//! @brief Get value of CSU_CSL2_NUR_S1 from a register value.
#define BG_CSU_CSL2_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_NUR_S1) >> BP_CSU_CSL2_NUR_S1)

//! @brief Format value for bitfield CSU_CSL2_NUR_S1.
#define BF_CSU_CSL2_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_NUR_S1) & BM_CSU_CSL2_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL2_NUR_S1(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_NUR_S1) | BF_CSU_CSL2_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL2, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL2_NSR_S1      (19)      //!< Bit position for CSU_CSL2_NSR_S1.
#define BM_CSU_CSL2_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL2_NSR_S1.

//! @brief Get value of CSU_CSL2_NSR_S1 from a register value.
#define BG_CSU_CSL2_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_NSR_S1) >> BP_CSU_CSL2_NSR_S1)

//! @brief Format value for bitfield CSU_CSL2_NSR_S1.
#define BF_CSU_CSL2_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_NSR_S1) & BM_CSU_CSL2_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL2_NSR_S1(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_NSR_S1) | BF_CSU_CSL2_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL2, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL2_SUW_S1      (20)      //!< Bit position for CSU_CSL2_SUW_S1.
#define BM_CSU_CSL2_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL2_SUW_S1.

//! @brief Get value of CSU_CSL2_SUW_S1 from a register value.
#define BG_CSU_CSL2_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_SUW_S1) >> BP_CSU_CSL2_SUW_S1)

//! @brief Format value for bitfield CSU_CSL2_SUW_S1.
#define BF_CSU_CSL2_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_SUW_S1) & BM_CSU_CSL2_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL2_SUW_S1(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_SUW_S1) | BF_CSU_CSL2_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL2, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL2_SSW_S1      (21)      //!< Bit position for CSU_CSL2_SSW_S1.
#define BM_CSU_CSL2_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL2_SSW_S1.

//! @brief Get value of CSU_CSL2_SSW_S1 from a register value.
#define BG_CSU_CSL2_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_SSW_S1) >> BP_CSU_CSL2_SSW_S1)

//! @brief Format value for bitfield CSU_CSL2_SSW_S1.
#define BF_CSU_CSL2_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_SSW_S1) & BM_CSU_CSL2_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL2_SSW_S1(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_SSW_S1) | BF_CSU_CSL2_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL2, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL2_NUW_S1      (22)      //!< Bit position for CSU_CSL2_NUW_S1.
#define BM_CSU_CSL2_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL2_NUW_S1.

//! @brief Get value of CSU_CSL2_NUW_S1 from a register value.
#define BG_CSU_CSL2_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_NUW_S1) >> BP_CSU_CSL2_NUW_S1)

//! @brief Format value for bitfield CSU_CSL2_NUW_S1.
#define BF_CSU_CSL2_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_NUW_S1) & BM_CSU_CSL2_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL2_NUW_S1(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_NUW_S1) | BF_CSU_CSL2_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL2, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL2_NSW_S1      (23)      //!< Bit position for CSU_CSL2_NSW_S1.
#define BM_CSU_CSL2_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL2_NSW_S1.

//! @brief Get value of CSU_CSL2_NSW_S1 from a register value.
#define BG_CSU_CSL2_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_NSW_S1) >> BP_CSU_CSL2_NSW_S1)

//! @brief Format value for bitfield CSU_CSL2_NSW_S1.
#define BF_CSU_CSL2_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_NSW_S1) & BM_CSU_CSL2_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL2_NSW_S1(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_NSW_S1) | BF_CSU_CSL2_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL2, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL2_LOCK_S1      (24)      //!< Bit position for CSU_CSL2_LOCK_S1.
#define BM_CSU_CSL2_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL2_LOCK_S1.

//! @brief Get value of CSU_CSL2_LOCK_S1 from a register value.
#define BG_CSU_CSL2_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL2_LOCK_S1) >> BP_CSU_CSL2_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL2_LOCK_S1.
#define BF_CSU_CSL2_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL2_LOCK_S1) & BM_CSU_CSL2_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL2_LOCK_S1(v)   (HW_CSU_CSL2_WR((HW_CSU_CSL2_RD() & ~BM_CSU_CSL2_LOCK_S1) | BF_CSU_CSL2_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL3 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL3 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl3
{
    reg32_t U;
    struct _hw_csu_csl3_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl3_t;
#endif

/*
 * constants & macros for entire CSU_CSL3 register
 */
#define HW_CSU_CSL3_ADDR      (REGS_CSU_BASE + 0xc)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL3           (*(volatile hw_csu_csl3_t *) HW_CSU_CSL3_ADDR)
#define HW_CSU_CSL3_RD()      (HW_CSU_CSL3.U)
#define HW_CSU_CSL3_WR(v)     (HW_CSU_CSL3.U = (v))
#define HW_CSU_CSL3_SET(v)    (HW_CSU_CSL3_WR(HW_CSU_CSL3_RD() |  (v)))
#define HW_CSU_CSL3_CLR(v)    (HW_CSU_CSL3_WR(HW_CSU_CSL3_RD() & ~(v)))
#define HW_CSU_CSL3_TOG(v)    (HW_CSU_CSL3_WR(HW_CSU_CSL3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL3 bitfields
 */

/* --- Register HW_CSU_CSL3, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL3_SUR_S2      (0)      //!< Bit position for CSU_CSL3_SUR_S2.
#define BM_CSU_CSL3_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL3_SUR_S2.

//! @brief Get value of CSU_CSL3_SUR_S2 from a register value.
#define BG_CSU_CSL3_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_SUR_S2) >> BP_CSU_CSL3_SUR_S2)

//! @brief Format value for bitfield CSU_CSL3_SUR_S2.
#define BF_CSU_CSL3_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_SUR_S2) & BM_CSU_CSL3_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL3_SUR_S2(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_SUR_S2) | BF_CSU_CSL3_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL3, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL3_SSR_S2      (1)      //!< Bit position for CSU_CSL3_SSR_S2.
#define BM_CSU_CSL3_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL3_SSR_S2.

//! @brief Get value of CSU_CSL3_SSR_S2 from a register value.
#define BG_CSU_CSL3_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_SSR_S2) >> BP_CSU_CSL3_SSR_S2)

//! @brief Format value for bitfield CSU_CSL3_SSR_S2.
#define BF_CSU_CSL3_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_SSR_S2) & BM_CSU_CSL3_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL3_SSR_S2(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_SSR_S2) | BF_CSU_CSL3_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL3, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL3_NUR_S2      (2)      //!< Bit position for CSU_CSL3_NUR_S2.
#define BM_CSU_CSL3_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL3_NUR_S2.

//! @brief Get value of CSU_CSL3_NUR_S2 from a register value.
#define BG_CSU_CSL3_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_NUR_S2) >> BP_CSU_CSL3_NUR_S2)

//! @brief Format value for bitfield CSU_CSL3_NUR_S2.
#define BF_CSU_CSL3_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_NUR_S2) & BM_CSU_CSL3_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL3_NUR_S2(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_NUR_S2) | BF_CSU_CSL3_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL3, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL3_NSR_S2      (3)      //!< Bit position for CSU_CSL3_NSR_S2.
#define BM_CSU_CSL3_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL3_NSR_S2.

//! @brief Get value of CSU_CSL3_NSR_S2 from a register value.
#define BG_CSU_CSL3_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_NSR_S2) >> BP_CSU_CSL3_NSR_S2)

//! @brief Format value for bitfield CSU_CSL3_NSR_S2.
#define BF_CSU_CSL3_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_NSR_S2) & BM_CSU_CSL3_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL3_NSR_S2(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_NSR_S2) | BF_CSU_CSL3_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL3, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL3_SUW_S2      (4)      //!< Bit position for CSU_CSL3_SUW_S2.
#define BM_CSU_CSL3_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL3_SUW_S2.

//! @brief Get value of CSU_CSL3_SUW_S2 from a register value.
#define BG_CSU_CSL3_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_SUW_S2) >> BP_CSU_CSL3_SUW_S2)

//! @brief Format value for bitfield CSU_CSL3_SUW_S2.
#define BF_CSU_CSL3_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_SUW_S2) & BM_CSU_CSL3_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL3_SUW_S2(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_SUW_S2) | BF_CSU_CSL3_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL3, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL3_SSW_S2      (5)      //!< Bit position for CSU_CSL3_SSW_S2.
#define BM_CSU_CSL3_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL3_SSW_S2.

//! @brief Get value of CSU_CSL3_SSW_S2 from a register value.
#define BG_CSU_CSL3_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_SSW_S2) >> BP_CSU_CSL3_SSW_S2)

//! @brief Format value for bitfield CSU_CSL3_SSW_S2.
#define BF_CSU_CSL3_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_SSW_S2) & BM_CSU_CSL3_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL3_SSW_S2(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_SSW_S2) | BF_CSU_CSL3_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL3, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL3_NUW_S2      (6)      //!< Bit position for CSU_CSL3_NUW_S2.
#define BM_CSU_CSL3_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL3_NUW_S2.

//! @brief Get value of CSU_CSL3_NUW_S2 from a register value.
#define BG_CSU_CSL3_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_NUW_S2) >> BP_CSU_CSL3_NUW_S2)

//! @brief Format value for bitfield CSU_CSL3_NUW_S2.
#define BF_CSU_CSL3_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_NUW_S2) & BM_CSU_CSL3_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL3_NUW_S2(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_NUW_S2) | BF_CSU_CSL3_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL3, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL3_NSW_S2      (7)      //!< Bit position for CSU_CSL3_NSW_S2.
#define BM_CSU_CSL3_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL3_NSW_S2.

//! @brief Get value of CSU_CSL3_NSW_S2 from a register value.
#define BG_CSU_CSL3_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_NSW_S2) >> BP_CSU_CSL3_NSW_S2)

//! @brief Format value for bitfield CSU_CSL3_NSW_S2.
#define BF_CSU_CSL3_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_NSW_S2) & BM_CSU_CSL3_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL3_NSW_S2(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_NSW_S2) | BF_CSU_CSL3_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL3, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL3_LOCK_S2      (8)      //!< Bit position for CSU_CSL3_LOCK_S2.
#define BM_CSU_CSL3_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL3_LOCK_S2.

//! @brief Get value of CSU_CSL3_LOCK_S2 from a register value.
#define BG_CSU_CSL3_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_LOCK_S2) >> BP_CSU_CSL3_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL3_LOCK_S2.
#define BF_CSU_CSL3_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_LOCK_S2) & BM_CSU_CSL3_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL3_LOCK_S2(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_LOCK_S2) | BF_CSU_CSL3_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL3, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL3_SUR_S1      (16)      //!< Bit position for CSU_CSL3_SUR_S1.
#define BM_CSU_CSL3_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL3_SUR_S1.

//! @brief Get value of CSU_CSL3_SUR_S1 from a register value.
#define BG_CSU_CSL3_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_SUR_S1) >> BP_CSU_CSL3_SUR_S1)

//! @brief Format value for bitfield CSU_CSL3_SUR_S1.
#define BF_CSU_CSL3_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_SUR_S1) & BM_CSU_CSL3_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL3_SUR_S1(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_SUR_S1) | BF_CSU_CSL3_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL3, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL3_SSR_S1      (17)      //!< Bit position for CSU_CSL3_SSR_S1.
#define BM_CSU_CSL3_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL3_SSR_S1.

//! @brief Get value of CSU_CSL3_SSR_S1 from a register value.
#define BG_CSU_CSL3_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_SSR_S1) >> BP_CSU_CSL3_SSR_S1)

//! @brief Format value for bitfield CSU_CSL3_SSR_S1.
#define BF_CSU_CSL3_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_SSR_S1) & BM_CSU_CSL3_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL3_SSR_S1(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_SSR_S1) | BF_CSU_CSL3_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL3, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL3_NUR_S1      (18)      //!< Bit position for CSU_CSL3_NUR_S1.
#define BM_CSU_CSL3_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL3_NUR_S1.

//! @brief Get value of CSU_CSL3_NUR_S1 from a register value.
#define BG_CSU_CSL3_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_NUR_S1) >> BP_CSU_CSL3_NUR_S1)

//! @brief Format value for bitfield CSU_CSL3_NUR_S1.
#define BF_CSU_CSL3_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_NUR_S1) & BM_CSU_CSL3_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL3_NUR_S1(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_NUR_S1) | BF_CSU_CSL3_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL3, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL3_NSR_S1      (19)      //!< Bit position for CSU_CSL3_NSR_S1.
#define BM_CSU_CSL3_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL3_NSR_S1.

//! @brief Get value of CSU_CSL3_NSR_S1 from a register value.
#define BG_CSU_CSL3_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_NSR_S1) >> BP_CSU_CSL3_NSR_S1)

//! @brief Format value for bitfield CSU_CSL3_NSR_S1.
#define BF_CSU_CSL3_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_NSR_S1) & BM_CSU_CSL3_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL3_NSR_S1(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_NSR_S1) | BF_CSU_CSL3_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL3, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL3_SUW_S1      (20)      //!< Bit position for CSU_CSL3_SUW_S1.
#define BM_CSU_CSL3_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL3_SUW_S1.

//! @brief Get value of CSU_CSL3_SUW_S1 from a register value.
#define BG_CSU_CSL3_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_SUW_S1) >> BP_CSU_CSL3_SUW_S1)

//! @brief Format value for bitfield CSU_CSL3_SUW_S1.
#define BF_CSU_CSL3_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_SUW_S1) & BM_CSU_CSL3_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL3_SUW_S1(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_SUW_S1) | BF_CSU_CSL3_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL3, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL3_SSW_S1      (21)      //!< Bit position for CSU_CSL3_SSW_S1.
#define BM_CSU_CSL3_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL3_SSW_S1.

//! @brief Get value of CSU_CSL3_SSW_S1 from a register value.
#define BG_CSU_CSL3_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_SSW_S1) >> BP_CSU_CSL3_SSW_S1)

//! @brief Format value for bitfield CSU_CSL3_SSW_S1.
#define BF_CSU_CSL3_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_SSW_S1) & BM_CSU_CSL3_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL3_SSW_S1(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_SSW_S1) | BF_CSU_CSL3_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL3, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL3_NUW_S1      (22)      //!< Bit position for CSU_CSL3_NUW_S1.
#define BM_CSU_CSL3_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL3_NUW_S1.

//! @brief Get value of CSU_CSL3_NUW_S1 from a register value.
#define BG_CSU_CSL3_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_NUW_S1) >> BP_CSU_CSL3_NUW_S1)

//! @brief Format value for bitfield CSU_CSL3_NUW_S1.
#define BF_CSU_CSL3_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_NUW_S1) & BM_CSU_CSL3_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL3_NUW_S1(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_NUW_S1) | BF_CSU_CSL3_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL3, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL3_NSW_S1      (23)      //!< Bit position for CSU_CSL3_NSW_S1.
#define BM_CSU_CSL3_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL3_NSW_S1.

//! @brief Get value of CSU_CSL3_NSW_S1 from a register value.
#define BG_CSU_CSL3_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_NSW_S1) >> BP_CSU_CSL3_NSW_S1)

//! @brief Format value for bitfield CSU_CSL3_NSW_S1.
#define BF_CSU_CSL3_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_NSW_S1) & BM_CSU_CSL3_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL3_NSW_S1(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_NSW_S1) | BF_CSU_CSL3_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL3, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL3_LOCK_S1      (24)      //!< Bit position for CSU_CSL3_LOCK_S1.
#define BM_CSU_CSL3_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL3_LOCK_S1.

//! @brief Get value of CSU_CSL3_LOCK_S1 from a register value.
#define BG_CSU_CSL3_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL3_LOCK_S1) >> BP_CSU_CSL3_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL3_LOCK_S1.
#define BF_CSU_CSL3_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL3_LOCK_S1) & BM_CSU_CSL3_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL3_LOCK_S1(v)   (HW_CSU_CSL3_WR((HW_CSU_CSL3_RD() & ~BM_CSU_CSL3_LOCK_S1) | BF_CSU_CSL3_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL4 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL4 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl4
{
    reg32_t U;
    struct _hw_csu_csl4_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl4_t;
#endif

/*
 * constants & macros for entire CSU_CSL4 register
 */
#define HW_CSU_CSL4_ADDR      (REGS_CSU_BASE + 0x10)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL4           (*(volatile hw_csu_csl4_t *) HW_CSU_CSL4_ADDR)
#define HW_CSU_CSL4_RD()      (HW_CSU_CSL4.U)
#define HW_CSU_CSL4_WR(v)     (HW_CSU_CSL4.U = (v))
#define HW_CSU_CSL4_SET(v)    (HW_CSU_CSL4_WR(HW_CSU_CSL4_RD() |  (v)))
#define HW_CSU_CSL4_CLR(v)    (HW_CSU_CSL4_WR(HW_CSU_CSL4_RD() & ~(v)))
#define HW_CSU_CSL4_TOG(v)    (HW_CSU_CSL4_WR(HW_CSU_CSL4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL4 bitfields
 */

/* --- Register HW_CSU_CSL4, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL4_SUR_S2      (0)      //!< Bit position for CSU_CSL4_SUR_S2.
#define BM_CSU_CSL4_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL4_SUR_S2.

//! @brief Get value of CSU_CSL4_SUR_S2 from a register value.
#define BG_CSU_CSL4_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_SUR_S2) >> BP_CSU_CSL4_SUR_S2)

//! @brief Format value for bitfield CSU_CSL4_SUR_S2.
#define BF_CSU_CSL4_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_SUR_S2) & BM_CSU_CSL4_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL4_SUR_S2(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_SUR_S2) | BF_CSU_CSL4_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL4, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL4_SSR_S2      (1)      //!< Bit position for CSU_CSL4_SSR_S2.
#define BM_CSU_CSL4_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL4_SSR_S2.

//! @brief Get value of CSU_CSL4_SSR_S2 from a register value.
#define BG_CSU_CSL4_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_SSR_S2) >> BP_CSU_CSL4_SSR_S2)

//! @brief Format value for bitfield CSU_CSL4_SSR_S2.
#define BF_CSU_CSL4_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_SSR_S2) & BM_CSU_CSL4_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL4_SSR_S2(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_SSR_S2) | BF_CSU_CSL4_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL4, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL4_NUR_S2      (2)      //!< Bit position for CSU_CSL4_NUR_S2.
#define BM_CSU_CSL4_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL4_NUR_S2.

//! @brief Get value of CSU_CSL4_NUR_S2 from a register value.
#define BG_CSU_CSL4_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_NUR_S2) >> BP_CSU_CSL4_NUR_S2)

//! @brief Format value for bitfield CSU_CSL4_NUR_S2.
#define BF_CSU_CSL4_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_NUR_S2) & BM_CSU_CSL4_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL4_NUR_S2(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_NUR_S2) | BF_CSU_CSL4_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL4, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL4_NSR_S2      (3)      //!< Bit position for CSU_CSL4_NSR_S2.
#define BM_CSU_CSL4_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL4_NSR_S2.

//! @brief Get value of CSU_CSL4_NSR_S2 from a register value.
#define BG_CSU_CSL4_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_NSR_S2) >> BP_CSU_CSL4_NSR_S2)

//! @brief Format value for bitfield CSU_CSL4_NSR_S2.
#define BF_CSU_CSL4_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_NSR_S2) & BM_CSU_CSL4_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL4_NSR_S2(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_NSR_S2) | BF_CSU_CSL4_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL4, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL4_SUW_S2      (4)      //!< Bit position for CSU_CSL4_SUW_S2.
#define BM_CSU_CSL4_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL4_SUW_S2.

//! @brief Get value of CSU_CSL4_SUW_S2 from a register value.
#define BG_CSU_CSL4_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_SUW_S2) >> BP_CSU_CSL4_SUW_S2)

//! @brief Format value for bitfield CSU_CSL4_SUW_S2.
#define BF_CSU_CSL4_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_SUW_S2) & BM_CSU_CSL4_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL4_SUW_S2(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_SUW_S2) | BF_CSU_CSL4_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL4, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL4_SSW_S2      (5)      //!< Bit position for CSU_CSL4_SSW_S2.
#define BM_CSU_CSL4_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL4_SSW_S2.

//! @brief Get value of CSU_CSL4_SSW_S2 from a register value.
#define BG_CSU_CSL4_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_SSW_S2) >> BP_CSU_CSL4_SSW_S2)

//! @brief Format value for bitfield CSU_CSL4_SSW_S2.
#define BF_CSU_CSL4_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_SSW_S2) & BM_CSU_CSL4_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL4_SSW_S2(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_SSW_S2) | BF_CSU_CSL4_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL4, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL4_NUW_S2      (6)      //!< Bit position for CSU_CSL4_NUW_S2.
#define BM_CSU_CSL4_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL4_NUW_S2.

//! @brief Get value of CSU_CSL4_NUW_S2 from a register value.
#define BG_CSU_CSL4_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_NUW_S2) >> BP_CSU_CSL4_NUW_S2)

//! @brief Format value for bitfield CSU_CSL4_NUW_S2.
#define BF_CSU_CSL4_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_NUW_S2) & BM_CSU_CSL4_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL4_NUW_S2(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_NUW_S2) | BF_CSU_CSL4_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL4, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL4_NSW_S2      (7)      //!< Bit position for CSU_CSL4_NSW_S2.
#define BM_CSU_CSL4_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL4_NSW_S2.

//! @brief Get value of CSU_CSL4_NSW_S2 from a register value.
#define BG_CSU_CSL4_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_NSW_S2) >> BP_CSU_CSL4_NSW_S2)

//! @brief Format value for bitfield CSU_CSL4_NSW_S2.
#define BF_CSU_CSL4_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_NSW_S2) & BM_CSU_CSL4_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL4_NSW_S2(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_NSW_S2) | BF_CSU_CSL4_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL4, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL4_LOCK_S2      (8)      //!< Bit position for CSU_CSL4_LOCK_S2.
#define BM_CSU_CSL4_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL4_LOCK_S2.

//! @brief Get value of CSU_CSL4_LOCK_S2 from a register value.
#define BG_CSU_CSL4_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_LOCK_S2) >> BP_CSU_CSL4_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL4_LOCK_S2.
#define BF_CSU_CSL4_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_LOCK_S2) & BM_CSU_CSL4_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL4_LOCK_S2(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_LOCK_S2) | BF_CSU_CSL4_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL4, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL4_SUR_S1      (16)      //!< Bit position for CSU_CSL4_SUR_S1.
#define BM_CSU_CSL4_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL4_SUR_S1.

//! @brief Get value of CSU_CSL4_SUR_S1 from a register value.
#define BG_CSU_CSL4_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_SUR_S1) >> BP_CSU_CSL4_SUR_S1)

//! @brief Format value for bitfield CSU_CSL4_SUR_S1.
#define BF_CSU_CSL4_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_SUR_S1) & BM_CSU_CSL4_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL4_SUR_S1(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_SUR_S1) | BF_CSU_CSL4_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL4, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL4_SSR_S1      (17)      //!< Bit position for CSU_CSL4_SSR_S1.
#define BM_CSU_CSL4_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL4_SSR_S1.

//! @brief Get value of CSU_CSL4_SSR_S1 from a register value.
#define BG_CSU_CSL4_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_SSR_S1) >> BP_CSU_CSL4_SSR_S1)

//! @brief Format value for bitfield CSU_CSL4_SSR_S1.
#define BF_CSU_CSL4_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_SSR_S1) & BM_CSU_CSL4_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL4_SSR_S1(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_SSR_S1) | BF_CSU_CSL4_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL4, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL4_NUR_S1      (18)      //!< Bit position for CSU_CSL4_NUR_S1.
#define BM_CSU_CSL4_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL4_NUR_S1.

//! @brief Get value of CSU_CSL4_NUR_S1 from a register value.
#define BG_CSU_CSL4_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_NUR_S1) >> BP_CSU_CSL4_NUR_S1)

//! @brief Format value for bitfield CSU_CSL4_NUR_S1.
#define BF_CSU_CSL4_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_NUR_S1) & BM_CSU_CSL4_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL4_NUR_S1(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_NUR_S1) | BF_CSU_CSL4_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL4, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL4_NSR_S1      (19)      //!< Bit position for CSU_CSL4_NSR_S1.
#define BM_CSU_CSL4_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL4_NSR_S1.

//! @brief Get value of CSU_CSL4_NSR_S1 from a register value.
#define BG_CSU_CSL4_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_NSR_S1) >> BP_CSU_CSL4_NSR_S1)

//! @brief Format value for bitfield CSU_CSL4_NSR_S1.
#define BF_CSU_CSL4_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_NSR_S1) & BM_CSU_CSL4_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL4_NSR_S1(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_NSR_S1) | BF_CSU_CSL4_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL4, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL4_SUW_S1      (20)      //!< Bit position for CSU_CSL4_SUW_S1.
#define BM_CSU_CSL4_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL4_SUW_S1.

//! @brief Get value of CSU_CSL4_SUW_S1 from a register value.
#define BG_CSU_CSL4_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_SUW_S1) >> BP_CSU_CSL4_SUW_S1)

//! @brief Format value for bitfield CSU_CSL4_SUW_S1.
#define BF_CSU_CSL4_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_SUW_S1) & BM_CSU_CSL4_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL4_SUW_S1(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_SUW_S1) | BF_CSU_CSL4_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL4, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL4_SSW_S1      (21)      //!< Bit position for CSU_CSL4_SSW_S1.
#define BM_CSU_CSL4_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL4_SSW_S1.

//! @brief Get value of CSU_CSL4_SSW_S1 from a register value.
#define BG_CSU_CSL4_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_SSW_S1) >> BP_CSU_CSL4_SSW_S1)

//! @brief Format value for bitfield CSU_CSL4_SSW_S1.
#define BF_CSU_CSL4_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_SSW_S1) & BM_CSU_CSL4_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL4_SSW_S1(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_SSW_S1) | BF_CSU_CSL4_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL4, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL4_NUW_S1      (22)      //!< Bit position for CSU_CSL4_NUW_S1.
#define BM_CSU_CSL4_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL4_NUW_S1.

//! @brief Get value of CSU_CSL4_NUW_S1 from a register value.
#define BG_CSU_CSL4_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_NUW_S1) >> BP_CSU_CSL4_NUW_S1)

//! @brief Format value for bitfield CSU_CSL4_NUW_S1.
#define BF_CSU_CSL4_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_NUW_S1) & BM_CSU_CSL4_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL4_NUW_S1(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_NUW_S1) | BF_CSU_CSL4_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL4, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL4_NSW_S1      (23)      //!< Bit position for CSU_CSL4_NSW_S1.
#define BM_CSU_CSL4_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL4_NSW_S1.

//! @brief Get value of CSU_CSL4_NSW_S1 from a register value.
#define BG_CSU_CSL4_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_NSW_S1) >> BP_CSU_CSL4_NSW_S1)

//! @brief Format value for bitfield CSU_CSL4_NSW_S1.
#define BF_CSU_CSL4_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_NSW_S1) & BM_CSU_CSL4_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL4_NSW_S1(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_NSW_S1) | BF_CSU_CSL4_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL4, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL4_LOCK_S1      (24)      //!< Bit position for CSU_CSL4_LOCK_S1.
#define BM_CSU_CSL4_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL4_LOCK_S1.

//! @brief Get value of CSU_CSL4_LOCK_S1 from a register value.
#define BG_CSU_CSL4_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL4_LOCK_S1) >> BP_CSU_CSL4_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL4_LOCK_S1.
#define BF_CSU_CSL4_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL4_LOCK_S1) & BM_CSU_CSL4_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL4_LOCK_S1(v)   (HW_CSU_CSL4_WR((HW_CSU_CSL4_RD() & ~BM_CSU_CSL4_LOCK_S1) | BF_CSU_CSL4_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL5 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL5 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl5
{
    reg32_t U;
    struct _hw_csu_csl5_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl5_t;
#endif

/*
 * constants & macros for entire CSU_CSL5 register
 */
#define HW_CSU_CSL5_ADDR      (REGS_CSU_BASE + 0x14)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL5           (*(volatile hw_csu_csl5_t *) HW_CSU_CSL5_ADDR)
#define HW_CSU_CSL5_RD()      (HW_CSU_CSL5.U)
#define HW_CSU_CSL5_WR(v)     (HW_CSU_CSL5.U = (v))
#define HW_CSU_CSL5_SET(v)    (HW_CSU_CSL5_WR(HW_CSU_CSL5_RD() |  (v)))
#define HW_CSU_CSL5_CLR(v)    (HW_CSU_CSL5_WR(HW_CSU_CSL5_RD() & ~(v)))
#define HW_CSU_CSL5_TOG(v)    (HW_CSU_CSL5_WR(HW_CSU_CSL5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL5 bitfields
 */

/* --- Register HW_CSU_CSL5, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL5_SUR_S2      (0)      //!< Bit position for CSU_CSL5_SUR_S2.
#define BM_CSU_CSL5_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL5_SUR_S2.

//! @brief Get value of CSU_CSL5_SUR_S2 from a register value.
#define BG_CSU_CSL5_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_SUR_S2) >> BP_CSU_CSL5_SUR_S2)

//! @brief Format value for bitfield CSU_CSL5_SUR_S2.
#define BF_CSU_CSL5_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_SUR_S2) & BM_CSU_CSL5_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL5_SUR_S2(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_SUR_S2) | BF_CSU_CSL5_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL5, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL5_SSR_S2      (1)      //!< Bit position for CSU_CSL5_SSR_S2.
#define BM_CSU_CSL5_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL5_SSR_S2.

//! @brief Get value of CSU_CSL5_SSR_S2 from a register value.
#define BG_CSU_CSL5_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_SSR_S2) >> BP_CSU_CSL5_SSR_S2)

//! @brief Format value for bitfield CSU_CSL5_SSR_S2.
#define BF_CSU_CSL5_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_SSR_S2) & BM_CSU_CSL5_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL5_SSR_S2(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_SSR_S2) | BF_CSU_CSL5_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL5, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL5_NUR_S2      (2)      //!< Bit position for CSU_CSL5_NUR_S2.
#define BM_CSU_CSL5_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL5_NUR_S2.

//! @brief Get value of CSU_CSL5_NUR_S2 from a register value.
#define BG_CSU_CSL5_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_NUR_S2) >> BP_CSU_CSL5_NUR_S2)

//! @brief Format value for bitfield CSU_CSL5_NUR_S2.
#define BF_CSU_CSL5_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_NUR_S2) & BM_CSU_CSL5_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL5_NUR_S2(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_NUR_S2) | BF_CSU_CSL5_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL5, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL5_NSR_S2      (3)      //!< Bit position for CSU_CSL5_NSR_S2.
#define BM_CSU_CSL5_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL5_NSR_S2.

//! @brief Get value of CSU_CSL5_NSR_S2 from a register value.
#define BG_CSU_CSL5_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_NSR_S2) >> BP_CSU_CSL5_NSR_S2)

//! @brief Format value for bitfield CSU_CSL5_NSR_S2.
#define BF_CSU_CSL5_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_NSR_S2) & BM_CSU_CSL5_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL5_NSR_S2(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_NSR_S2) | BF_CSU_CSL5_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL5, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL5_SUW_S2      (4)      //!< Bit position for CSU_CSL5_SUW_S2.
#define BM_CSU_CSL5_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL5_SUW_S2.

//! @brief Get value of CSU_CSL5_SUW_S2 from a register value.
#define BG_CSU_CSL5_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_SUW_S2) >> BP_CSU_CSL5_SUW_S2)

//! @brief Format value for bitfield CSU_CSL5_SUW_S2.
#define BF_CSU_CSL5_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_SUW_S2) & BM_CSU_CSL5_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL5_SUW_S2(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_SUW_S2) | BF_CSU_CSL5_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL5, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL5_SSW_S2      (5)      //!< Bit position for CSU_CSL5_SSW_S2.
#define BM_CSU_CSL5_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL5_SSW_S2.

//! @brief Get value of CSU_CSL5_SSW_S2 from a register value.
#define BG_CSU_CSL5_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_SSW_S2) >> BP_CSU_CSL5_SSW_S2)

//! @brief Format value for bitfield CSU_CSL5_SSW_S2.
#define BF_CSU_CSL5_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_SSW_S2) & BM_CSU_CSL5_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL5_SSW_S2(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_SSW_S2) | BF_CSU_CSL5_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL5, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL5_NUW_S2      (6)      //!< Bit position for CSU_CSL5_NUW_S2.
#define BM_CSU_CSL5_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL5_NUW_S2.

//! @brief Get value of CSU_CSL5_NUW_S2 from a register value.
#define BG_CSU_CSL5_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_NUW_S2) >> BP_CSU_CSL5_NUW_S2)

//! @brief Format value for bitfield CSU_CSL5_NUW_S2.
#define BF_CSU_CSL5_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_NUW_S2) & BM_CSU_CSL5_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL5_NUW_S2(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_NUW_S2) | BF_CSU_CSL5_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL5, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL5_NSW_S2      (7)      //!< Bit position for CSU_CSL5_NSW_S2.
#define BM_CSU_CSL5_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL5_NSW_S2.

//! @brief Get value of CSU_CSL5_NSW_S2 from a register value.
#define BG_CSU_CSL5_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_NSW_S2) >> BP_CSU_CSL5_NSW_S2)

//! @brief Format value for bitfield CSU_CSL5_NSW_S2.
#define BF_CSU_CSL5_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_NSW_S2) & BM_CSU_CSL5_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL5_NSW_S2(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_NSW_S2) | BF_CSU_CSL5_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL5, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL5_LOCK_S2      (8)      //!< Bit position for CSU_CSL5_LOCK_S2.
#define BM_CSU_CSL5_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL5_LOCK_S2.

//! @brief Get value of CSU_CSL5_LOCK_S2 from a register value.
#define BG_CSU_CSL5_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_LOCK_S2) >> BP_CSU_CSL5_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL5_LOCK_S2.
#define BF_CSU_CSL5_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_LOCK_S2) & BM_CSU_CSL5_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL5_LOCK_S2(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_LOCK_S2) | BF_CSU_CSL5_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL5, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL5_SUR_S1      (16)      //!< Bit position for CSU_CSL5_SUR_S1.
#define BM_CSU_CSL5_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL5_SUR_S1.

//! @brief Get value of CSU_CSL5_SUR_S1 from a register value.
#define BG_CSU_CSL5_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_SUR_S1) >> BP_CSU_CSL5_SUR_S1)

//! @brief Format value for bitfield CSU_CSL5_SUR_S1.
#define BF_CSU_CSL5_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_SUR_S1) & BM_CSU_CSL5_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL5_SUR_S1(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_SUR_S1) | BF_CSU_CSL5_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL5, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL5_SSR_S1      (17)      //!< Bit position for CSU_CSL5_SSR_S1.
#define BM_CSU_CSL5_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL5_SSR_S1.

//! @brief Get value of CSU_CSL5_SSR_S1 from a register value.
#define BG_CSU_CSL5_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_SSR_S1) >> BP_CSU_CSL5_SSR_S1)

//! @brief Format value for bitfield CSU_CSL5_SSR_S1.
#define BF_CSU_CSL5_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_SSR_S1) & BM_CSU_CSL5_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL5_SSR_S1(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_SSR_S1) | BF_CSU_CSL5_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL5, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL5_NUR_S1      (18)      //!< Bit position for CSU_CSL5_NUR_S1.
#define BM_CSU_CSL5_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL5_NUR_S1.

//! @brief Get value of CSU_CSL5_NUR_S1 from a register value.
#define BG_CSU_CSL5_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_NUR_S1) >> BP_CSU_CSL5_NUR_S1)

//! @brief Format value for bitfield CSU_CSL5_NUR_S1.
#define BF_CSU_CSL5_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_NUR_S1) & BM_CSU_CSL5_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL5_NUR_S1(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_NUR_S1) | BF_CSU_CSL5_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL5, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL5_NSR_S1      (19)      //!< Bit position for CSU_CSL5_NSR_S1.
#define BM_CSU_CSL5_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL5_NSR_S1.

//! @brief Get value of CSU_CSL5_NSR_S1 from a register value.
#define BG_CSU_CSL5_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_NSR_S1) >> BP_CSU_CSL5_NSR_S1)

//! @brief Format value for bitfield CSU_CSL5_NSR_S1.
#define BF_CSU_CSL5_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_NSR_S1) & BM_CSU_CSL5_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL5_NSR_S1(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_NSR_S1) | BF_CSU_CSL5_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL5, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL5_SUW_S1      (20)      //!< Bit position for CSU_CSL5_SUW_S1.
#define BM_CSU_CSL5_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL5_SUW_S1.

//! @brief Get value of CSU_CSL5_SUW_S1 from a register value.
#define BG_CSU_CSL5_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_SUW_S1) >> BP_CSU_CSL5_SUW_S1)

//! @brief Format value for bitfield CSU_CSL5_SUW_S1.
#define BF_CSU_CSL5_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_SUW_S1) & BM_CSU_CSL5_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL5_SUW_S1(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_SUW_S1) | BF_CSU_CSL5_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL5, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL5_SSW_S1      (21)      //!< Bit position for CSU_CSL5_SSW_S1.
#define BM_CSU_CSL5_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL5_SSW_S1.

//! @brief Get value of CSU_CSL5_SSW_S1 from a register value.
#define BG_CSU_CSL5_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_SSW_S1) >> BP_CSU_CSL5_SSW_S1)

//! @brief Format value for bitfield CSU_CSL5_SSW_S1.
#define BF_CSU_CSL5_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_SSW_S1) & BM_CSU_CSL5_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL5_SSW_S1(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_SSW_S1) | BF_CSU_CSL5_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL5, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL5_NUW_S1      (22)      //!< Bit position for CSU_CSL5_NUW_S1.
#define BM_CSU_CSL5_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL5_NUW_S1.

//! @brief Get value of CSU_CSL5_NUW_S1 from a register value.
#define BG_CSU_CSL5_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_NUW_S1) >> BP_CSU_CSL5_NUW_S1)

//! @brief Format value for bitfield CSU_CSL5_NUW_S1.
#define BF_CSU_CSL5_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_NUW_S1) & BM_CSU_CSL5_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL5_NUW_S1(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_NUW_S1) | BF_CSU_CSL5_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL5, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL5_NSW_S1      (23)      //!< Bit position for CSU_CSL5_NSW_S1.
#define BM_CSU_CSL5_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL5_NSW_S1.

//! @brief Get value of CSU_CSL5_NSW_S1 from a register value.
#define BG_CSU_CSL5_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_NSW_S1) >> BP_CSU_CSL5_NSW_S1)

//! @brief Format value for bitfield CSU_CSL5_NSW_S1.
#define BF_CSU_CSL5_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_NSW_S1) & BM_CSU_CSL5_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL5_NSW_S1(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_NSW_S1) | BF_CSU_CSL5_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL5, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL5_LOCK_S1      (24)      //!< Bit position for CSU_CSL5_LOCK_S1.
#define BM_CSU_CSL5_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL5_LOCK_S1.

//! @brief Get value of CSU_CSL5_LOCK_S1 from a register value.
#define BG_CSU_CSL5_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL5_LOCK_S1) >> BP_CSU_CSL5_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL5_LOCK_S1.
#define BF_CSU_CSL5_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL5_LOCK_S1) & BM_CSU_CSL5_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL5_LOCK_S1(v)   (HW_CSU_CSL5_WR((HW_CSU_CSL5_RD() & ~BM_CSU_CSL5_LOCK_S1) | BF_CSU_CSL5_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL6 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL6 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl6
{
    reg32_t U;
    struct _hw_csu_csl6_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl6_t;
#endif

/*
 * constants & macros for entire CSU_CSL6 register
 */
#define HW_CSU_CSL6_ADDR      (REGS_CSU_BASE + 0x18)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL6           (*(volatile hw_csu_csl6_t *) HW_CSU_CSL6_ADDR)
#define HW_CSU_CSL6_RD()      (HW_CSU_CSL6.U)
#define HW_CSU_CSL6_WR(v)     (HW_CSU_CSL6.U = (v))
#define HW_CSU_CSL6_SET(v)    (HW_CSU_CSL6_WR(HW_CSU_CSL6_RD() |  (v)))
#define HW_CSU_CSL6_CLR(v)    (HW_CSU_CSL6_WR(HW_CSU_CSL6_RD() & ~(v)))
#define HW_CSU_CSL6_TOG(v)    (HW_CSU_CSL6_WR(HW_CSU_CSL6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL6 bitfields
 */

/* --- Register HW_CSU_CSL6, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL6_SUR_S2      (0)      //!< Bit position for CSU_CSL6_SUR_S2.
#define BM_CSU_CSL6_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL6_SUR_S2.

//! @brief Get value of CSU_CSL6_SUR_S2 from a register value.
#define BG_CSU_CSL6_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_SUR_S2) >> BP_CSU_CSL6_SUR_S2)

//! @brief Format value for bitfield CSU_CSL6_SUR_S2.
#define BF_CSU_CSL6_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_SUR_S2) & BM_CSU_CSL6_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL6_SUR_S2(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_SUR_S2) | BF_CSU_CSL6_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL6, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL6_SSR_S2      (1)      //!< Bit position for CSU_CSL6_SSR_S2.
#define BM_CSU_CSL6_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL6_SSR_S2.

//! @brief Get value of CSU_CSL6_SSR_S2 from a register value.
#define BG_CSU_CSL6_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_SSR_S2) >> BP_CSU_CSL6_SSR_S2)

//! @brief Format value for bitfield CSU_CSL6_SSR_S2.
#define BF_CSU_CSL6_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_SSR_S2) & BM_CSU_CSL6_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL6_SSR_S2(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_SSR_S2) | BF_CSU_CSL6_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL6, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL6_NUR_S2      (2)      //!< Bit position for CSU_CSL6_NUR_S2.
#define BM_CSU_CSL6_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL6_NUR_S2.

//! @brief Get value of CSU_CSL6_NUR_S2 from a register value.
#define BG_CSU_CSL6_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_NUR_S2) >> BP_CSU_CSL6_NUR_S2)

//! @brief Format value for bitfield CSU_CSL6_NUR_S2.
#define BF_CSU_CSL6_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_NUR_S2) & BM_CSU_CSL6_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL6_NUR_S2(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_NUR_S2) | BF_CSU_CSL6_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL6, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL6_NSR_S2      (3)      //!< Bit position for CSU_CSL6_NSR_S2.
#define BM_CSU_CSL6_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL6_NSR_S2.

//! @brief Get value of CSU_CSL6_NSR_S2 from a register value.
#define BG_CSU_CSL6_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_NSR_S2) >> BP_CSU_CSL6_NSR_S2)

//! @brief Format value for bitfield CSU_CSL6_NSR_S2.
#define BF_CSU_CSL6_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_NSR_S2) & BM_CSU_CSL6_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL6_NSR_S2(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_NSR_S2) | BF_CSU_CSL6_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL6, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL6_SUW_S2      (4)      //!< Bit position for CSU_CSL6_SUW_S2.
#define BM_CSU_CSL6_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL6_SUW_S2.

//! @brief Get value of CSU_CSL6_SUW_S2 from a register value.
#define BG_CSU_CSL6_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_SUW_S2) >> BP_CSU_CSL6_SUW_S2)

//! @brief Format value for bitfield CSU_CSL6_SUW_S2.
#define BF_CSU_CSL6_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_SUW_S2) & BM_CSU_CSL6_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL6_SUW_S2(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_SUW_S2) | BF_CSU_CSL6_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL6, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL6_SSW_S2      (5)      //!< Bit position for CSU_CSL6_SSW_S2.
#define BM_CSU_CSL6_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL6_SSW_S2.

//! @brief Get value of CSU_CSL6_SSW_S2 from a register value.
#define BG_CSU_CSL6_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_SSW_S2) >> BP_CSU_CSL6_SSW_S2)

//! @brief Format value for bitfield CSU_CSL6_SSW_S2.
#define BF_CSU_CSL6_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_SSW_S2) & BM_CSU_CSL6_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL6_SSW_S2(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_SSW_S2) | BF_CSU_CSL6_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL6, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL6_NUW_S2      (6)      //!< Bit position for CSU_CSL6_NUW_S2.
#define BM_CSU_CSL6_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL6_NUW_S2.

//! @brief Get value of CSU_CSL6_NUW_S2 from a register value.
#define BG_CSU_CSL6_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_NUW_S2) >> BP_CSU_CSL6_NUW_S2)

//! @brief Format value for bitfield CSU_CSL6_NUW_S2.
#define BF_CSU_CSL6_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_NUW_S2) & BM_CSU_CSL6_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL6_NUW_S2(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_NUW_S2) | BF_CSU_CSL6_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL6, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL6_NSW_S2      (7)      //!< Bit position for CSU_CSL6_NSW_S2.
#define BM_CSU_CSL6_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL6_NSW_S2.

//! @brief Get value of CSU_CSL6_NSW_S2 from a register value.
#define BG_CSU_CSL6_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_NSW_S2) >> BP_CSU_CSL6_NSW_S2)

//! @brief Format value for bitfield CSU_CSL6_NSW_S2.
#define BF_CSU_CSL6_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_NSW_S2) & BM_CSU_CSL6_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL6_NSW_S2(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_NSW_S2) | BF_CSU_CSL6_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL6, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL6_LOCK_S2      (8)      //!< Bit position for CSU_CSL6_LOCK_S2.
#define BM_CSU_CSL6_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL6_LOCK_S2.

//! @brief Get value of CSU_CSL6_LOCK_S2 from a register value.
#define BG_CSU_CSL6_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_LOCK_S2) >> BP_CSU_CSL6_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL6_LOCK_S2.
#define BF_CSU_CSL6_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_LOCK_S2) & BM_CSU_CSL6_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL6_LOCK_S2(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_LOCK_S2) | BF_CSU_CSL6_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL6, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL6_SUR_S1      (16)      //!< Bit position for CSU_CSL6_SUR_S1.
#define BM_CSU_CSL6_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL6_SUR_S1.

//! @brief Get value of CSU_CSL6_SUR_S1 from a register value.
#define BG_CSU_CSL6_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_SUR_S1) >> BP_CSU_CSL6_SUR_S1)

//! @brief Format value for bitfield CSU_CSL6_SUR_S1.
#define BF_CSU_CSL6_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_SUR_S1) & BM_CSU_CSL6_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL6_SUR_S1(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_SUR_S1) | BF_CSU_CSL6_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL6, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL6_SSR_S1      (17)      //!< Bit position for CSU_CSL6_SSR_S1.
#define BM_CSU_CSL6_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL6_SSR_S1.

//! @brief Get value of CSU_CSL6_SSR_S1 from a register value.
#define BG_CSU_CSL6_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_SSR_S1) >> BP_CSU_CSL6_SSR_S1)

//! @brief Format value for bitfield CSU_CSL6_SSR_S1.
#define BF_CSU_CSL6_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_SSR_S1) & BM_CSU_CSL6_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL6_SSR_S1(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_SSR_S1) | BF_CSU_CSL6_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL6, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL6_NUR_S1      (18)      //!< Bit position for CSU_CSL6_NUR_S1.
#define BM_CSU_CSL6_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL6_NUR_S1.

//! @brief Get value of CSU_CSL6_NUR_S1 from a register value.
#define BG_CSU_CSL6_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_NUR_S1) >> BP_CSU_CSL6_NUR_S1)

//! @brief Format value for bitfield CSU_CSL6_NUR_S1.
#define BF_CSU_CSL6_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_NUR_S1) & BM_CSU_CSL6_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL6_NUR_S1(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_NUR_S1) | BF_CSU_CSL6_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL6, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL6_NSR_S1      (19)      //!< Bit position for CSU_CSL6_NSR_S1.
#define BM_CSU_CSL6_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL6_NSR_S1.

//! @brief Get value of CSU_CSL6_NSR_S1 from a register value.
#define BG_CSU_CSL6_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_NSR_S1) >> BP_CSU_CSL6_NSR_S1)

//! @brief Format value for bitfield CSU_CSL6_NSR_S1.
#define BF_CSU_CSL6_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_NSR_S1) & BM_CSU_CSL6_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL6_NSR_S1(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_NSR_S1) | BF_CSU_CSL6_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL6, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL6_SUW_S1      (20)      //!< Bit position for CSU_CSL6_SUW_S1.
#define BM_CSU_CSL6_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL6_SUW_S1.

//! @brief Get value of CSU_CSL6_SUW_S1 from a register value.
#define BG_CSU_CSL6_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_SUW_S1) >> BP_CSU_CSL6_SUW_S1)

//! @brief Format value for bitfield CSU_CSL6_SUW_S1.
#define BF_CSU_CSL6_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_SUW_S1) & BM_CSU_CSL6_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL6_SUW_S1(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_SUW_S1) | BF_CSU_CSL6_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL6, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL6_SSW_S1      (21)      //!< Bit position for CSU_CSL6_SSW_S1.
#define BM_CSU_CSL6_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL6_SSW_S1.

//! @brief Get value of CSU_CSL6_SSW_S1 from a register value.
#define BG_CSU_CSL6_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_SSW_S1) >> BP_CSU_CSL6_SSW_S1)

//! @brief Format value for bitfield CSU_CSL6_SSW_S1.
#define BF_CSU_CSL6_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_SSW_S1) & BM_CSU_CSL6_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL6_SSW_S1(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_SSW_S1) | BF_CSU_CSL6_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL6, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL6_NUW_S1      (22)      //!< Bit position for CSU_CSL6_NUW_S1.
#define BM_CSU_CSL6_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL6_NUW_S1.

//! @brief Get value of CSU_CSL6_NUW_S1 from a register value.
#define BG_CSU_CSL6_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_NUW_S1) >> BP_CSU_CSL6_NUW_S1)

//! @brief Format value for bitfield CSU_CSL6_NUW_S1.
#define BF_CSU_CSL6_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_NUW_S1) & BM_CSU_CSL6_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL6_NUW_S1(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_NUW_S1) | BF_CSU_CSL6_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL6, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL6_NSW_S1      (23)      //!< Bit position for CSU_CSL6_NSW_S1.
#define BM_CSU_CSL6_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL6_NSW_S1.

//! @brief Get value of CSU_CSL6_NSW_S1 from a register value.
#define BG_CSU_CSL6_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_NSW_S1) >> BP_CSU_CSL6_NSW_S1)

//! @brief Format value for bitfield CSU_CSL6_NSW_S1.
#define BF_CSU_CSL6_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_NSW_S1) & BM_CSU_CSL6_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL6_NSW_S1(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_NSW_S1) | BF_CSU_CSL6_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL6, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL6_LOCK_S1      (24)      //!< Bit position for CSU_CSL6_LOCK_S1.
#define BM_CSU_CSL6_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL6_LOCK_S1.

//! @brief Get value of CSU_CSL6_LOCK_S1 from a register value.
#define BG_CSU_CSL6_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL6_LOCK_S1) >> BP_CSU_CSL6_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL6_LOCK_S1.
#define BF_CSU_CSL6_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL6_LOCK_S1) & BM_CSU_CSL6_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL6_LOCK_S1(v)   (HW_CSU_CSL6_WR((HW_CSU_CSL6_RD() & ~BM_CSU_CSL6_LOCK_S1) | BF_CSU_CSL6_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL7 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL7 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl7
{
    reg32_t U;
    struct _hw_csu_csl7_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl7_t;
#endif

/*
 * constants & macros for entire CSU_CSL7 register
 */
#define HW_CSU_CSL7_ADDR      (REGS_CSU_BASE + 0x1c)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL7           (*(volatile hw_csu_csl7_t *) HW_CSU_CSL7_ADDR)
#define HW_CSU_CSL7_RD()      (HW_CSU_CSL7.U)
#define HW_CSU_CSL7_WR(v)     (HW_CSU_CSL7.U = (v))
#define HW_CSU_CSL7_SET(v)    (HW_CSU_CSL7_WR(HW_CSU_CSL7_RD() |  (v)))
#define HW_CSU_CSL7_CLR(v)    (HW_CSU_CSL7_WR(HW_CSU_CSL7_RD() & ~(v)))
#define HW_CSU_CSL7_TOG(v)    (HW_CSU_CSL7_WR(HW_CSU_CSL7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL7 bitfields
 */

/* --- Register HW_CSU_CSL7, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL7_SUR_S2      (0)      //!< Bit position for CSU_CSL7_SUR_S2.
#define BM_CSU_CSL7_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL7_SUR_S2.

//! @brief Get value of CSU_CSL7_SUR_S2 from a register value.
#define BG_CSU_CSL7_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_SUR_S2) >> BP_CSU_CSL7_SUR_S2)

//! @brief Format value for bitfield CSU_CSL7_SUR_S2.
#define BF_CSU_CSL7_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_SUR_S2) & BM_CSU_CSL7_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL7_SUR_S2(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_SUR_S2) | BF_CSU_CSL7_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL7, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL7_SSR_S2      (1)      //!< Bit position for CSU_CSL7_SSR_S2.
#define BM_CSU_CSL7_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL7_SSR_S2.

//! @brief Get value of CSU_CSL7_SSR_S2 from a register value.
#define BG_CSU_CSL7_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_SSR_S2) >> BP_CSU_CSL7_SSR_S2)

//! @brief Format value for bitfield CSU_CSL7_SSR_S2.
#define BF_CSU_CSL7_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_SSR_S2) & BM_CSU_CSL7_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL7_SSR_S2(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_SSR_S2) | BF_CSU_CSL7_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL7, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL7_NUR_S2      (2)      //!< Bit position for CSU_CSL7_NUR_S2.
#define BM_CSU_CSL7_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL7_NUR_S2.

//! @brief Get value of CSU_CSL7_NUR_S2 from a register value.
#define BG_CSU_CSL7_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_NUR_S2) >> BP_CSU_CSL7_NUR_S2)

//! @brief Format value for bitfield CSU_CSL7_NUR_S2.
#define BF_CSU_CSL7_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_NUR_S2) & BM_CSU_CSL7_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL7_NUR_S2(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_NUR_S2) | BF_CSU_CSL7_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL7, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL7_NSR_S2      (3)      //!< Bit position for CSU_CSL7_NSR_S2.
#define BM_CSU_CSL7_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL7_NSR_S2.

//! @brief Get value of CSU_CSL7_NSR_S2 from a register value.
#define BG_CSU_CSL7_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_NSR_S2) >> BP_CSU_CSL7_NSR_S2)

//! @brief Format value for bitfield CSU_CSL7_NSR_S2.
#define BF_CSU_CSL7_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_NSR_S2) & BM_CSU_CSL7_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL7_NSR_S2(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_NSR_S2) | BF_CSU_CSL7_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL7, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL7_SUW_S2      (4)      //!< Bit position for CSU_CSL7_SUW_S2.
#define BM_CSU_CSL7_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL7_SUW_S2.

//! @brief Get value of CSU_CSL7_SUW_S2 from a register value.
#define BG_CSU_CSL7_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_SUW_S2) >> BP_CSU_CSL7_SUW_S2)

//! @brief Format value for bitfield CSU_CSL7_SUW_S2.
#define BF_CSU_CSL7_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_SUW_S2) & BM_CSU_CSL7_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL7_SUW_S2(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_SUW_S2) | BF_CSU_CSL7_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL7, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL7_SSW_S2      (5)      //!< Bit position for CSU_CSL7_SSW_S2.
#define BM_CSU_CSL7_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL7_SSW_S2.

//! @brief Get value of CSU_CSL7_SSW_S2 from a register value.
#define BG_CSU_CSL7_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_SSW_S2) >> BP_CSU_CSL7_SSW_S2)

//! @brief Format value for bitfield CSU_CSL7_SSW_S2.
#define BF_CSU_CSL7_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_SSW_S2) & BM_CSU_CSL7_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL7_SSW_S2(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_SSW_S2) | BF_CSU_CSL7_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL7, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL7_NUW_S2      (6)      //!< Bit position for CSU_CSL7_NUW_S2.
#define BM_CSU_CSL7_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL7_NUW_S2.

//! @brief Get value of CSU_CSL7_NUW_S2 from a register value.
#define BG_CSU_CSL7_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_NUW_S2) >> BP_CSU_CSL7_NUW_S2)

//! @brief Format value for bitfield CSU_CSL7_NUW_S2.
#define BF_CSU_CSL7_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_NUW_S2) & BM_CSU_CSL7_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL7_NUW_S2(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_NUW_S2) | BF_CSU_CSL7_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL7, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL7_NSW_S2      (7)      //!< Bit position for CSU_CSL7_NSW_S2.
#define BM_CSU_CSL7_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL7_NSW_S2.

//! @brief Get value of CSU_CSL7_NSW_S2 from a register value.
#define BG_CSU_CSL7_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_NSW_S2) >> BP_CSU_CSL7_NSW_S2)

//! @brief Format value for bitfield CSU_CSL7_NSW_S2.
#define BF_CSU_CSL7_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_NSW_S2) & BM_CSU_CSL7_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL7_NSW_S2(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_NSW_S2) | BF_CSU_CSL7_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL7, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL7_LOCK_S2      (8)      //!< Bit position for CSU_CSL7_LOCK_S2.
#define BM_CSU_CSL7_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL7_LOCK_S2.

//! @brief Get value of CSU_CSL7_LOCK_S2 from a register value.
#define BG_CSU_CSL7_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_LOCK_S2) >> BP_CSU_CSL7_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL7_LOCK_S2.
#define BF_CSU_CSL7_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_LOCK_S2) & BM_CSU_CSL7_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL7_LOCK_S2(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_LOCK_S2) | BF_CSU_CSL7_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL7, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL7_SUR_S1      (16)      //!< Bit position for CSU_CSL7_SUR_S1.
#define BM_CSU_CSL7_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL7_SUR_S1.

//! @brief Get value of CSU_CSL7_SUR_S1 from a register value.
#define BG_CSU_CSL7_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_SUR_S1) >> BP_CSU_CSL7_SUR_S1)

//! @brief Format value for bitfield CSU_CSL7_SUR_S1.
#define BF_CSU_CSL7_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_SUR_S1) & BM_CSU_CSL7_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL7_SUR_S1(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_SUR_S1) | BF_CSU_CSL7_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL7, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL7_SSR_S1      (17)      //!< Bit position for CSU_CSL7_SSR_S1.
#define BM_CSU_CSL7_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL7_SSR_S1.

//! @brief Get value of CSU_CSL7_SSR_S1 from a register value.
#define BG_CSU_CSL7_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_SSR_S1) >> BP_CSU_CSL7_SSR_S1)

//! @brief Format value for bitfield CSU_CSL7_SSR_S1.
#define BF_CSU_CSL7_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_SSR_S1) & BM_CSU_CSL7_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL7_SSR_S1(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_SSR_S1) | BF_CSU_CSL7_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL7, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL7_NUR_S1      (18)      //!< Bit position for CSU_CSL7_NUR_S1.
#define BM_CSU_CSL7_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL7_NUR_S1.

//! @brief Get value of CSU_CSL7_NUR_S1 from a register value.
#define BG_CSU_CSL7_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_NUR_S1) >> BP_CSU_CSL7_NUR_S1)

//! @brief Format value for bitfield CSU_CSL7_NUR_S1.
#define BF_CSU_CSL7_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_NUR_S1) & BM_CSU_CSL7_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL7_NUR_S1(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_NUR_S1) | BF_CSU_CSL7_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL7, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL7_NSR_S1      (19)      //!< Bit position for CSU_CSL7_NSR_S1.
#define BM_CSU_CSL7_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL7_NSR_S1.

//! @brief Get value of CSU_CSL7_NSR_S1 from a register value.
#define BG_CSU_CSL7_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_NSR_S1) >> BP_CSU_CSL7_NSR_S1)

//! @brief Format value for bitfield CSU_CSL7_NSR_S1.
#define BF_CSU_CSL7_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_NSR_S1) & BM_CSU_CSL7_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL7_NSR_S1(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_NSR_S1) | BF_CSU_CSL7_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL7, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL7_SUW_S1      (20)      //!< Bit position for CSU_CSL7_SUW_S1.
#define BM_CSU_CSL7_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL7_SUW_S1.

//! @brief Get value of CSU_CSL7_SUW_S1 from a register value.
#define BG_CSU_CSL7_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_SUW_S1) >> BP_CSU_CSL7_SUW_S1)

//! @brief Format value for bitfield CSU_CSL7_SUW_S1.
#define BF_CSU_CSL7_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_SUW_S1) & BM_CSU_CSL7_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL7_SUW_S1(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_SUW_S1) | BF_CSU_CSL7_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL7, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL7_SSW_S1      (21)      //!< Bit position for CSU_CSL7_SSW_S1.
#define BM_CSU_CSL7_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL7_SSW_S1.

//! @brief Get value of CSU_CSL7_SSW_S1 from a register value.
#define BG_CSU_CSL7_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_SSW_S1) >> BP_CSU_CSL7_SSW_S1)

//! @brief Format value for bitfield CSU_CSL7_SSW_S1.
#define BF_CSU_CSL7_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_SSW_S1) & BM_CSU_CSL7_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL7_SSW_S1(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_SSW_S1) | BF_CSU_CSL7_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL7, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL7_NUW_S1      (22)      //!< Bit position for CSU_CSL7_NUW_S1.
#define BM_CSU_CSL7_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL7_NUW_S1.

//! @brief Get value of CSU_CSL7_NUW_S1 from a register value.
#define BG_CSU_CSL7_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_NUW_S1) >> BP_CSU_CSL7_NUW_S1)

//! @brief Format value for bitfield CSU_CSL7_NUW_S1.
#define BF_CSU_CSL7_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_NUW_S1) & BM_CSU_CSL7_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL7_NUW_S1(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_NUW_S1) | BF_CSU_CSL7_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL7, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL7_NSW_S1      (23)      //!< Bit position for CSU_CSL7_NSW_S1.
#define BM_CSU_CSL7_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL7_NSW_S1.

//! @brief Get value of CSU_CSL7_NSW_S1 from a register value.
#define BG_CSU_CSL7_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_NSW_S1) >> BP_CSU_CSL7_NSW_S1)

//! @brief Format value for bitfield CSU_CSL7_NSW_S1.
#define BF_CSU_CSL7_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_NSW_S1) & BM_CSU_CSL7_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL7_NSW_S1(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_NSW_S1) | BF_CSU_CSL7_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL7, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL7_LOCK_S1      (24)      //!< Bit position for CSU_CSL7_LOCK_S1.
#define BM_CSU_CSL7_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL7_LOCK_S1.

//! @brief Get value of CSU_CSL7_LOCK_S1 from a register value.
#define BG_CSU_CSL7_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL7_LOCK_S1) >> BP_CSU_CSL7_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL7_LOCK_S1.
#define BF_CSU_CSL7_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL7_LOCK_S1) & BM_CSU_CSL7_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL7_LOCK_S1(v)   (HW_CSU_CSL7_WR((HW_CSU_CSL7_RD() & ~BM_CSU_CSL7_LOCK_S1) | BF_CSU_CSL7_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL8 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL8 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl8
{
    reg32_t U;
    struct _hw_csu_csl8_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl8_t;
#endif

/*
 * constants & macros for entire CSU_CSL8 register
 */
#define HW_CSU_CSL8_ADDR      (REGS_CSU_BASE + 0x20)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL8           (*(volatile hw_csu_csl8_t *) HW_CSU_CSL8_ADDR)
#define HW_CSU_CSL8_RD()      (HW_CSU_CSL8.U)
#define HW_CSU_CSL8_WR(v)     (HW_CSU_CSL8.U = (v))
#define HW_CSU_CSL8_SET(v)    (HW_CSU_CSL8_WR(HW_CSU_CSL8_RD() |  (v)))
#define HW_CSU_CSL8_CLR(v)    (HW_CSU_CSL8_WR(HW_CSU_CSL8_RD() & ~(v)))
#define HW_CSU_CSL8_TOG(v)    (HW_CSU_CSL8_WR(HW_CSU_CSL8_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL8 bitfields
 */

/* --- Register HW_CSU_CSL8, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL8_SUR_S2      (0)      //!< Bit position for CSU_CSL8_SUR_S2.
#define BM_CSU_CSL8_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL8_SUR_S2.

//! @brief Get value of CSU_CSL8_SUR_S2 from a register value.
#define BG_CSU_CSL8_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_SUR_S2) >> BP_CSU_CSL8_SUR_S2)

//! @brief Format value for bitfield CSU_CSL8_SUR_S2.
#define BF_CSU_CSL8_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_SUR_S2) & BM_CSU_CSL8_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL8_SUR_S2(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_SUR_S2) | BF_CSU_CSL8_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL8, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL8_SSR_S2      (1)      //!< Bit position for CSU_CSL8_SSR_S2.
#define BM_CSU_CSL8_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL8_SSR_S2.

//! @brief Get value of CSU_CSL8_SSR_S2 from a register value.
#define BG_CSU_CSL8_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_SSR_S2) >> BP_CSU_CSL8_SSR_S2)

//! @brief Format value for bitfield CSU_CSL8_SSR_S2.
#define BF_CSU_CSL8_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_SSR_S2) & BM_CSU_CSL8_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL8_SSR_S2(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_SSR_S2) | BF_CSU_CSL8_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL8, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL8_NUR_S2      (2)      //!< Bit position for CSU_CSL8_NUR_S2.
#define BM_CSU_CSL8_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL8_NUR_S2.

//! @brief Get value of CSU_CSL8_NUR_S2 from a register value.
#define BG_CSU_CSL8_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_NUR_S2) >> BP_CSU_CSL8_NUR_S2)

//! @brief Format value for bitfield CSU_CSL8_NUR_S2.
#define BF_CSU_CSL8_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_NUR_S2) & BM_CSU_CSL8_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL8_NUR_S2(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_NUR_S2) | BF_CSU_CSL8_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL8, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL8_NSR_S2      (3)      //!< Bit position for CSU_CSL8_NSR_S2.
#define BM_CSU_CSL8_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL8_NSR_S2.

//! @brief Get value of CSU_CSL8_NSR_S2 from a register value.
#define BG_CSU_CSL8_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_NSR_S2) >> BP_CSU_CSL8_NSR_S2)

//! @brief Format value for bitfield CSU_CSL8_NSR_S2.
#define BF_CSU_CSL8_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_NSR_S2) & BM_CSU_CSL8_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL8_NSR_S2(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_NSR_S2) | BF_CSU_CSL8_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL8, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL8_SUW_S2      (4)      //!< Bit position for CSU_CSL8_SUW_S2.
#define BM_CSU_CSL8_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL8_SUW_S2.

//! @brief Get value of CSU_CSL8_SUW_S2 from a register value.
#define BG_CSU_CSL8_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_SUW_S2) >> BP_CSU_CSL8_SUW_S2)

//! @brief Format value for bitfield CSU_CSL8_SUW_S2.
#define BF_CSU_CSL8_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_SUW_S2) & BM_CSU_CSL8_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL8_SUW_S2(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_SUW_S2) | BF_CSU_CSL8_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL8, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL8_SSW_S2      (5)      //!< Bit position for CSU_CSL8_SSW_S2.
#define BM_CSU_CSL8_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL8_SSW_S2.

//! @brief Get value of CSU_CSL8_SSW_S2 from a register value.
#define BG_CSU_CSL8_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_SSW_S2) >> BP_CSU_CSL8_SSW_S2)

//! @brief Format value for bitfield CSU_CSL8_SSW_S2.
#define BF_CSU_CSL8_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_SSW_S2) & BM_CSU_CSL8_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL8_SSW_S2(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_SSW_S2) | BF_CSU_CSL8_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL8, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL8_NUW_S2      (6)      //!< Bit position for CSU_CSL8_NUW_S2.
#define BM_CSU_CSL8_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL8_NUW_S2.

//! @brief Get value of CSU_CSL8_NUW_S2 from a register value.
#define BG_CSU_CSL8_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_NUW_S2) >> BP_CSU_CSL8_NUW_S2)

//! @brief Format value for bitfield CSU_CSL8_NUW_S2.
#define BF_CSU_CSL8_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_NUW_S2) & BM_CSU_CSL8_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL8_NUW_S2(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_NUW_S2) | BF_CSU_CSL8_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL8, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL8_NSW_S2      (7)      //!< Bit position for CSU_CSL8_NSW_S2.
#define BM_CSU_CSL8_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL8_NSW_S2.

//! @brief Get value of CSU_CSL8_NSW_S2 from a register value.
#define BG_CSU_CSL8_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_NSW_S2) >> BP_CSU_CSL8_NSW_S2)

//! @brief Format value for bitfield CSU_CSL8_NSW_S2.
#define BF_CSU_CSL8_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_NSW_S2) & BM_CSU_CSL8_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL8_NSW_S2(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_NSW_S2) | BF_CSU_CSL8_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL8, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL8_LOCK_S2      (8)      //!< Bit position for CSU_CSL8_LOCK_S2.
#define BM_CSU_CSL8_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL8_LOCK_S2.

//! @brief Get value of CSU_CSL8_LOCK_S2 from a register value.
#define BG_CSU_CSL8_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_LOCK_S2) >> BP_CSU_CSL8_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL8_LOCK_S2.
#define BF_CSU_CSL8_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_LOCK_S2) & BM_CSU_CSL8_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL8_LOCK_S2(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_LOCK_S2) | BF_CSU_CSL8_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL8, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL8_SUR_S1      (16)      //!< Bit position for CSU_CSL8_SUR_S1.
#define BM_CSU_CSL8_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL8_SUR_S1.

//! @brief Get value of CSU_CSL8_SUR_S1 from a register value.
#define BG_CSU_CSL8_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_SUR_S1) >> BP_CSU_CSL8_SUR_S1)

//! @brief Format value for bitfield CSU_CSL8_SUR_S1.
#define BF_CSU_CSL8_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_SUR_S1) & BM_CSU_CSL8_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL8_SUR_S1(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_SUR_S1) | BF_CSU_CSL8_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL8, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL8_SSR_S1      (17)      //!< Bit position for CSU_CSL8_SSR_S1.
#define BM_CSU_CSL8_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL8_SSR_S1.

//! @brief Get value of CSU_CSL8_SSR_S1 from a register value.
#define BG_CSU_CSL8_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_SSR_S1) >> BP_CSU_CSL8_SSR_S1)

//! @brief Format value for bitfield CSU_CSL8_SSR_S1.
#define BF_CSU_CSL8_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_SSR_S1) & BM_CSU_CSL8_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL8_SSR_S1(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_SSR_S1) | BF_CSU_CSL8_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL8, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL8_NUR_S1      (18)      //!< Bit position for CSU_CSL8_NUR_S1.
#define BM_CSU_CSL8_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL8_NUR_S1.

//! @brief Get value of CSU_CSL8_NUR_S1 from a register value.
#define BG_CSU_CSL8_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_NUR_S1) >> BP_CSU_CSL8_NUR_S1)

//! @brief Format value for bitfield CSU_CSL8_NUR_S1.
#define BF_CSU_CSL8_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_NUR_S1) & BM_CSU_CSL8_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL8_NUR_S1(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_NUR_S1) | BF_CSU_CSL8_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL8, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL8_NSR_S1      (19)      //!< Bit position for CSU_CSL8_NSR_S1.
#define BM_CSU_CSL8_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL8_NSR_S1.

//! @brief Get value of CSU_CSL8_NSR_S1 from a register value.
#define BG_CSU_CSL8_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_NSR_S1) >> BP_CSU_CSL8_NSR_S1)

//! @brief Format value for bitfield CSU_CSL8_NSR_S1.
#define BF_CSU_CSL8_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_NSR_S1) & BM_CSU_CSL8_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL8_NSR_S1(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_NSR_S1) | BF_CSU_CSL8_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL8, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL8_SUW_S1      (20)      //!< Bit position for CSU_CSL8_SUW_S1.
#define BM_CSU_CSL8_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL8_SUW_S1.

//! @brief Get value of CSU_CSL8_SUW_S1 from a register value.
#define BG_CSU_CSL8_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_SUW_S1) >> BP_CSU_CSL8_SUW_S1)

//! @brief Format value for bitfield CSU_CSL8_SUW_S1.
#define BF_CSU_CSL8_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_SUW_S1) & BM_CSU_CSL8_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL8_SUW_S1(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_SUW_S1) | BF_CSU_CSL8_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL8, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL8_SSW_S1      (21)      //!< Bit position for CSU_CSL8_SSW_S1.
#define BM_CSU_CSL8_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL8_SSW_S1.

//! @brief Get value of CSU_CSL8_SSW_S1 from a register value.
#define BG_CSU_CSL8_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_SSW_S1) >> BP_CSU_CSL8_SSW_S1)

//! @brief Format value for bitfield CSU_CSL8_SSW_S1.
#define BF_CSU_CSL8_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_SSW_S1) & BM_CSU_CSL8_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL8_SSW_S1(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_SSW_S1) | BF_CSU_CSL8_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL8, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL8_NUW_S1      (22)      //!< Bit position for CSU_CSL8_NUW_S1.
#define BM_CSU_CSL8_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL8_NUW_S1.

//! @brief Get value of CSU_CSL8_NUW_S1 from a register value.
#define BG_CSU_CSL8_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_NUW_S1) >> BP_CSU_CSL8_NUW_S1)

//! @brief Format value for bitfield CSU_CSL8_NUW_S1.
#define BF_CSU_CSL8_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_NUW_S1) & BM_CSU_CSL8_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL8_NUW_S1(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_NUW_S1) | BF_CSU_CSL8_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL8, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL8_NSW_S1      (23)      //!< Bit position for CSU_CSL8_NSW_S1.
#define BM_CSU_CSL8_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL8_NSW_S1.

//! @brief Get value of CSU_CSL8_NSW_S1 from a register value.
#define BG_CSU_CSL8_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_NSW_S1) >> BP_CSU_CSL8_NSW_S1)

//! @brief Format value for bitfield CSU_CSL8_NSW_S1.
#define BF_CSU_CSL8_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_NSW_S1) & BM_CSU_CSL8_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL8_NSW_S1(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_NSW_S1) | BF_CSU_CSL8_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL8, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL8_LOCK_S1      (24)      //!< Bit position for CSU_CSL8_LOCK_S1.
#define BM_CSU_CSL8_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL8_LOCK_S1.

//! @brief Get value of CSU_CSL8_LOCK_S1 from a register value.
#define BG_CSU_CSL8_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL8_LOCK_S1) >> BP_CSU_CSL8_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL8_LOCK_S1.
#define BF_CSU_CSL8_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL8_LOCK_S1) & BM_CSU_CSL8_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL8_LOCK_S1(v)   (HW_CSU_CSL8_WR((HW_CSU_CSL8_RD() & ~BM_CSU_CSL8_LOCK_S1) | BF_CSU_CSL8_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL9 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL9 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl9
{
    reg32_t U;
    struct _hw_csu_csl9_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl9_t;
#endif

/*
 * constants & macros for entire CSU_CSL9 register
 */
#define HW_CSU_CSL9_ADDR      (REGS_CSU_BASE + 0x24)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL9           (*(volatile hw_csu_csl9_t *) HW_CSU_CSL9_ADDR)
#define HW_CSU_CSL9_RD()      (HW_CSU_CSL9.U)
#define HW_CSU_CSL9_WR(v)     (HW_CSU_CSL9.U = (v))
#define HW_CSU_CSL9_SET(v)    (HW_CSU_CSL9_WR(HW_CSU_CSL9_RD() |  (v)))
#define HW_CSU_CSL9_CLR(v)    (HW_CSU_CSL9_WR(HW_CSU_CSL9_RD() & ~(v)))
#define HW_CSU_CSL9_TOG(v)    (HW_CSU_CSL9_WR(HW_CSU_CSL9_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL9 bitfields
 */

/* --- Register HW_CSU_CSL9, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL9_SUR_S2      (0)      //!< Bit position for CSU_CSL9_SUR_S2.
#define BM_CSU_CSL9_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL9_SUR_S2.

//! @brief Get value of CSU_CSL9_SUR_S2 from a register value.
#define BG_CSU_CSL9_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_SUR_S2) >> BP_CSU_CSL9_SUR_S2)

//! @brief Format value for bitfield CSU_CSL9_SUR_S2.
#define BF_CSU_CSL9_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_SUR_S2) & BM_CSU_CSL9_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL9_SUR_S2(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_SUR_S2) | BF_CSU_CSL9_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL9, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL9_SSR_S2      (1)      //!< Bit position for CSU_CSL9_SSR_S2.
#define BM_CSU_CSL9_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL9_SSR_S2.

//! @brief Get value of CSU_CSL9_SSR_S2 from a register value.
#define BG_CSU_CSL9_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_SSR_S2) >> BP_CSU_CSL9_SSR_S2)

//! @brief Format value for bitfield CSU_CSL9_SSR_S2.
#define BF_CSU_CSL9_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_SSR_S2) & BM_CSU_CSL9_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL9_SSR_S2(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_SSR_S2) | BF_CSU_CSL9_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL9, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL9_NUR_S2      (2)      //!< Bit position for CSU_CSL9_NUR_S2.
#define BM_CSU_CSL9_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL9_NUR_S2.

//! @brief Get value of CSU_CSL9_NUR_S2 from a register value.
#define BG_CSU_CSL9_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_NUR_S2) >> BP_CSU_CSL9_NUR_S2)

//! @brief Format value for bitfield CSU_CSL9_NUR_S2.
#define BF_CSU_CSL9_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_NUR_S2) & BM_CSU_CSL9_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL9_NUR_S2(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_NUR_S2) | BF_CSU_CSL9_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL9, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL9_NSR_S2      (3)      //!< Bit position for CSU_CSL9_NSR_S2.
#define BM_CSU_CSL9_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL9_NSR_S2.

//! @brief Get value of CSU_CSL9_NSR_S2 from a register value.
#define BG_CSU_CSL9_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_NSR_S2) >> BP_CSU_CSL9_NSR_S2)

//! @brief Format value for bitfield CSU_CSL9_NSR_S2.
#define BF_CSU_CSL9_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_NSR_S2) & BM_CSU_CSL9_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL9_NSR_S2(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_NSR_S2) | BF_CSU_CSL9_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL9, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL9_SUW_S2      (4)      //!< Bit position for CSU_CSL9_SUW_S2.
#define BM_CSU_CSL9_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL9_SUW_S2.

//! @brief Get value of CSU_CSL9_SUW_S2 from a register value.
#define BG_CSU_CSL9_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_SUW_S2) >> BP_CSU_CSL9_SUW_S2)

//! @brief Format value for bitfield CSU_CSL9_SUW_S2.
#define BF_CSU_CSL9_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_SUW_S2) & BM_CSU_CSL9_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL9_SUW_S2(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_SUW_S2) | BF_CSU_CSL9_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL9, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL9_SSW_S2      (5)      //!< Bit position for CSU_CSL9_SSW_S2.
#define BM_CSU_CSL9_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL9_SSW_S2.

//! @brief Get value of CSU_CSL9_SSW_S2 from a register value.
#define BG_CSU_CSL9_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_SSW_S2) >> BP_CSU_CSL9_SSW_S2)

//! @brief Format value for bitfield CSU_CSL9_SSW_S2.
#define BF_CSU_CSL9_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_SSW_S2) & BM_CSU_CSL9_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL9_SSW_S2(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_SSW_S2) | BF_CSU_CSL9_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL9, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL9_NUW_S2      (6)      //!< Bit position for CSU_CSL9_NUW_S2.
#define BM_CSU_CSL9_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL9_NUW_S2.

//! @brief Get value of CSU_CSL9_NUW_S2 from a register value.
#define BG_CSU_CSL9_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_NUW_S2) >> BP_CSU_CSL9_NUW_S2)

//! @brief Format value for bitfield CSU_CSL9_NUW_S2.
#define BF_CSU_CSL9_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_NUW_S2) & BM_CSU_CSL9_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL9_NUW_S2(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_NUW_S2) | BF_CSU_CSL9_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL9, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL9_NSW_S2      (7)      //!< Bit position for CSU_CSL9_NSW_S2.
#define BM_CSU_CSL9_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL9_NSW_S2.

//! @brief Get value of CSU_CSL9_NSW_S2 from a register value.
#define BG_CSU_CSL9_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_NSW_S2) >> BP_CSU_CSL9_NSW_S2)

//! @brief Format value for bitfield CSU_CSL9_NSW_S2.
#define BF_CSU_CSL9_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_NSW_S2) & BM_CSU_CSL9_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL9_NSW_S2(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_NSW_S2) | BF_CSU_CSL9_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL9, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL9_LOCK_S2      (8)      //!< Bit position for CSU_CSL9_LOCK_S2.
#define BM_CSU_CSL9_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL9_LOCK_S2.

//! @brief Get value of CSU_CSL9_LOCK_S2 from a register value.
#define BG_CSU_CSL9_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_LOCK_S2) >> BP_CSU_CSL9_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL9_LOCK_S2.
#define BF_CSU_CSL9_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_LOCK_S2) & BM_CSU_CSL9_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL9_LOCK_S2(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_LOCK_S2) | BF_CSU_CSL9_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL9, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL9_SUR_S1      (16)      //!< Bit position for CSU_CSL9_SUR_S1.
#define BM_CSU_CSL9_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL9_SUR_S1.

//! @brief Get value of CSU_CSL9_SUR_S1 from a register value.
#define BG_CSU_CSL9_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_SUR_S1) >> BP_CSU_CSL9_SUR_S1)

//! @brief Format value for bitfield CSU_CSL9_SUR_S1.
#define BF_CSU_CSL9_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_SUR_S1) & BM_CSU_CSL9_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL9_SUR_S1(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_SUR_S1) | BF_CSU_CSL9_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL9, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL9_SSR_S1      (17)      //!< Bit position for CSU_CSL9_SSR_S1.
#define BM_CSU_CSL9_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL9_SSR_S1.

//! @brief Get value of CSU_CSL9_SSR_S1 from a register value.
#define BG_CSU_CSL9_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_SSR_S1) >> BP_CSU_CSL9_SSR_S1)

//! @brief Format value for bitfield CSU_CSL9_SSR_S1.
#define BF_CSU_CSL9_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_SSR_S1) & BM_CSU_CSL9_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL9_SSR_S1(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_SSR_S1) | BF_CSU_CSL9_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL9, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL9_NUR_S1      (18)      //!< Bit position for CSU_CSL9_NUR_S1.
#define BM_CSU_CSL9_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL9_NUR_S1.

//! @brief Get value of CSU_CSL9_NUR_S1 from a register value.
#define BG_CSU_CSL9_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_NUR_S1) >> BP_CSU_CSL9_NUR_S1)

//! @brief Format value for bitfield CSU_CSL9_NUR_S1.
#define BF_CSU_CSL9_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_NUR_S1) & BM_CSU_CSL9_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL9_NUR_S1(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_NUR_S1) | BF_CSU_CSL9_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL9, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL9_NSR_S1      (19)      //!< Bit position for CSU_CSL9_NSR_S1.
#define BM_CSU_CSL9_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL9_NSR_S1.

//! @brief Get value of CSU_CSL9_NSR_S1 from a register value.
#define BG_CSU_CSL9_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_NSR_S1) >> BP_CSU_CSL9_NSR_S1)

//! @brief Format value for bitfield CSU_CSL9_NSR_S1.
#define BF_CSU_CSL9_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_NSR_S1) & BM_CSU_CSL9_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL9_NSR_S1(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_NSR_S1) | BF_CSU_CSL9_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL9, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL9_SUW_S1      (20)      //!< Bit position for CSU_CSL9_SUW_S1.
#define BM_CSU_CSL9_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL9_SUW_S1.

//! @brief Get value of CSU_CSL9_SUW_S1 from a register value.
#define BG_CSU_CSL9_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_SUW_S1) >> BP_CSU_CSL9_SUW_S1)

//! @brief Format value for bitfield CSU_CSL9_SUW_S1.
#define BF_CSU_CSL9_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_SUW_S1) & BM_CSU_CSL9_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL9_SUW_S1(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_SUW_S1) | BF_CSU_CSL9_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL9, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL9_SSW_S1      (21)      //!< Bit position for CSU_CSL9_SSW_S1.
#define BM_CSU_CSL9_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL9_SSW_S1.

//! @brief Get value of CSU_CSL9_SSW_S1 from a register value.
#define BG_CSU_CSL9_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_SSW_S1) >> BP_CSU_CSL9_SSW_S1)

//! @brief Format value for bitfield CSU_CSL9_SSW_S1.
#define BF_CSU_CSL9_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_SSW_S1) & BM_CSU_CSL9_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL9_SSW_S1(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_SSW_S1) | BF_CSU_CSL9_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL9, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL9_NUW_S1      (22)      //!< Bit position for CSU_CSL9_NUW_S1.
#define BM_CSU_CSL9_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL9_NUW_S1.

//! @brief Get value of CSU_CSL9_NUW_S1 from a register value.
#define BG_CSU_CSL9_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_NUW_S1) >> BP_CSU_CSL9_NUW_S1)

//! @brief Format value for bitfield CSU_CSL9_NUW_S1.
#define BF_CSU_CSL9_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_NUW_S1) & BM_CSU_CSL9_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL9_NUW_S1(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_NUW_S1) | BF_CSU_CSL9_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL9, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL9_NSW_S1      (23)      //!< Bit position for CSU_CSL9_NSW_S1.
#define BM_CSU_CSL9_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL9_NSW_S1.

//! @brief Get value of CSU_CSL9_NSW_S1 from a register value.
#define BG_CSU_CSL9_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_NSW_S1) >> BP_CSU_CSL9_NSW_S1)

//! @brief Format value for bitfield CSU_CSL9_NSW_S1.
#define BF_CSU_CSL9_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_NSW_S1) & BM_CSU_CSL9_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL9_NSW_S1(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_NSW_S1) | BF_CSU_CSL9_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL9, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL9_LOCK_S1      (24)      //!< Bit position for CSU_CSL9_LOCK_S1.
#define BM_CSU_CSL9_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL9_LOCK_S1.

//! @brief Get value of CSU_CSL9_LOCK_S1 from a register value.
#define BG_CSU_CSL9_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL9_LOCK_S1) >> BP_CSU_CSL9_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL9_LOCK_S1.
#define BF_CSU_CSL9_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL9_LOCK_S1) & BM_CSU_CSL9_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL9_LOCK_S1(v)   (HW_CSU_CSL9_WR((HW_CSU_CSL9_RD() & ~BM_CSU_CSL9_LOCK_S1) | BF_CSU_CSL9_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL10 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL10 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl10
{
    reg32_t U;
    struct _hw_csu_csl10_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl10_t;
#endif

/*
 * constants & macros for entire CSU_CSL10 register
 */
#define HW_CSU_CSL10_ADDR      (REGS_CSU_BASE + 0x28)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL10           (*(volatile hw_csu_csl10_t *) HW_CSU_CSL10_ADDR)
#define HW_CSU_CSL10_RD()      (HW_CSU_CSL10.U)
#define HW_CSU_CSL10_WR(v)     (HW_CSU_CSL10.U = (v))
#define HW_CSU_CSL10_SET(v)    (HW_CSU_CSL10_WR(HW_CSU_CSL10_RD() |  (v)))
#define HW_CSU_CSL10_CLR(v)    (HW_CSU_CSL10_WR(HW_CSU_CSL10_RD() & ~(v)))
#define HW_CSU_CSL10_TOG(v)    (HW_CSU_CSL10_WR(HW_CSU_CSL10_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL10 bitfields
 */

/* --- Register HW_CSU_CSL10, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL10_SUR_S2      (0)      //!< Bit position for CSU_CSL10_SUR_S2.
#define BM_CSU_CSL10_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL10_SUR_S2.

//! @brief Get value of CSU_CSL10_SUR_S2 from a register value.
#define BG_CSU_CSL10_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_SUR_S2) >> BP_CSU_CSL10_SUR_S2)

//! @brief Format value for bitfield CSU_CSL10_SUR_S2.
#define BF_CSU_CSL10_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_SUR_S2) & BM_CSU_CSL10_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL10_SUR_S2(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_SUR_S2) | BF_CSU_CSL10_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL10, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL10_SSR_S2      (1)      //!< Bit position for CSU_CSL10_SSR_S2.
#define BM_CSU_CSL10_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL10_SSR_S2.

//! @brief Get value of CSU_CSL10_SSR_S2 from a register value.
#define BG_CSU_CSL10_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_SSR_S2) >> BP_CSU_CSL10_SSR_S2)

//! @brief Format value for bitfield CSU_CSL10_SSR_S2.
#define BF_CSU_CSL10_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_SSR_S2) & BM_CSU_CSL10_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL10_SSR_S2(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_SSR_S2) | BF_CSU_CSL10_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL10, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL10_NUR_S2      (2)      //!< Bit position for CSU_CSL10_NUR_S2.
#define BM_CSU_CSL10_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL10_NUR_S2.

//! @brief Get value of CSU_CSL10_NUR_S2 from a register value.
#define BG_CSU_CSL10_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_NUR_S2) >> BP_CSU_CSL10_NUR_S2)

//! @brief Format value for bitfield CSU_CSL10_NUR_S2.
#define BF_CSU_CSL10_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_NUR_S2) & BM_CSU_CSL10_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL10_NUR_S2(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_NUR_S2) | BF_CSU_CSL10_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL10, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL10_NSR_S2      (3)      //!< Bit position for CSU_CSL10_NSR_S2.
#define BM_CSU_CSL10_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL10_NSR_S2.

//! @brief Get value of CSU_CSL10_NSR_S2 from a register value.
#define BG_CSU_CSL10_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_NSR_S2) >> BP_CSU_CSL10_NSR_S2)

//! @brief Format value for bitfield CSU_CSL10_NSR_S2.
#define BF_CSU_CSL10_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_NSR_S2) & BM_CSU_CSL10_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL10_NSR_S2(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_NSR_S2) | BF_CSU_CSL10_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL10, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL10_SUW_S2      (4)      //!< Bit position for CSU_CSL10_SUW_S2.
#define BM_CSU_CSL10_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL10_SUW_S2.

//! @brief Get value of CSU_CSL10_SUW_S2 from a register value.
#define BG_CSU_CSL10_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_SUW_S2) >> BP_CSU_CSL10_SUW_S2)

//! @brief Format value for bitfield CSU_CSL10_SUW_S2.
#define BF_CSU_CSL10_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_SUW_S2) & BM_CSU_CSL10_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL10_SUW_S2(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_SUW_S2) | BF_CSU_CSL10_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL10, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL10_SSW_S2      (5)      //!< Bit position for CSU_CSL10_SSW_S2.
#define BM_CSU_CSL10_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL10_SSW_S2.

//! @brief Get value of CSU_CSL10_SSW_S2 from a register value.
#define BG_CSU_CSL10_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_SSW_S2) >> BP_CSU_CSL10_SSW_S2)

//! @brief Format value for bitfield CSU_CSL10_SSW_S2.
#define BF_CSU_CSL10_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_SSW_S2) & BM_CSU_CSL10_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL10_SSW_S2(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_SSW_S2) | BF_CSU_CSL10_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL10, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL10_NUW_S2      (6)      //!< Bit position for CSU_CSL10_NUW_S2.
#define BM_CSU_CSL10_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL10_NUW_S2.

//! @brief Get value of CSU_CSL10_NUW_S2 from a register value.
#define BG_CSU_CSL10_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_NUW_S2) >> BP_CSU_CSL10_NUW_S2)

//! @brief Format value for bitfield CSU_CSL10_NUW_S2.
#define BF_CSU_CSL10_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_NUW_S2) & BM_CSU_CSL10_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL10_NUW_S2(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_NUW_S2) | BF_CSU_CSL10_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL10, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL10_NSW_S2      (7)      //!< Bit position for CSU_CSL10_NSW_S2.
#define BM_CSU_CSL10_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL10_NSW_S2.

//! @brief Get value of CSU_CSL10_NSW_S2 from a register value.
#define BG_CSU_CSL10_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_NSW_S2) >> BP_CSU_CSL10_NSW_S2)

//! @brief Format value for bitfield CSU_CSL10_NSW_S2.
#define BF_CSU_CSL10_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_NSW_S2) & BM_CSU_CSL10_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL10_NSW_S2(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_NSW_S2) | BF_CSU_CSL10_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL10, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL10_LOCK_S2      (8)      //!< Bit position for CSU_CSL10_LOCK_S2.
#define BM_CSU_CSL10_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL10_LOCK_S2.

//! @brief Get value of CSU_CSL10_LOCK_S2 from a register value.
#define BG_CSU_CSL10_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_LOCK_S2) >> BP_CSU_CSL10_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL10_LOCK_S2.
#define BF_CSU_CSL10_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_LOCK_S2) & BM_CSU_CSL10_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL10_LOCK_S2(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_LOCK_S2) | BF_CSU_CSL10_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL10, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL10_SUR_S1      (16)      //!< Bit position for CSU_CSL10_SUR_S1.
#define BM_CSU_CSL10_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL10_SUR_S1.

//! @brief Get value of CSU_CSL10_SUR_S1 from a register value.
#define BG_CSU_CSL10_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_SUR_S1) >> BP_CSU_CSL10_SUR_S1)

//! @brief Format value for bitfield CSU_CSL10_SUR_S1.
#define BF_CSU_CSL10_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_SUR_S1) & BM_CSU_CSL10_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL10_SUR_S1(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_SUR_S1) | BF_CSU_CSL10_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL10, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL10_SSR_S1      (17)      //!< Bit position for CSU_CSL10_SSR_S1.
#define BM_CSU_CSL10_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL10_SSR_S1.

//! @brief Get value of CSU_CSL10_SSR_S1 from a register value.
#define BG_CSU_CSL10_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_SSR_S1) >> BP_CSU_CSL10_SSR_S1)

//! @brief Format value for bitfield CSU_CSL10_SSR_S1.
#define BF_CSU_CSL10_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_SSR_S1) & BM_CSU_CSL10_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL10_SSR_S1(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_SSR_S1) | BF_CSU_CSL10_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL10, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL10_NUR_S1      (18)      //!< Bit position for CSU_CSL10_NUR_S1.
#define BM_CSU_CSL10_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL10_NUR_S1.

//! @brief Get value of CSU_CSL10_NUR_S1 from a register value.
#define BG_CSU_CSL10_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_NUR_S1) >> BP_CSU_CSL10_NUR_S1)

//! @brief Format value for bitfield CSU_CSL10_NUR_S1.
#define BF_CSU_CSL10_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_NUR_S1) & BM_CSU_CSL10_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL10_NUR_S1(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_NUR_S1) | BF_CSU_CSL10_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL10, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL10_NSR_S1      (19)      //!< Bit position for CSU_CSL10_NSR_S1.
#define BM_CSU_CSL10_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL10_NSR_S1.

//! @brief Get value of CSU_CSL10_NSR_S1 from a register value.
#define BG_CSU_CSL10_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_NSR_S1) >> BP_CSU_CSL10_NSR_S1)

//! @brief Format value for bitfield CSU_CSL10_NSR_S1.
#define BF_CSU_CSL10_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_NSR_S1) & BM_CSU_CSL10_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL10_NSR_S1(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_NSR_S1) | BF_CSU_CSL10_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL10, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL10_SUW_S1      (20)      //!< Bit position for CSU_CSL10_SUW_S1.
#define BM_CSU_CSL10_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL10_SUW_S1.

//! @brief Get value of CSU_CSL10_SUW_S1 from a register value.
#define BG_CSU_CSL10_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_SUW_S1) >> BP_CSU_CSL10_SUW_S1)

//! @brief Format value for bitfield CSU_CSL10_SUW_S1.
#define BF_CSU_CSL10_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_SUW_S1) & BM_CSU_CSL10_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL10_SUW_S1(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_SUW_S1) | BF_CSU_CSL10_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL10, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL10_SSW_S1      (21)      //!< Bit position for CSU_CSL10_SSW_S1.
#define BM_CSU_CSL10_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL10_SSW_S1.

//! @brief Get value of CSU_CSL10_SSW_S1 from a register value.
#define BG_CSU_CSL10_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_SSW_S1) >> BP_CSU_CSL10_SSW_S1)

//! @brief Format value for bitfield CSU_CSL10_SSW_S1.
#define BF_CSU_CSL10_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_SSW_S1) & BM_CSU_CSL10_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL10_SSW_S1(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_SSW_S1) | BF_CSU_CSL10_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL10, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL10_NUW_S1      (22)      //!< Bit position for CSU_CSL10_NUW_S1.
#define BM_CSU_CSL10_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL10_NUW_S1.

//! @brief Get value of CSU_CSL10_NUW_S1 from a register value.
#define BG_CSU_CSL10_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_NUW_S1) >> BP_CSU_CSL10_NUW_S1)

//! @brief Format value for bitfield CSU_CSL10_NUW_S1.
#define BF_CSU_CSL10_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_NUW_S1) & BM_CSU_CSL10_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL10_NUW_S1(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_NUW_S1) | BF_CSU_CSL10_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL10, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL10_NSW_S1      (23)      //!< Bit position for CSU_CSL10_NSW_S1.
#define BM_CSU_CSL10_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL10_NSW_S1.

//! @brief Get value of CSU_CSL10_NSW_S1 from a register value.
#define BG_CSU_CSL10_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_NSW_S1) >> BP_CSU_CSL10_NSW_S1)

//! @brief Format value for bitfield CSU_CSL10_NSW_S1.
#define BF_CSU_CSL10_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_NSW_S1) & BM_CSU_CSL10_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL10_NSW_S1(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_NSW_S1) | BF_CSU_CSL10_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL10, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL10_LOCK_S1      (24)      //!< Bit position for CSU_CSL10_LOCK_S1.
#define BM_CSU_CSL10_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL10_LOCK_S1.

//! @brief Get value of CSU_CSL10_LOCK_S1 from a register value.
#define BG_CSU_CSL10_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL10_LOCK_S1) >> BP_CSU_CSL10_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL10_LOCK_S1.
#define BF_CSU_CSL10_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL10_LOCK_S1) & BM_CSU_CSL10_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL10_LOCK_S1(v)   (HW_CSU_CSL10_WR((HW_CSU_CSL10_RD() & ~BM_CSU_CSL10_LOCK_S1) | BF_CSU_CSL10_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL11 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL11 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl11
{
    reg32_t U;
    struct _hw_csu_csl11_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl11_t;
#endif

/*
 * constants & macros for entire CSU_CSL11 register
 */
#define HW_CSU_CSL11_ADDR      (REGS_CSU_BASE + 0x2c)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL11           (*(volatile hw_csu_csl11_t *) HW_CSU_CSL11_ADDR)
#define HW_CSU_CSL11_RD()      (HW_CSU_CSL11.U)
#define HW_CSU_CSL11_WR(v)     (HW_CSU_CSL11.U = (v))
#define HW_CSU_CSL11_SET(v)    (HW_CSU_CSL11_WR(HW_CSU_CSL11_RD() |  (v)))
#define HW_CSU_CSL11_CLR(v)    (HW_CSU_CSL11_WR(HW_CSU_CSL11_RD() & ~(v)))
#define HW_CSU_CSL11_TOG(v)    (HW_CSU_CSL11_WR(HW_CSU_CSL11_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL11 bitfields
 */

/* --- Register HW_CSU_CSL11, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL11_SUR_S2      (0)      //!< Bit position for CSU_CSL11_SUR_S2.
#define BM_CSU_CSL11_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL11_SUR_S2.

//! @brief Get value of CSU_CSL11_SUR_S2 from a register value.
#define BG_CSU_CSL11_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_SUR_S2) >> BP_CSU_CSL11_SUR_S2)

//! @brief Format value for bitfield CSU_CSL11_SUR_S2.
#define BF_CSU_CSL11_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_SUR_S2) & BM_CSU_CSL11_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL11_SUR_S2(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_SUR_S2) | BF_CSU_CSL11_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL11, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL11_SSR_S2      (1)      //!< Bit position for CSU_CSL11_SSR_S2.
#define BM_CSU_CSL11_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL11_SSR_S2.

//! @brief Get value of CSU_CSL11_SSR_S2 from a register value.
#define BG_CSU_CSL11_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_SSR_S2) >> BP_CSU_CSL11_SSR_S2)

//! @brief Format value for bitfield CSU_CSL11_SSR_S2.
#define BF_CSU_CSL11_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_SSR_S2) & BM_CSU_CSL11_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL11_SSR_S2(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_SSR_S2) | BF_CSU_CSL11_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL11, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL11_NUR_S2      (2)      //!< Bit position for CSU_CSL11_NUR_S2.
#define BM_CSU_CSL11_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL11_NUR_S2.

//! @brief Get value of CSU_CSL11_NUR_S2 from a register value.
#define BG_CSU_CSL11_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_NUR_S2) >> BP_CSU_CSL11_NUR_S2)

//! @brief Format value for bitfield CSU_CSL11_NUR_S2.
#define BF_CSU_CSL11_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_NUR_S2) & BM_CSU_CSL11_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL11_NUR_S2(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_NUR_S2) | BF_CSU_CSL11_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL11, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL11_NSR_S2      (3)      //!< Bit position for CSU_CSL11_NSR_S2.
#define BM_CSU_CSL11_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL11_NSR_S2.

//! @brief Get value of CSU_CSL11_NSR_S2 from a register value.
#define BG_CSU_CSL11_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_NSR_S2) >> BP_CSU_CSL11_NSR_S2)

//! @brief Format value for bitfield CSU_CSL11_NSR_S2.
#define BF_CSU_CSL11_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_NSR_S2) & BM_CSU_CSL11_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL11_NSR_S2(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_NSR_S2) | BF_CSU_CSL11_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL11, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL11_SUW_S2      (4)      //!< Bit position for CSU_CSL11_SUW_S2.
#define BM_CSU_CSL11_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL11_SUW_S2.

//! @brief Get value of CSU_CSL11_SUW_S2 from a register value.
#define BG_CSU_CSL11_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_SUW_S2) >> BP_CSU_CSL11_SUW_S2)

//! @brief Format value for bitfield CSU_CSL11_SUW_S2.
#define BF_CSU_CSL11_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_SUW_S2) & BM_CSU_CSL11_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL11_SUW_S2(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_SUW_S2) | BF_CSU_CSL11_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL11, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL11_SSW_S2      (5)      //!< Bit position for CSU_CSL11_SSW_S2.
#define BM_CSU_CSL11_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL11_SSW_S2.

//! @brief Get value of CSU_CSL11_SSW_S2 from a register value.
#define BG_CSU_CSL11_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_SSW_S2) >> BP_CSU_CSL11_SSW_S2)

//! @brief Format value for bitfield CSU_CSL11_SSW_S2.
#define BF_CSU_CSL11_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_SSW_S2) & BM_CSU_CSL11_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL11_SSW_S2(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_SSW_S2) | BF_CSU_CSL11_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL11, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL11_NUW_S2      (6)      //!< Bit position for CSU_CSL11_NUW_S2.
#define BM_CSU_CSL11_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL11_NUW_S2.

//! @brief Get value of CSU_CSL11_NUW_S2 from a register value.
#define BG_CSU_CSL11_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_NUW_S2) >> BP_CSU_CSL11_NUW_S2)

//! @brief Format value for bitfield CSU_CSL11_NUW_S2.
#define BF_CSU_CSL11_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_NUW_S2) & BM_CSU_CSL11_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL11_NUW_S2(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_NUW_S2) | BF_CSU_CSL11_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL11, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL11_NSW_S2      (7)      //!< Bit position for CSU_CSL11_NSW_S2.
#define BM_CSU_CSL11_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL11_NSW_S2.

//! @brief Get value of CSU_CSL11_NSW_S2 from a register value.
#define BG_CSU_CSL11_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_NSW_S2) >> BP_CSU_CSL11_NSW_S2)

//! @brief Format value for bitfield CSU_CSL11_NSW_S2.
#define BF_CSU_CSL11_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_NSW_S2) & BM_CSU_CSL11_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL11_NSW_S2(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_NSW_S2) | BF_CSU_CSL11_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL11, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL11_LOCK_S2      (8)      //!< Bit position for CSU_CSL11_LOCK_S2.
#define BM_CSU_CSL11_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL11_LOCK_S2.

//! @brief Get value of CSU_CSL11_LOCK_S2 from a register value.
#define BG_CSU_CSL11_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_LOCK_S2) >> BP_CSU_CSL11_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL11_LOCK_S2.
#define BF_CSU_CSL11_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_LOCK_S2) & BM_CSU_CSL11_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL11_LOCK_S2(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_LOCK_S2) | BF_CSU_CSL11_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL11, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL11_SUR_S1      (16)      //!< Bit position for CSU_CSL11_SUR_S1.
#define BM_CSU_CSL11_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL11_SUR_S1.

//! @brief Get value of CSU_CSL11_SUR_S1 from a register value.
#define BG_CSU_CSL11_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_SUR_S1) >> BP_CSU_CSL11_SUR_S1)

//! @brief Format value for bitfield CSU_CSL11_SUR_S1.
#define BF_CSU_CSL11_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_SUR_S1) & BM_CSU_CSL11_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL11_SUR_S1(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_SUR_S1) | BF_CSU_CSL11_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL11, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL11_SSR_S1      (17)      //!< Bit position for CSU_CSL11_SSR_S1.
#define BM_CSU_CSL11_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL11_SSR_S1.

//! @brief Get value of CSU_CSL11_SSR_S1 from a register value.
#define BG_CSU_CSL11_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_SSR_S1) >> BP_CSU_CSL11_SSR_S1)

//! @brief Format value for bitfield CSU_CSL11_SSR_S1.
#define BF_CSU_CSL11_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_SSR_S1) & BM_CSU_CSL11_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL11_SSR_S1(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_SSR_S1) | BF_CSU_CSL11_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL11, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL11_NUR_S1      (18)      //!< Bit position for CSU_CSL11_NUR_S1.
#define BM_CSU_CSL11_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL11_NUR_S1.

//! @brief Get value of CSU_CSL11_NUR_S1 from a register value.
#define BG_CSU_CSL11_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_NUR_S1) >> BP_CSU_CSL11_NUR_S1)

//! @brief Format value for bitfield CSU_CSL11_NUR_S1.
#define BF_CSU_CSL11_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_NUR_S1) & BM_CSU_CSL11_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL11_NUR_S1(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_NUR_S1) | BF_CSU_CSL11_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL11, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL11_NSR_S1      (19)      //!< Bit position for CSU_CSL11_NSR_S1.
#define BM_CSU_CSL11_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL11_NSR_S1.

//! @brief Get value of CSU_CSL11_NSR_S1 from a register value.
#define BG_CSU_CSL11_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_NSR_S1) >> BP_CSU_CSL11_NSR_S1)

//! @brief Format value for bitfield CSU_CSL11_NSR_S1.
#define BF_CSU_CSL11_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_NSR_S1) & BM_CSU_CSL11_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL11_NSR_S1(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_NSR_S1) | BF_CSU_CSL11_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL11, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL11_SUW_S1      (20)      //!< Bit position for CSU_CSL11_SUW_S1.
#define BM_CSU_CSL11_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL11_SUW_S1.

//! @brief Get value of CSU_CSL11_SUW_S1 from a register value.
#define BG_CSU_CSL11_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_SUW_S1) >> BP_CSU_CSL11_SUW_S1)

//! @brief Format value for bitfield CSU_CSL11_SUW_S1.
#define BF_CSU_CSL11_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_SUW_S1) & BM_CSU_CSL11_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL11_SUW_S1(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_SUW_S1) | BF_CSU_CSL11_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL11, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL11_SSW_S1      (21)      //!< Bit position for CSU_CSL11_SSW_S1.
#define BM_CSU_CSL11_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL11_SSW_S1.

//! @brief Get value of CSU_CSL11_SSW_S1 from a register value.
#define BG_CSU_CSL11_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_SSW_S1) >> BP_CSU_CSL11_SSW_S1)

//! @brief Format value for bitfield CSU_CSL11_SSW_S1.
#define BF_CSU_CSL11_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_SSW_S1) & BM_CSU_CSL11_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL11_SSW_S1(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_SSW_S1) | BF_CSU_CSL11_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL11, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL11_NUW_S1      (22)      //!< Bit position for CSU_CSL11_NUW_S1.
#define BM_CSU_CSL11_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL11_NUW_S1.

//! @brief Get value of CSU_CSL11_NUW_S1 from a register value.
#define BG_CSU_CSL11_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_NUW_S1) >> BP_CSU_CSL11_NUW_S1)

//! @brief Format value for bitfield CSU_CSL11_NUW_S1.
#define BF_CSU_CSL11_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_NUW_S1) & BM_CSU_CSL11_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL11_NUW_S1(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_NUW_S1) | BF_CSU_CSL11_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL11, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL11_NSW_S1      (23)      //!< Bit position for CSU_CSL11_NSW_S1.
#define BM_CSU_CSL11_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL11_NSW_S1.

//! @brief Get value of CSU_CSL11_NSW_S1 from a register value.
#define BG_CSU_CSL11_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_NSW_S1) >> BP_CSU_CSL11_NSW_S1)

//! @brief Format value for bitfield CSU_CSL11_NSW_S1.
#define BF_CSU_CSL11_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_NSW_S1) & BM_CSU_CSL11_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL11_NSW_S1(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_NSW_S1) | BF_CSU_CSL11_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL11, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL11_LOCK_S1      (24)      //!< Bit position for CSU_CSL11_LOCK_S1.
#define BM_CSU_CSL11_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL11_LOCK_S1.

//! @brief Get value of CSU_CSL11_LOCK_S1 from a register value.
#define BG_CSU_CSL11_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL11_LOCK_S1) >> BP_CSU_CSL11_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL11_LOCK_S1.
#define BF_CSU_CSL11_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL11_LOCK_S1) & BM_CSU_CSL11_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL11_LOCK_S1(v)   (HW_CSU_CSL11_WR((HW_CSU_CSL11_RD() & ~BM_CSU_CSL11_LOCK_S1) | BF_CSU_CSL11_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL12 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL12 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl12
{
    reg32_t U;
    struct _hw_csu_csl12_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl12_t;
#endif

/*
 * constants & macros for entire CSU_CSL12 register
 */
#define HW_CSU_CSL12_ADDR      (REGS_CSU_BASE + 0x30)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL12           (*(volatile hw_csu_csl12_t *) HW_CSU_CSL12_ADDR)
#define HW_CSU_CSL12_RD()      (HW_CSU_CSL12.U)
#define HW_CSU_CSL12_WR(v)     (HW_CSU_CSL12.U = (v))
#define HW_CSU_CSL12_SET(v)    (HW_CSU_CSL12_WR(HW_CSU_CSL12_RD() |  (v)))
#define HW_CSU_CSL12_CLR(v)    (HW_CSU_CSL12_WR(HW_CSU_CSL12_RD() & ~(v)))
#define HW_CSU_CSL12_TOG(v)    (HW_CSU_CSL12_WR(HW_CSU_CSL12_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL12 bitfields
 */

/* --- Register HW_CSU_CSL12, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL12_SUR_S2      (0)      //!< Bit position for CSU_CSL12_SUR_S2.
#define BM_CSU_CSL12_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL12_SUR_S2.

//! @brief Get value of CSU_CSL12_SUR_S2 from a register value.
#define BG_CSU_CSL12_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_SUR_S2) >> BP_CSU_CSL12_SUR_S2)

//! @brief Format value for bitfield CSU_CSL12_SUR_S2.
#define BF_CSU_CSL12_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_SUR_S2) & BM_CSU_CSL12_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL12_SUR_S2(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_SUR_S2) | BF_CSU_CSL12_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL12, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL12_SSR_S2      (1)      //!< Bit position for CSU_CSL12_SSR_S2.
#define BM_CSU_CSL12_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL12_SSR_S2.

//! @brief Get value of CSU_CSL12_SSR_S2 from a register value.
#define BG_CSU_CSL12_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_SSR_S2) >> BP_CSU_CSL12_SSR_S2)

//! @brief Format value for bitfield CSU_CSL12_SSR_S2.
#define BF_CSU_CSL12_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_SSR_S2) & BM_CSU_CSL12_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL12_SSR_S2(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_SSR_S2) | BF_CSU_CSL12_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL12, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL12_NUR_S2      (2)      //!< Bit position for CSU_CSL12_NUR_S2.
#define BM_CSU_CSL12_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL12_NUR_S2.

//! @brief Get value of CSU_CSL12_NUR_S2 from a register value.
#define BG_CSU_CSL12_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_NUR_S2) >> BP_CSU_CSL12_NUR_S2)

//! @brief Format value for bitfield CSU_CSL12_NUR_S2.
#define BF_CSU_CSL12_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_NUR_S2) & BM_CSU_CSL12_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL12_NUR_S2(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_NUR_S2) | BF_CSU_CSL12_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL12, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL12_NSR_S2      (3)      //!< Bit position for CSU_CSL12_NSR_S2.
#define BM_CSU_CSL12_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL12_NSR_S2.

//! @brief Get value of CSU_CSL12_NSR_S2 from a register value.
#define BG_CSU_CSL12_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_NSR_S2) >> BP_CSU_CSL12_NSR_S2)

//! @brief Format value for bitfield CSU_CSL12_NSR_S2.
#define BF_CSU_CSL12_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_NSR_S2) & BM_CSU_CSL12_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL12_NSR_S2(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_NSR_S2) | BF_CSU_CSL12_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL12, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL12_SUW_S2      (4)      //!< Bit position for CSU_CSL12_SUW_S2.
#define BM_CSU_CSL12_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL12_SUW_S2.

//! @brief Get value of CSU_CSL12_SUW_S2 from a register value.
#define BG_CSU_CSL12_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_SUW_S2) >> BP_CSU_CSL12_SUW_S2)

//! @brief Format value for bitfield CSU_CSL12_SUW_S2.
#define BF_CSU_CSL12_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_SUW_S2) & BM_CSU_CSL12_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL12_SUW_S2(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_SUW_S2) | BF_CSU_CSL12_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL12, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL12_SSW_S2      (5)      //!< Bit position for CSU_CSL12_SSW_S2.
#define BM_CSU_CSL12_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL12_SSW_S2.

//! @brief Get value of CSU_CSL12_SSW_S2 from a register value.
#define BG_CSU_CSL12_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_SSW_S2) >> BP_CSU_CSL12_SSW_S2)

//! @brief Format value for bitfield CSU_CSL12_SSW_S2.
#define BF_CSU_CSL12_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_SSW_S2) & BM_CSU_CSL12_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL12_SSW_S2(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_SSW_S2) | BF_CSU_CSL12_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL12, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL12_NUW_S2      (6)      //!< Bit position for CSU_CSL12_NUW_S2.
#define BM_CSU_CSL12_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL12_NUW_S2.

//! @brief Get value of CSU_CSL12_NUW_S2 from a register value.
#define BG_CSU_CSL12_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_NUW_S2) >> BP_CSU_CSL12_NUW_S2)

//! @brief Format value for bitfield CSU_CSL12_NUW_S2.
#define BF_CSU_CSL12_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_NUW_S2) & BM_CSU_CSL12_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL12_NUW_S2(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_NUW_S2) | BF_CSU_CSL12_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL12, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL12_NSW_S2      (7)      //!< Bit position for CSU_CSL12_NSW_S2.
#define BM_CSU_CSL12_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL12_NSW_S2.

//! @brief Get value of CSU_CSL12_NSW_S2 from a register value.
#define BG_CSU_CSL12_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_NSW_S2) >> BP_CSU_CSL12_NSW_S2)

//! @brief Format value for bitfield CSU_CSL12_NSW_S2.
#define BF_CSU_CSL12_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_NSW_S2) & BM_CSU_CSL12_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL12_NSW_S2(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_NSW_S2) | BF_CSU_CSL12_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL12, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL12_LOCK_S2      (8)      //!< Bit position for CSU_CSL12_LOCK_S2.
#define BM_CSU_CSL12_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL12_LOCK_S2.

//! @brief Get value of CSU_CSL12_LOCK_S2 from a register value.
#define BG_CSU_CSL12_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_LOCK_S2) >> BP_CSU_CSL12_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL12_LOCK_S2.
#define BF_CSU_CSL12_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_LOCK_S2) & BM_CSU_CSL12_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL12_LOCK_S2(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_LOCK_S2) | BF_CSU_CSL12_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL12, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL12_SUR_S1      (16)      //!< Bit position for CSU_CSL12_SUR_S1.
#define BM_CSU_CSL12_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL12_SUR_S1.

//! @brief Get value of CSU_CSL12_SUR_S1 from a register value.
#define BG_CSU_CSL12_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_SUR_S1) >> BP_CSU_CSL12_SUR_S1)

//! @brief Format value for bitfield CSU_CSL12_SUR_S1.
#define BF_CSU_CSL12_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_SUR_S1) & BM_CSU_CSL12_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL12_SUR_S1(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_SUR_S1) | BF_CSU_CSL12_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL12, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL12_SSR_S1      (17)      //!< Bit position for CSU_CSL12_SSR_S1.
#define BM_CSU_CSL12_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL12_SSR_S1.

//! @brief Get value of CSU_CSL12_SSR_S1 from a register value.
#define BG_CSU_CSL12_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_SSR_S1) >> BP_CSU_CSL12_SSR_S1)

//! @brief Format value for bitfield CSU_CSL12_SSR_S1.
#define BF_CSU_CSL12_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_SSR_S1) & BM_CSU_CSL12_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL12_SSR_S1(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_SSR_S1) | BF_CSU_CSL12_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL12, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL12_NUR_S1      (18)      //!< Bit position for CSU_CSL12_NUR_S1.
#define BM_CSU_CSL12_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL12_NUR_S1.

//! @brief Get value of CSU_CSL12_NUR_S1 from a register value.
#define BG_CSU_CSL12_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_NUR_S1) >> BP_CSU_CSL12_NUR_S1)

//! @brief Format value for bitfield CSU_CSL12_NUR_S1.
#define BF_CSU_CSL12_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_NUR_S1) & BM_CSU_CSL12_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL12_NUR_S1(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_NUR_S1) | BF_CSU_CSL12_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL12, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL12_NSR_S1      (19)      //!< Bit position for CSU_CSL12_NSR_S1.
#define BM_CSU_CSL12_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL12_NSR_S1.

//! @brief Get value of CSU_CSL12_NSR_S1 from a register value.
#define BG_CSU_CSL12_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_NSR_S1) >> BP_CSU_CSL12_NSR_S1)

//! @brief Format value for bitfield CSU_CSL12_NSR_S1.
#define BF_CSU_CSL12_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_NSR_S1) & BM_CSU_CSL12_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL12_NSR_S1(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_NSR_S1) | BF_CSU_CSL12_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL12, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL12_SUW_S1      (20)      //!< Bit position for CSU_CSL12_SUW_S1.
#define BM_CSU_CSL12_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL12_SUW_S1.

//! @brief Get value of CSU_CSL12_SUW_S1 from a register value.
#define BG_CSU_CSL12_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_SUW_S1) >> BP_CSU_CSL12_SUW_S1)

//! @brief Format value for bitfield CSU_CSL12_SUW_S1.
#define BF_CSU_CSL12_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_SUW_S1) & BM_CSU_CSL12_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL12_SUW_S1(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_SUW_S1) | BF_CSU_CSL12_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL12, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL12_SSW_S1      (21)      //!< Bit position for CSU_CSL12_SSW_S1.
#define BM_CSU_CSL12_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL12_SSW_S1.

//! @brief Get value of CSU_CSL12_SSW_S1 from a register value.
#define BG_CSU_CSL12_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_SSW_S1) >> BP_CSU_CSL12_SSW_S1)

//! @brief Format value for bitfield CSU_CSL12_SSW_S1.
#define BF_CSU_CSL12_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_SSW_S1) & BM_CSU_CSL12_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL12_SSW_S1(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_SSW_S1) | BF_CSU_CSL12_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL12, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL12_NUW_S1      (22)      //!< Bit position for CSU_CSL12_NUW_S1.
#define BM_CSU_CSL12_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL12_NUW_S1.

//! @brief Get value of CSU_CSL12_NUW_S1 from a register value.
#define BG_CSU_CSL12_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_NUW_S1) >> BP_CSU_CSL12_NUW_S1)

//! @brief Format value for bitfield CSU_CSL12_NUW_S1.
#define BF_CSU_CSL12_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_NUW_S1) & BM_CSU_CSL12_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL12_NUW_S1(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_NUW_S1) | BF_CSU_CSL12_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL12, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL12_NSW_S1      (23)      //!< Bit position for CSU_CSL12_NSW_S1.
#define BM_CSU_CSL12_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL12_NSW_S1.

//! @brief Get value of CSU_CSL12_NSW_S1 from a register value.
#define BG_CSU_CSL12_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_NSW_S1) >> BP_CSU_CSL12_NSW_S1)

//! @brief Format value for bitfield CSU_CSL12_NSW_S1.
#define BF_CSU_CSL12_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_NSW_S1) & BM_CSU_CSL12_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL12_NSW_S1(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_NSW_S1) | BF_CSU_CSL12_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL12, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL12_LOCK_S1      (24)      //!< Bit position for CSU_CSL12_LOCK_S1.
#define BM_CSU_CSL12_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL12_LOCK_S1.

//! @brief Get value of CSU_CSL12_LOCK_S1 from a register value.
#define BG_CSU_CSL12_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL12_LOCK_S1) >> BP_CSU_CSL12_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL12_LOCK_S1.
#define BF_CSU_CSL12_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL12_LOCK_S1) & BM_CSU_CSL12_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL12_LOCK_S1(v)   (HW_CSU_CSL12_WR((HW_CSU_CSL12_RD() & ~BM_CSU_CSL12_LOCK_S1) | BF_CSU_CSL12_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL13 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL13 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl13
{
    reg32_t U;
    struct _hw_csu_csl13_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl13_t;
#endif

/*
 * constants & macros for entire CSU_CSL13 register
 */
#define HW_CSU_CSL13_ADDR      (REGS_CSU_BASE + 0x34)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL13           (*(volatile hw_csu_csl13_t *) HW_CSU_CSL13_ADDR)
#define HW_CSU_CSL13_RD()      (HW_CSU_CSL13.U)
#define HW_CSU_CSL13_WR(v)     (HW_CSU_CSL13.U = (v))
#define HW_CSU_CSL13_SET(v)    (HW_CSU_CSL13_WR(HW_CSU_CSL13_RD() |  (v)))
#define HW_CSU_CSL13_CLR(v)    (HW_CSU_CSL13_WR(HW_CSU_CSL13_RD() & ~(v)))
#define HW_CSU_CSL13_TOG(v)    (HW_CSU_CSL13_WR(HW_CSU_CSL13_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL13 bitfields
 */

/* --- Register HW_CSU_CSL13, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL13_SUR_S2      (0)      //!< Bit position for CSU_CSL13_SUR_S2.
#define BM_CSU_CSL13_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL13_SUR_S2.

//! @brief Get value of CSU_CSL13_SUR_S2 from a register value.
#define BG_CSU_CSL13_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_SUR_S2) >> BP_CSU_CSL13_SUR_S2)

//! @brief Format value for bitfield CSU_CSL13_SUR_S2.
#define BF_CSU_CSL13_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_SUR_S2) & BM_CSU_CSL13_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL13_SUR_S2(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_SUR_S2) | BF_CSU_CSL13_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL13, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL13_SSR_S2      (1)      //!< Bit position for CSU_CSL13_SSR_S2.
#define BM_CSU_CSL13_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL13_SSR_S2.

//! @brief Get value of CSU_CSL13_SSR_S2 from a register value.
#define BG_CSU_CSL13_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_SSR_S2) >> BP_CSU_CSL13_SSR_S2)

//! @brief Format value for bitfield CSU_CSL13_SSR_S2.
#define BF_CSU_CSL13_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_SSR_S2) & BM_CSU_CSL13_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL13_SSR_S2(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_SSR_S2) | BF_CSU_CSL13_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL13, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL13_NUR_S2      (2)      //!< Bit position for CSU_CSL13_NUR_S2.
#define BM_CSU_CSL13_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL13_NUR_S2.

//! @brief Get value of CSU_CSL13_NUR_S2 from a register value.
#define BG_CSU_CSL13_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_NUR_S2) >> BP_CSU_CSL13_NUR_S2)

//! @brief Format value for bitfield CSU_CSL13_NUR_S2.
#define BF_CSU_CSL13_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_NUR_S2) & BM_CSU_CSL13_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL13_NUR_S2(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_NUR_S2) | BF_CSU_CSL13_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL13, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL13_NSR_S2      (3)      //!< Bit position for CSU_CSL13_NSR_S2.
#define BM_CSU_CSL13_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL13_NSR_S2.

//! @brief Get value of CSU_CSL13_NSR_S2 from a register value.
#define BG_CSU_CSL13_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_NSR_S2) >> BP_CSU_CSL13_NSR_S2)

//! @brief Format value for bitfield CSU_CSL13_NSR_S2.
#define BF_CSU_CSL13_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_NSR_S2) & BM_CSU_CSL13_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL13_NSR_S2(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_NSR_S2) | BF_CSU_CSL13_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL13, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL13_SUW_S2      (4)      //!< Bit position for CSU_CSL13_SUW_S2.
#define BM_CSU_CSL13_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL13_SUW_S2.

//! @brief Get value of CSU_CSL13_SUW_S2 from a register value.
#define BG_CSU_CSL13_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_SUW_S2) >> BP_CSU_CSL13_SUW_S2)

//! @brief Format value for bitfield CSU_CSL13_SUW_S2.
#define BF_CSU_CSL13_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_SUW_S2) & BM_CSU_CSL13_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL13_SUW_S2(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_SUW_S2) | BF_CSU_CSL13_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL13, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL13_SSW_S2      (5)      //!< Bit position for CSU_CSL13_SSW_S2.
#define BM_CSU_CSL13_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL13_SSW_S2.

//! @brief Get value of CSU_CSL13_SSW_S2 from a register value.
#define BG_CSU_CSL13_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_SSW_S2) >> BP_CSU_CSL13_SSW_S2)

//! @brief Format value for bitfield CSU_CSL13_SSW_S2.
#define BF_CSU_CSL13_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_SSW_S2) & BM_CSU_CSL13_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL13_SSW_S2(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_SSW_S2) | BF_CSU_CSL13_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL13, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL13_NUW_S2      (6)      //!< Bit position for CSU_CSL13_NUW_S2.
#define BM_CSU_CSL13_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL13_NUW_S2.

//! @brief Get value of CSU_CSL13_NUW_S2 from a register value.
#define BG_CSU_CSL13_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_NUW_S2) >> BP_CSU_CSL13_NUW_S2)

//! @brief Format value for bitfield CSU_CSL13_NUW_S2.
#define BF_CSU_CSL13_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_NUW_S2) & BM_CSU_CSL13_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL13_NUW_S2(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_NUW_S2) | BF_CSU_CSL13_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL13, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL13_NSW_S2      (7)      //!< Bit position for CSU_CSL13_NSW_S2.
#define BM_CSU_CSL13_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL13_NSW_S2.

//! @brief Get value of CSU_CSL13_NSW_S2 from a register value.
#define BG_CSU_CSL13_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_NSW_S2) >> BP_CSU_CSL13_NSW_S2)

//! @brief Format value for bitfield CSU_CSL13_NSW_S2.
#define BF_CSU_CSL13_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_NSW_S2) & BM_CSU_CSL13_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL13_NSW_S2(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_NSW_S2) | BF_CSU_CSL13_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL13, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL13_LOCK_S2      (8)      //!< Bit position for CSU_CSL13_LOCK_S2.
#define BM_CSU_CSL13_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL13_LOCK_S2.

//! @brief Get value of CSU_CSL13_LOCK_S2 from a register value.
#define BG_CSU_CSL13_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_LOCK_S2) >> BP_CSU_CSL13_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL13_LOCK_S2.
#define BF_CSU_CSL13_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_LOCK_S2) & BM_CSU_CSL13_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL13_LOCK_S2(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_LOCK_S2) | BF_CSU_CSL13_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL13, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL13_SUR_S1      (16)      //!< Bit position for CSU_CSL13_SUR_S1.
#define BM_CSU_CSL13_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL13_SUR_S1.

//! @brief Get value of CSU_CSL13_SUR_S1 from a register value.
#define BG_CSU_CSL13_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_SUR_S1) >> BP_CSU_CSL13_SUR_S1)

//! @brief Format value for bitfield CSU_CSL13_SUR_S1.
#define BF_CSU_CSL13_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_SUR_S1) & BM_CSU_CSL13_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL13_SUR_S1(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_SUR_S1) | BF_CSU_CSL13_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL13, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL13_SSR_S1      (17)      //!< Bit position for CSU_CSL13_SSR_S1.
#define BM_CSU_CSL13_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL13_SSR_S1.

//! @brief Get value of CSU_CSL13_SSR_S1 from a register value.
#define BG_CSU_CSL13_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_SSR_S1) >> BP_CSU_CSL13_SSR_S1)

//! @brief Format value for bitfield CSU_CSL13_SSR_S1.
#define BF_CSU_CSL13_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_SSR_S1) & BM_CSU_CSL13_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL13_SSR_S1(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_SSR_S1) | BF_CSU_CSL13_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL13, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL13_NUR_S1      (18)      //!< Bit position for CSU_CSL13_NUR_S1.
#define BM_CSU_CSL13_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL13_NUR_S1.

//! @brief Get value of CSU_CSL13_NUR_S1 from a register value.
#define BG_CSU_CSL13_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_NUR_S1) >> BP_CSU_CSL13_NUR_S1)

//! @brief Format value for bitfield CSU_CSL13_NUR_S1.
#define BF_CSU_CSL13_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_NUR_S1) & BM_CSU_CSL13_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL13_NUR_S1(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_NUR_S1) | BF_CSU_CSL13_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL13, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL13_NSR_S1      (19)      //!< Bit position for CSU_CSL13_NSR_S1.
#define BM_CSU_CSL13_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL13_NSR_S1.

//! @brief Get value of CSU_CSL13_NSR_S1 from a register value.
#define BG_CSU_CSL13_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_NSR_S1) >> BP_CSU_CSL13_NSR_S1)

//! @brief Format value for bitfield CSU_CSL13_NSR_S1.
#define BF_CSU_CSL13_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_NSR_S1) & BM_CSU_CSL13_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL13_NSR_S1(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_NSR_S1) | BF_CSU_CSL13_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL13, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL13_SUW_S1      (20)      //!< Bit position for CSU_CSL13_SUW_S1.
#define BM_CSU_CSL13_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL13_SUW_S1.

//! @brief Get value of CSU_CSL13_SUW_S1 from a register value.
#define BG_CSU_CSL13_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_SUW_S1) >> BP_CSU_CSL13_SUW_S1)

//! @brief Format value for bitfield CSU_CSL13_SUW_S1.
#define BF_CSU_CSL13_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_SUW_S1) & BM_CSU_CSL13_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL13_SUW_S1(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_SUW_S1) | BF_CSU_CSL13_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL13, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL13_SSW_S1      (21)      //!< Bit position for CSU_CSL13_SSW_S1.
#define BM_CSU_CSL13_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL13_SSW_S1.

//! @brief Get value of CSU_CSL13_SSW_S1 from a register value.
#define BG_CSU_CSL13_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_SSW_S1) >> BP_CSU_CSL13_SSW_S1)

//! @brief Format value for bitfield CSU_CSL13_SSW_S1.
#define BF_CSU_CSL13_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_SSW_S1) & BM_CSU_CSL13_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL13_SSW_S1(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_SSW_S1) | BF_CSU_CSL13_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL13, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL13_NUW_S1      (22)      //!< Bit position for CSU_CSL13_NUW_S1.
#define BM_CSU_CSL13_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL13_NUW_S1.

//! @brief Get value of CSU_CSL13_NUW_S1 from a register value.
#define BG_CSU_CSL13_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_NUW_S1) >> BP_CSU_CSL13_NUW_S1)

//! @brief Format value for bitfield CSU_CSL13_NUW_S1.
#define BF_CSU_CSL13_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_NUW_S1) & BM_CSU_CSL13_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL13_NUW_S1(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_NUW_S1) | BF_CSU_CSL13_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL13, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL13_NSW_S1      (23)      //!< Bit position for CSU_CSL13_NSW_S1.
#define BM_CSU_CSL13_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL13_NSW_S1.

//! @brief Get value of CSU_CSL13_NSW_S1 from a register value.
#define BG_CSU_CSL13_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_NSW_S1) >> BP_CSU_CSL13_NSW_S1)

//! @brief Format value for bitfield CSU_CSL13_NSW_S1.
#define BF_CSU_CSL13_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_NSW_S1) & BM_CSU_CSL13_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL13_NSW_S1(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_NSW_S1) | BF_CSU_CSL13_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL13, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL13_LOCK_S1      (24)      //!< Bit position for CSU_CSL13_LOCK_S1.
#define BM_CSU_CSL13_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL13_LOCK_S1.

//! @brief Get value of CSU_CSL13_LOCK_S1 from a register value.
#define BG_CSU_CSL13_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL13_LOCK_S1) >> BP_CSU_CSL13_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL13_LOCK_S1.
#define BF_CSU_CSL13_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL13_LOCK_S1) & BM_CSU_CSL13_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL13_LOCK_S1(v)   (HW_CSU_CSL13_WR((HW_CSU_CSL13_RD() & ~BM_CSU_CSL13_LOCK_S1) | BF_CSU_CSL13_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL14 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL14 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl14
{
    reg32_t U;
    struct _hw_csu_csl14_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl14_t;
#endif

/*
 * constants & macros for entire CSU_CSL14 register
 */
#define HW_CSU_CSL14_ADDR      (REGS_CSU_BASE + 0x38)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL14           (*(volatile hw_csu_csl14_t *) HW_CSU_CSL14_ADDR)
#define HW_CSU_CSL14_RD()      (HW_CSU_CSL14.U)
#define HW_CSU_CSL14_WR(v)     (HW_CSU_CSL14.U = (v))
#define HW_CSU_CSL14_SET(v)    (HW_CSU_CSL14_WR(HW_CSU_CSL14_RD() |  (v)))
#define HW_CSU_CSL14_CLR(v)    (HW_CSU_CSL14_WR(HW_CSU_CSL14_RD() & ~(v)))
#define HW_CSU_CSL14_TOG(v)    (HW_CSU_CSL14_WR(HW_CSU_CSL14_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL14 bitfields
 */

/* --- Register HW_CSU_CSL14, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL14_SUR_S2      (0)      //!< Bit position for CSU_CSL14_SUR_S2.
#define BM_CSU_CSL14_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL14_SUR_S2.

//! @brief Get value of CSU_CSL14_SUR_S2 from a register value.
#define BG_CSU_CSL14_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_SUR_S2) >> BP_CSU_CSL14_SUR_S2)

//! @brief Format value for bitfield CSU_CSL14_SUR_S2.
#define BF_CSU_CSL14_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_SUR_S2) & BM_CSU_CSL14_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL14_SUR_S2(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_SUR_S2) | BF_CSU_CSL14_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL14, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL14_SSR_S2      (1)      //!< Bit position for CSU_CSL14_SSR_S2.
#define BM_CSU_CSL14_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL14_SSR_S2.

//! @brief Get value of CSU_CSL14_SSR_S2 from a register value.
#define BG_CSU_CSL14_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_SSR_S2) >> BP_CSU_CSL14_SSR_S2)

//! @brief Format value for bitfield CSU_CSL14_SSR_S2.
#define BF_CSU_CSL14_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_SSR_S2) & BM_CSU_CSL14_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL14_SSR_S2(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_SSR_S2) | BF_CSU_CSL14_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL14, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL14_NUR_S2      (2)      //!< Bit position for CSU_CSL14_NUR_S2.
#define BM_CSU_CSL14_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL14_NUR_S2.

//! @brief Get value of CSU_CSL14_NUR_S2 from a register value.
#define BG_CSU_CSL14_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_NUR_S2) >> BP_CSU_CSL14_NUR_S2)

//! @brief Format value for bitfield CSU_CSL14_NUR_S2.
#define BF_CSU_CSL14_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_NUR_S2) & BM_CSU_CSL14_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL14_NUR_S2(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_NUR_S2) | BF_CSU_CSL14_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL14, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL14_NSR_S2      (3)      //!< Bit position for CSU_CSL14_NSR_S2.
#define BM_CSU_CSL14_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL14_NSR_S2.

//! @brief Get value of CSU_CSL14_NSR_S2 from a register value.
#define BG_CSU_CSL14_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_NSR_S2) >> BP_CSU_CSL14_NSR_S2)

//! @brief Format value for bitfield CSU_CSL14_NSR_S2.
#define BF_CSU_CSL14_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_NSR_S2) & BM_CSU_CSL14_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL14_NSR_S2(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_NSR_S2) | BF_CSU_CSL14_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL14, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL14_SUW_S2      (4)      //!< Bit position for CSU_CSL14_SUW_S2.
#define BM_CSU_CSL14_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL14_SUW_S2.

//! @brief Get value of CSU_CSL14_SUW_S2 from a register value.
#define BG_CSU_CSL14_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_SUW_S2) >> BP_CSU_CSL14_SUW_S2)

//! @brief Format value for bitfield CSU_CSL14_SUW_S2.
#define BF_CSU_CSL14_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_SUW_S2) & BM_CSU_CSL14_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL14_SUW_S2(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_SUW_S2) | BF_CSU_CSL14_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL14, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL14_SSW_S2      (5)      //!< Bit position for CSU_CSL14_SSW_S2.
#define BM_CSU_CSL14_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL14_SSW_S2.

//! @brief Get value of CSU_CSL14_SSW_S2 from a register value.
#define BG_CSU_CSL14_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_SSW_S2) >> BP_CSU_CSL14_SSW_S2)

//! @brief Format value for bitfield CSU_CSL14_SSW_S2.
#define BF_CSU_CSL14_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_SSW_S2) & BM_CSU_CSL14_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL14_SSW_S2(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_SSW_S2) | BF_CSU_CSL14_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL14, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL14_NUW_S2      (6)      //!< Bit position for CSU_CSL14_NUW_S2.
#define BM_CSU_CSL14_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL14_NUW_S2.

//! @brief Get value of CSU_CSL14_NUW_S2 from a register value.
#define BG_CSU_CSL14_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_NUW_S2) >> BP_CSU_CSL14_NUW_S2)

//! @brief Format value for bitfield CSU_CSL14_NUW_S2.
#define BF_CSU_CSL14_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_NUW_S2) & BM_CSU_CSL14_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL14_NUW_S2(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_NUW_S2) | BF_CSU_CSL14_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL14, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL14_NSW_S2      (7)      //!< Bit position for CSU_CSL14_NSW_S2.
#define BM_CSU_CSL14_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL14_NSW_S2.

//! @brief Get value of CSU_CSL14_NSW_S2 from a register value.
#define BG_CSU_CSL14_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_NSW_S2) >> BP_CSU_CSL14_NSW_S2)

//! @brief Format value for bitfield CSU_CSL14_NSW_S2.
#define BF_CSU_CSL14_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_NSW_S2) & BM_CSU_CSL14_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL14_NSW_S2(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_NSW_S2) | BF_CSU_CSL14_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL14, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL14_LOCK_S2      (8)      //!< Bit position for CSU_CSL14_LOCK_S2.
#define BM_CSU_CSL14_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL14_LOCK_S2.

//! @brief Get value of CSU_CSL14_LOCK_S2 from a register value.
#define BG_CSU_CSL14_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_LOCK_S2) >> BP_CSU_CSL14_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL14_LOCK_S2.
#define BF_CSU_CSL14_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_LOCK_S2) & BM_CSU_CSL14_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL14_LOCK_S2(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_LOCK_S2) | BF_CSU_CSL14_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL14, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL14_SUR_S1      (16)      //!< Bit position for CSU_CSL14_SUR_S1.
#define BM_CSU_CSL14_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL14_SUR_S1.

//! @brief Get value of CSU_CSL14_SUR_S1 from a register value.
#define BG_CSU_CSL14_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_SUR_S1) >> BP_CSU_CSL14_SUR_S1)

//! @brief Format value for bitfield CSU_CSL14_SUR_S1.
#define BF_CSU_CSL14_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_SUR_S1) & BM_CSU_CSL14_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL14_SUR_S1(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_SUR_S1) | BF_CSU_CSL14_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL14, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL14_SSR_S1      (17)      //!< Bit position for CSU_CSL14_SSR_S1.
#define BM_CSU_CSL14_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL14_SSR_S1.

//! @brief Get value of CSU_CSL14_SSR_S1 from a register value.
#define BG_CSU_CSL14_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_SSR_S1) >> BP_CSU_CSL14_SSR_S1)

//! @brief Format value for bitfield CSU_CSL14_SSR_S1.
#define BF_CSU_CSL14_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_SSR_S1) & BM_CSU_CSL14_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL14_SSR_S1(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_SSR_S1) | BF_CSU_CSL14_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL14, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL14_NUR_S1      (18)      //!< Bit position for CSU_CSL14_NUR_S1.
#define BM_CSU_CSL14_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL14_NUR_S1.

//! @brief Get value of CSU_CSL14_NUR_S1 from a register value.
#define BG_CSU_CSL14_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_NUR_S1) >> BP_CSU_CSL14_NUR_S1)

//! @brief Format value for bitfield CSU_CSL14_NUR_S1.
#define BF_CSU_CSL14_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_NUR_S1) & BM_CSU_CSL14_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL14_NUR_S1(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_NUR_S1) | BF_CSU_CSL14_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL14, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL14_NSR_S1      (19)      //!< Bit position for CSU_CSL14_NSR_S1.
#define BM_CSU_CSL14_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL14_NSR_S1.

//! @brief Get value of CSU_CSL14_NSR_S1 from a register value.
#define BG_CSU_CSL14_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_NSR_S1) >> BP_CSU_CSL14_NSR_S1)

//! @brief Format value for bitfield CSU_CSL14_NSR_S1.
#define BF_CSU_CSL14_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_NSR_S1) & BM_CSU_CSL14_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL14_NSR_S1(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_NSR_S1) | BF_CSU_CSL14_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL14, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL14_SUW_S1      (20)      //!< Bit position for CSU_CSL14_SUW_S1.
#define BM_CSU_CSL14_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL14_SUW_S1.

//! @brief Get value of CSU_CSL14_SUW_S1 from a register value.
#define BG_CSU_CSL14_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_SUW_S1) >> BP_CSU_CSL14_SUW_S1)

//! @brief Format value for bitfield CSU_CSL14_SUW_S1.
#define BF_CSU_CSL14_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_SUW_S1) & BM_CSU_CSL14_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL14_SUW_S1(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_SUW_S1) | BF_CSU_CSL14_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL14, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL14_SSW_S1      (21)      //!< Bit position for CSU_CSL14_SSW_S1.
#define BM_CSU_CSL14_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL14_SSW_S1.

//! @brief Get value of CSU_CSL14_SSW_S1 from a register value.
#define BG_CSU_CSL14_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_SSW_S1) >> BP_CSU_CSL14_SSW_S1)

//! @brief Format value for bitfield CSU_CSL14_SSW_S1.
#define BF_CSU_CSL14_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_SSW_S1) & BM_CSU_CSL14_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL14_SSW_S1(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_SSW_S1) | BF_CSU_CSL14_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL14, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL14_NUW_S1      (22)      //!< Bit position for CSU_CSL14_NUW_S1.
#define BM_CSU_CSL14_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL14_NUW_S1.

//! @brief Get value of CSU_CSL14_NUW_S1 from a register value.
#define BG_CSU_CSL14_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_NUW_S1) >> BP_CSU_CSL14_NUW_S1)

//! @brief Format value for bitfield CSU_CSL14_NUW_S1.
#define BF_CSU_CSL14_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_NUW_S1) & BM_CSU_CSL14_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL14_NUW_S1(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_NUW_S1) | BF_CSU_CSL14_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL14, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL14_NSW_S1      (23)      //!< Bit position for CSU_CSL14_NSW_S1.
#define BM_CSU_CSL14_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL14_NSW_S1.

//! @brief Get value of CSU_CSL14_NSW_S1 from a register value.
#define BG_CSU_CSL14_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_NSW_S1) >> BP_CSU_CSL14_NSW_S1)

//! @brief Format value for bitfield CSU_CSL14_NSW_S1.
#define BF_CSU_CSL14_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_NSW_S1) & BM_CSU_CSL14_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL14_NSW_S1(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_NSW_S1) | BF_CSU_CSL14_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL14, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL14_LOCK_S1      (24)      //!< Bit position for CSU_CSL14_LOCK_S1.
#define BM_CSU_CSL14_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL14_LOCK_S1.

//! @brief Get value of CSU_CSL14_LOCK_S1 from a register value.
#define BG_CSU_CSL14_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL14_LOCK_S1) >> BP_CSU_CSL14_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL14_LOCK_S1.
#define BF_CSU_CSL14_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL14_LOCK_S1) & BM_CSU_CSL14_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL14_LOCK_S1(v)   (HW_CSU_CSL14_WR((HW_CSU_CSL14_RD() & ~BM_CSU_CSL14_LOCK_S1) | BF_CSU_CSL14_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL15 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL15 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl15
{
    reg32_t U;
    struct _hw_csu_csl15_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl15_t;
#endif

/*
 * constants & macros for entire CSU_CSL15 register
 */
#define HW_CSU_CSL15_ADDR      (REGS_CSU_BASE + 0x3c)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL15           (*(volatile hw_csu_csl15_t *) HW_CSU_CSL15_ADDR)
#define HW_CSU_CSL15_RD()      (HW_CSU_CSL15.U)
#define HW_CSU_CSL15_WR(v)     (HW_CSU_CSL15.U = (v))
#define HW_CSU_CSL15_SET(v)    (HW_CSU_CSL15_WR(HW_CSU_CSL15_RD() |  (v)))
#define HW_CSU_CSL15_CLR(v)    (HW_CSU_CSL15_WR(HW_CSU_CSL15_RD() & ~(v)))
#define HW_CSU_CSL15_TOG(v)    (HW_CSU_CSL15_WR(HW_CSU_CSL15_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL15 bitfields
 */

/* --- Register HW_CSU_CSL15, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL15_SUR_S2      (0)      //!< Bit position for CSU_CSL15_SUR_S2.
#define BM_CSU_CSL15_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL15_SUR_S2.

//! @brief Get value of CSU_CSL15_SUR_S2 from a register value.
#define BG_CSU_CSL15_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_SUR_S2) >> BP_CSU_CSL15_SUR_S2)

//! @brief Format value for bitfield CSU_CSL15_SUR_S2.
#define BF_CSU_CSL15_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_SUR_S2) & BM_CSU_CSL15_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL15_SUR_S2(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_SUR_S2) | BF_CSU_CSL15_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL15, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL15_SSR_S2      (1)      //!< Bit position for CSU_CSL15_SSR_S2.
#define BM_CSU_CSL15_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL15_SSR_S2.

//! @brief Get value of CSU_CSL15_SSR_S2 from a register value.
#define BG_CSU_CSL15_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_SSR_S2) >> BP_CSU_CSL15_SSR_S2)

//! @brief Format value for bitfield CSU_CSL15_SSR_S2.
#define BF_CSU_CSL15_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_SSR_S2) & BM_CSU_CSL15_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL15_SSR_S2(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_SSR_S2) | BF_CSU_CSL15_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL15, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL15_NUR_S2      (2)      //!< Bit position for CSU_CSL15_NUR_S2.
#define BM_CSU_CSL15_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL15_NUR_S2.

//! @brief Get value of CSU_CSL15_NUR_S2 from a register value.
#define BG_CSU_CSL15_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_NUR_S2) >> BP_CSU_CSL15_NUR_S2)

//! @brief Format value for bitfield CSU_CSL15_NUR_S2.
#define BF_CSU_CSL15_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_NUR_S2) & BM_CSU_CSL15_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL15_NUR_S2(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_NUR_S2) | BF_CSU_CSL15_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL15, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL15_NSR_S2      (3)      //!< Bit position for CSU_CSL15_NSR_S2.
#define BM_CSU_CSL15_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL15_NSR_S2.

//! @brief Get value of CSU_CSL15_NSR_S2 from a register value.
#define BG_CSU_CSL15_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_NSR_S2) >> BP_CSU_CSL15_NSR_S2)

//! @brief Format value for bitfield CSU_CSL15_NSR_S2.
#define BF_CSU_CSL15_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_NSR_S2) & BM_CSU_CSL15_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL15_NSR_S2(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_NSR_S2) | BF_CSU_CSL15_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL15, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL15_SUW_S2      (4)      //!< Bit position for CSU_CSL15_SUW_S2.
#define BM_CSU_CSL15_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL15_SUW_S2.

//! @brief Get value of CSU_CSL15_SUW_S2 from a register value.
#define BG_CSU_CSL15_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_SUW_S2) >> BP_CSU_CSL15_SUW_S2)

//! @brief Format value for bitfield CSU_CSL15_SUW_S2.
#define BF_CSU_CSL15_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_SUW_S2) & BM_CSU_CSL15_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL15_SUW_S2(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_SUW_S2) | BF_CSU_CSL15_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL15, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL15_SSW_S2      (5)      //!< Bit position for CSU_CSL15_SSW_S2.
#define BM_CSU_CSL15_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL15_SSW_S2.

//! @brief Get value of CSU_CSL15_SSW_S2 from a register value.
#define BG_CSU_CSL15_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_SSW_S2) >> BP_CSU_CSL15_SSW_S2)

//! @brief Format value for bitfield CSU_CSL15_SSW_S2.
#define BF_CSU_CSL15_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_SSW_S2) & BM_CSU_CSL15_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL15_SSW_S2(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_SSW_S2) | BF_CSU_CSL15_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL15, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL15_NUW_S2      (6)      //!< Bit position for CSU_CSL15_NUW_S2.
#define BM_CSU_CSL15_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL15_NUW_S2.

//! @brief Get value of CSU_CSL15_NUW_S2 from a register value.
#define BG_CSU_CSL15_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_NUW_S2) >> BP_CSU_CSL15_NUW_S2)

//! @brief Format value for bitfield CSU_CSL15_NUW_S2.
#define BF_CSU_CSL15_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_NUW_S2) & BM_CSU_CSL15_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL15_NUW_S2(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_NUW_S2) | BF_CSU_CSL15_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL15, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL15_NSW_S2      (7)      //!< Bit position for CSU_CSL15_NSW_S2.
#define BM_CSU_CSL15_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL15_NSW_S2.

//! @brief Get value of CSU_CSL15_NSW_S2 from a register value.
#define BG_CSU_CSL15_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_NSW_S2) >> BP_CSU_CSL15_NSW_S2)

//! @brief Format value for bitfield CSU_CSL15_NSW_S2.
#define BF_CSU_CSL15_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_NSW_S2) & BM_CSU_CSL15_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL15_NSW_S2(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_NSW_S2) | BF_CSU_CSL15_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL15, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL15_LOCK_S2      (8)      //!< Bit position for CSU_CSL15_LOCK_S2.
#define BM_CSU_CSL15_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL15_LOCK_S2.

//! @brief Get value of CSU_CSL15_LOCK_S2 from a register value.
#define BG_CSU_CSL15_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_LOCK_S2) >> BP_CSU_CSL15_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL15_LOCK_S2.
#define BF_CSU_CSL15_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_LOCK_S2) & BM_CSU_CSL15_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL15_LOCK_S2(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_LOCK_S2) | BF_CSU_CSL15_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL15, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL15_SUR_S1      (16)      //!< Bit position for CSU_CSL15_SUR_S1.
#define BM_CSU_CSL15_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL15_SUR_S1.

//! @brief Get value of CSU_CSL15_SUR_S1 from a register value.
#define BG_CSU_CSL15_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_SUR_S1) >> BP_CSU_CSL15_SUR_S1)

//! @brief Format value for bitfield CSU_CSL15_SUR_S1.
#define BF_CSU_CSL15_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_SUR_S1) & BM_CSU_CSL15_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL15_SUR_S1(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_SUR_S1) | BF_CSU_CSL15_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL15, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL15_SSR_S1      (17)      //!< Bit position for CSU_CSL15_SSR_S1.
#define BM_CSU_CSL15_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL15_SSR_S1.

//! @brief Get value of CSU_CSL15_SSR_S1 from a register value.
#define BG_CSU_CSL15_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_SSR_S1) >> BP_CSU_CSL15_SSR_S1)

//! @brief Format value for bitfield CSU_CSL15_SSR_S1.
#define BF_CSU_CSL15_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_SSR_S1) & BM_CSU_CSL15_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL15_SSR_S1(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_SSR_S1) | BF_CSU_CSL15_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL15, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL15_NUR_S1      (18)      //!< Bit position for CSU_CSL15_NUR_S1.
#define BM_CSU_CSL15_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL15_NUR_S1.

//! @brief Get value of CSU_CSL15_NUR_S1 from a register value.
#define BG_CSU_CSL15_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_NUR_S1) >> BP_CSU_CSL15_NUR_S1)

//! @brief Format value for bitfield CSU_CSL15_NUR_S1.
#define BF_CSU_CSL15_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_NUR_S1) & BM_CSU_CSL15_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL15_NUR_S1(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_NUR_S1) | BF_CSU_CSL15_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL15, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL15_NSR_S1      (19)      //!< Bit position for CSU_CSL15_NSR_S1.
#define BM_CSU_CSL15_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL15_NSR_S1.

//! @brief Get value of CSU_CSL15_NSR_S1 from a register value.
#define BG_CSU_CSL15_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_NSR_S1) >> BP_CSU_CSL15_NSR_S1)

//! @brief Format value for bitfield CSU_CSL15_NSR_S1.
#define BF_CSU_CSL15_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_NSR_S1) & BM_CSU_CSL15_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL15_NSR_S1(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_NSR_S1) | BF_CSU_CSL15_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL15, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL15_SUW_S1      (20)      //!< Bit position for CSU_CSL15_SUW_S1.
#define BM_CSU_CSL15_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL15_SUW_S1.

//! @brief Get value of CSU_CSL15_SUW_S1 from a register value.
#define BG_CSU_CSL15_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_SUW_S1) >> BP_CSU_CSL15_SUW_S1)

//! @brief Format value for bitfield CSU_CSL15_SUW_S1.
#define BF_CSU_CSL15_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_SUW_S1) & BM_CSU_CSL15_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL15_SUW_S1(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_SUW_S1) | BF_CSU_CSL15_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL15, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL15_SSW_S1      (21)      //!< Bit position for CSU_CSL15_SSW_S1.
#define BM_CSU_CSL15_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL15_SSW_S1.

//! @brief Get value of CSU_CSL15_SSW_S1 from a register value.
#define BG_CSU_CSL15_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_SSW_S1) >> BP_CSU_CSL15_SSW_S1)

//! @brief Format value for bitfield CSU_CSL15_SSW_S1.
#define BF_CSU_CSL15_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_SSW_S1) & BM_CSU_CSL15_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL15_SSW_S1(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_SSW_S1) | BF_CSU_CSL15_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL15, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL15_NUW_S1      (22)      //!< Bit position for CSU_CSL15_NUW_S1.
#define BM_CSU_CSL15_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL15_NUW_S1.

//! @brief Get value of CSU_CSL15_NUW_S1 from a register value.
#define BG_CSU_CSL15_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_NUW_S1) >> BP_CSU_CSL15_NUW_S1)

//! @brief Format value for bitfield CSU_CSL15_NUW_S1.
#define BF_CSU_CSL15_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_NUW_S1) & BM_CSU_CSL15_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL15_NUW_S1(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_NUW_S1) | BF_CSU_CSL15_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL15, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL15_NSW_S1      (23)      //!< Bit position for CSU_CSL15_NSW_S1.
#define BM_CSU_CSL15_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL15_NSW_S1.

//! @brief Get value of CSU_CSL15_NSW_S1 from a register value.
#define BG_CSU_CSL15_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_NSW_S1) >> BP_CSU_CSL15_NSW_S1)

//! @brief Format value for bitfield CSU_CSL15_NSW_S1.
#define BF_CSU_CSL15_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_NSW_S1) & BM_CSU_CSL15_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL15_NSW_S1(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_NSW_S1) | BF_CSU_CSL15_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL15, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL15_LOCK_S1      (24)      //!< Bit position for CSU_CSL15_LOCK_S1.
#define BM_CSU_CSL15_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL15_LOCK_S1.

//! @brief Get value of CSU_CSL15_LOCK_S1 from a register value.
#define BG_CSU_CSL15_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL15_LOCK_S1) >> BP_CSU_CSL15_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL15_LOCK_S1.
#define BF_CSU_CSL15_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL15_LOCK_S1) & BM_CSU_CSL15_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL15_LOCK_S1(v)   (HW_CSU_CSL15_WR((HW_CSU_CSL15_RD() & ~BM_CSU_CSL15_LOCK_S1) | BF_CSU_CSL15_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL16 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL16 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl16
{
    reg32_t U;
    struct _hw_csu_csl16_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl16_t;
#endif

/*
 * constants & macros for entire CSU_CSL16 register
 */
#define HW_CSU_CSL16_ADDR      (REGS_CSU_BASE + 0x40)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL16           (*(volatile hw_csu_csl16_t *) HW_CSU_CSL16_ADDR)
#define HW_CSU_CSL16_RD()      (HW_CSU_CSL16.U)
#define HW_CSU_CSL16_WR(v)     (HW_CSU_CSL16.U = (v))
#define HW_CSU_CSL16_SET(v)    (HW_CSU_CSL16_WR(HW_CSU_CSL16_RD() |  (v)))
#define HW_CSU_CSL16_CLR(v)    (HW_CSU_CSL16_WR(HW_CSU_CSL16_RD() & ~(v)))
#define HW_CSU_CSL16_TOG(v)    (HW_CSU_CSL16_WR(HW_CSU_CSL16_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL16 bitfields
 */

/* --- Register HW_CSU_CSL16, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL16_SUR_S2      (0)      //!< Bit position for CSU_CSL16_SUR_S2.
#define BM_CSU_CSL16_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL16_SUR_S2.

//! @brief Get value of CSU_CSL16_SUR_S2 from a register value.
#define BG_CSU_CSL16_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_SUR_S2) >> BP_CSU_CSL16_SUR_S2)

//! @brief Format value for bitfield CSU_CSL16_SUR_S2.
#define BF_CSU_CSL16_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_SUR_S2) & BM_CSU_CSL16_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL16_SUR_S2(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_SUR_S2) | BF_CSU_CSL16_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL16, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL16_SSR_S2      (1)      //!< Bit position for CSU_CSL16_SSR_S2.
#define BM_CSU_CSL16_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL16_SSR_S2.

//! @brief Get value of CSU_CSL16_SSR_S2 from a register value.
#define BG_CSU_CSL16_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_SSR_S2) >> BP_CSU_CSL16_SSR_S2)

//! @brief Format value for bitfield CSU_CSL16_SSR_S2.
#define BF_CSU_CSL16_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_SSR_S2) & BM_CSU_CSL16_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL16_SSR_S2(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_SSR_S2) | BF_CSU_CSL16_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL16, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL16_NUR_S2      (2)      //!< Bit position for CSU_CSL16_NUR_S2.
#define BM_CSU_CSL16_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL16_NUR_S2.

//! @brief Get value of CSU_CSL16_NUR_S2 from a register value.
#define BG_CSU_CSL16_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_NUR_S2) >> BP_CSU_CSL16_NUR_S2)

//! @brief Format value for bitfield CSU_CSL16_NUR_S2.
#define BF_CSU_CSL16_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_NUR_S2) & BM_CSU_CSL16_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL16_NUR_S2(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_NUR_S2) | BF_CSU_CSL16_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL16, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL16_NSR_S2      (3)      //!< Bit position for CSU_CSL16_NSR_S2.
#define BM_CSU_CSL16_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL16_NSR_S2.

//! @brief Get value of CSU_CSL16_NSR_S2 from a register value.
#define BG_CSU_CSL16_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_NSR_S2) >> BP_CSU_CSL16_NSR_S2)

//! @brief Format value for bitfield CSU_CSL16_NSR_S2.
#define BF_CSU_CSL16_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_NSR_S2) & BM_CSU_CSL16_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL16_NSR_S2(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_NSR_S2) | BF_CSU_CSL16_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL16, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL16_SUW_S2      (4)      //!< Bit position for CSU_CSL16_SUW_S2.
#define BM_CSU_CSL16_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL16_SUW_S2.

//! @brief Get value of CSU_CSL16_SUW_S2 from a register value.
#define BG_CSU_CSL16_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_SUW_S2) >> BP_CSU_CSL16_SUW_S2)

//! @brief Format value for bitfield CSU_CSL16_SUW_S2.
#define BF_CSU_CSL16_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_SUW_S2) & BM_CSU_CSL16_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL16_SUW_S2(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_SUW_S2) | BF_CSU_CSL16_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL16, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL16_SSW_S2      (5)      //!< Bit position for CSU_CSL16_SSW_S2.
#define BM_CSU_CSL16_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL16_SSW_S2.

//! @brief Get value of CSU_CSL16_SSW_S2 from a register value.
#define BG_CSU_CSL16_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_SSW_S2) >> BP_CSU_CSL16_SSW_S2)

//! @brief Format value for bitfield CSU_CSL16_SSW_S2.
#define BF_CSU_CSL16_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_SSW_S2) & BM_CSU_CSL16_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL16_SSW_S2(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_SSW_S2) | BF_CSU_CSL16_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL16, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL16_NUW_S2      (6)      //!< Bit position for CSU_CSL16_NUW_S2.
#define BM_CSU_CSL16_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL16_NUW_S2.

//! @brief Get value of CSU_CSL16_NUW_S2 from a register value.
#define BG_CSU_CSL16_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_NUW_S2) >> BP_CSU_CSL16_NUW_S2)

//! @brief Format value for bitfield CSU_CSL16_NUW_S2.
#define BF_CSU_CSL16_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_NUW_S2) & BM_CSU_CSL16_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL16_NUW_S2(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_NUW_S2) | BF_CSU_CSL16_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL16, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL16_NSW_S2      (7)      //!< Bit position for CSU_CSL16_NSW_S2.
#define BM_CSU_CSL16_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL16_NSW_S2.

//! @brief Get value of CSU_CSL16_NSW_S2 from a register value.
#define BG_CSU_CSL16_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_NSW_S2) >> BP_CSU_CSL16_NSW_S2)

//! @brief Format value for bitfield CSU_CSL16_NSW_S2.
#define BF_CSU_CSL16_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_NSW_S2) & BM_CSU_CSL16_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL16_NSW_S2(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_NSW_S2) | BF_CSU_CSL16_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL16, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL16_LOCK_S2      (8)      //!< Bit position for CSU_CSL16_LOCK_S2.
#define BM_CSU_CSL16_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL16_LOCK_S2.

//! @brief Get value of CSU_CSL16_LOCK_S2 from a register value.
#define BG_CSU_CSL16_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_LOCK_S2) >> BP_CSU_CSL16_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL16_LOCK_S2.
#define BF_CSU_CSL16_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_LOCK_S2) & BM_CSU_CSL16_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL16_LOCK_S2(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_LOCK_S2) | BF_CSU_CSL16_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL16, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL16_SUR_S1      (16)      //!< Bit position for CSU_CSL16_SUR_S1.
#define BM_CSU_CSL16_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL16_SUR_S1.

//! @brief Get value of CSU_CSL16_SUR_S1 from a register value.
#define BG_CSU_CSL16_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_SUR_S1) >> BP_CSU_CSL16_SUR_S1)

//! @brief Format value for bitfield CSU_CSL16_SUR_S1.
#define BF_CSU_CSL16_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_SUR_S1) & BM_CSU_CSL16_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL16_SUR_S1(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_SUR_S1) | BF_CSU_CSL16_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL16, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL16_SSR_S1      (17)      //!< Bit position for CSU_CSL16_SSR_S1.
#define BM_CSU_CSL16_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL16_SSR_S1.

//! @brief Get value of CSU_CSL16_SSR_S1 from a register value.
#define BG_CSU_CSL16_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_SSR_S1) >> BP_CSU_CSL16_SSR_S1)

//! @brief Format value for bitfield CSU_CSL16_SSR_S1.
#define BF_CSU_CSL16_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_SSR_S1) & BM_CSU_CSL16_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL16_SSR_S1(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_SSR_S1) | BF_CSU_CSL16_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL16, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL16_NUR_S1      (18)      //!< Bit position for CSU_CSL16_NUR_S1.
#define BM_CSU_CSL16_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL16_NUR_S1.

//! @brief Get value of CSU_CSL16_NUR_S1 from a register value.
#define BG_CSU_CSL16_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_NUR_S1) >> BP_CSU_CSL16_NUR_S1)

//! @brief Format value for bitfield CSU_CSL16_NUR_S1.
#define BF_CSU_CSL16_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_NUR_S1) & BM_CSU_CSL16_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL16_NUR_S1(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_NUR_S1) | BF_CSU_CSL16_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL16, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL16_NSR_S1      (19)      //!< Bit position for CSU_CSL16_NSR_S1.
#define BM_CSU_CSL16_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL16_NSR_S1.

//! @brief Get value of CSU_CSL16_NSR_S1 from a register value.
#define BG_CSU_CSL16_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_NSR_S1) >> BP_CSU_CSL16_NSR_S1)

//! @brief Format value for bitfield CSU_CSL16_NSR_S1.
#define BF_CSU_CSL16_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_NSR_S1) & BM_CSU_CSL16_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL16_NSR_S1(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_NSR_S1) | BF_CSU_CSL16_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL16, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL16_SUW_S1      (20)      //!< Bit position for CSU_CSL16_SUW_S1.
#define BM_CSU_CSL16_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL16_SUW_S1.

//! @brief Get value of CSU_CSL16_SUW_S1 from a register value.
#define BG_CSU_CSL16_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_SUW_S1) >> BP_CSU_CSL16_SUW_S1)

//! @brief Format value for bitfield CSU_CSL16_SUW_S1.
#define BF_CSU_CSL16_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_SUW_S1) & BM_CSU_CSL16_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL16_SUW_S1(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_SUW_S1) | BF_CSU_CSL16_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL16, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL16_SSW_S1      (21)      //!< Bit position for CSU_CSL16_SSW_S1.
#define BM_CSU_CSL16_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL16_SSW_S1.

//! @brief Get value of CSU_CSL16_SSW_S1 from a register value.
#define BG_CSU_CSL16_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_SSW_S1) >> BP_CSU_CSL16_SSW_S1)

//! @brief Format value for bitfield CSU_CSL16_SSW_S1.
#define BF_CSU_CSL16_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_SSW_S1) & BM_CSU_CSL16_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL16_SSW_S1(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_SSW_S1) | BF_CSU_CSL16_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL16, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL16_NUW_S1      (22)      //!< Bit position for CSU_CSL16_NUW_S1.
#define BM_CSU_CSL16_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL16_NUW_S1.

//! @brief Get value of CSU_CSL16_NUW_S1 from a register value.
#define BG_CSU_CSL16_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_NUW_S1) >> BP_CSU_CSL16_NUW_S1)

//! @brief Format value for bitfield CSU_CSL16_NUW_S1.
#define BF_CSU_CSL16_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_NUW_S1) & BM_CSU_CSL16_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL16_NUW_S1(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_NUW_S1) | BF_CSU_CSL16_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL16, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL16_NSW_S1      (23)      //!< Bit position for CSU_CSL16_NSW_S1.
#define BM_CSU_CSL16_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL16_NSW_S1.

//! @brief Get value of CSU_CSL16_NSW_S1 from a register value.
#define BG_CSU_CSL16_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_NSW_S1) >> BP_CSU_CSL16_NSW_S1)

//! @brief Format value for bitfield CSU_CSL16_NSW_S1.
#define BF_CSU_CSL16_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_NSW_S1) & BM_CSU_CSL16_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL16_NSW_S1(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_NSW_S1) | BF_CSU_CSL16_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL16, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL16_LOCK_S1      (24)      //!< Bit position for CSU_CSL16_LOCK_S1.
#define BM_CSU_CSL16_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL16_LOCK_S1.

//! @brief Get value of CSU_CSL16_LOCK_S1 from a register value.
#define BG_CSU_CSL16_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL16_LOCK_S1) >> BP_CSU_CSL16_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL16_LOCK_S1.
#define BF_CSU_CSL16_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL16_LOCK_S1) & BM_CSU_CSL16_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL16_LOCK_S1(v)   (HW_CSU_CSL16_WR((HW_CSU_CSL16_RD() & ~BM_CSU_CSL16_LOCK_S1) | BF_CSU_CSL16_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL17 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL17 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl17
{
    reg32_t U;
    struct _hw_csu_csl17_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl17_t;
#endif

/*
 * constants & macros for entire CSU_CSL17 register
 */
#define HW_CSU_CSL17_ADDR      (REGS_CSU_BASE + 0x44)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL17           (*(volatile hw_csu_csl17_t *) HW_CSU_CSL17_ADDR)
#define HW_CSU_CSL17_RD()      (HW_CSU_CSL17.U)
#define HW_CSU_CSL17_WR(v)     (HW_CSU_CSL17.U = (v))
#define HW_CSU_CSL17_SET(v)    (HW_CSU_CSL17_WR(HW_CSU_CSL17_RD() |  (v)))
#define HW_CSU_CSL17_CLR(v)    (HW_CSU_CSL17_WR(HW_CSU_CSL17_RD() & ~(v)))
#define HW_CSU_CSL17_TOG(v)    (HW_CSU_CSL17_WR(HW_CSU_CSL17_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL17 bitfields
 */

/* --- Register HW_CSU_CSL17, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL17_SUR_S2      (0)      //!< Bit position for CSU_CSL17_SUR_S2.
#define BM_CSU_CSL17_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL17_SUR_S2.

//! @brief Get value of CSU_CSL17_SUR_S2 from a register value.
#define BG_CSU_CSL17_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_SUR_S2) >> BP_CSU_CSL17_SUR_S2)

//! @brief Format value for bitfield CSU_CSL17_SUR_S2.
#define BF_CSU_CSL17_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_SUR_S2) & BM_CSU_CSL17_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL17_SUR_S2(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_SUR_S2) | BF_CSU_CSL17_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL17, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL17_SSR_S2      (1)      //!< Bit position for CSU_CSL17_SSR_S2.
#define BM_CSU_CSL17_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL17_SSR_S2.

//! @brief Get value of CSU_CSL17_SSR_S2 from a register value.
#define BG_CSU_CSL17_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_SSR_S2) >> BP_CSU_CSL17_SSR_S2)

//! @brief Format value for bitfield CSU_CSL17_SSR_S2.
#define BF_CSU_CSL17_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_SSR_S2) & BM_CSU_CSL17_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL17_SSR_S2(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_SSR_S2) | BF_CSU_CSL17_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL17, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL17_NUR_S2      (2)      //!< Bit position for CSU_CSL17_NUR_S2.
#define BM_CSU_CSL17_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL17_NUR_S2.

//! @brief Get value of CSU_CSL17_NUR_S2 from a register value.
#define BG_CSU_CSL17_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_NUR_S2) >> BP_CSU_CSL17_NUR_S2)

//! @brief Format value for bitfield CSU_CSL17_NUR_S2.
#define BF_CSU_CSL17_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_NUR_S2) & BM_CSU_CSL17_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL17_NUR_S2(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_NUR_S2) | BF_CSU_CSL17_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL17, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL17_NSR_S2      (3)      //!< Bit position for CSU_CSL17_NSR_S2.
#define BM_CSU_CSL17_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL17_NSR_S2.

//! @brief Get value of CSU_CSL17_NSR_S2 from a register value.
#define BG_CSU_CSL17_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_NSR_S2) >> BP_CSU_CSL17_NSR_S2)

//! @brief Format value for bitfield CSU_CSL17_NSR_S2.
#define BF_CSU_CSL17_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_NSR_S2) & BM_CSU_CSL17_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL17_NSR_S2(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_NSR_S2) | BF_CSU_CSL17_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL17, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL17_SUW_S2      (4)      //!< Bit position for CSU_CSL17_SUW_S2.
#define BM_CSU_CSL17_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL17_SUW_S2.

//! @brief Get value of CSU_CSL17_SUW_S2 from a register value.
#define BG_CSU_CSL17_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_SUW_S2) >> BP_CSU_CSL17_SUW_S2)

//! @brief Format value for bitfield CSU_CSL17_SUW_S2.
#define BF_CSU_CSL17_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_SUW_S2) & BM_CSU_CSL17_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL17_SUW_S2(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_SUW_S2) | BF_CSU_CSL17_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL17, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL17_SSW_S2      (5)      //!< Bit position for CSU_CSL17_SSW_S2.
#define BM_CSU_CSL17_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL17_SSW_S2.

//! @brief Get value of CSU_CSL17_SSW_S2 from a register value.
#define BG_CSU_CSL17_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_SSW_S2) >> BP_CSU_CSL17_SSW_S2)

//! @brief Format value for bitfield CSU_CSL17_SSW_S2.
#define BF_CSU_CSL17_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_SSW_S2) & BM_CSU_CSL17_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL17_SSW_S2(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_SSW_S2) | BF_CSU_CSL17_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL17, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL17_NUW_S2      (6)      //!< Bit position for CSU_CSL17_NUW_S2.
#define BM_CSU_CSL17_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL17_NUW_S2.

//! @brief Get value of CSU_CSL17_NUW_S2 from a register value.
#define BG_CSU_CSL17_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_NUW_S2) >> BP_CSU_CSL17_NUW_S2)

//! @brief Format value for bitfield CSU_CSL17_NUW_S2.
#define BF_CSU_CSL17_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_NUW_S2) & BM_CSU_CSL17_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL17_NUW_S2(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_NUW_S2) | BF_CSU_CSL17_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL17, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL17_NSW_S2      (7)      //!< Bit position for CSU_CSL17_NSW_S2.
#define BM_CSU_CSL17_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL17_NSW_S2.

//! @brief Get value of CSU_CSL17_NSW_S2 from a register value.
#define BG_CSU_CSL17_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_NSW_S2) >> BP_CSU_CSL17_NSW_S2)

//! @brief Format value for bitfield CSU_CSL17_NSW_S2.
#define BF_CSU_CSL17_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_NSW_S2) & BM_CSU_CSL17_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL17_NSW_S2(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_NSW_S2) | BF_CSU_CSL17_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL17, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL17_LOCK_S2      (8)      //!< Bit position for CSU_CSL17_LOCK_S2.
#define BM_CSU_CSL17_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL17_LOCK_S2.

//! @brief Get value of CSU_CSL17_LOCK_S2 from a register value.
#define BG_CSU_CSL17_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_LOCK_S2) >> BP_CSU_CSL17_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL17_LOCK_S2.
#define BF_CSU_CSL17_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_LOCK_S2) & BM_CSU_CSL17_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL17_LOCK_S2(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_LOCK_S2) | BF_CSU_CSL17_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL17, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL17_SUR_S1      (16)      //!< Bit position for CSU_CSL17_SUR_S1.
#define BM_CSU_CSL17_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL17_SUR_S1.

//! @brief Get value of CSU_CSL17_SUR_S1 from a register value.
#define BG_CSU_CSL17_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_SUR_S1) >> BP_CSU_CSL17_SUR_S1)

//! @brief Format value for bitfield CSU_CSL17_SUR_S1.
#define BF_CSU_CSL17_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_SUR_S1) & BM_CSU_CSL17_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL17_SUR_S1(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_SUR_S1) | BF_CSU_CSL17_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL17, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL17_SSR_S1      (17)      //!< Bit position for CSU_CSL17_SSR_S1.
#define BM_CSU_CSL17_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL17_SSR_S1.

//! @brief Get value of CSU_CSL17_SSR_S1 from a register value.
#define BG_CSU_CSL17_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_SSR_S1) >> BP_CSU_CSL17_SSR_S1)

//! @brief Format value for bitfield CSU_CSL17_SSR_S1.
#define BF_CSU_CSL17_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_SSR_S1) & BM_CSU_CSL17_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL17_SSR_S1(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_SSR_S1) | BF_CSU_CSL17_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL17, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL17_NUR_S1      (18)      //!< Bit position for CSU_CSL17_NUR_S1.
#define BM_CSU_CSL17_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL17_NUR_S1.

//! @brief Get value of CSU_CSL17_NUR_S1 from a register value.
#define BG_CSU_CSL17_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_NUR_S1) >> BP_CSU_CSL17_NUR_S1)

//! @brief Format value for bitfield CSU_CSL17_NUR_S1.
#define BF_CSU_CSL17_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_NUR_S1) & BM_CSU_CSL17_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL17_NUR_S1(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_NUR_S1) | BF_CSU_CSL17_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL17, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL17_NSR_S1      (19)      //!< Bit position for CSU_CSL17_NSR_S1.
#define BM_CSU_CSL17_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL17_NSR_S1.

//! @brief Get value of CSU_CSL17_NSR_S1 from a register value.
#define BG_CSU_CSL17_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_NSR_S1) >> BP_CSU_CSL17_NSR_S1)

//! @brief Format value for bitfield CSU_CSL17_NSR_S1.
#define BF_CSU_CSL17_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_NSR_S1) & BM_CSU_CSL17_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL17_NSR_S1(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_NSR_S1) | BF_CSU_CSL17_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL17, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL17_SUW_S1      (20)      //!< Bit position for CSU_CSL17_SUW_S1.
#define BM_CSU_CSL17_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL17_SUW_S1.

//! @brief Get value of CSU_CSL17_SUW_S1 from a register value.
#define BG_CSU_CSL17_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_SUW_S1) >> BP_CSU_CSL17_SUW_S1)

//! @brief Format value for bitfield CSU_CSL17_SUW_S1.
#define BF_CSU_CSL17_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_SUW_S1) & BM_CSU_CSL17_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL17_SUW_S1(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_SUW_S1) | BF_CSU_CSL17_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL17, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL17_SSW_S1      (21)      //!< Bit position for CSU_CSL17_SSW_S1.
#define BM_CSU_CSL17_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL17_SSW_S1.

//! @brief Get value of CSU_CSL17_SSW_S1 from a register value.
#define BG_CSU_CSL17_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_SSW_S1) >> BP_CSU_CSL17_SSW_S1)

//! @brief Format value for bitfield CSU_CSL17_SSW_S1.
#define BF_CSU_CSL17_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_SSW_S1) & BM_CSU_CSL17_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL17_SSW_S1(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_SSW_S1) | BF_CSU_CSL17_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL17, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL17_NUW_S1      (22)      //!< Bit position for CSU_CSL17_NUW_S1.
#define BM_CSU_CSL17_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL17_NUW_S1.

//! @brief Get value of CSU_CSL17_NUW_S1 from a register value.
#define BG_CSU_CSL17_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_NUW_S1) >> BP_CSU_CSL17_NUW_S1)

//! @brief Format value for bitfield CSU_CSL17_NUW_S1.
#define BF_CSU_CSL17_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_NUW_S1) & BM_CSU_CSL17_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL17_NUW_S1(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_NUW_S1) | BF_CSU_CSL17_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL17, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL17_NSW_S1      (23)      //!< Bit position for CSU_CSL17_NSW_S1.
#define BM_CSU_CSL17_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL17_NSW_S1.

//! @brief Get value of CSU_CSL17_NSW_S1 from a register value.
#define BG_CSU_CSL17_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_NSW_S1) >> BP_CSU_CSL17_NSW_S1)

//! @brief Format value for bitfield CSU_CSL17_NSW_S1.
#define BF_CSU_CSL17_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_NSW_S1) & BM_CSU_CSL17_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL17_NSW_S1(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_NSW_S1) | BF_CSU_CSL17_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL17, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL17_LOCK_S1      (24)      //!< Bit position for CSU_CSL17_LOCK_S1.
#define BM_CSU_CSL17_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL17_LOCK_S1.

//! @brief Get value of CSU_CSL17_LOCK_S1 from a register value.
#define BG_CSU_CSL17_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL17_LOCK_S1) >> BP_CSU_CSL17_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL17_LOCK_S1.
#define BF_CSU_CSL17_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL17_LOCK_S1) & BM_CSU_CSL17_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL17_LOCK_S1(v)   (HW_CSU_CSL17_WR((HW_CSU_CSL17_RD() & ~BM_CSU_CSL17_LOCK_S1) | BF_CSU_CSL17_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL18 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL18 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl18
{
    reg32_t U;
    struct _hw_csu_csl18_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl18_t;
#endif

/*
 * constants & macros for entire CSU_CSL18 register
 */
#define HW_CSU_CSL18_ADDR      (REGS_CSU_BASE + 0x48)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL18           (*(volatile hw_csu_csl18_t *) HW_CSU_CSL18_ADDR)
#define HW_CSU_CSL18_RD()      (HW_CSU_CSL18.U)
#define HW_CSU_CSL18_WR(v)     (HW_CSU_CSL18.U = (v))
#define HW_CSU_CSL18_SET(v)    (HW_CSU_CSL18_WR(HW_CSU_CSL18_RD() |  (v)))
#define HW_CSU_CSL18_CLR(v)    (HW_CSU_CSL18_WR(HW_CSU_CSL18_RD() & ~(v)))
#define HW_CSU_CSL18_TOG(v)    (HW_CSU_CSL18_WR(HW_CSU_CSL18_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL18 bitfields
 */

/* --- Register HW_CSU_CSL18, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL18_SUR_S2      (0)      //!< Bit position for CSU_CSL18_SUR_S2.
#define BM_CSU_CSL18_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL18_SUR_S2.

//! @brief Get value of CSU_CSL18_SUR_S2 from a register value.
#define BG_CSU_CSL18_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_SUR_S2) >> BP_CSU_CSL18_SUR_S2)

//! @brief Format value for bitfield CSU_CSL18_SUR_S2.
#define BF_CSU_CSL18_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_SUR_S2) & BM_CSU_CSL18_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL18_SUR_S2(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_SUR_S2) | BF_CSU_CSL18_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL18, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL18_SSR_S2      (1)      //!< Bit position for CSU_CSL18_SSR_S2.
#define BM_CSU_CSL18_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL18_SSR_S2.

//! @brief Get value of CSU_CSL18_SSR_S2 from a register value.
#define BG_CSU_CSL18_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_SSR_S2) >> BP_CSU_CSL18_SSR_S2)

//! @brief Format value for bitfield CSU_CSL18_SSR_S2.
#define BF_CSU_CSL18_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_SSR_S2) & BM_CSU_CSL18_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL18_SSR_S2(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_SSR_S2) | BF_CSU_CSL18_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL18, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL18_NUR_S2      (2)      //!< Bit position for CSU_CSL18_NUR_S2.
#define BM_CSU_CSL18_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL18_NUR_S2.

//! @brief Get value of CSU_CSL18_NUR_S2 from a register value.
#define BG_CSU_CSL18_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_NUR_S2) >> BP_CSU_CSL18_NUR_S2)

//! @brief Format value for bitfield CSU_CSL18_NUR_S2.
#define BF_CSU_CSL18_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_NUR_S2) & BM_CSU_CSL18_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL18_NUR_S2(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_NUR_S2) | BF_CSU_CSL18_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL18, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL18_NSR_S2      (3)      //!< Bit position for CSU_CSL18_NSR_S2.
#define BM_CSU_CSL18_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL18_NSR_S2.

//! @brief Get value of CSU_CSL18_NSR_S2 from a register value.
#define BG_CSU_CSL18_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_NSR_S2) >> BP_CSU_CSL18_NSR_S2)

//! @brief Format value for bitfield CSU_CSL18_NSR_S2.
#define BF_CSU_CSL18_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_NSR_S2) & BM_CSU_CSL18_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL18_NSR_S2(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_NSR_S2) | BF_CSU_CSL18_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL18, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL18_SUW_S2      (4)      //!< Bit position for CSU_CSL18_SUW_S2.
#define BM_CSU_CSL18_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL18_SUW_S2.

//! @brief Get value of CSU_CSL18_SUW_S2 from a register value.
#define BG_CSU_CSL18_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_SUW_S2) >> BP_CSU_CSL18_SUW_S2)

//! @brief Format value for bitfield CSU_CSL18_SUW_S2.
#define BF_CSU_CSL18_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_SUW_S2) & BM_CSU_CSL18_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL18_SUW_S2(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_SUW_S2) | BF_CSU_CSL18_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL18, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL18_SSW_S2      (5)      //!< Bit position for CSU_CSL18_SSW_S2.
#define BM_CSU_CSL18_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL18_SSW_S2.

//! @brief Get value of CSU_CSL18_SSW_S2 from a register value.
#define BG_CSU_CSL18_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_SSW_S2) >> BP_CSU_CSL18_SSW_S2)

//! @brief Format value for bitfield CSU_CSL18_SSW_S2.
#define BF_CSU_CSL18_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_SSW_S2) & BM_CSU_CSL18_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL18_SSW_S2(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_SSW_S2) | BF_CSU_CSL18_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL18, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL18_NUW_S2      (6)      //!< Bit position for CSU_CSL18_NUW_S2.
#define BM_CSU_CSL18_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL18_NUW_S2.

//! @brief Get value of CSU_CSL18_NUW_S2 from a register value.
#define BG_CSU_CSL18_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_NUW_S2) >> BP_CSU_CSL18_NUW_S2)

//! @brief Format value for bitfield CSU_CSL18_NUW_S2.
#define BF_CSU_CSL18_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_NUW_S2) & BM_CSU_CSL18_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL18_NUW_S2(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_NUW_S2) | BF_CSU_CSL18_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL18, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL18_NSW_S2      (7)      //!< Bit position for CSU_CSL18_NSW_S2.
#define BM_CSU_CSL18_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL18_NSW_S2.

//! @brief Get value of CSU_CSL18_NSW_S2 from a register value.
#define BG_CSU_CSL18_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_NSW_S2) >> BP_CSU_CSL18_NSW_S2)

//! @brief Format value for bitfield CSU_CSL18_NSW_S2.
#define BF_CSU_CSL18_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_NSW_S2) & BM_CSU_CSL18_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL18_NSW_S2(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_NSW_S2) | BF_CSU_CSL18_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL18, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL18_LOCK_S2      (8)      //!< Bit position for CSU_CSL18_LOCK_S2.
#define BM_CSU_CSL18_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL18_LOCK_S2.

//! @brief Get value of CSU_CSL18_LOCK_S2 from a register value.
#define BG_CSU_CSL18_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_LOCK_S2) >> BP_CSU_CSL18_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL18_LOCK_S2.
#define BF_CSU_CSL18_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_LOCK_S2) & BM_CSU_CSL18_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL18_LOCK_S2(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_LOCK_S2) | BF_CSU_CSL18_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL18, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL18_SUR_S1      (16)      //!< Bit position for CSU_CSL18_SUR_S1.
#define BM_CSU_CSL18_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL18_SUR_S1.

//! @brief Get value of CSU_CSL18_SUR_S1 from a register value.
#define BG_CSU_CSL18_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_SUR_S1) >> BP_CSU_CSL18_SUR_S1)

//! @brief Format value for bitfield CSU_CSL18_SUR_S1.
#define BF_CSU_CSL18_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_SUR_S1) & BM_CSU_CSL18_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL18_SUR_S1(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_SUR_S1) | BF_CSU_CSL18_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL18, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL18_SSR_S1      (17)      //!< Bit position for CSU_CSL18_SSR_S1.
#define BM_CSU_CSL18_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL18_SSR_S1.

//! @brief Get value of CSU_CSL18_SSR_S1 from a register value.
#define BG_CSU_CSL18_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_SSR_S1) >> BP_CSU_CSL18_SSR_S1)

//! @brief Format value for bitfield CSU_CSL18_SSR_S1.
#define BF_CSU_CSL18_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_SSR_S1) & BM_CSU_CSL18_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL18_SSR_S1(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_SSR_S1) | BF_CSU_CSL18_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL18, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL18_NUR_S1      (18)      //!< Bit position for CSU_CSL18_NUR_S1.
#define BM_CSU_CSL18_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL18_NUR_S1.

//! @brief Get value of CSU_CSL18_NUR_S1 from a register value.
#define BG_CSU_CSL18_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_NUR_S1) >> BP_CSU_CSL18_NUR_S1)

//! @brief Format value for bitfield CSU_CSL18_NUR_S1.
#define BF_CSU_CSL18_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_NUR_S1) & BM_CSU_CSL18_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL18_NUR_S1(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_NUR_S1) | BF_CSU_CSL18_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL18, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL18_NSR_S1      (19)      //!< Bit position for CSU_CSL18_NSR_S1.
#define BM_CSU_CSL18_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL18_NSR_S1.

//! @brief Get value of CSU_CSL18_NSR_S1 from a register value.
#define BG_CSU_CSL18_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_NSR_S1) >> BP_CSU_CSL18_NSR_S1)

//! @brief Format value for bitfield CSU_CSL18_NSR_S1.
#define BF_CSU_CSL18_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_NSR_S1) & BM_CSU_CSL18_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL18_NSR_S1(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_NSR_S1) | BF_CSU_CSL18_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL18, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL18_SUW_S1      (20)      //!< Bit position for CSU_CSL18_SUW_S1.
#define BM_CSU_CSL18_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL18_SUW_S1.

//! @brief Get value of CSU_CSL18_SUW_S1 from a register value.
#define BG_CSU_CSL18_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_SUW_S1) >> BP_CSU_CSL18_SUW_S1)

//! @brief Format value for bitfield CSU_CSL18_SUW_S1.
#define BF_CSU_CSL18_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_SUW_S1) & BM_CSU_CSL18_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL18_SUW_S1(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_SUW_S1) | BF_CSU_CSL18_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL18, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL18_SSW_S1      (21)      //!< Bit position for CSU_CSL18_SSW_S1.
#define BM_CSU_CSL18_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL18_SSW_S1.

//! @brief Get value of CSU_CSL18_SSW_S1 from a register value.
#define BG_CSU_CSL18_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_SSW_S1) >> BP_CSU_CSL18_SSW_S1)

//! @brief Format value for bitfield CSU_CSL18_SSW_S1.
#define BF_CSU_CSL18_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_SSW_S1) & BM_CSU_CSL18_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL18_SSW_S1(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_SSW_S1) | BF_CSU_CSL18_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL18, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL18_NUW_S1      (22)      //!< Bit position for CSU_CSL18_NUW_S1.
#define BM_CSU_CSL18_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL18_NUW_S1.

//! @brief Get value of CSU_CSL18_NUW_S1 from a register value.
#define BG_CSU_CSL18_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_NUW_S1) >> BP_CSU_CSL18_NUW_S1)

//! @brief Format value for bitfield CSU_CSL18_NUW_S1.
#define BF_CSU_CSL18_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_NUW_S1) & BM_CSU_CSL18_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL18_NUW_S1(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_NUW_S1) | BF_CSU_CSL18_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL18, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL18_NSW_S1      (23)      //!< Bit position for CSU_CSL18_NSW_S1.
#define BM_CSU_CSL18_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL18_NSW_S1.

//! @brief Get value of CSU_CSL18_NSW_S1 from a register value.
#define BG_CSU_CSL18_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_NSW_S1) >> BP_CSU_CSL18_NSW_S1)

//! @brief Format value for bitfield CSU_CSL18_NSW_S1.
#define BF_CSU_CSL18_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_NSW_S1) & BM_CSU_CSL18_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL18_NSW_S1(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_NSW_S1) | BF_CSU_CSL18_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL18, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL18_LOCK_S1      (24)      //!< Bit position for CSU_CSL18_LOCK_S1.
#define BM_CSU_CSL18_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL18_LOCK_S1.

//! @brief Get value of CSU_CSL18_LOCK_S1 from a register value.
#define BG_CSU_CSL18_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL18_LOCK_S1) >> BP_CSU_CSL18_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL18_LOCK_S1.
#define BF_CSU_CSL18_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL18_LOCK_S1) & BM_CSU_CSL18_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL18_LOCK_S1(v)   (HW_CSU_CSL18_WR((HW_CSU_CSL18_RD() & ~BM_CSU_CSL18_LOCK_S1) | BF_CSU_CSL18_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL19 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL19 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl19
{
    reg32_t U;
    struct _hw_csu_csl19_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl19_t;
#endif

/*
 * constants & macros for entire CSU_CSL19 register
 */
#define HW_CSU_CSL19_ADDR      (REGS_CSU_BASE + 0x4c)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL19           (*(volatile hw_csu_csl19_t *) HW_CSU_CSL19_ADDR)
#define HW_CSU_CSL19_RD()      (HW_CSU_CSL19.U)
#define HW_CSU_CSL19_WR(v)     (HW_CSU_CSL19.U = (v))
#define HW_CSU_CSL19_SET(v)    (HW_CSU_CSL19_WR(HW_CSU_CSL19_RD() |  (v)))
#define HW_CSU_CSL19_CLR(v)    (HW_CSU_CSL19_WR(HW_CSU_CSL19_RD() & ~(v)))
#define HW_CSU_CSL19_TOG(v)    (HW_CSU_CSL19_WR(HW_CSU_CSL19_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL19 bitfields
 */

/* --- Register HW_CSU_CSL19, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL19_SUR_S2      (0)      //!< Bit position for CSU_CSL19_SUR_S2.
#define BM_CSU_CSL19_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL19_SUR_S2.

//! @brief Get value of CSU_CSL19_SUR_S2 from a register value.
#define BG_CSU_CSL19_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_SUR_S2) >> BP_CSU_CSL19_SUR_S2)

//! @brief Format value for bitfield CSU_CSL19_SUR_S2.
#define BF_CSU_CSL19_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_SUR_S2) & BM_CSU_CSL19_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL19_SUR_S2(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_SUR_S2) | BF_CSU_CSL19_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL19, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL19_SSR_S2      (1)      //!< Bit position for CSU_CSL19_SSR_S2.
#define BM_CSU_CSL19_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL19_SSR_S2.

//! @brief Get value of CSU_CSL19_SSR_S2 from a register value.
#define BG_CSU_CSL19_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_SSR_S2) >> BP_CSU_CSL19_SSR_S2)

//! @brief Format value for bitfield CSU_CSL19_SSR_S2.
#define BF_CSU_CSL19_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_SSR_S2) & BM_CSU_CSL19_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL19_SSR_S2(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_SSR_S2) | BF_CSU_CSL19_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL19, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL19_NUR_S2      (2)      //!< Bit position for CSU_CSL19_NUR_S2.
#define BM_CSU_CSL19_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL19_NUR_S2.

//! @brief Get value of CSU_CSL19_NUR_S2 from a register value.
#define BG_CSU_CSL19_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_NUR_S2) >> BP_CSU_CSL19_NUR_S2)

//! @brief Format value for bitfield CSU_CSL19_NUR_S2.
#define BF_CSU_CSL19_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_NUR_S2) & BM_CSU_CSL19_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL19_NUR_S2(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_NUR_S2) | BF_CSU_CSL19_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL19, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL19_NSR_S2      (3)      //!< Bit position for CSU_CSL19_NSR_S2.
#define BM_CSU_CSL19_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL19_NSR_S2.

//! @brief Get value of CSU_CSL19_NSR_S2 from a register value.
#define BG_CSU_CSL19_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_NSR_S2) >> BP_CSU_CSL19_NSR_S2)

//! @brief Format value for bitfield CSU_CSL19_NSR_S2.
#define BF_CSU_CSL19_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_NSR_S2) & BM_CSU_CSL19_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL19_NSR_S2(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_NSR_S2) | BF_CSU_CSL19_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL19, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL19_SUW_S2      (4)      //!< Bit position for CSU_CSL19_SUW_S2.
#define BM_CSU_CSL19_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL19_SUW_S2.

//! @brief Get value of CSU_CSL19_SUW_S2 from a register value.
#define BG_CSU_CSL19_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_SUW_S2) >> BP_CSU_CSL19_SUW_S2)

//! @brief Format value for bitfield CSU_CSL19_SUW_S2.
#define BF_CSU_CSL19_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_SUW_S2) & BM_CSU_CSL19_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL19_SUW_S2(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_SUW_S2) | BF_CSU_CSL19_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL19, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL19_SSW_S2      (5)      //!< Bit position for CSU_CSL19_SSW_S2.
#define BM_CSU_CSL19_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL19_SSW_S2.

//! @brief Get value of CSU_CSL19_SSW_S2 from a register value.
#define BG_CSU_CSL19_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_SSW_S2) >> BP_CSU_CSL19_SSW_S2)

//! @brief Format value for bitfield CSU_CSL19_SSW_S2.
#define BF_CSU_CSL19_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_SSW_S2) & BM_CSU_CSL19_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL19_SSW_S2(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_SSW_S2) | BF_CSU_CSL19_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL19, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL19_NUW_S2      (6)      //!< Bit position for CSU_CSL19_NUW_S2.
#define BM_CSU_CSL19_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL19_NUW_S2.

//! @brief Get value of CSU_CSL19_NUW_S2 from a register value.
#define BG_CSU_CSL19_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_NUW_S2) >> BP_CSU_CSL19_NUW_S2)

//! @brief Format value for bitfield CSU_CSL19_NUW_S2.
#define BF_CSU_CSL19_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_NUW_S2) & BM_CSU_CSL19_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL19_NUW_S2(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_NUW_S2) | BF_CSU_CSL19_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL19, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL19_NSW_S2      (7)      //!< Bit position for CSU_CSL19_NSW_S2.
#define BM_CSU_CSL19_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL19_NSW_S2.

//! @brief Get value of CSU_CSL19_NSW_S2 from a register value.
#define BG_CSU_CSL19_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_NSW_S2) >> BP_CSU_CSL19_NSW_S2)

//! @brief Format value for bitfield CSU_CSL19_NSW_S2.
#define BF_CSU_CSL19_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_NSW_S2) & BM_CSU_CSL19_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL19_NSW_S2(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_NSW_S2) | BF_CSU_CSL19_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL19, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL19_LOCK_S2      (8)      //!< Bit position for CSU_CSL19_LOCK_S2.
#define BM_CSU_CSL19_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL19_LOCK_S2.

//! @brief Get value of CSU_CSL19_LOCK_S2 from a register value.
#define BG_CSU_CSL19_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_LOCK_S2) >> BP_CSU_CSL19_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL19_LOCK_S2.
#define BF_CSU_CSL19_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_LOCK_S2) & BM_CSU_CSL19_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL19_LOCK_S2(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_LOCK_S2) | BF_CSU_CSL19_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL19, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL19_SUR_S1      (16)      //!< Bit position for CSU_CSL19_SUR_S1.
#define BM_CSU_CSL19_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL19_SUR_S1.

//! @brief Get value of CSU_CSL19_SUR_S1 from a register value.
#define BG_CSU_CSL19_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_SUR_S1) >> BP_CSU_CSL19_SUR_S1)

//! @brief Format value for bitfield CSU_CSL19_SUR_S1.
#define BF_CSU_CSL19_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_SUR_S1) & BM_CSU_CSL19_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL19_SUR_S1(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_SUR_S1) | BF_CSU_CSL19_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL19, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL19_SSR_S1      (17)      //!< Bit position for CSU_CSL19_SSR_S1.
#define BM_CSU_CSL19_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL19_SSR_S1.

//! @brief Get value of CSU_CSL19_SSR_S1 from a register value.
#define BG_CSU_CSL19_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_SSR_S1) >> BP_CSU_CSL19_SSR_S1)

//! @brief Format value for bitfield CSU_CSL19_SSR_S1.
#define BF_CSU_CSL19_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_SSR_S1) & BM_CSU_CSL19_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL19_SSR_S1(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_SSR_S1) | BF_CSU_CSL19_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL19, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL19_NUR_S1      (18)      //!< Bit position for CSU_CSL19_NUR_S1.
#define BM_CSU_CSL19_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL19_NUR_S1.

//! @brief Get value of CSU_CSL19_NUR_S1 from a register value.
#define BG_CSU_CSL19_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_NUR_S1) >> BP_CSU_CSL19_NUR_S1)

//! @brief Format value for bitfield CSU_CSL19_NUR_S1.
#define BF_CSU_CSL19_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_NUR_S1) & BM_CSU_CSL19_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL19_NUR_S1(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_NUR_S1) | BF_CSU_CSL19_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL19, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL19_NSR_S1      (19)      //!< Bit position for CSU_CSL19_NSR_S1.
#define BM_CSU_CSL19_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL19_NSR_S1.

//! @brief Get value of CSU_CSL19_NSR_S1 from a register value.
#define BG_CSU_CSL19_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_NSR_S1) >> BP_CSU_CSL19_NSR_S1)

//! @brief Format value for bitfield CSU_CSL19_NSR_S1.
#define BF_CSU_CSL19_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_NSR_S1) & BM_CSU_CSL19_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL19_NSR_S1(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_NSR_S1) | BF_CSU_CSL19_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL19, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL19_SUW_S1      (20)      //!< Bit position for CSU_CSL19_SUW_S1.
#define BM_CSU_CSL19_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL19_SUW_S1.

//! @brief Get value of CSU_CSL19_SUW_S1 from a register value.
#define BG_CSU_CSL19_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_SUW_S1) >> BP_CSU_CSL19_SUW_S1)

//! @brief Format value for bitfield CSU_CSL19_SUW_S1.
#define BF_CSU_CSL19_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_SUW_S1) & BM_CSU_CSL19_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL19_SUW_S1(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_SUW_S1) | BF_CSU_CSL19_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL19, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL19_SSW_S1      (21)      //!< Bit position for CSU_CSL19_SSW_S1.
#define BM_CSU_CSL19_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL19_SSW_S1.

//! @brief Get value of CSU_CSL19_SSW_S1 from a register value.
#define BG_CSU_CSL19_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_SSW_S1) >> BP_CSU_CSL19_SSW_S1)

//! @brief Format value for bitfield CSU_CSL19_SSW_S1.
#define BF_CSU_CSL19_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_SSW_S1) & BM_CSU_CSL19_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL19_SSW_S1(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_SSW_S1) | BF_CSU_CSL19_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL19, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL19_NUW_S1      (22)      //!< Bit position for CSU_CSL19_NUW_S1.
#define BM_CSU_CSL19_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL19_NUW_S1.

//! @brief Get value of CSU_CSL19_NUW_S1 from a register value.
#define BG_CSU_CSL19_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_NUW_S1) >> BP_CSU_CSL19_NUW_S1)

//! @brief Format value for bitfield CSU_CSL19_NUW_S1.
#define BF_CSU_CSL19_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_NUW_S1) & BM_CSU_CSL19_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL19_NUW_S1(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_NUW_S1) | BF_CSU_CSL19_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL19, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL19_NSW_S1      (23)      //!< Bit position for CSU_CSL19_NSW_S1.
#define BM_CSU_CSL19_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL19_NSW_S1.

//! @brief Get value of CSU_CSL19_NSW_S1 from a register value.
#define BG_CSU_CSL19_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_NSW_S1) >> BP_CSU_CSL19_NSW_S1)

//! @brief Format value for bitfield CSU_CSL19_NSW_S1.
#define BF_CSU_CSL19_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_NSW_S1) & BM_CSU_CSL19_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL19_NSW_S1(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_NSW_S1) | BF_CSU_CSL19_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL19, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL19_LOCK_S1      (24)      //!< Bit position for CSU_CSL19_LOCK_S1.
#define BM_CSU_CSL19_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL19_LOCK_S1.

//! @brief Get value of CSU_CSL19_LOCK_S1 from a register value.
#define BG_CSU_CSL19_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL19_LOCK_S1) >> BP_CSU_CSL19_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL19_LOCK_S1.
#define BF_CSU_CSL19_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL19_LOCK_S1) & BM_CSU_CSL19_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL19_LOCK_S1(v)   (HW_CSU_CSL19_WR((HW_CSU_CSL19_RD() & ~BM_CSU_CSL19_LOCK_S1) | BF_CSU_CSL19_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL20 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL20 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl20
{
    reg32_t U;
    struct _hw_csu_csl20_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl20_t;
#endif

/*
 * constants & macros for entire CSU_CSL20 register
 */
#define HW_CSU_CSL20_ADDR      (REGS_CSU_BASE + 0x50)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL20           (*(volatile hw_csu_csl20_t *) HW_CSU_CSL20_ADDR)
#define HW_CSU_CSL20_RD()      (HW_CSU_CSL20.U)
#define HW_CSU_CSL20_WR(v)     (HW_CSU_CSL20.U = (v))
#define HW_CSU_CSL20_SET(v)    (HW_CSU_CSL20_WR(HW_CSU_CSL20_RD() |  (v)))
#define HW_CSU_CSL20_CLR(v)    (HW_CSU_CSL20_WR(HW_CSU_CSL20_RD() & ~(v)))
#define HW_CSU_CSL20_TOG(v)    (HW_CSU_CSL20_WR(HW_CSU_CSL20_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL20 bitfields
 */

/* --- Register HW_CSU_CSL20, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL20_SUR_S2      (0)      //!< Bit position for CSU_CSL20_SUR_S2.
#define BM_CSU_CSL20_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL20_SUR_S2.

//! @brief Get value of CSU_CSL20_SUR_S2 from a register value.
#define BG_CSU_CSL20_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_SUR_S2) >> BP_CSU_CSL20_SUR_S2)

//! @brief Format value for bitfield CSU_CSL20_SUR_S2.
#define BF_CSU_CSL20_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_SUR_S2) & BM_CSU_CSL20_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL20_SUR_S2(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_SUR_S2) | BF_CSU_CSL20_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL20, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL20_SSR_S2      (1)      //!< Bit position for CSU_CSL20_SSR_S2.
#define BM_CSU_CSL20_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL20_SSR_S2.

//! @brief Get value of CSU_CSL20_SSR_S2 from a register value.
#define BG_CSU_CSL20_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_SSR_S2) >> BP_CSU_CSL20_SSR_S2)

//! @brief Format value for bitfield CSU_CSL20_SSR_S2.
#define BF_CSU_CSL20_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_SSR_S2) & BM_CSU_CSL20_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL20_SSR_S2(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_SSR_S2) | BF_CSU_CSL20_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL20, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL20_NUR_S2      (2)      //!< Bit position for CSU_CSL20_NUR_S2.
#define BM_CSU_CSL20_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL20_NUR_S2.

//! @brief Get value of CSU_CSL20_NUR_S2 from a register value.
#define BG_CSU_CSL20_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_NUR_S2) >> BP_CSU_CSL20_NUR_S2)

//! @brief Format value for bitfield CSU_CSL20_NUR_S2.
#define BF_CSU_CSL20_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_NUR_S2) & BM_CSU_CSL20_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL20_NUR_S2(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_NUR_S2) | BF_CSU_CSL20_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL20, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL20_NSR_S2      (3)      //!< Bit position for CSU_CSL20_NSR_S2.
#define BM_CSU_CSL20_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL20_NSR_S2.

//! @brief Get value of CSU_CSL20_NSR_S2 from a register value.
#define BG_CSU_CSL20_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_NSR_S2) >> BP_CSU_CSL20_NSR_S2)

//! @brief Format value for bitfield CSU_CSL20_NSR_S2.
#define BF_CSU_CSL20_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_NSR_S2) & BM_CSU_CSL20_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL20_NSR_S2(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_NSR_S2) | BF_CSU_CSL20_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL20, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL20_SUW_S2      (4)      //!< Bit position for CSU_CSL20_SUW_S2.
#define BM_CSU_CSL20_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL20_SUW_S2.

//! @brief Get value of CSU_CSL20_SUW_S2 from a register value.
#define BG_CSU_CSL20_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_SUW_S2) >> BP_CSU_CSL20_SUW_S2)

//! @brief Format value for bitfield CSU_CSL20_SUW_S2.
#define BF_CSU_CSL20_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_SUW_S2) & BM_CSU_CSL20_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL20_SUW_S2(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_SUW_S2) | BF_CSU_CSL20_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL20, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL20_SSW_S2      (5)      //!< Bit position for CSU_CSL20_SSW_S2.
#define BM_CSU_CSL20_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL20_SSW_S2.

//! @brief Get value of CSU_CSL20_SSW_S2 from a register value.
#define BG_CSU_CSL20_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_SSW_S2) >> BP_CSU_CSL20_SSW_S2)

//! @brief Format value for bitfield CSU_CSL20_SSW_S2.
#define BF_CSU_CSL20_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_SSW_S2) & BM_CSU_CSL20_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL20_SSW_S2(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_SSW_S2) | BF_CSU_CSL20_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL20, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL20_NUW_S2      (6)      //!< Bit position for CSU_CSL20_NUW_S2.
#define BM_CSU_CSL20_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL20_NUW_S2.

//! @brief Get value of CSU_CSL20_NUW_S2 from a register value.
#define BG_CSU_CSL20_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_NUW_S2) >> BP_CSU_CSL20_NUW_S2)

//! @brief Format value for bitfield CSU_CSL20_NUW_S2.
#define BF_CSU_CSL20_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_NUW_S2) & BM_CSU_CSL20_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL20_NUW_S2(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_NUW_S2) | BF_CSU_CSL20_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL20, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL20_NSW_S2      (7)      //!< Bit position for CSU_CSL20_NSW_S2.
#define BM_CSU_CSL20_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL20_NSW_S2.

//! @brief Get value of CSU_CSL20_NSW_S2 from a register value.
#define BG_CSU_CSL20_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_NSW_S2) >> BP_CSU_CSL20_NSW_S2)

//! @brief Format value for bitfield CSU_CSL20_NSW_S2.
#define BF_CSU_CSL20_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_NSW_S2) & BM_CSU_CSL20_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL20_NSW_S2(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_NSW_S2) | BF_CSU_CSL20_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL20, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL20_LOCK_S2      (8)      //!< Bit position for CSU_CSL20_LOCK_S2.
#define BM_CSU_CSL20_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL20_LOCK_S2.

//! @brief Get value of CSU_CSL20_LOCK_S2 from a register value.
#define BG_CSU_CSL20_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_LOCK_S2) >> BP_CSU_CSL20_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL20_LOCK_S2.
#define BF_CSU_CSL20_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_LOCK_S2) & BM_CSU_CSL20_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL20_LOCK_S2(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_LOCK_S2) | BF_CSU_CSL20_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL20, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL20_SUR_S1      (16)      //!< Bit position for CSU_CSL20_SUR_S1.
#define BM_CSU_CSL20_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL20_SUR_S1.

//! @brief Get value of CSU_CSL20_SUR_S1 from a register value.
#define BG_CSU_CSL20_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_SUR_S1) >> BP_CSU_CSL20_SUR_S1)

//! @brief Format value for bitfield CSU_CSL20_SUR_S1.
#define BF_CSU_CSL20_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_SUR_S1) & BM_CSU_CSL20_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL20_SUR_S1(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_SUR_S1) | BF_CSU_CSL20_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL20, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL20_SSR_S1      (17)      //!< Bit position for CSU_CSL20_SSR_S1.
#define BM_CSU_CSL20_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL20_SSR_S1.

//! @brief Get value of CSU_CSL20_SSR_S1 from a register value.
#define BG_CSU_CSL20_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_SSR_S1) >> BP_CSU_CSL20_SSR_S1)

//! @brief Format value for bitfield CSU_CSL20_SSR_S1.
#define BF_CSU_CSL20_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_SSR_S1) & BM_CSU_CSL20_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL20_SSR_S1(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_SSR_S1) | BF_CSU_CSL20_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL20, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL20_NUR_S1      (18)      //!< Bit position for CSU_CSL20_NUR_S1.
#define BM_CSU_CSL20_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL20_NUR_S1.

//! @brief Get value of CSU_CSL20_NUR_S1 from a register value.
#define BG_CSU_CSL20_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_NUR_S1) >> BP_CSU_CSL20_NUR_S1)

//! @brief Format value for bitfield CSU_CSL20_NUR_S1.
#define BF_CSU_CSL20_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_NUR_S1) & BM_CSU_CSL20_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL20_NUR_S1(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_NUR_S1) | BF_CSU_CSL20_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL20, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL20_NSR_S1      (19)      //!< Bit position for CSU_CSL20_NSR_S1.
#define BM_CSU_CSL20_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL20_NSR_S1.

//! @brief Get value of CSU_CSL20_NSR_S1 from a register value.
#define BG_CSU_CSL20_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_NSR_S1) >> BP_CSU_CSL20_NSR_S1)

//! @brief Format value for bitfield CSU_CSL20_NSR_S1.
#define BF_CSU_CSL20_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_NSR_S1) & BM_CSU_CSL20_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL20_NSR_S1(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_NSR_S1) | BF_CSU_CSL20_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL20, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL20_SUW_S1      (20)      //!< Bit position for CSU_CSL20_SUW_S1.
#define BM_CSU_CSL20_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL20_SUW_S1.

//! @brief Get value of CSU_CSL20_SUW_S1 from a register value.
#define BG_CSU_CSL20_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_SUW_S1) >> BP_CSU_CSL20_SUW_S1)

//! @brief Format value for bitfield CSU_CSL20_SUW_S1.
#define BF_CSU_CSL20_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_SUW_S1) & BM_CSU_CSL20_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL20_SUW_S1(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_SUW_S1) | BF_CSU_CSL20_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL20, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL20_SSW_S1      (21)      //!< Bit position for CSU_CSL20_SSW_S1.
#define BM_CSU_CSL20_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL20_SSW_S1.

//! @brief Get value of CSU_CSL20_SSW_S1 from a register value.
#define BG_CSU_CSL20_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_SSW_S1) >> BP_CSU_CSL20_SSW_S1)

//! @brief Format value for bitfield CSU_CSL20_SSW_S1.
#define BF_CSU_CSL20_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_SSW_S1) & BM_CSU_CSL20_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL20_SSW_S1(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_SSW_S1) | BF_CSU_CSL20_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL20, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL20_NUW_S1      (22)      //!< Bit position for CSU_CSL20_NUW_S1.
#define BM_CSU_CSL20_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL20_NUW_S1.

//! @brief Get value of CSU_CSL20_NUW_S1 from a register value.
#define BG_CSU_CSL20_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_NUW_S1) >> BP_CSU_CSL20_NUW_S1)

//! @brief Format value for bitfield CSU_CSL20_NUW_S1.
#define BF_CSU_CSL20_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_NUW_S1) & BM_CSU_CSL20_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL20_NUW_S1(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_NUW_S1) | BF_CSU_CSL20_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL20, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL20_NSW_S1      (23)      //!< Bit position for CSU_CSL20_NSW_S1.
#define BM_CSU_CSL20_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL20_NSW_S1.

//! @brief Get value of CSU_CSL20_NSW_S1 from a register value.
#define BG_CSU_CSL20_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_NSW_S1) >> BP_CSU_CSL20_NSW_S1)

//! @brief Format value for bitfield CSU_CSL20_NSW_S1.
#define BF_CSU_CSL20_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_NSW_S1) & BM_CSU_CSL20_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL20_NSW_S1(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_NSW_S1) | BF_CSU_CSL20_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL20, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL20_LOCK_S1      (24)      //!< Bit position for CSU_CSL20_LOCK_S1.
#define BM_CSU_CSL20_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL20_LOCK_S1.

//! @brief Get value of CSU_CSL20_LOCK_S1 from a register value.
#define BG_CSU_CSL20_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL20_LOCK_S1) >> BP_CSU_CSL20_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL20_LOCK_S1.
#define BF_CSU_CSL20_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL20_LOCK_S1) & BM_CSU_CSL20_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL20_LOCK_S1(v)   (HW_CSU_CSL20_WR((HW_CSU_CSL20_RD() & ~BM_CSU_CSL20_LOCK_S1) | BF_CSU_CSL20_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL21 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL21 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl21
{
    reg32_t U;
    struct _hw_csu_csl21_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl21_t;
#endif

/*
 * constants & macros for entire CSU_CSL21 register
 */
#define HW_CSU_CSL21_ADDR      (REGS_CSU_BASE + 0x54)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL21           (*(volatile hw_csu_csl21_t *) HW_CSU_CSL21_ADDR)
#define HW_CSU_CSL21_RD()      (HW_CSU_CSL21.U)
#define HW_CSU_CSL21_WR(v)     (HW_CSU_CSL21.U = (v))
#define HW_CSU_CSL21_SET(v)    (HW_CSU_CSL21_WR(HW_CSU_CSL21_RD() |  (v)))
#define HW_CSU_CSL21_CLR(v)    (HW_CSU_CSL21_WR(HW_CSU_CSL21_RD() & ~(v)))
#define HW_CSU_CSL21_TOG(v)    (HW_CSU_CSL21_WR(HW_CSU_CSL21_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL21 bitfields
 */

/* --- Register HW_CSU_CSL21, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL21_SUR_S2      (0)      //!< Bit position for CSU_CSL21_SUR_S2.
#define BM_CSU_CSL21_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL21_SUR_S2.

//! @brief Get value of CSU_CSL21_SUR_S2 from a register value.
#define BG_CSU_CSL21_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_SUR_S2) >> BP_CSU_CSL21_SUR_S2)

//! @brief Format value for bitfield CSU_CSL21_SUR_S2.
#define BF_CSU_CSL21_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_SUR_S2) & BM_CSU_CSL21_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL21_SUR_S2(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_SUR_S2) | BF_CSU_CSL21_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL21, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL21_SSR_S2      (1)      //!< Bit position for CSU_CSL21_SSR_S2.
#define BM_CSU_CSL21_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL21_SSR_S2.

//! @brief Get value of CSU_CSL21_SSR_S2 from a register value.
#define BG_CSU_CSL21_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_SSR_S2) >> BP_CSU_CSL21_SSR_S2)

//! @brief Format value for bitfield CSU_CSL21_SSR_S2.
#define BF_CSU_CSL21_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_SSR_S2) & BM_CSU_CSL21_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL21_SSR_S2(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_SSR_S2) | BF_CSU_CSL21_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL21, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL21_NUR_S2      (2)      //!< Bit position for CSU_CSL21_NUR_S2.
#define BM_CSU_CSL21_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL21_NUR_S2.

//! @brief Get value of CSU_CSL21_NUR_S2 from a register value.
#define BG_CSU_CSL21_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_NUR_S2) >> BP_CSU_CSL21_NUR_S2)

//! @brief Format value for bitfield CSU_CSL21_NUR_S2.
#define BF_CSU_CSL21_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_NUR_S2) & BM_CSU_CSL21_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL21_NUR_S2(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_NUR_S2) | BF_CSU_CSL21_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL21, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL21_NSR_S2      (3)      //!< Bit position for CSU_CSL21_NSR_S2.
#define BM_CSU_CSL21_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL21_NSR_S2.

//! @brief Get value of CSU_CSL21_NSR_S2 from a register value.
#define BG_CSU_CSL21_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_NSR_S2) >> BP_CSU_CSL21_NSR_S2)

//! @brief Format value for bitfield CSU_CSL21_NSR_S2.
#define BF_CSU_CSL21_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_NSR_S2) & BM_CSU_CSL21_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL21_NSR_S2(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_NSR_S2) | BF_CSU_CSL21_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL21, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL21_SUW_S2      (4)      //!< Bit position for CSU_CSL21_SUW_S2.
#define BM_CSU_CSL21_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL21_SUW_S2.

//! @brief Get value of CSU_CSL21_SUW_S2 from a register value.
#define BG_CSU_CSL21_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_SUW_S2) >> BP_CSU_CSL21_SUW_S2)

//! @brief Format value for bitfield CSU_CSL21_SUW_S2.
#define BF_CSU_CSL21_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_SUW_S2) & BM_CSU_CSL21_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL21_SUW_S2(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_SUW_S2) | BF_CSU_CSL21_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL21, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL21_SSW_S2      (5)      //!< Bit position for CSU_CSL21_SSW_S2.
#define BM_CSU_CSL21_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL21_SSW_S2.

//! @brief Get value of CSU_CSL21_SSW_S2 from a register value.
#define BG_CSU_CSL21_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_SSW_S2) >> BP_CSU_CSL21_SSW_S2)

//! @brief Format value for bitfield CSU_CSL21_SSW_S2.
#define BF_CSU_CSL21_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_SSW_S2) & BM_CSU_CSL21_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL21_SSW_S2(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_SSW_S2) | BF_CSU_CSL21_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL21, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL21_NUW_S2      (6)      //!< Bit position for CSU_CSL21_NUW_S2.
#define BM_CSU_CSL21_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL21_NUW_S2.

//! @brief Get value of CSU_CSL21_NUW_S2 from a register value.
#define BG_CSU_CSL21_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_NUW_S2) >> BP_CSU_CSL21_NUW_S2)

//! @brief Format value for bitfield CSU_CSL21_NUW_S2.
#define BF_CSU_CSL21_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_NUW_S2) & BM_CSU_CSL21_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL21_NUW_S2(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_NUW_S2) | BF_CSU_CSL21_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL21, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL21_NSW_S2      (7)      //!< Bit position for CSU_CSL21_NSW_S2.
#define BM_CSU_CSL21_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL21_NSW_S2.

//! @brief Get value of CSU_CSL21_NSW_S2 from a register value.
#define BG_CSU_CSL21_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_NSW_S2) >> BP_CSU_CSL21_NSW_S2)

//! @brief Format value for bitfield CSU_CSL21_NSW_S2.
#define BF_CSU_CSL21_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_NSW_S2) & BM_CSU_CSL21_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL21_NSW_S2(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_NSW_S2) | BF_CSU_CSL21_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL21, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL21_LOCK_S2      (8)      //!< Bit position for CSU_CSL21_LOCK_S2.
#define BM_CSU_CSL21_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL21_LOCK_S2.

//! @brief Get value of CSU_CSL21_LOCK_S2 from a register value.
#define BG_CSU_CSL21_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_LOCK_S2) >> BP_CSU_CSL21_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL21_LOCK_S2.
#define BF_CSU_CSL21_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_LOCK_S2) & BM_CSU_CSL21_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL21_LOCK_S2(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_LOCK_S2) | BF_CSU_CSL21_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL21, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL21_SUR_S1      (16)      //!< Bit position for CSU_CSL21_SUR_S1.
#define BM_CSU_CSL21_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL21_SUR_S1.

//! @brief Get value of CSU_CSL21_SUR_S1 from a register value.
#define BG_CSU_CSL21_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_SUR_S1) >> BP_CSU_CSL21_SUR_S1)

//! @brief Format value for bitfield CSU_CSL21_SUR_S1.
#define BF_CSU_CSL21_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_SUR_S1) & BM_CSU_CSL21_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL21_SUR_S1(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_SUR_S1) | BF_CSU_CSL21_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL21, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL21_SSR_S1      (17)      //!< Bit position for CSU_CSL21_SSR_S1.
#define BM_CSU_CSL21_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL21_SSR_S1.

//! @brief Get value of CSU_CSL21_SSR_S1 from a register value.
#define BG_CSU_CSL21_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_SSR_S1) >> BP_CSU_CSL21_SSR_S1)

//! @brief Format value for bitfield CSU_CSL21_SSR_S1.
#define BF_CSU_CSL21_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_SSR_S1) & BM_CSU_CSL21_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL21_SSR_S1(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_SSR_S1) | BF_CSU_CSL21_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL21, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL21_NUR_S1      (18)      //!< Bit position for CSU_CSL21_NUR_S1.
#define BM_CSU_CSL21_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL21_NUR_S1.

//! @brief Get value of CSU_CSL21_NUR_S1 from a register value.
#define BG_CSU_CSL21_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_NUR_S1) >> BP_CSU_CSL21_NUR_S1)

//! @brief Format value for bitfield CSU_CSL21_NUR_S1.
#define BF_CSU_CSL21_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_NUR_S1) & BM_CSU_CSL21_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL21_NUR_S1(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_NUR_S1) | BF_CSU_CSL21_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL21, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL21_NSR_S1      (19)      //!< Bit position for CSU_CSL21_NSR_S1.
#define BM_CSU_CSL21_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL21_NSR_S1.

//! @brief Get value of CSU_CSL21_NSR_S1 from a register value.
#define BG_CSU_CSL21_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_NSR_S1) >> BP_CSU_CSL21_NSR_S1)

//! @brief Format value for bitfield CSU_CSL21_NSR_S1.
#define BF_CSU_CSL21_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_NSR_S1) & BM_CSU_CSL21_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL21_NSR_S1(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_NSR_S1) | BF_CSU_CSL21_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL21, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL21_SUW_S1      (20)      //!< Bit position for CSU_CSL21_SUW_S1.
#define BM_CSU_CSL21_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL21_SUW_S1.

//! @brief Get value of CSU_CSL21_SUW_S1 from a register value.
#define BG_CSU_CSL21_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_SUW_S1) >> BP_CSU_CSL21_SUW_S1)

//! @brief Format value for bitfield CSU_CSL21_SUW_S1.
#define BF_CSU_CSL21_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_SUW_S1) & BM_CSU_CSL21_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL21_SUW_S1(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_SUW_S1) | BF_CSU_CSL21_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL21, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL21_SSW_S1      (21)      //!< Bit position for CSU_CSL21_SSW_S1.
#define BM_CSU_CSL21_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL21_SSW_S1.

//! @brief Get value of CSU_CSL21_SSW_S1 from a register value.
#define BG_CSU_CSL21_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_SSW_S1) >> BP_CSU_CSL21_SSW_S1)

//! @brief Format value for bitfield CSU_CSL21_SSW_S1.
#define BF_CSU_CSL21_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_SSW_S1) & BM_CSU_CSL21_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL21_SSW_S1(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_SSW_S1) | BF_CSU_CSL21_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL21, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL21_NUW_S1      (22)      //!< Bit position for CSU_CSL21_NUW_S1.
#define BM_CSU_CSL21_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL21_NUW_S1.

//! @brief Get value of CSU_CSL21_NUW_S1 from a register value.
#define BG_CSU_CSL21_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_NUW_S1) >> BP_CSU_CSL21_NUW_S1)

//! @brief Format value for bitfield CSU_CSL21_NUW_S1.
#define BF_CSU_CSL21_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_NUW_S1) & BM_CSU_CSL21_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL21_NUW_S1(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_NUW_S1) | BF_CSU_CSL21_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL21, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL21_NSW_S1      (23)      //!< Bit position for CSU_CSL21_NSW_S1.
#define BM_CSU_CSL21_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL21_NSW_S1.

//! @brief Get value of CSU_CSL21_NSW_S1 from a register value.
#define BG_CSU_CSL21_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_NSW_S1) >> BP_CSU_CSL21_NSW_S1)

//! @brief Format value for bitfield CSU_CSL21_NSW_S1.
#define BF_CSU_CSL21_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_NSW_S1) & BM_CSU_CSL21_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL21_NSW_S1(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_NSW_S1) | BF_CSU_CSL21_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL21, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL21_LOCK_S1      (24)      //!< Bit position for CSU_CSL21_LOCK_S1.
#define BM_CSU_CSL21_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL21_LOCK_S1.

//! @brief Get value of CSU_CSL21_LOCK_S1 from a register value.
#define BG_CSU_CSL21_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL21_LOCK_S1) >> BP_CSU_CSL21_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL21_LOCK_S1.
#define BF_CSU_CSL21_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL21_LOCK_S1) & BM_CSU_CSL21_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL21_LOCK_S1(v)   (HW_CSU_CSL21_WR((HW_CSU_CSL21_RD() & ~BM_CSU_CSL21_LOCK_S1) | BF_CSU_CSL21_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL22 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL22 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl22
{
    reg32_t U;
    struct _hw_csu_csl22_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl22_t;
#endif

/*
 * constants & macros for entire CSU_CSL22 register
 */
#define HW_CSU_CSL22_ADDR      (REGS_CSU_BASE + 0x58)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL22           (*(volatile hw_csu_csl22_t *) HW_CSU_CSL22_ADDR)
#define HW_CSU_CSL22_RD()      (HW_CSU_CSL22.U)
#define HW_CSU_CSL22_WR(v)     (HW_CSU_CSL22.U = (v))
#define HW_CSU_CSL22_SET(v)    (HW_CSU_CSL22_WR(HW_CSU_CSL22_RD() |  (v)))
#define HW_CSU_CSL22_CLR(v)    (HW_CSU_CSL22_WR(HW_CSU_CSL22_RD() & ~(v)))
#define HW_CSU_CSL22_TOG(v)    (HW_CSU_CSL22_WR(HW_CSU_CSL22_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL22 bitfields
 */

/* --- Register HW_CSU_CSL22, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL22_SUR_S2      (0)      //!< Bit position for CSU_CSL22_SUR_S2.
#define BM_CSU_CSL22_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL22_SUR_S2.

//! @brief Get value of CSU_CSL22_SUR_S2 from a register value.
#define BG_CSU_CSL22_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_SUR_S2) >> BP_CSU_CSL22_SUR_S2)

//! @brief Format value for bitfield CSU_CSL22_SUR_S2.
#define BF_CSU_CSL22_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_SUR_S2) & BM_CSU_CSL22_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL22_SUR_S2(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_SUR_S2) | BF_CSU_CSL22_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL22, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL22_SSR_S2      (1)      //!< Bit position for CSU_CSL22_SSR_S2.
#define BM_CSU_CSL22_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL22_SSR_S2.

//! @brief Get value of CSU_CSL22_SSR_S2 from a register value.
#define BG_CSU_CSL22_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_SSR_S2) >> BP_CSU_CSL22_SSR_S2)

//! @brief Format value for bitfield CSU_CSL22_SSR_S2.
#define BF_CSU_CSL22_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_SSR_S2) & BM_CSU_CSL22_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL22_SSR_S2(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_SSR_S2) | BF_CSU_CSL22_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL22, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL22_NUR_S2      (2)      //!< Bit position for CSU_CSL22_NUR_S2.
#define BM_CSU_CSL22_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL22_NUR_S2.

//! @brief Get value of CSU_CSL22_NUR_S2 from a register value.
#define BG_CSU_CSL22_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_NUR_S2) >> BP_CSU_CSL22_NUR_S2)

//! @brief Format value for bitfield CSU_CSL22_NUR_S2.
#define BF_CSU_CSL22_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_NUR_S2) & BM_CSU_CSL22_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL22_NUR_S2(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_NUR_S2) | BF_CSU_CSL22_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL22, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL22_NSR_S2      (3)      //!< Bit position for CSU_CSL22_NSR_S2.
#define BM_CSU_CSL22_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL22_NSR_S2.

//! @brief Get value of CSU_CSL22_NSR_S2 from a register value.
#define BG_CSU_CSL22_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_NSR_S2) >> BP_CSU_CSL22_NSR_S2)

//! @brief Format value for bitfield CSU_CSL22_NSR_S2.
#define BF_CSU_CSL22_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_NSR_S2) & BM_CSU_CSL22_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL22_NSR_S2(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_NSR_S2) | BF_CSU_CSL22_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL22, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL22_SUW_S2      (4)      //!< Bit position for CSU_CSL22_SUW_S2.
#define BM_CSU_CSL22_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL22_SUW_S2.

//! @brief Get value of CSU_CSL22_SUW_S2 from a register value.
#define BG_CSU_CSL22_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_SUW_S2) >> BP_CSU_CSL22_SUW_S2)

//! @brief Format value for bitfield CSU_CSL22_SUW_S2.
#define BF_CSU_CSL22_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_SUW_S2) & BM_CSU_CSL22_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL22_SUW_S2(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_SUW_S2) | BF_CSU_CSL22_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL22, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL22_SSW_S2      (5)      //!< Bit position for CSU_CSL22_SSW_S2.
#define BM_CSU_CSL22_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL22_SSW_S2.

//! @brief Get value of CSU_CSL22_SSW_S2 from a register value.
#define BG_CSU_CSL22_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_SSW_S2) >> BP_CSU_CSL22_SSW_S2)

//! @brief Format value for bitfield CSU_CSL22_SSW_S2.
#define BF_CSU_CSL22_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_SSW_S2) & BM_CSU_CSL22_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL22_SSW_S2(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_SSW_S2) | BF_CSU_CSL22_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL22, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL22_NUW_S2      (6)      //!< Bit position for CSU_CSL22_NUW_S2.
#define BM_CSU_CSL22_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL22_NUW_S2.

//! @brief Get value of CSU_CSL22_NUW_S2 from a register value.
#define BG_CSU_CSL22_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_NUW_S2) >> BP_CSU_CSL22_NUW_S2)

//! @brief Format value for bitfield CSU_CSL22_NUW_S2.
#define BF_CSU_CSL22_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_NUW_S2) & BM_CSU_CSL22_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL22_NUW_S2(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_NUW_S2) | BF_CSU_CSL22_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL22, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL22_NSW_S2      (7)      //!< Bit position for CSU_CSL22_NSW_S2.
#define BM_CSU_CSL22_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL22_NSW_S2.

//! @brief Get value of CSU_CSL22_NSW_S2 from a register value.
#define BG_CSU_CSL22_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_NSW_S2) >> BP_CSU_CSL22_NSW_S2)

//! @brief Format value for bitfield CSU_CSL22_NSW_S2.
#define BF_CSU_CSL22_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_NSW_S2) & BM_CSU_CSL22_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL22_NSW_S2(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_NSW_S2) | BF_CSU_CSL22_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL22, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL22_LOCK_S2      (8)      //!< Bit position for CSU_CSL22_LOCK_S2.
#define BM_CSU_CSL22_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL22_LOCK_S2.

//! @brief Get value of CSU_CSL22_LOCK_S2 from a register value.
#define BG_CSU_CSL22_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_LOCK_S2) >> BP_CSU_CSL22_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL22_LOCK_S2.
#define BF_CSU_CSL22_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_LOCK_S2) & BM_CSU_CSL22_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL22_LOCK_S2(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_LOCK_S2) | BF_CSU_CSL22_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL22, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL22_SUR_S1      (16)      //!< Bit position for CSU_CSL22_SUR_S1.
#define BM_CSU_CSL22_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL22_SUR_S1.

//! @brief Get value of CSU_CSL22_SUR_S1 from a register value.
#define BG_CSU_CSL22_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_SUR_S1) >> BP_CSU_CSL22_SUR_S1)

//! @brief Format value for bitfield CSU_CSL22_SUR_S1.
#define BF_CSU_CSL22_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_SUR_S1) & BM_CSU_CSL22_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL22_SUR_S1(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_SUR_S1) | BF_CSU_CSL22_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL22, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL22_SSR_S1      (17)      //!< Bit position for CSU_CSL22_SSR_S1.
#define BM_CSU_CSL22_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL22_SSR_S1.

//! @brief Get value of CSU_CSL22_SSR_S1 from a register value.
#define BG_CSU_CSL22_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_SSR_S1) >> BP_CSU_CSL22_SSR_S1)

//! @brief Format value for bitfield CSU_CSL22_SSR_S1.
#define BF_CSU_CSL22_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_SSR_S1) & BM_CSU_CSL22_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL22_SSR_S1(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_SSR_S1) | BF_CSU_CSL22_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL22, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL22_NUR_S1      (18)      //!< Bit position for CSU_CSL22_NUR_S1.
#define BM_CSU_CSL22_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL22_NUR_S1.

//! @brief Get value of CSU_CSL22_NUR_S1 from a register value.
#define BG_CSU_CSL22_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_NUR_S1) >> BP_CSU_CSL22_NUR_S1)

//! @brief Format value for bitfield CSU_CSL22_NUR_S1.
#define BF_CSU_CSL22_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_NUR_S1) & BM_CSU_CSL22_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL22_NUR_S1(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_NUR_S1) | BF_CSU_CSL22_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL22, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL22_NSR_S1      (19)      //!< Bit position for CSU_CSL22_NSR_S1.
#define BM_CSU_CSL22_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL22_NSR_S1.

//! @brief Get value of CSU_CSL22_NSR_S1 from a register value.
#define BG_CSU_CSL22_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_NSR_S1) >> BP_CSU_CSL22_NSR_S1)

//! @brief Format value for bitfield CSU_CSL22_NSR_S1.
#define BF_CSU_CSL22_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_NSR_S1) & BM_CSU_CSL22_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL22_NSR_S1(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_NSR_S1) | BF_CSU_CSL22_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL22, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL22_SUW_S1      (20)      //!< Bit position for CSU_CSL22_SUW_S1.
#define BM_CSU_CSL22_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL22_SUW_S1.

//! @brief Get value of CSU_CSL22_SUW_S1 from a register value.
#define BG_CSU_CSL22_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_SUW_S1) >> BP_CSU_CSL22_SUW_S1)

//! @brief Format value for bitfield CSU_CSL22_SUW_S1.
#define BF_CSU_CSL22_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_SUW_S1) & BM_CSU_CSL22_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL22_SUW_S1(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_SUW_S1) | BF_CSU_CSL22_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL22, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL22_SSW_S1      (21)      //!< Bit position for CSU_CSL22_SSW_S1.
#define BM_CSU_CSL22_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL22_SSW_S1.

//! @brief Get value of CSU_CSL22_SSW_S1 from a register value.
#define BG_CSU_CSL22_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_SSW_S1) >> BP_CSU_CSL22_SSW_S1)

//! @brief Format value for bitfield CSU_CSL22_SSW_S1.
#define BF_CSU_CSL22_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_SSW_S1) & BM_CSU_CSL22_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL22_SSW_S1(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_SSW_S1) | BF_CSU_CSL22_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL22, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL22_NUW_S1      (22)      //!< Bit position for CSU_CSL22_NUW_S1.
#define BM_CSU_CSL22_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL22_NUW_S1.

//! @brief Get value of CSU_CSL22_NUW_S1 from a register value.
#define BG_CSU_CSL22_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_NUW_S1) >> BP_CSU_CSL22_NUW_S1)

//! @brief Format value for bitfield CSU_CSL22_NUW_S1.
#define BF_CSU_CSL22_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_NUW_S1) & BM_CSU_CSL22_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL22_NUW_S1(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_NUW_S1) | BF_CSU_CSL22_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL22, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL22_NSW_S1      (23)      //!< Bit position for CSU_CSL22_NSW_S1.
#define BM_CSU_CSL22_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL22_NSW_S1.

//! @brief Get value of CSU_CSL22_NSW_S1 from a register value.
#define BG_CSU_CSL22_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_NSW_S1) >> BP_CSU_CSL22_NSW_S1)

//! @brief Format value for bitfield CSU_CSL22_NSW_S1.
#define BF_CSU_CSL22_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_NSW_S1) & BM_CSU_CSL22_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL22_NSW_S1(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_NSW_S1) | BF_CSU_CSL22_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL22, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL22_LOCK_S1      (24)      //!< Bit position for CSU_CSL22_LOCK_S1.
#define BM_CSU_CSL22_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL22_LOCK_S1.

//! @brief Get value of CSU_CSL22_LOCK_S1 from a register value.
#define BG_CSU_CSL22_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL22_LOCK_S1) >> BP_CSU_CSL22_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL22_LOCK_S1.
#define BF_CSU_CSL22_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL22_LOCK_S1) & BM_CSU_CSL22_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL22_LOCK_S1(v)   (HW_CSU_CSL22_WR((HW_CSU_CSL22_RD() & ~BM_CSU_CSL22_LOCK_S1) | BF_CSU_CSL22_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL23 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL23 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl23
{
    reg32_t U;
    struct _hw_csu_csl23_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl23_t;
#endif

/*
 * constants & macros for entire CSU_CSL23 register
 */
#define HW_CSU_CSL23_ADDR      (REGS_CSU_BASE + 0x5c)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL23           (*(volatile hw_csu_csl23_t *) HW_CSU_CSL23_ADDR)
#define HW_CSU_CSL23_RD()      (HW_CSU_CSL23.U)
#define HW_CSU_CSL23_WR(v)     (HW_CSU_CSL23.U = (v))
#define HW_CSU_CSL23_SET(v)    (HW_CSU_CSL23_WR(HW_CSU_CSL23_RD() |  (v)))
#define HW_CSU_CSL23_CLR(v)    (HW_CSU_CSL23_WR(HW_CSU_CSL23_RD() & ~(v)))
#define HW_CSU_CSL23_TOG(v)    (HW_CSU_CSL23_WR(HW_CSU_CSL23_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL23 bitfields
 */

/* --- Register HW_CSU_CSL23, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL23_SUR_S2      (0)      //!< Bit position for CSU_CSL23_SUR_S2.
#define BM_CSU_CSL23_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL23_SUR_S2.

//! @brief Get value of CSU_CSL23_SUR_S2 from a register value.
#define BG_CSU_CSL23_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_SUR_S2) >> BP_CSU_CSL23_SUR_S2)

//! @brief Format value for bitfield CSU_CSL23_SUR_S2.
#define BF_CSU_CSL23_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_SUR_S2) & BM_CSU_CSL23_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL23_SUR_S2(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_SUR_S2) | BF_CSU_CSL23_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL23, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL23_SSR_S2      (1)      //!< Bit position for CSU_CSL23_SSR_S2.
#define BM_CSU_CSL23_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL23_SSR_S2.

//! @brief Get value of CSU_CSL23_SSR_S2 from a register value.
#define BG_CSU_CSL23_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_SSR_S2) >> BP_CSU_CSL23_SSR_S2)

//! @brief Format value for bitfield CSU_CSL23_SSR_S2.
#define BF_CSU_CSL23_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_SSR_S2) & BM_CSU_CSL23_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL23_SSR_S2(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_SSR_S2) | BF_CSU_CSL23_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL23, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL23_NUR_S2      (2)      //!< Bit position for CSU_CSL23_NUR_S2.
#define BM_CSU_CSL23_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL23_NUR_S2.

//! @brief Get value of CSU_CSL23_NUR_S2 from a register value.
#define BG_CSU_CSL23_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_NUR_S2) >> BP_CSU_CSL23_NUR_S2)

//! @brief Format value for bitfield CSU_CSL23_NUR_S2.
#define BF_CSU_CSL23_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_NUR_S2) & BM_CSU_CSL23_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL23_NUR_S2(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_NUR_S2) | BF_CSU_CSL23_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL23, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL23_NSR_S2      (3)      //!< Bit position for CSU_CSL23_NSR_S2.
#define BM_CSU_CSL23_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL23_NSR_S2.

//! @brief Get value of CSU_CSL23_NSR_S2 from a register value.
#define BG_CSU_CSL23_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_NSR_S2) >> BP_CSU_CSL23_NSR_S2)

//! @brief Format value for bitfield CSU_CSL23_NSR_S2.
#define BF_CSU_CSL23_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_NSR_S2) & BM_CSU_CSL23_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL23_NSR_S2(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_NSR_S2) | BF_CSU_CSL23_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL23, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL23_SUW_S2      (4)      //!< Bit position for CSU_CSL23_SUW_S2.
#define BM_CSU_CSL23_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL23_SUW_S2.

//! @brief Get value of CSU_CSL23_SUW_S2 from a register value.
#define BG_CSU_CSL23_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_SUW_S2) >> BP_CSU_CSL23_SUW_S2)

//! @brief Format value for bitfield CSU_CSL23_SUW_S2.
#define BF_CSU_CSL23_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_SUW_S2) & BM_CSU_CSL23_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL23_SUW_S2(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_SUW_S2) | BF_CSU_CSL23_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL23, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL23_SSW_S2      (5)      //!< Bit position for CSU_CSL23_SSW_S2.
#define BM_CSU_CSL23_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL23_SSW_S2.

//! @brief Get value of CSU_CSL23_SSW_S2 from a register value.
#define BG_CSU_CSL23_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_SSW_S2) >> BP_CSU_CSL23_SSW_S2)

//! @brief Format value for bitfield CSU_CSL23_SSW_S2.
#define BF_CSU_CSL23_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_SSW_S2) & BM_CSU_CSL23_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL23_SSW_S2(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_SSW_S2) | BF_CSU_CSL23_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL23, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL23_NUW_S2      (6)      //!< Bit position for CSU_CSL23_NUW_S2.
#define BM_CSU_CSL23_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL23_NUW_S2.

//! @brief Get value of CSU_CSL23_NUW_S2 from a register value.
#define BG_CSU_CSL23_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_NUW_S2) >> BP_CSU_CSL23_NUW_S2)

//! @brief Format value for bitfield CSU_CSL23_NUW_S2.
#define BF_CSU_CSL23_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_NUW_S2) & BM_CSU_CSL23_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL23_NUW_S2(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_NUW_S2) | BF_CSU_CSL23_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL23, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL23_NSW_S2      (7)      //!< Bit position for CSU_CSL23_NSW_S2.
#define BM_CSU_CSL23_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL23_NSW_S2.

//! @brief Get value of CSU_CSL23_NSW_S2 from a register value.
#define BG_CSU_CSL23_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_NSW_S2) >> BP_CSU_CSL23_NSW_S2)

//! @brief Format value for bitfield CSU_CSL23_NSW_S2.
#define BF_CSU_CSL23_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_NSW_S2) & BM_CSU_CSL23_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL23_NSW_S2(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_NSW_S2) | BF_CSU_CSL23_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL23, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL23_LOCK_S2      (8)      //!< Bit position for CSU_CSL23_LOCK_S2.
#define BM_CSU_CSL23_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL23_LOCK_S2.

//! @brief Get value of CSU_CSL23_LOCK_S2 from a register value.
#define BG_CSU_CSL23_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_LOCK_S2) >> BP_CSU_CSL23_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL23_LOCK_S2.
#define BF_CSU_CSL23_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_LOCK_S2) & BM_CSU_CSL23_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL23_LOCK_S2(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_LOCK_S2) | BF_CSU_CSL23_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL23, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL23_SUR_S1      (16)      //!< Bit position for CSU_CSL23_SUR_S1.
#define BM_CSU_CSL23_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL23_SUR_S1.

//! @brief Get value of CSU_CSL23_SUR_S1 from a register value.
#define BG_CSU_CSL23_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_SUR_S1) >> BP_CSU_CSL23_SUR_S1)

//! @brief Format value for bitfield CSU_CSL23_SUR_S1.
#define BF_CSU_CSL23_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_SUR_S1) & BM_CSU_CSL23_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL23_SUR_S1(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_SUR_S1) | BF_CSU_CSL23_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL23, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL23_SSR_S1      (17)      //!< Bit position for CSU_CSL23_SSR_S1.
#define BM_CSU_CSL23_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL23_SSR_S1.

//! @brief Get value of CSU_CSL23_SSR_S1 from a register value.
#define BG_CSU_CSL23_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_SSR_S1) >> BP_CSU_CSL23_SSR_S1)

//! @brief Format value for bitfield CSU_CSL23_SSR_S1.
#define BF_CSU_CSL23_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_SSR_S1) & BM_CSU_CSL23_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL23_SSR_S1(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_SSR_S1) | BF_CSU_CSL23_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL23, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL23_NUR_S1      (18)      //!< Bit position for CSU_CSL23_NUR_S1.
#define BM_CSU_CSL23_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL23_NUR_S1.

//! @brief Get value of CSU_CSL23_NUR_S1 from a register value.
#define BG_CSU_CSL23_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_NUR_S1) >> BP_CSU_CSL23_NUR_S1)

//! @brief Format value for bitfield CSU_CSL23_NUR_S1.
#define BF_CSU_CSL23_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_NUR_S1) & BM_CSU_CSL23_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL23_NUR_S1(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_NUR_S1) | BF_CSU_CSL23_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL23, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL23_NSR_S1      (19)      //!< Bit position for CSU_CSL23_NSR_S1.
#define BM_CSU_CSL23_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL23_NSR_S1.

//! @brief Get value of CSU_CSL23_NSR_S1 from a register value.
#define BG_CSU_CSL23_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_NSR_S1) >> BP_CSU_CSL23_NSR_S1)

//! @brief Format value for bitfield CSU_CSL23_NSR_S1.
#define BF_CSU_CSL23_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_NSR_S1) & BM_CSU_CSL23_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL23_NSR_S1(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_NSR_S1) | BF_CSU_CSL23_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL23, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL23_SUW_S1      (20)      //!< Bit position for CSU_CSL23_SUW_S1.
#define BM_CSU_CSL23_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL23_SUW_S1.

//! @brief Get value of CSU_CSL23_SUW_S1 from a register value.
#define BG_CSU_CSL23_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_SUW_S1) >> BP_CSU_CSL23_SUW_S1)

//! @brief Format value for bitfield CSU_CSL23_SUW_S1.
#define BF_CSU_CSL23_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_SUW_S1) & BM_CSU_CSL23_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL23_SUW_S1(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_SUW_S1) | BF_CSU_CSL23_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL23, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL23_SSW_S1      (21)      //!< Bit position for CSU_CSL23_SSW_S1.
#define BM_CSU_CSL23_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL23_SSW_S1.

//! @brief Get value of CSU_CSL23_SSW_S1 from a register value.
#define BG_CSU_CSL23_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_SSW_S1) >> BP_CSU_CSL23_SSW_S1)

//! @brief Format value for bitfield CSU_CSL23_SSW_S1.
#define BF_CSU_CSL23_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_SSW_S1) & BM_CSU_CSL23_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL23_SSW_S1(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_SSW_S1) | BF_CSU_CSL23_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL23, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL23_NUW_S1      (22)      //!< Bit position for CSU_CSL23_NUW_S1.
#define BM_CSU_CSL23_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL23_NUW_S1.

//! @brief Get value of CSU_CSL23_NUW_S1 from a register value.
#define BG_CSU_CSL23_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_NUW_S1) >> BP_CSU_CSL23_NUW_S1)

//! @brief Format value for bitfield CSU_CSL23_NUW_S1.
#define BF_CSU_CSL23_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_NUW_S1) & BM_CSU_CSL23_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL23_NUW_S1(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_NUW_S1) | BF_CSU_CSL23_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL23, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL23_NSW_S1      (23)      //!< Bit position for CSU_CSL23_NSW_S1.
#define BM_CSU_CSL23_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL23_NSW_S1.

//! @brief Get value of CSU_CSL23_NSW_S1 from a register value.
#define BG_CSU_CSL23_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_NSW_S1) >> BP_CSU_CSL23_NSW_S1)

//! @brief Format value for bitfield CSU_CSL23_NSW_S1.
#define BF_CSU_CSL23_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_NSW_S1) & BM_CSU_CSL23_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL23_NSW_S1(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_NSW_S1) | BF_CSU_CSL23_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL23, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL23_LOCK_S1      (24)      //!< Bit position for CSU_CSL23_LOCK_S1.
#define BM_CSU_CSL23_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL23_LOCK_S1.

//! @brief Get value of CSU_CSL23_LOCK_S1 from a register value.
#define BG_CSU_CSL23_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL23_LOCK_S1) >> BP_CSU_CSL23_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL23_LOCK_S1.
#define BF_CSU_CSL23_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL23_LOCK_S1) & BM_CSU_CSL23_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL23_LOCK_S1(v)   (HW_CSU_CSL23_WR((HW_CSU_CSL23_RD() & ~BM_CSU_CSL23_LOCK_S1) | BF_CSU_CSL23_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL24 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL24 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl24
{
    reg32_t U;
    struct _hw_csu_csl24_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl24_t;
#endif

/*
 * constants & macros for entire CSU_CSL24 register
 */
#define HW_CSU_CSL24_ADDR      (REGS_CSU_BASE + 0x60)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL24           (*(volatile hw_csu_csl24_t *) HW_CSU_CSL24_ADDR)
#define HW_CSU_CSL24_RD()      (HW_CSU_CSL24.U)
#define HW_CSU_CSL24_WR(v)     (HW_CSU_CSL24.U = (v))
#define HW_CSU_CSL24_SET(v)    (HW_CSU_CSL24_WR(HW_CSU_CSL24_RD() |  (v)))
#define HW_CSU_CSL24_CLR(v)    (HW_CSU_CSL24_WR(HW_CSU_CSL24_RD() & ~(v)))
#define HW_CSU_CSL24_TOG(v)    (HW_CSU_CSL24_WR(HW_CSU_CSL24_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL24 bitfields
 */

/* --- Register HW_CSU_CSL24, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL24_SUR_S2      (0)      //!< Bit position for CSU_CSL24_SUR_S2.
#define BM_CSU_CSL24_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL24_SUR_S2.

//! @brief Get value of CSU_CSL24_SUR_S2 from a register value.
#define BG_CSU_CSL24_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_SUR_S2) >> BP_CSU_CSL24_SUR_S2)

//! @brief Format value for bitfield CSU_CSL24_SUR_S2.
#define BF_CSU_CSL24_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_SUR_S2) & BM_CSU_CSL24_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL24_SUR_S2(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_SUR_S2) | BF_CSU_CSL24_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL24, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL24_SSR_S2      (1)      //!< Bit position for CSU_CSL24_SSR_S2.
#define BM_CSU_CSL24_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL24_SSR_S2.

//! @brief Get value of CSU_CSL24_SSR_S2 from a register value.
#define BG_CSU_CSL24_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_SSR_S2) >> BP_CSU_CSL24_SSR_S2)

//! @brief Format value for bitfield CSU_CSL24_SSR_S2.
#define BF_CSU_CSL24_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_SSR_S2) & BM_CSU_CSL24_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL24_SSR_S2(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_SSR_S2) | BF_CSU_CSL24_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL24, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL24_NUR_S2      (2)      //!< Bit position for CSU_CSL24_NUR_S2.
#define BM_CSU_CSL24_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL24_NUR_S2.

//! @brief Get value of CSU_CSL24_NUR_S2 from a register value.
#define BG_CSU_CSL24_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_NUR_S2) >> BP_CSU_CSL24_NUR_S2)

//! @brief Format value for bitfield CSU_CSL24_NUR_S2.
#define BF_CSU_CSL24_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_NUR_S2) & BM_CSU_CSL24_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL24_NUR_S2(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_NUR_S2) | BF_CSU_CSL24_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL24, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL24_NSR_S2      (3)      //!< Bit position for CSU_CSL24_NSR_S2.
#define BM_CSU_CSL24_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL24_NSR_S2.

//! @brief Get value of CSU_CSL24_NSR_S2 from a register value.
#define BG_CSU_CSL24_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_NSR_S2) >> BP_CSU_CSL24_NSR_S2)

//! @brief Format value for bitfield CSU_CSL24_NSR_S2.
#define BF_CSU_CSL24_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_NSR_S2) & BM_CSU_CSL24_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL24_NSR_S2(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_NSR_S2) | BF_CSU_CSL24_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL24, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL24_SUW_S2      (4)      //!< Bit position for CSU_CSL24_SUW_S2.
#define BM_CSU_CSL24_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL24_SUW_S2.

//! @brief Get value of CSU_CSL24_SUW_S2 from a register value.
#define BG_CSU_CSL24_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_SUW_S2) >> BP_CSU_CSL24_SUW_S2)

//! @brief Format value for bitfield CSU_CSL24_SUW_S2.
#define BF_CSU_CSL24_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_SUW_S2) & BM_CSU_CSL24_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL24_SUW_S2(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_SUW_S2) | BF_CSU_CSL24_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL24, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL24_SSW_S2      (5)      //!< Bit position for CSU_CSL24_SSW_S2.
#define BM_CSU_CSL24_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL24_SSW_S2.

//! @brief Get value of CSU_CSL24_SSW_S2 from a register value.
#define BG_CSU_CSL24_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_SSW_S2) >> BP_CSU_CSL24_SSW_S2)

//! @brief Format value for bitfield CSU_CSL24_SSW_S2.
#define BF_CSU_CSL24_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_SSW_S2) & BM_CSU_CSL24_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL24_SSW_S2(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_SSW_S2) | BF_CSU_CSL24_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL24, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL24_NUW_S2      (6)      //!< Bit position for CSU_CSL24_NUW_S2.
#define BM_CSU_CSL24_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL24_NUW_S2.

//! @brief Get value of CSU_CSL24_NUW_S2 from a register value.
#define BG_CSU_CSL24_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_NUW_S2) >> BP_CSU_CSL24_NUW_S2)

//! @brief Format value for bitfield CSU_CSL24_NUW_S2.
#define BF_CSU_CSL24_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_NUW_S2) & BM_CSU_CSL24_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL24_NUW_S2(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_NUW_S2) | BF_CSU_CSL24_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL24, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL24_NSW_S2      (7)      //!< Bit position for CSU_CSL24_NSW_S2.
#define BM_CSU_CSL24_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL24_NSW_S2.

//! @brief Get value of CSU_CSL24_NSW_S2 from a register value.
#define BG_CSU_CSL24_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_NSW_S2) >> BP_CSU_CSL24_NSW_S2)

//! @brief Format value for bitfield CSU_CSL24_NSW_S2.
#define BF_CSU_CSL24_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_NSW_S2) & BM_CSU_CSL24_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL24_NSW_S2(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_NSW_S2) | BF_CSU_CSL24_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL24, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL24_LOCK_S2      (8)      //!< Bit position for CSU_CSL24_LOCK_S2.
#define BM_CSU_CSL24_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL24_LOCK_S2.

//! @brief Get value of CSU_CSL24_LOCK_S2 from a register value.
#define BG_CSU_CSL24_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_LOCK_S2) >> BP_CSU_CSL24_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL24_LOCK_S2.
#define BF_CSU_CSL24_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_LOCK_S2) & BM_CSU_CSL24_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL24_LOCK_S2(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_LOCK_S2) | BF_CSU_CSL24_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL24, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL24_SUR_S1      (16)      //!< Bit position for CSU_CSL24_SUR_S1.
#define BM_CSU_CSL24_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL24_SUR_S1.

//! @brief Get value of CSU_CSL24_SUR_S1 from a register value.
#define BG_CSU_CSL24_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_SUR_S1) >> BP_CSU_CSL24_SUR_S1)

//! @brief Format value for bitfield CSU_CSL24_SUR_S1.
#define BF_CSU_CSL24_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_SUR_S1) & BM_CSU_CSL24_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL24_SUR_S1(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_SUR_S1) | BF_CSU_CSL24_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL24, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL24_SSR_S1      (17)      //!< Bit position for CSU_CSL24_SSR_S1.
#define BM_CSU_CSL24_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL24_SSR_S1.

//! @brief Get value of CSU_CSL24_SSR_S1 from a register value.
#define BG_CSU_CSL24_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_SSR_S1) >> BP_CSU_CSL24_SSR_S1)

//! @brief Format value for bitfield CSU_CSL24_SSR_S1.
#define BF_CSU_CSL24_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_SSR_S1) & BM_CSU_CSL24_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL24_SSR_S1(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_SSR_S1) | BF_CSU_CSL24_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL24, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL24_NUR_S1      (18)      //!< Bit position for CSU_CSL24_NUR_S1.
#define BM_CSU_CSL24_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL24_NUR_S1.

//! @brief Get value of CSU_CSL24_NUR_S1 from a register value.
#define BG_CSU_CSL24_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_NUR_S1) >> BP_CSU_CSL24_NUR_S1)

//! @brief Format value for bitfield CSU_CSL24_NUR_S1.
#define BF_CSU_CSL24_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_NUR_S1) & BM_CSU_CSL24_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL24_NUR_S1(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_NUR_S1) | BF_CSU_CSL24_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL24, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL24_NSR_S1      (19)      //!< Bit position for CSU_CSL24_NSR_S1.
#define BM_CSU_CSL24_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL24_NSR_S1.

//! @brief Get value of CSU_CSL24_NSR_S1 from a register value.
#define BG_CSU_CSL24_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_NSR_S1) >> BP_CSU_CSL24_NSR_S1)

//! @brief Format value for bitfield CSU_CSL24_NSR_S1.
#define BF_CSU_CSL24_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_NSR_S1) & BM_CSU_CSL24_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL24_NSR_S1(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_NSR_S1) | BF_CSU_CSL24_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL24, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL24_SUW_S1      (20)      //!< Bit position for CSU_CSL24_SUW_S1.
#define BM_CSU_CSL24_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL24_SUW_S1.

//! @brief Get value of CSU_CSL24_SUW_S1 from a register value.
#define BG_CSU_CSL24_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_SUW_S1) >> BP_CSU_CSL24_SUW_S1)

//! @brief Format value for bitfield CSU_CSL24_SUW_S1.
#define BF_CSU_CSL24_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_SUW_S1) & BM_CSU_CSL24_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL24_SUW_S1(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_SUW_S1) | BF_CSU_CSL24_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL24, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL24_SSW_S1      (21)      //!< Bit position for CSU_CSL24_SSW_S1.
#define BM_CSU_CSL24_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL24_SSW_S1.

//! @brief Get value of CSU_CSL24_SSW_S1 from a register value.
#define BG_CSU_CSL24_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_SSW_S1) >> BP_CSU_CSL24_SSW_S1)

//! @brief Format value for bitfield CSU_CSL24_SSW_S1.
#define BF_CSU_CSL24_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_SSW_S1) & BM_CSU_CSL24_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL24_SSW_S1(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_SSW_S1) | BF_CSU_CSL24_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL24, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL24_NUW_S1      (22)      //!< Bit position for CSU_CSL24_NUW_S1.
#define BM_CSU_CSL24_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL24_NUW_S1.

//! @brief Get value of CSU_CSL24_NUW_S1 from a register value.
#define BG_CSU_CSL24_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_NUW_S1) >> BP_CSU_CSL24_NUW_S1)

//! @brief Format value for bitfield CSU_CSL24_NUW_S1.
#define BF_CSU_CSL24_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_NUW_S1) & BM_CSU_CSL24_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL24_NUW_S1(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_NUW_S1) | BF_CSU_CSL24_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL24, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL24_NSW_S1      (23)      //!< Bit position for CSU_CSL24_NSW_S1.
#define BM_CSU_CSL24_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL24_NSW_S1.

//! @brief Get value of CSU_CSL24_NSW_S1 from a register value.
#define BG_CSU_CSL24_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_NSW_S1) >> BP_CSU_CSL24_NSW_S1)

//! @brief Format value for bitfield CSU_CSL24_NSW_S1.
#define BF_CSU_CSL24_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_NSW_S1) & BM_CSU_CSL24_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL24_NSW_S1(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_NSW_S1) | BF_CSU_CSL24_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL24, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL24_LOCK_S1      (24)      //!< Bit position for CSU_CSL24_LOCK_S1.
#define BM_CSU_CSL24_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL24_LOCK_S1.

//! @brief Get value of CSU_CSL24_LOCK_S1 from a register value.
#define BG_CSU_CSL24_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL24_LOCK_S1) >> BP_CSU_CSL24_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL24_LOCK_S1.
#define BF_CSU_CSL24_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL24_LOCK_S1) & BM_CSU_CSL24_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL24_LOCK_S1(v)   (HW_CSU_CSL24_WR((HW_CSU_CSL24_RD() & ~BM_CSU_CSL24_LOCK_S1) | BF_CSU_CSL24_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL25 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL25 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl25
{
    reg32_t U;
    struct _hw_csu_csl25_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl25_t;
#endif

/*
 * constants & macros for entire CSU_CSL25 register
 */
#define HW_CSU_CSL25_ADDR      (REGS_CSU_BASE + 0x64)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL25           (*(volatile hw_csu_csl25_t *) HW_CSU_CSL25_ADDR)
#define HW_CSU_CSL25_RD()      (HW_CSU_CSL25.U)
#define HW_CSU_CSL25_WR(v)     (HW_CSU_CSL25.U = (v))
#define HW_CSU_CSL25_SET(v)    (HW_CSU_CSL25_WR(HW_CSU_CSL25_RD() |  (v)))
#define HW_CSU_CSL25_CLR(v)    (HW_CSU_CSL25_WR(HW_CSU_CSL25_RD() & ~(v)))
#define HW_CSU_CSL25_TOG(v)    (HW_CSU_CSL25_WR(HW_CSU_CSL25_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL25 bitfields
 */

/* --- Register HW_CSU_CSL25, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL25_SUR_S2      (0)      //!< Bit position for CSU_CSL25_SUR_S2.
#define BM_CSU_CSL25_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL25_SUR_S2.

//! @brief Get value of CSU_CSL25_SUR_S2 from a register value.
#define BG_CSU_CSL25_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_SUR_S2) >> BP_CSU_CSL25_SUR_S2)

//! @brief Format value for bitfield CSU_CSL25_SUR_S2.
#define BF_CSU_CSL25_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_SUR_S2) & BM_CSU_CSL25_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL25_SUR_S2(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_SUR_S2) | BF_CSU_CSL25_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL25, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL25_SSR_S2      (1)      //!< Bit position for CSU_CSL25_SSR_S2.
#define BM_CSU_CSL25_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL25_SSR_S2.

//! @brief Get value of CSU_CSL25_SSR_S2 from a register value.
#define BG_CSU_CSL25_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_SSR_S2) >> BP_CSU_CSL25_SSR_S2)

//! @brief Format value for bitfield CSU_CSL25_SSR_S2.
#define BF_CSU_CSL25_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_SSR_S2) & BM_CSU_CSL25_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL25_SSR_S2(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_SSR_S2) | BF_CSU_CSL25_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL25, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL25_NUR_S2      (2)      //!< Bit position for CSU_CSL25_NUR_S2.
#define BM_CSU_CSL25_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL25_NUR_S2.

//! @brief Get value of CSU_CSL25_NUR_S2 from a register value.
#define BG_CSU_CSL25_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_NUR_S2) >> BP_CSU_CSL25_NUR_S2)

//! @brief Format value for bitfield CSU_CSL25_NUR_S2.
#define BF_CSU_CSL25_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_NUR_S2) & BM_CSU_CSL25_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL25_NUR_S2(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_NUR_S2) | BF_CSU_CSL25_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL25, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL25_NSR_S2      (3)      //!< Bit position for CSU_CSL25_NSR_S2.
#define BM_CSU_CSL25_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL25_NSR_S2.

//! @brief Get value of CSU_CSL25_NSR_S2 from a register value.
#define BG_CSU_CSL25_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_NSR_S2) >> BP_CSU_CSL25_NSR_S2)

//! @brief Format value for bitfield CSU_CSL25_NSR_S2.
#define BF_CSU_CSL25_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_NSR_S2) & BM_CSU_CSL25_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL25_NSR_S2(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_NSR_S2) | BF_CSU_CSL25_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL25, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL25_SUW_S2      (4)      //!< Bit position for CSU_CSL25_SUW_S2.
#define BM_CSU_CSL25_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL25_SUW_S2.

//! @brief Get value of CSU_CSL25_SUW_S2 from a register value.
#define BG_CSU_CSL25_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_SUW_S2) >> BP_CSU_CSL25_SUW_S2)

//! @brief Format value for bitfield CSU_CSL25_SUW_S2.
#define BF_CSU_CSL25_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_SUW_S2) & BM_CSU_CSL25_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL25_SUW_S2(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_SUW_S2) | BF_CSU_CSL25_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL25, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL25_SSW_S2      (5)      //!< Bit position for CSU_CSL25_SSW_S2.
#define BM_CSU_CSL25_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL25_SSW_S2.

//! @brief Get value of CSU_CSL25_SSW_S2 from a register value.
#define BG_CSU_CSL25_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_SSW_S2) >> BP_CSU_CSL25_SSW_S2)

//! @brief Format value for bitfield CSU_CSL25_SSW_S2.
#define BF_CSU_CSL25_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_SSW_S2) & BM_CSU_CSL25_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL25_SSW_S2(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_SSW_S2) | BF_CSU_CSL25_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL25, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL25_NUW_S2      (6)      //!< Bit position for CSU_CSL25_NUW_S2.
#define BM_CSU_CSL25_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL25_NUW_S2.

//! @brief Get value of CSU_CSL25_NUW_S2 from a register value.
#define BG_CSU_CSL25_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_NUW_S2) >> BP_CSU_CSL25_NUW_S2)

//! @brief Format value for bitfield CSU_CSL25_NUW_S2.
#define BF_CSU_CSL25_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_NUW_S2) & BM_CSU_CSL25_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL25_NUW_S2(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_NUW_S2) | BF_CSU_CSL25_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL25, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL25_NSW_S2      (7)      //!< Bit position for CSU_CSL25_NSW_S2.
#define BM_CSU_CSL25_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL25_NSW_S2.

//! @brief Get value of CSU_CSL25_NSW_S2 from a register value.
#define BG_CSU_CSL25_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_NSW_S2) >> BP_CSU_CSL25_NSW_S2)

//! @brief Format value for bitfield CSU_CSL25_NSW_S2.
#define BF_CSU_CSL25_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_NSW_S2) & BM_CSU_CSL25_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL25_NSW_S2(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_NSW_S2) | BF_CSU_CSL25_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL25, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL25_LOCK_S2      (8)      //!< Bit position for CSU_CSL25_LOCK_S2.
#define BM_CSU_CSL25_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL25_LOCK_S2.

//! @brief Get value of CSU_CSL25_LOCK_S2 from a register value.
#define BG_CSU_CSL25_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_LOCK_S2) >> BP_CSU_CSL25_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL25_LOCK_S2.
#define BF_CSU_CSL25_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_LOCK_S2) & BM_CSU_CSL25_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL25_LOCK_S2(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_LOCK_S2) | BF_CSU_CSL25_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL25, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL25_SUR_S1      (16)      //!< Bit position for CSU_CSL25_SUR_S1.
#define BM_CSU_CSL25_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL25_SUR_S1.

//! @brief Get value of CSU_CSL25_SUR_S1 from a register value.
#define BG_CSU_CSL25_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_SUR_S1) >> BP_CSU_CSL25_SUR_S1)

//! @brief Format value for bitfield CSU_CSL25_SUR_S1.
#define BF_CSU_CSL25_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_SUR_S1) & BM_CSU_CSL25_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL25_SUR_S1(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_SUR_S1) | BF_CSU_CSL25_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL25, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL25_SSR_S1      (17)      //!< Bit position for CSU_CSL25_SSR_S1.
#define BM_CSU_CSL25_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL25_SSR_S1.

//! @brief Get value of CSU_CSL25_SSR_S1 from a register value.
#define BG_CSU_CSL25_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_SSR_S1) >> BP_CSU_CSL25_SSR_S1)

//! @brief Format value for bitfield CSU_CSL25_SSR_S1.
#define BF_CSU_CSL25_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_SSR_S1) & BM_CSU_CSL25_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL25_SSR_S1(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_SSR_S1) | BF_CSU_CSL25_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL25, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL25_NUR_S1      (18)      //!< Bit position for CSU_CSL25_NUR_S1.
#define BM_CSU_CSL25_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL25_NUR_S1.

//! @brief Get value of CSU_CSL25_NUR_S1 from a register value.
#define BG_CSU_CSL25_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_NUR_S1) >> BP_CSU_CSL25_NUR_S1)

//! @brief Format value for bitfield CSU_CSL25_NUR_S1.
#define BF_CSU_CSL25_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_NUR_S1) & BM_CSU_CSL25_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL25_NUR_S1(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_NUR_S1) | BF_CSU_CSL25_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL25, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL25_NSR_S1      (19)      //!< Bit position for CSU_CSL25_NSR_S1.
#define BM_CSU_CSL25_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL25_NSR_S1.

//! @brief Get value of CSU_CSL25_NSR_S1 from a register value.
#define BG_CSU_CSL25_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_NSR_S1) >> BP_CSU_CSL25_NSR_S1)

//! @brief Format value for bitfield CSU_CSL25_NSR_S1.
#define BF_CSU_CSL25_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_NSR_S1) & BM_CSU_CSL25_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL25_NSR_S1(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_NSR_S1) | BF_CSU_CSL25_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL25, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL25_SUW_S1      (20)      //!< Bit position for CSU_CSL25_SUW_S1.
#define BM_CSU_CSL25_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL25_SUW_S1.

//! @brief Get value of CSU_CSL25_SUW_S1 from a register value.
#define BG_CSU_CSL25_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_SUW_S1) >> BP_CSU_CSL25_SUW_S1)

//! @brief Format value for bitfield CSU_CSL25_SUW_S1.
#define BF_CSU_CSL25_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_SUW_S1) & BM_CSU_CSL25_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL25_SUW_S1(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_SUW_S1) | BF_CSU_CSL25_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL25, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL25_SSW_S1      (21)      //!< Bit position for CSU_CSL25_SSW_S1.
#define BM_CSU_CSL25_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL25_SSW_S1.

//! @brief Get value of CSU_CSL25_SSW_S1 from a register value.
#define BG_CSU_CSL25_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_SSW_S1) >> BP_CSU_CSL25_SSW_S1)

//! @brief Format value for bitfield CSU_CSL25_SSW_S1.
#define BF_CSU_CSL25_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_SSW_S1) & BM_CSU_CSL25_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL25_SSW_S1(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_SSW_S1) | BF_CSU_CSL25_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL25, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL25_NUW_S1      (22)      //!< Bit position for CSU_CSL25_NUW_S1.
#define BM_CSU_CSL25_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL25_NUW_S1.

//! @brief Get value of CSU_CSL25_NUW_S1 from a register value.
#define BG_CSU_CSL25_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_NUW_S1) >> BP_CSU_CSL25_NUW_S1)

//! @brief Format value for bitfield CSU_CSL25_NUW_S1.
#define BF_CSU_CSL25_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_NUW_S1) & BM_CSU_CSL25_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL25_NUW_S1(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_NUW_S1) | BF_CSU_CSL25_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL25, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL25_NSW_S1      (23)      //!< Bit position for CSU_CSL25_NSW_S1.
#define BM_CSU_CSL25_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL25_NSW_S1.

//! @brief Get value of CSU_CSL25_NSW_S1 from a register value.
#define BG_CSU_CSL25_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_NSW_S1) >> BP_CSU_CSL25_NSW_S1)

//! @brief Format value for bitfield CSU_CSL25_NSW_S1.
#define BF_CSU_CSL25_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_NSW_S1) & BM_CSU_CSL25_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL25_NSW_S1(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_NSW_S1) | BF_CSU_CSL25_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL25, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL25_LOCK_S1      (24)      //!< Bit position for CSU_CSL25_LOCK_S1.
#define BM_CSU_CSL25_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL25_LOCK_S1.

//! @brief Get value of CSU_CSL25_LOCK_S1 from a register value.
#define BG_CSU_CSL25_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL25_LOCK_S1) >> BP_CSU_CSL25_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL25_LOCK_S1.
#define BF_CSU_CSL25_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL25_LOCK_S1) & BM_CSU_CSL25_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL25_LOCK_S1(v)   (HW_CSU_CSL25_WR((HW_CSU_CSL25_RD() & ~BM_CSU_CSL25_LOCK_S1) | BF_CSU_CSL25_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL26 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL26 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl26
{
    reg32_t U;
    struct _hw_csu_csl26_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl26_t;
#endif

/*
 * constants & macros for entire CSU_CSL26 register
 */
#define HW_CSU_CSL26_ADDR      (REGS_CSU_BASE + 0x68)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL26           (*(volatile hw_csu_csl26_t *) HW_CSU_CSL26_ADDR)
#define HW_CSU_CSL26_RD()      (HW_CSU_CSL26.U)
#define HW_CSU_CSL26_WR(v)     (HW_CSU_CSL26.U = (v))
#define HW_CSU_CSL26_SET(v)    (HW_CSU_CSL26_WR(HW_CSU_CSL26_RD() |  (v)))
#define HW_CSU_CSL26_CLR(v)    (HW_CSU_CSL26_WR(HW_CSU_CSL26_RD() & ~(v)))
#define HW_CSU_CSL26_TOG(v)    (HW_CSU_CSL26_WR(HW_CSU_CSL26_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL26 bitfields
 */

/* --- Register HW_CSU_CSL26, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL26_SUR_S2      (0)      //!< Bit position for CSU_CSL26_SUR_S2.
#define BM_CSU_CSL26_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL26_SUR_S2.

//! @brief Get value of CSU_CSL26_SUR_S2 from a register value.
#define BG_CSU_CSL26_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_SUR_S2) >> BP_CSU_CSL26_SUR_S2)

//! @brief Format value for bitfield CSU_CSL26_SUR_S2.
#define BF_CSU_CSL26_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_SUR_S2) & BM_CSU_CSL26_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL26_SUR_S2(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_SUR_S2) | BF_CSU_CSL26_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL26, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL26_SSR_S2      (1)      //!< Bit position for CSU_CSL26_SSR_S2.
#define BM_CSU_CSL26_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL26_SSR_S2.

//! @brief Get value of CSU_CSL26_SSR_S2 from a register value.
#define BG_CSU_CSL26_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_SSR_S2) >> BP_CSU_CSL26_SSR_S2)

//! @brief Format value for bitfield CSU_CSL26_SSR_S2.
#define BF_CSU_CSL26_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_SSR_S2) & BM_CSU_CSL26_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL26_SSR_S2(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_SSR_S2) | BF_CSU_CSL26_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL26, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL26_NUR_S2      (2)      //!< Bit position for CSU_CSL26_NUR_S2.
#define BM_CSU_CSL26_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL26_NUR_S2.

//! @brief Get value of CSU_CSL26_NUR_S2 from a register value.
#define BG_CSU_CSL26_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_NUR_S2) >> BP_CSU_CSL26_NUR_S2)

//! @brief Format value for bitfield CSU_CSL26_NUR_S2.
#define BF_CSU_CSL26_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_NUR_S2) & BM_CSU_CSL26_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL26_NUR_S2(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_NUR_S2) | BF_CSU_CSL26_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL26, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL26_NSR_S2      (3)      //!< Bit position for CSU_CSL26_NSR_S2.
#define BM_CSU_CSL26_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL26_NSR_S2.

//! @brief Get value of CSU_CSL26_NSR_S2 from a register value.
#define BG_CSU_CSL26_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_NSR_S2) >> BP_CSU_CSL26_NSR_S2)

//! @brief Format value for bitfield CSU_CSL26_NSR_S2.
#define BF_CSU_CSL26_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_NSR_S2) & BM_CSU_CSL26_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL26_NSR_S2(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_NSR_S2) | BF_CSU_CSL26_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL26, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL26_SUW_S2      (4)      //!< Bit position for CSU_CSL26_SUW_S2.
#define BM_CSU_CSL26_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL26_SUW_S2.

//! @brief Get value of CSU_CSL26_SUW_S2 from a register value.
#define BG_CSU_CSL26_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_SUW_S2) >> BP_CSU_CSL26_SUW_S2)

//! @brief Format value for bitfield CSU_CSL26_SUW_S2.
#define BF_CSU_CSL26_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_SUW_S2) & BM_CSU_CSL26_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL26_SUW_S2(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_SUW_S2) | BF_CSU_CSL26_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL26, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL26_SSW_S2      (5)      //!< Bit position for CSU_CSL26_SSW_S2.
#define BM_CSU_CSL26_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL26_SSW_S2.

//! @brief Get value of CSU_CSL26_SSW_S2 from a register value.
#define BG_CSU_CSL26_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_SSW_S2) >> BP_CSU_CSL26_SSW_S2)

//! @brief Format value for bitfield CSU_CSL26_SSW_S2.
#define BF_CSU_CSL26_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_SSW_S2) & BM_CSU_CSL26_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL26_SSW_S2(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_SSW_S2) | BF_CSU_CSL26_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL26, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL26_NUW_S2      (6)      //!< Bit position for CSU_CSL26_NUW_S2.
#define BM_CSU_CSL26_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL26_NUW_S2.

//! @brief Get value of CSU_CSL26_NUW_S2 from a register value.
#define BG_CSU_CSL26_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_NUW_S2) >> BP_CSU_CSL26_NUW_S2)

//! @brief Format value for bitfield CSU_CSL26_NUW_S2.
#define BF_CSU_CSL26_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_NUW_S2) & BM_CSU_CSL26_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL26_NUW_S2(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_NUW_S2) | BF_CSU_CSL26_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL26, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL26_NSW_S2      (7)      //!< Bit position for CSU_CSL26_NSW_S2.
#define BM_CSU_CSL26_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL26_NSW_S2.

//! @brief Get value of CSU_CSL26_NSW_S2 from a register value.
#define BG_CSU_CSL26_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_NSW_S2) >> BP_CSU_CSL26_NSW_S2)

//! @brief Format value for bitfield CSU_CSL26_NSW_S2.
#define BF_CSU_CSL26_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_NSW_S2) & BM_CSU_CSL26_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL26_NSW_S2(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_NSW_S2) | BF_CSU_CSL26_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL26, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL26_LOCK_S2      (8)      //!< Bit position for CSU_CSL26_LOCK_S2.
#define BM_CSU_CSL26_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL26_LOCK_S2.

//! @brief Get value of CSU_CSL26_LOCK_S2 from a register value.
#define BG_CSU_CSL26_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_LOCK_S2) >> BP_CSU_CSL26_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL26_LOCK_S2.
#define BF_CSU_CSL26_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_LOCK_S2) & BM_CSU_CSL26_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL26_LOCK_S2(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_LOCK_S2) | BF_CSU_CSL26_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL26, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL26_SUR_S1      (16)      //!< Bit position for CSU_CSL26_SUR_S1.
#define BM_CSU_CSL26_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL26_SUR_S1.

//! @brief Get value of CSU_CSL26_SUR_S1 from a register value.
#define BG_CSU_CSL26_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_SUR_S1) >> BP_CSU_CSL26_SUR_S1)

//! @brief Format value for bitfield CSU_CSL26_SUR_S1.
#define BF_CSU_CSL26_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_SUR_S1) & BM_CSU_CSL26_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL26_SUR_S1(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_SUR_S1) | BF_CSU_CSL26_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL26, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL26_SSR_S1      (17)      //!< Bit position for CSU_CSL26_SSR_S1.
#define BM_CSU_CSL26_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL26_SSR_S1.

//! @brief Get value of CSU_CSL26_SSR_S1 from a register value.
#define BG_CSU_CSL26_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_SSR_S1) >> BP_CSU_CSL26_SSR_S1)

//! @brief Format value for bitfield CSU_CSL26_SSR_S1.
#define BF_CSU_CSL26_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_SSR_S1) & BM_CSU_CSL26_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL26_SSR_S1(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_SSR_S1) | BF_CSU_CSL26_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL26, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL26_NUR_S1      (18)      //!< Bit position for CSU_CSL26_NUR_S1.
#define BM_CSU_CSL26_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL26_NUR_S1.

//! @brief Get value of CSU_CSL26_NUR_S1 from a register value.
#define BG_CSU_CSL26_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_NUR_S1) >> BP_CSU_CSL26_NUR_S1)

//! @brief Format value for bitfield CSU_CSL26_NUR_S1.
#define BF_CSU_CSL26_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_NUR_S1) & BM_CSU_CSL26_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL26_NUR_S1(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_NUR_S1) | BF_CSU_CSL26_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL26, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL26_NSR_S1      (19)      //!< Bit position for CSU_CSL26_NSR_S1.
#define BM_CSU_CSL26_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL26_NSR_S1.

//! @brief Get value of CSU_CSL26_NSR_S1 from a register value.
#define BG_CSU_CSL26_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_NSR_S1) >> BP_CSU_CSL26_NSR_S1)

//! @brief Format value for bitfield CSU_CSL26_NSR_S1.
#define BF_CSU_CSL26_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_NSR_S1) & BM_CSU_CSL26_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL26_NSR_S1(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_NSR_S1) | BF_CSU_CSL26_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL26, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL26_SUW_S1      (20)      //!< Bit position for CSU_CSL26_SUW_S1.
#define BM_CSU_CSL26_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL26_SUW_S1.

//! @brief Get value of CSU_CSL26_SUW_S1 from a register value.
#define BG_CSU_CSL26_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_SUW_S1) >> BP_CSU_CSL26_SUW_S1)

//! @brief Format value for bitfield CSU_CSL26_SUW_S1.
#define BF_CSU_CSL26_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_SUW_S1) & BM_CSU_CSL26_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL26_SUW_S1(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_SUW_S1) | BF_CSU_CSL26_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL26, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL26_SSW_S1      (21)      //!< Bit position for CSU_CSL26_SSW_S1.
#define BM_CSU_CSL26_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL26_SSW_S1.

//! @brief Get value of CSU_CSL26_SSW_S1 from a register value.
#define BG_CSU_CSL26_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_SSW_S1) >> BP_CSU_CSL26_SSW_S1)

//! @brief Format value for bitfield CSU_CSL26_SSW_S1.
#define BF_CSU_CSL26_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_SSW_S1) & BM_CSU_CSL26_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL26_SSW_S1(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_SSW_S1) | BF_CSU_CSL26_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL26, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL26_NUW_S1      (22)      //!< Bit position for CSU_CSL26_NUW_S1.
#define BM_CSU_CSL26_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL26_NUW_S1.

//! @brief Get value of CSU_CSL26_NUW_S1 from a register value.
#define BG_CSU_CSL26_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_NUW_S1) >> BP_CSU_CSL26_NUW_S1)

//! @brief Format value for bitfield CSU_CSL26_NUW_S1.
#define BF_CSU_CSL26_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_NUW_S1) & BM_CSU_CSL26_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL26_NUW_S1(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_NUW_S1) | BF_CSU_CSL26_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL26, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL26_NSW_S1      (23)      //!< Bit position for CSU_CSL26_NSW_S1.
#define BM_CSU_CSL26_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL26_NSW_S1.

//! @brief Get value of CSU_CSL26_NSW_S1 from a register value.
#define BG_CSU_CSL26_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_NSW_S1) >> BP_CSU_CSL26_NSW_S1)

//! @brief Format value for bitfield CSU_CSL26_NSW_S1.
#define BF_CSU_CSL26_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_NSW_S1) & BM_CSU_CSL26_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL26_NSW_S1(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_NSW_S1) | BF_CSU_CSL26_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL26, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL26_LOCK_S1      (24)      //!< Bit position for CSU_CSL26_LOCK_S1.
#define BM_CSU_CSL26_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL26_LOCK_S1.

//! @brief Get value of CSU_CSL26_LOCK_S1 from a register value.
#define BG_CSU_CSL26_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL26_LOCK_S1) >> BP_CSU_CSL26_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL26_LOCK_S1.
#define BF_CSU_CSL26_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL26_LOCK_S1) & BM_CSU_CSL26_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL26_LOCK_S1(v)   (HW_CSU_CSL26_WR((HW_CSU_CSL26_RD() & ~BM_CSU_CSL26_LOCK_S1) | BF_CSU_CSL26_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL27 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL27 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl27
{
    reg32_t U;
    struct _hw_csu_csl27_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl27_t;
#endif

/*
 * constants & macros for entire CSU_CSL27 register
 */
#define HW_CSU_CSL27_ADDR      (REGS_CSU_BASE + 0x6c)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL27           (*(volatile hw_csu_csl27_t *) HW_CSU_CSL27_ADDR)
#define HW_CSU_CSL27_RD()      (HW_CSU_CSL27.U)
#define HW_CSU_CSL27_WR(v)     (HW_CSU_CSL27.U = (v))
#define HW_CSU_CSL27_SET(v)    (HW_CSU_CSL27_WR(HW_CSU_CSL27_RD() |  (v)))
#define HW_CSU_CSL27_CLR(v)    (HW_CSU_CSL27_WR(HW_CSU_CSL27_RD() & ~(v)))
#define HW_CSU_CSL27_TOG(v)    (HW_CSU_CSL27_WR(HW_CSU_CSL27_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL27 bitfields
 */

/* --- Register HW_CSU_CSL27, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL27_SUR_S2      (0)      //!< Bit position for CSU_CSL27_SUR_S2.
#define BM_CSU_CSL27_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL27_SUR_S2.

//! @brief Get value of CSU_CSL27_SUR_S2 from a register value.
#define BG_CSU_CSL27_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_SUR_S2) >> BP_CSU_CSL27_SUR_S2)

//! @brief Format value for bitfield CSU_CSL27_SUR_S2.
#define BF_CSU_CSL27_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_SUR_S2) & BM_CSU_CSL27_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL27_SUR_S2(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_SUR_S2) | BF_CSU_CSL27_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL27, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL27_SSR_S2      (1)      //!< Bit position for CSU_CSL27_SSR_S2.
#define BM_CSU_CSL27_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL27_SSR_S2.

//! @brief Get value of CSU_CSL27_SSR_S2 from a register value.
#define BG_CSU_CSL27_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_SSR_S2) >> BP_CSU_CSL27_SSR_S2)

//! @brief Format value for bitfield CSU_CSL27_SSR_S2.
#define BF_CSU_CSL27_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_SSR_S2) & BM_CSU_CSL27_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL27_SSR_S2(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_SSR_S2) | BF_CSU_CSL27_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL27, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL27_NUR_S2      (2)      //!< Bit position for CSU_CSL27_NUR_S2.
#define BM_CSU_CSL27_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL27_NUR_S2.

//! @brief Get value of CSU_CSL27_NUR_S2 from a register value.
#define BG_CSU_CSL27_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_NUR_S2) >> BP_CSU_CSL27_NUR_S2)

//! @brief Format value for bitfield CSU_CSL27_NUR_S2.
#define BF_CSU_CSL27_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_NUR_S2) & BM_CSU_CSL27_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL27_NUR_S2(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_NUR_S2) | BF_CSU_CSL27_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL27, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL27_NSR_S2      (3)      //!< Bit position for CSU_CSL27_NSR_S2.
#define BM_CSU_CSL27_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL27_NSR_S2.

//! @brief Get value of CSU_CSL27_NSR_S2 from a register value.
#define BG_CSU_CSL27_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_NSR_S2) >> BP_CSU_CSL27_NSR_S2)

//! @brief Format value for bitfield CSU_CSL27_NSR_S2.
#define BF_CSU_CSL27_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_NSR_S2) & BM_CSU_CSL27_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL27_NSR_S2(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_NSR_S2) | BF_CSU_CSL27_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL27, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL27_SUW_S2      (4)      //!< Bit position for CSU_CSL27_SUW_S2.
#define BM_CSU_CSL27_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL27_SUW_S2.

//! @brief Get value of CSU_CSL27_SUW_S2 from a register value.
#define BG_CSU_CSL27_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_SUW_S2) >> BP_CSU_CSL27_SUW_S2)

//! @brief Format value for bitfield CSU_CSL27_SUW_S2.
#define BF_CSU_CSL27_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_SUW_S2) & BM_CSU_CSL27_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL27_SUW_S2(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_SUW_S2) | BF_CSU_CSL27_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL27, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL27_SSW_S2      (5)      //!< Bit position for CSU_CSL27_SSW_S2.
#define BM_CSU_CSL27_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL27_SSW_S2.

//! @brief Get value of CSU_CSL27_SSW_S2 from a register value.
#define BG_CSU_CSL27_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_SSW_S2) >> BP_CSU_CSL27_SSW_S2)

//! @brief Format value for bitfield CSU_CSL27_SSW_S2.
#define BF_CSU_CSL27_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_SSW_S2) & BM_CSU_CSL27_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL27_SSW_S2(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_SSW_S2) | BF_CSU_CSL27_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL27, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL27_NUW_S2      (6)      //!< Bit position for CSU_CSL27_NUW_S2.
#define BM_CSU_CSL27_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL27_NUW_S2.

//! @brief Get value of CSU_CSL27_NUW_S2 from a register value.
#define BG_CSU_CSL27_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_NUW_S2) >> BP_CSU_CSL27_NUW_S2)

//! @brief Format value for bitfield CSU_CSL27_NUW_S2.
#define BF_CSU_CSL27_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_NUW_S2) & BM_CSU_CSL27_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL27_NUW_S2(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_NUW_S2) | BF_CSU_CSL27_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL27, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL27_NSW_S2      (7)      //!< Bit position for CSU_CSL27_NSW_S2.
#define BM_CSU_CSL27_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL27_NSW_S2.

//! @brief Get value of CSU_CSL27_NSW_S2 from a register value.
#define BG_CSU_CSL27_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_NSW_S2) >> BP_CSU_CSL27_NSW_S2)

//! @brief Format value for bitfield CSU_CSL27_NSW_S2.
#define BF_CSU_CSL27_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_NSW_S2) & BM_CSU_CSL27_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL27_NSW_S2(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_NSW_S2) | BF_CSU_CSL27_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL27, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL27_LOCK_S2      (8)      //!< Bit position for CSU_CSL27_LOCK_S2.
#define BM_CSU_CSL27_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL27_LOCK_S2.

//! @brief Get value of CSU_CSL27_LOCK_S2 from a register value.
#define BG_CSU_CSL27_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_LOCK_S2) >> BP_CSU_CSL27_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL27_LOCK_S2.
#define BF_CSU_CSL27_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_LOCK_S2) & BM_CSU_CSL27_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL27_LOCK_S2(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_LOCK_S2) | BF_CSU_CSL27_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL27, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL27_SUR_S1      (16)      //!< Bit position for CSU_CSL27_SUR_S1.
#define BM_CSU_CSL27_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL27_SUR_S1.

//! @brief Get value of CSU_CSL27_SUR_S1 from a register value.
#define BG_CSU_CSL27_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_SUR_S1) >> BP_CSU_CSL27_SUR_S1)

//! @brief Format value for bitfield CSU_CSL27_SUR_S1.
#define BF_CSU_CSL27_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_SUR_S1) & BM_CSU_CSL27_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL27_SUR_S1(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_SUR_S1) | BF_CSU_CSL27_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL27, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL27_SSR_S1      (17)      //!< Bit position for CSU_CSL27_SSR_S1.
#define BM_CSU_CSL27_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL27_SSR_S1.

//! @brief Get value of CSU_CSL27_SSR_S1 from a register value.
#define BG_CSU_CSL27_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_SSR_S1) >> BP_CSU_CSL27_SSR_S1)

//! @brief Format value for bitfield CSU_CSL27_SSR_S1.
#define BF_CSU_CSL27_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_SSR_S1) & BM_CSU_CSL27_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL27_SSR_S1(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_SSR_S1) | BF_CSU_CSL27_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL27, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL27_NUR_S1      (18)      //!< Bit position for CSU_CSL27_NUR_S1.
#define BM_CSU_CSL27_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL27_NUR_S1.

//! @brief Get value of CSU_CSL27_NUR_S1 from a register value.
#define BG_CSU_CSL27_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_NUR_S1) >> BP_CSU_CSL27_NUR_S1)

//! @brief Format value for bitfield CSU_CSL27_NUR_S1.
#define BF_CSU_CSL27_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_NUR_S1) & BM_CSU_CSL27_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL27_NUR_S1(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_NUR_S1) | BF_CSU_CSL27_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL27, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL27_NSR_S1      (19)      //!< Bit position for CSU_CSL27_NSR_S1.
#define BM_CSU_CSL27_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL27_NSR_S1.

//! @brief Get value of CSU_CSL27_NSR_S1 from a register value.
#define BG_CSU_CSL27_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_NSR_S1) >> BP_CSU_CSL27_NSR_S1)

//! @brief Format value for bitfield CSU_CSL27_NSR_S1.
#define BF_CSU_CSL27_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_NSR_S1) & BM_CSU_CSL27_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL27_NSR_S1(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_NSR_S1) | BF_CSU_CSL27_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL27, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL27_SUW_S1      (20)      //!< Bit position for CSU_CSL27_SUW_S1.
#define BM_CSU_CSL27_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL27_SUW_S1.

//! @brief Get value of CSU_CSL27_SUW_S1 from a register value.
#define BG_CSU_CSL27_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_SUW_S1) >> BP_CSU_CSL27_SUW_S1)

//! @brief Format value for bitfield CSU_CSL27_SUW_S1.
#define BF_CSU_CSL27_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_SUW_S1) & BM_CSU_CSL27_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL27_SUW_S1(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_SUW_S1) | BF_CSU_CSL27_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL27, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL27_SSW_S1      (21)      //!< Bit position for CSU_CSL27_SSW_S1.
#define BM_CSU_CSL27_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL27_SSW_S1.

//! @brief Get value of CSU_CSL27_SSW_S1 from a register value.
#define BG_CSU_CSL27_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_SSW_S1) >> BP_CSU_CSL27_SSW_S1)

//! @brief Format value for bitfield CSU_CSL27_SSW_S1.
#define BF_CSU_CSL27_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_SSW_S1) & BM_CSU_CSL27_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL27_SSW_S1(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_SSW_S1) | BF_CSU_CSL27_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL27, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL27_NUW_S1      (22)      //!< Bit position for CSU_CSL27_NUW_S1.
#define BM_CSU_CSL27_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL27_NUW_S1.

//! @brief Get value of CSU_CSL27_NUW_S1 from a register value.
#define BG_CSU_CSL27_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_NUW_S1) >> BP_CSU_CSL27_NUW_S1)

//! @brief Format value for bitfield CSU_CSL27_NUW_S1.
#define BF_CSU_CSL27_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_NUW_S1) & BM_CSU_CSL27_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL27_NUW_S1(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_NUW_S1) | BF_CSU_CSL27_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL27, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL27_NSW_S1      (23)      //!< Bit position for CSU_CSL27_NSW_S1.
#define BM_CSU_CSL27_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL27_NSW_S1.

//! @brief Get value of CSU_CSL27_NSW_S1 from a register value.
#define BG_CSU_CSL27_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_NSW_S1) >> BP_CSU_CSL27_NSW_S1)

//! @brief Format value for bitfield CSU_CSL27_NSW_S1.
#define BF_CSU_CSL27_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_NSW_S1) & BM_CSU_CSL27_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL27_NSW_S1(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_NSW_S1) | BF_CSU_CSL27_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL27, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL27_LOCK_S1      (24)      //!< Bit position for CSU_CSL27_LOCK_S1.
#define BM_CSU_CSL27_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL27_LOCK_S1.

//! @brief Get value of CSU_CSL27_LOCK_S1 from a register value.
#define BG_CSU_CSL27_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL27_LOCK_S1) >> BP_CSU_CSL27_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL27_LOCK_S1.
#define BF_CSU_CSL27_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL27_LOCK_S1) & BM_CSU_CSL27_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL27_LOCK_S1(v)   (HW_CSU_CSL27_WR((HW_CSU_CSL27_RD() & ~BM_CSU_CSL27_LOCK_S1) | BF_CSU_CSL27_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL28 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL28 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl28
{
    reg32_t U;
    struct _hw_csu_csl28_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl28_t;
#endif

/*
 * constants & macros for entire CSU_CSL28 register
 */
#define HW_CSU_CSL28_ADDR      (REGS_CSU_BASE + 0x70)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL28           (*(volatile hw_csu_csl28_t *) HW_CSU_CSL28_ADDR)
#define HW_CSU_CSL28_RD()      (HW_CSU_CSL28.U)
#define HW_CSU_CSL28_WR(v)     (HW_CSU_CSL28.U = (v))
#define HW_CSU_CSL28_SET(v)    (HW_CSU_CSL28_WR(HW_CSU_CSL28_RD() |  (v)))
#define HW_CSU_CSL28_CLR(v)    (HW_CSU_CSL28_WR(HW_CSU_CSL28_RD() & ~(v)))
#define HW_CSU_CSL28_TOG(v)    (HW_CSU_CSL28_WR(HW_CSU_CSL28_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL28 bitfields
 */

/* --- Register HW_CSU_CSL28, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL28_SUR_S2      (0)      //!< Bit position for CSU_CSL28_SUR_S2.
#define BM_CSU_CSL28_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL28_SUR_S2.

//! @brief Get value of CSU_CSL28_SUR_S2 from a register value.
#define BG_CSU_CSL28_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_SUR_S2) >> BP_CSU_CSL28_SUR_S2)

//! @brief Format value for bitfield CSU_CSL28_SUR_S2.
#define BF_CSU_CSL28_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_SUR_S2) & BM_CSU_CSL28_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL28_SUR_S2(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_SUR_S2) | BF_CSU_CSL28_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL28, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL28_SSR_S2      (1)      //!< Bit position for CSU_CSL28_SSR_S2.
#define BM_CSU_CSL28_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL28_SSR_S2.

//! @brief Get value of CSU_CSL28_SSR_S2 from a register value.
#define BG_CSU_CSL28_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_SSR_S2) >> BP_CSU_CSL28_SSR_S2)

//! @brief Format value for bitfield CSU_CSL28_SSR_S2.
#define BF_CSU_CSL28_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_SSR_S2) & BM_CSU_CSL28_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL28_SSR_S2(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_SSR_S2) | BF_CSU_CSL28_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL28, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL28_NUR_S2      (2)      //!< Bit position for CSU_CSL28_NUR_S2.
#define BM_CSU_CSL28_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL28_NUR_S2.

//! @brief Get value of CSU_CSL28_NUR_S2 from a register value.
#define BG_CSU_CSL28_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_NUR_S2) >> BP_CSU_CSL28_NUR_S2)

//! @brief Format value for bitfield CSU_CSL28_NUR_S2.
#define BF_CSU_CSL28_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_NUR_S2) & BM_CSU_CSL28_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL28_NUR_S2(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_NUR_S2) | BF_CSU_CSL28_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL28, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL28_NSR_S2      (3)      //!< Bit position for CSU_CSL28_NSR_S2.
#define BM_CSU_CSL28_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL28_NSR_S2.

//! @brief Get value of CSU_CSL28_NSR_S2 from a register value.
#define BG_CSU_CSL28_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_NSR_S2) >> BP_CSU_CSL28_NSR_S2)

//! @brief Format value for bitfield CSU_CSL28_NSR_S2.
#define BF_CSU_CSL28_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_NSR_S2) & BM_CSU_CSL28_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL28_NSR_S2(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_NSR_S2) | BF_CSU_CSL28_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL28, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL28_SUW_S2      (4)      //!< Bit position for CSU_CSL28_SUW_S2.
#define BM_CSU_CSL28_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL28_SUW_S2.

//! @brief Get value of CSU_CSL28_SUW_S2 from a register value.
#define BG_CSU_CSL28_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_SUW_S2) >> BP_CSU_CSL28_SUW_S2)

//! @brief Format value for bitfield CSU_CSL28_SUW_S2.
#define BF_CSU_CSL28_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_SUW_S2) & BM_CSU_CSL28_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL28_SUW_S2(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_SUW_S2) | BF_CSU_CSL28_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL28, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL28_SSW_S2      (5)      //!< Bit position for CSU_CSL28_SSW_S2.
#define BM_CSU_CSL28_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL28_SSW_S2.

//! @brief Get value of CSU_CSL28_SSW_S2 from a register value.
#define BG_CSU_CSL28_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_SSW_S2) >> BP_CSU_CSL28_SSW_S2)

//! @brief Format value for bitfield CSU_CSL28_SSW_S2.
#define BF_CSU_CSL28_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_SSW_S2) & BM_CSU_CSL28_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL28_SSW_S2(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_SSW_S2) | BF_CSU_CSL28_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL28, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL28_NUW_S2      (6)      //!< Bit position for CSU_CSL28_NUW_S2.
#define BM_CSU_CSL28_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL28_NUW_S2.

//! @brief Get value of CSU_CSL28_NUW_S2 from a register value.
#define BG_CSU_CSL28_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_NUW_S2) >> BP_CSU_CSL28_NUW_S2)

//! @brief Format value for bitfield CSU_CSL28_NUW_S2.
#define BF_CSU_CSL28_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_NUW_S2) & BM_CSU_CSL28_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL28_NUW_S2(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_NUW_S2) | BF_CSU_CSL28_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL28, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL28_NSW_S2      (7)      //!< Bit position for CSU_CSL28_NSW_S2.
#define BM_CSU_CSL28_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL28_NSW_S2.

//! @brief Get value of CSU_CSL28_NSW_S2 from a register value.
#define BG_CSU_CSL28_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_NSW_S2) >> BP_CSU_CSL28_NSW_S2)

//! @brief Format value for bitfield CSU_CSL28_NSW_S2.
#define BF_CSU_CSL28_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_NSW_S2) & BM_CSU_CSL28_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL28_NSW_S2(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_NSW_S2) | BF_CSU_CSL28_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL28, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL28_LOCK_S2      (8)      //!< Bit position for CSU_CSL28_LOCK_S2.
#define BM_CSU_CSL28_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL28_LOCK_S2.

//! @brief Get value of CSU_CSL28_LOCK_S2 from a register value.
#define BG_CSU_CSL28_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_LOCK_S2) >> BP_CSU_CSL28_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL28_LOCK_S2.
#define BF_CSU_CSL28_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_LOCK_S2) & BM_CSU_CSL28_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL28_LOCK_S2(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_LOCK_S2) | BF_CSU_CSL28_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL28, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL28_SUR_S1      (16)      //!< Bit position for CSU_CSL28_SUR_S1.
#define BM_CSU_CSL28_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL28_SUR_S1.

//! @brief Get value of CSU_CSL28_SUR_S1 from a register value.
#define BG_CSU_CSL28_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_SUR_S1) >> BP_CSU_CSL28_SUR_S1)

//! @brief Format value for bitfield CSU_CSL28_SUR_S1.
#define BF_CSU_CSL28_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_SUR_S1) & BM_CSU_CSL28_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL28_SUR_S1(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_SUR_S1) | BF_CSU_CSL28_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL28, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL28_SSR_S1      (17)      //!< Bit position for CSU_CSL28_SSR_S1.
#define BM_CSU_CSL28_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL28_SSR_S1.

//! @brief Get value of CSU_CSL28_SSR_S1 from a register value.
#define BG_CSU_CSL28_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_SSR_S1) >> BP_CSU_CSL28_SSR_S1)

//! @brief Format value for bitfield CSU_CSL28_SSR_S1.
#define BF_CSU_CSL28_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_SSR_S1) & BM_CSU_CSL28_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL28_SSR_S1(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_SSR_S1) | BF_CSU_CSL28_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL28, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL28_NUR_S1      (18)      //!< Bit position for CSU_CSL28_NUR_S1.
#define BM_CSU_CSL28_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL28_NUR_S1.

//! @brief Get value of CSU_CSL28_NUR_S1 from a register value.
#define BG_CSU_CSL28_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_NUR_S1) >> BP_CSU_CSL28_NUR_S1)

//! @brief Format value for bitfield CSU_CSL28_NUR_S1.
#define BF_CSU_CSL28_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_NUR_S1) & BM_CSU_CSL28_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL28_NUR_S1(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_NUR_S1) | BF_CSU_CSL28_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL28, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL28_NSR_S1      (19)      //!< Bit position for CSU_CSL28_NSR_S1.
#define BM_CSU_CSL28_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL28_NSR_S1.

//! @brief Get value of CSU_CSL28_NSR_S1 from a register value.
#define BG_CSU_CSL28_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_NSR_S1) >> BP_CSU_CSL28_NSR_S1)

//! @brief Format value for bitfield CSU_CSL28_NSR_S1.
#define BF_CSU_CSL28_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_NSR_S1) & BM_CSU_CSL28_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL28_NSR_S1(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_NSR_S1) | BF_CSU_CSL28_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL28, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL28_SUW_S1      (20)      //!< Bit position for CSU_CSL28_SUW_S1.
#define BM_CSU_CSL28_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL28_SUW_S1.

//! @brief Get value of CSU_CSL28_SUW_S1 from a register value.
#define BG_CSU_CSL28_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_SUW_S1) >> BP_CSU_CSL28_SUW_S1)

//! @brief Format value for bitfield CSU_CSL28_SUW_S1.
#define BF_CSU_CSL28_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_SUW_S1) & BM_CSU_CSL28_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL28_SUW_S1(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_SUW_S1) | BF_CSU_CSL28_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL28, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL28_SSW_S1      (21)      //!< Bit position for CSU_CSL28_SSW_S1.
#define BM_CSU_CSL28_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL28_SSW_S1.

//! @brief Get value of CSU_CSL28_SSW_S1 from a register value.
#define BG_CSU_CSL28_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_SSW_S1) >> BP_CSU_CSL28_SSW_S1)

//! @brief Format value for bitfield CSU_CSL28_SSW_S1.
#define BF_CSU_CSL28_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_SSW_S1) & BM_CSU_CSL28_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL28_SSW_S1(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_SSW_S1) | BF_CSU_CSL28_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL28, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL28_NUW_S1      (22)      //!< Bit position for CSU_CSL28_NUW_S1.
#define BM_CSU_CSL28_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL28_NUW_S1.

//! @brief Get value of CSU_CSL28_NUW_S1 from a register value.
#define BG_CSU_CSL28_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_NUW_S1) >> BP_CSU_CSL28_NUW_S1)

//! @brief Format value for bitfield CSU_CSL28_NUW_S1.
#define BF_CSU_CSL28_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_NUW_S1) & BM_CSU_CSL28_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL28_NUW_S1(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_NUW_S1) | BF_CSU_CSL28_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL28, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL28_NSW_S1      (23)      //!< Bit position for CSU_CSL28_NSW_S1.
#define BM_CSU_CSL28_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL28_NSW_S1.

//! @brief Get value of CSU_CSL28_NSW_S1 from a register value.
#define BG_CSU_CSL28_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_NSW_S1) >> BP_CSU_CSL28_NSW_S1)

//! @brief Format value for bitfield CSU_CSL28_NSW_S1.
#define BF_CSU_CSL28_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_NSW_S1) & BM_CSU_CSL28_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL28_NSW_S1(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_NSW_S1) | BF_CSU_CSL28_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL28, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL28_LOCK_S1      (24)      //!< Bit position for CSU_CSL28_LOCK_S1.
#define BM_CSU_CSL28_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL28_LOCK_S1.

//! @brief Get value of CSU_CSL28_LOCK_S1 from a register value.
#define BG_CSU_CSL28_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL28_LOCK_S1) >> BP_CSU_CSL28_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL28_LOCK_S1.
#define BF_CSU_CSL28_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL28_LOCK_S1) & BM_CSU_CSL28_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL28_LOCK_S1(v)   (HW_CSU_CSL28_WR((HW_CSU_CSL28_RD() & ~BM_CSU_CSL28_LOCK_S1) | BF_CSU_CSL28_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL29 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL29 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl29
{
    reg32_t U;
    struct _hw_csu_csl29_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl29_t;
#endif

/*
 * constants & macros for entire CSU_CSL29 register
 */
#define HW_CSU_CSL29_ADDR      (REGS_CSU_BASE + 0x74)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL29           (*(volatile hw_csu_csl29_t *) HW_CSU_CSL29_ADDR)
#define HW_CSU_CSL29_RD()      (HW_CSU_CSL29.U)
#define HW_CSU_CSL29_WR(v)     (HW_CSU_CSL29.U = (v))
#define HW_CSU_CSL29_SET(v)    (HW_CSU_CSL29_WR(HW_CSU_CSL29_RD() |  (v)))
#define HW_CSU_CSL29_CLR(v)    (HW_CSU_CSL29_WR(HW_CSU_CSL29_RD() & ~(v)))
#define HW_CSU_CSL29_TOG(v)    (HW_CSU_CSL29_WR(HW_CSU_CSL29_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL29 bitfields
 */

/* --- Register HW_CSU_CSL29, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL29_SUR_S2      (0)      //!< Bit position for CSU_CSL29_SUR_S2.
#define BM_CSU_CSL29_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL29_SUR_S2.

//! @brief Get value of CSU_CSL29_SUR_S2 from a register value.
#define BG_CSU_CSL29_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_SUR_S2) >> BP_CSU_CSL29_SUR_S2)

//! @brief Format value for bitfield CSU_CSL29_SUR_S2.
#define BF_CSU_CSL29_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_SUR_S2) & BM_CSU_CSL29_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL29_SUR_S2(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_SUR_S2) | BF_CSU_CSL29_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL29, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL29_SSR_S2      (1)      //!< Bit position for CSU_CSL29_SSR_S2.
#define BM_CSU_CSL29_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL29_SSR_S2.

//! @brief Get value of CSU_CSL29_SSR_S2 from a register value.
#define BG_CSU_CSL29_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_SSR_S2) >> BP_CSU_CSL29_SSR_S2)

//! @brief Format value for bitfield CSU_CSL29_SSR_S2.
#define BF_CSU_CSL29_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_SSR_S2) & BM_CSU_CSL29_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL29_SSR_S2(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_SSR_S2) | BF_CSU_CSL29_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL29, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL29_NUR_S2      (2)      //!< Bit position for CSU_CSL29_NUR_S2.
#define BM_CSU_CSL29_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL29_NUR_S2.

//! @brief Get value of CSU_CSL29_NUR_S2 from a register value.
#define BG_CSU_CSL29_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_NUR_S2) >> BP_CSU_CSL29_NUR_S2)

//! @brief Format value for bitfield CSU_CSL29_NUR_S2.
#define BF_CSU_CSL29_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_NUR_S2) & BM_CSU_CSL29_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL29_NUR_S2(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_NUR_S2) | BF_CSU_CSL29_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL29, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL29_NSR_S2      (3)      //!< Bit position for CSU_CSL29_NSR_S2.
#define BM_CSU_CSL29_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL29_NSR_S2.

//! @brief Get value of CSU_CSL29_NSR_S2 from a register value.
#define BG_CSU_CSL29_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_NSR_S2) >> BP_CSU_CSL29_NSR_S2)

//! @brief Format value for bitfield CSU_CSL29_NSR_S2.
#define BF_CSU_CSL29_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_NSR_S2) & BM_CSU_CSL29_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL29_NSR_S2(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_NSR_S2) | BF_CSU_CSL29_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL29, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL29_SUW_S2      (4)      //!< Bit position for CSU_CSL29_SUW_S2.
#define BM_CSU_CSL29_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL29_SUW_S2.

//! @brief Get value of CSU_CSL29_SUW_S2 from a register value.
#define BG_CSU_CSL29_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_SUW_S2) >> BP_CSU_CSL29_SUW_S2)

//! @brief Format value for bitfield CSU_CSL29_SUW_S2.
#define BF_CSU_CSL29_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_SUW_S2) & BM_CSU_CSL29_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL29_SUW_S2(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_SUW_S2) | BF_CSU_CSL29_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL29, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL29_SSW_S2      (5)      //!< Bit position for CSU_CSL29_SSW_S2.
#define BM_CSU_CSL29_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL29_SSW_S2.

//! @brief Get value of CSU_CSL29_SSW_S2 from a register value.
#define BG_CSU_CSL29_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_SSW_S2) >> BP_CSU_CSL29_SSW_S2)

//! @brief Format value for bitfield CSU_CSL29_SSW_S2.
#define BF_CSU_CSL29_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_SSW_S2) & BM_CSU_CSL29_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL29_SSW_S2(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_SSW_S2) | BF_CSU_CSL29_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL29, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL29_NUW_S2      (6)      //!< Bit position for CSU_CSL29_NUW_S2.
#define BM_CSU_CSL29_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL29_NUW_S2.

//! @brief Get value of CSU_CSL29_NUW_S2 from a register value.
#define BG_CSU_CSL29_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_NUW_S2) >> BP_CSU_CSL29_NUW_S2)

//! @brief Format value for bitfield CSU_CSL29_NUW_S2.
#define BF_CSU_CSL29_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_NUW_S2) & BM_CSU_CSL29_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL29_NUW_S2(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_NUW_S2) | BF_CSU_CSL29_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL29, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL29_NSW_S2      (7)      //!< Bit position for CSU_CSL29_NSW_S2.
#define BM_CSU_CSL29_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL29_NSW_S2.

//! @brief Get value of CSU_CSL29_NSW_S2 from a register value.
#define BG_CSU_CSL29_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_NSW_S2) >> BP_CSU_CSL29_NSW_S2)

//! @brief Format value for bitfield CSU_CSL29_NSW_S2.
#define BF_CSU_CSL29_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_NSW_S2) & BM_CSU_CSL29_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL29_NSW_S2(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_NSW_S2) | BF_CSU_CSL29_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL29, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL29_LOCK_S2      (8)      //!< Bit position for CSU_CSL29_LOCK_S2.
#define BM_CSU_CSL29_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL29_LOCK_S2.

//! @brief Get value of CSU_CSL29_LOCK_S2 from a register value.
#define BG_CSU_CSL29_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_LOCK_S2) >> BP_CSU_CSL29_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL29_LOCK_S2.
#define BF_CSU_CSL29_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_LOCK_S2) & BM_CSU_CSL29_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL29_LOCK_S2(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_LOCK_S2) | BF_CSU_CSL29_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL29, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL29_SUR_S1      (16)      //!< Bit position for CSU_CSL29_SUR_S1.
#define BM_CSU_CSL29_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL29_SUR_S1.

//! @brief Get value of CSU_CSL29_SUR_S1 from a register value.
#define BG_CSU_CSL29_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_SUR_S1) >> BP_CSU_CSL29_SUR_S1)

//! @brief Format value for bitfield CSU_CSL29_SUR_S1.
#define BF_CSU_CSL29_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_SUR_S1) & BM_CSU_CSL29_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL29_SUR_S1(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_SUR_S1) | BF_CSU_CSL29_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL29, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL29_SSR_S1      (17)      //!< Bit position for CSU_CSL29_SSR_S1.
#define BM_CSU_CSL29_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL29_SSR_S1.

//! @brief Get value of CSU_CSL29_SSR_S1 from a register value.
#define BG_CSU_CSL29_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_SSR_S1) >> BP_CSU_CSL29_SSR_S1)

//! @brief Format value for bitfield CSU_CSL29_SSR_S1.
#define BF_CSU_CSL29_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_SSR_S1) & BM_CSU_CSL29_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL29_SSR_S1(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_SSR_S1) | BF_CSU_CSL29_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL29, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL29_NUR_S1      (18)      //!< Bit position for CSU_CSL29_NUR_S1.
#define BM_CSU_CSL29_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL29_NUR_S1.

//! @brief Get value of CSU_CSL29_NUR_S1 from a register value.
#define BG_CSU_CSL29_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_NUR_S1) >> BP_CSU_CSL29_NUR_S1)

//! @brief Format value for bitfield CSU_CSL29_NUR_S1.
#define BF_CSU_CSL29_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_NUR_S1) & BM_CSU_CSL29_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL29_NUR_S1(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_NUR_S1) | BF_CSU_CSL29_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL29, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL29_NSR_S1      (19)      //!< Bit position for CSU_CSL29_NSR_S1.
#define BM_CSU_CSL29_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL29_NSR_S1.

//! @brief Get value of CSU_CSL29_NSR_S1 from a register value.
#define BG_CSU_CSL29_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_NSR_S1) >> BP_CSU_CSL29_NSR_S1)

//! @brief Format value for bitfield CSU_CSL29_NSR_S1.
#define BF_CSU_CSL29_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_NSR_S1) & BM_CSU_CSL29_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL29_NSR_S1(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_NSR_S1) | BF_CSU_CSL29_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL29, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL29_SUW_S1      (20)      //!< Bit position for CSU_CSL29_SUW_S1.
#define BM_CSU_CSL29_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL29_SUW_S1.

//! @brief Get value of CSU_CSL29_SUW_S1 from a register value.
#define BG_CSU_CSL29_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_SUW_S1) >> BP_CSU_CSL29_SUW_S1)

//! @brief Format value for bitfield CSU_CSL29_SUW_S1.
#define BF_CSU_CSL29_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_SUW_S1) & BM_CSU_CSL29_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL29_SUW_S1(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_SUW_S1) | BF_CSU_CSL29_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL29, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL29_SSW_S1      (21)      //!< Bit position for CSU_CSL29_SSW_S1.
#define BM_CSU_CSL29_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL29_SSW_S1.

//! @brief Get value of CSU_CSL29_SSW_S1 from a register value.
#define BG_CSU_CSL29_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_SSW_S1) >> BP_CSU_CSL29_SSW_S1)

//! @brief Format value for bitfield CSU_CSL29_SSW_S1.
#define BF_CSU_CSL29_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_SSW_S1) & BM_CSU_CSL29_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL29_SSW_S1(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_SSW_S1) | BF_CSU_CSL29_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL29, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL29_NUW_S1      (22)      //!< Bit position for CSU_CSL29_NUW_S1.
#define BM_CSU_CSL29_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL29_NUW_S1.

//! @brief Get value of CSU_CSL29_NUW_S1 from a register value.
#define BG_CSU_CSL29_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_NUW_S1) >> BP_CSU_CSL29_NUW_S1)

//! @brief Format value for bitfield CSU_CSL29_NUW_S1.
#define BF_CSU_CSL29_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_NUW_S1) & BM_CSU_CSL29_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL29_NUW_S1(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_NUW_S1) | BF_CSU_CSL29_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL29, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL29_NSW_S1      (23)      //!< Bit position for CSU_CSL29_NSW_S1.
#define BM_CSU_CSL29_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL29_NSW_S1.

//! @brief Get value of CSU_CSL29_NSW_S1 from a register value.
#define BG_CSU_CSL29_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_NSW_S1) >> BP_CSU_CSL29_NSW_S1)

//! @brief Format value for bitfield CSU_CSL29_NSW_S1.
#define BF_CSU_CSL29_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_NSW_S1) & BM_CSU_CSL29_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL29_NSW_S1(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_NSW_S1) | BF_CSU_CSL29_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL29, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL29_LOCK_S1      (24)      //!< Bit position for CSU_CSL29_LOCK_S1.
#define BM_CSU_CSL29_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL29_LOCK_S1.

//! @brief Get value of CSU_CSL29_LOCK_S1 from a register value.
#define BG_CSU_CSL29_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL29_LOCK_S1) >> BP_CSU_CSL29_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL29_LOCK_S1.
#define BF_CSU_CSL29_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL29_LOCK_S1) & BM_CSU_CSL29_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL29_LOCK_S1(v)   (HW_CSU_CSL29_WR((HW_CSU_CSL29_RD() & ~BM_CSU_CSL29_LOCK_S1) | BF_CSU_CSL29_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL30 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL30 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl30
{
    reg32_t U;
    struct _hw_csu_csl30_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl30_t;
#endif

/*
 * constants & macros for entire CSU_CSL30 register
 */
#define HW_CSU_CSL30_ADDR      (REGS_CSU_BASE + 0x78)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL30           (*(volatile hw_csu_csl30_t *) HW_CSU_CSL30_ADDR)
#define HW_CSU_CSL30_RD()      (HW_CSU_CSL30.U)
#define HW_CSU_CSL30_WR(v)     (HW_CSU_CSL30.U = (v))
#define HW_CSU_CSL30_SET(v)    (HW_CSU_CSL30_WR(HW_CSU_CSL30_RD() |  (v)))
#define HW_CSU_CSL30_CLR(v)    (HW_CSU_CSL30_WR(HW_CSU_CSL30_RD() & ~(v)))
#define HW_CSU_CSL30_TOG(v)    (HW_CSU_CSL30_WR(HW_CSU_CSL30_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL30 bitfields
 */

/* --- Register HW_CSU_CSL30, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL30_SUR_S2      (0)      //!< Bit position for CSU_CSL30_SUR_S2.
#define BM_CSU_CSL30_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL30_SUR_S2.

//! @brief Get value of CSU_CSL30_SUR_S2 from a register value.
#define BG_CSU_CSL30_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_SUR_S2) >> BP_CSU_CSL30_SUR_S2)

//! @brief Format value for bitfield CSU_CSL30_SUR_S2.
#define BF_CSU_CSL30_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_SUR_S2) & BM_CSU_CSL30_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL30_SUR_S2(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_SUR_S2) | BF_CSU_CSL30_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL30, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL30_SSR_S2      (1)      //!< Bit position for CSU_CSL30_SSR_S2.
#define BM_CSU_CSL30_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL30_SSR_S2.

//! @brief Get value of CSU_CSL30_SSR_S2 from a register value.
#define BG_CSU_CSL30_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_SSR_S2) >> BP_CSU_CSL30_SSR_S2)

//! @brief Format value for bitfield CSU_CSL30_SSR_S2.
#define BF_CSU_CSL30_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_SSR_S2) & BM_CSU_CSL30_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL30_SSR_S2(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_SSR_S2) | BF_CSU_CSL30_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL30, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL30_NUR_S2      (2)      //!< Bit position for CSU_CSL30_NUR_S2.
#define BM_CSU_CSL30_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL30_NUR_S2.

//! @brief Get value of CSU_CSL30_NUR_S2 from a register value.
#define BG_CSU_CSL30_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_NUR_S2) >> BP_CSU_CSL30_NUR_S2)

//! @brief Format value for bitfield CSU_CSL30_NUR_S2.
#define BF_CSU_CSL30_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_NUR_S2) & BM_CSU_CSL30_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL30_NUR_S2(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_NUR_S2) | BF_CSU_CSL30_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL30, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL30_NSR_S2      (3)      //!< Bit position for CSU_CSL30_NSR_S2.
#define BM_CSU_CSL30_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL30_NSR_S2.

//! @brief Get value of CSU_CSL30_NSR_S2 from a register value.
#define BG_CSU_CSL30_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_NSR_S2) >> BP_CSU_CSL30_NSR_S2)

//! @brief Format value for bitfield CSU_CSL30_NSR_S2.
#define BF_CSU_CSL30_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_NSR_S2) & BM_CSU_CSL30_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL30_NSR_S2(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_NSR_S2) | BF_CSU_CSL30_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL30, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL30_SUW_S2      (4)      //!< Bit position for CSU_CSL30_SUW_S2.
#define BM_CSU_CSL30_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL30_SUW_S2.

//! @brief Get value of CSU_CSL30_SUW_S2 from a register value.
#define BG_CSU_CSL30_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_SUW_S2) >> BP_CSU_CSL30_SUW_S2)

//! @brief Format value for bitfield CSU_CSL30_SUW_S2.
#define BF_CSU_CSL30_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_SUW_S2) & BM_CSU_CSL30_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL30_SUW_S2(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_SUW_S2) | BF_CSU_CSL30_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL30, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL30_SSW_S2      (5)      //!< Bit position for CSU_CSL30_SSW_S2.
#define BM_CSU_CSL30_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL30_SSW_S2.

//! @brief Get value of CSU_CSL30_SSW_S2 from a register value.
#define BG_CSU_CSL30_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_SSW_S2) >> BP_CSU_CSL30_SSW_S2)

//! @brief Format value for bitfield CSU_CSL30_SSW_S2.
#define BF_CSU_CSL30_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_SSW_S2) & BM_CSU_CSL30_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL30_SSW_S2(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_SSW_S2) | BF_CSU_CSL30_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL30, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL30_NUW_S2      (6)      //!< Bit position for CSU_CSL30_NUW_S2.
#define BM_CSU_CSL30_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL30_NUW_S2.

//! @brief Get value of CSU_CSL30_NUW_S2 from a register value.
#define BG_CSU_CSL30_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_NUW_S2) >> BP_CSU_CSL30_NUW_S2)

//! @brief Format value for bitfield CSU_CSL30_NUW_S2.
#define BF_CSU_CSL30_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_NUW_S2) & BM_CSU_CSL30_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL30_NUW_S2(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_NUW_S2) | BF_CSU_CSL30_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL30, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL30_NSW_S2      (7)      //!< Bit position for CSU_CSL30_NSW_S2.
#define BM_CSU_CSL30_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL30_NSW_S2.

//! @brief Get value of CSU_CSL30_NSW_S2 from a register value.
#define BG_CSU_CSL30_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_NSW_S2) >> BP_CSU_CSL30_NSW_S2)

//! @brief Format value for bitfield CSU_CSL30_NSW_S2.
#define BF_CSU_CSL30_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_NSW_S2) & BM_CSU_CSL30_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL30_NSW_S2(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_NSW_S2) | BF_CSU_CSL30_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL30, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL30_LOCK_S2      (8)      //!< Bit position for CSU_CSL30_LOCK_S2.
#define BM_CSU_CSL30_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL30_LOCK_S2.

//! @brief Get value of CSU_CSL30_LOCK_S2 from a register value.
#define BG_CSU_CSL30_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_LOCK_S2) >> BP_CSU_CSL30_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL30_LOCK_S2.
#define BF_CSU_CSL30_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_LOCK_S2) & BM_CSU_CSL30_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL30_LOCK_S2(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_LOCK_S2) | BF_CSU_CSL30_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL30, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL30_SUR_S1      (16)      //!< Bit position for CSU_CSL30_SUR_S1.
#define BM_CSU_CSL30_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL30_SUR_S1.

//! @brief Get value of CSU_CSL30_SUR_S1 from a register value.
#define BG_CSU_CSL30_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_SUR_S1) >> BP_CSU_CSL30_SUR_S1)

//! @brief Format value for bitfield CSU_CSL30_SUR_S1.
#define BF_CSU_CSL30_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_SUR_S1) & BM_CSU_CSL30_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL30_SUR_S1(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_SUR_S1) | BF_CSU_CSL30_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL30, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL30_SSR_S1      (17)      //!< Bit position for CSU_CSL30_SSR_S1.
#define BM_CSU_CSL30_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL30_SSR_S1.

//! @brief Get value of CSU_CSL30_SSR_S1 from a register value.
#define BG_CSU_CSL30_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_SSR_S1) >> BP_CSU_CSL30_SSR_S1)

//! @brief Format value for bitfield CSU_CSL30_SSR_S1.
#define BF_CSU_CSL30_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_SSR_S1) & BM_CSU_CSL30_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL30_SSR_S1(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_SSR_S1) | BF_CSU_CSL30_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL30, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL30_NUR_S1      (18)      //!< Bit position for CSU_CSL30_NUR_S1.
#define BM_CSU_CSL30_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL30_NUR_S1.

//! @brief Get value of CSU_CSL30_NUR_S1 from a register value.
#define BG_CSU_CSL30_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_NUR_S1) >> BP_CSU_CSL30_NUR_S1)

//! @brief Format value for bitfield CSU_CSL30_NUR_S1.
#define BF_CSU_CSL30_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_NUR_S1) & BM_CSU_CSL30_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL30_NUR_S1(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_NUR_S1) | BF_CSU_CSL30_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL30, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL30_NSR_S1      (19)      //!< Bit position for CSU_CSL30_NSR_S1.
#define BM_CSU_CSL30_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL30_NSR_S1.

//! @brief Get value of CSU_CSL30_NSR_S1 from a register value.
#define BG_CSU_CSL30_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_NSR_S1) >> BP_CSU_CSL30_NSR_S1)

//! @brief Format value for bitfield CSU_CSL30_NSR_S1.
#define BF_CSU_CSL30_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_NSR_S1) & BM_CSU_CSL30_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL30_NSR_S1(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_NSR_S1) | BF_CSU_CSL30_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL30, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL30_SUW_S1      (20)      //!< Bit position for CSU_CSL30_SUW_S1.
#define BM_CSU_CSL30_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL30_SUW_S1.

//! @brief Get value of CSU_CSL30_SUW_S1 from a register value.
#define BG_CSU_CSL30_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_SUW_S1) >> BP_CSU_CSL30_SUW_S1)

//! @brief Format value for bitfield CSU_CSL30_SUW_S1.
#define BF_CSU_CSL30_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_SUW_S1) & BM_CSU_CSL30_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL30_SUW_S1(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_SUW_S1) | BF_CSU_CSL30_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL30, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL30_SSW_S1      (21)      //!< Bit position for CSU_CSL30_SSW_S1.
#define BM_CSU_CSL30_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL30_SSW_S1.

//! @brief Get value of CSU_CSL30_SSW_S1 from a register value.
#define BG_CSU_CSL30_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_SSW_S1) >> BP_CSU_CSL30_SSW_S1)

//! @brief Format value for bitfield CSU_CSL30_SSW_S1.
#define BF_CSU_CSL30_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_SSW_S1) & BM_CSU_CSL30_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL30_SSW_S1(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_SSW_S1) | BF_CSU_CSL30_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL30, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL30_NUW_S1      (22)      //!< Bit position for CSU_CSL30_NUW_S1.
#define BM_CSU_CSL30_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL30_NUW_S1.

//! @brief Get value of CSU_CSL30_NUW_S1 from a register value.
#define BG_CSU_CSL30_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_NUW_S1) >> BP_CSU_CSL30_NUW_S1)

//! @brief Format value for bitfield CSU_CSL30_NUW_S1.
#define BF_CSU_CSL30_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_NUW_S1) & BM_CSU_CSL30_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL30_NUW_S1(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_NUW_S1) | BF_CSU_CSL30_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL30, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL30_NSW_S1      (23)      //!< Bit position for CSU_CSL30_NSW_S1.
#define BM_CSU_CSL30_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL30_NSW_S1.

//! @brief Get value of CSU_CSL30_NSW_S1 from a register value.
#define BG_CSU_CSL30_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_NSW_S1) >> BP_CSU_CSL30_NSW_S1)

//! @brief Format value for bitfield CSU_CSL30_NSW_S1.
#define BF_CSU_CSL30_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_NSW_S1) & BM_CSU_CSL30_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL30_NSW_S1(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_NSW_S1) | BF_CSU_CSL30_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL30, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL30_LOCK_S1      (24)      //!< Bit position for CSU_CSL30_LOCK_S1.
#define BM_CSU_CSL30_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL30_LOCK_S1.

//! @brief Get value of CSU_CSL30_LOCK_S1 from a register value.
#define BG_CSU_CSL30_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL30_LOCK_S1) >> BP_CSU_CSL30_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL30_LOCK_S1.
#define BF_CSU_CSL30_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL30_LOCK_S1) & BM_CSU_CSL30_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL30_LOCK_S1(v)   (HW_CSU_CSL30_WR((HW_CSU_CSL30_RD() & ~BM_CSU_CSL30_LOCK_S1) | BF_CSU_CSL30_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL31 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL31 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl31
{
    reg32_t U;
    struct _hw_csu_csl31_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl31_t;
#endif

/*
 * constants & macros for entire CSU_CSL31 register
 */
#define HW_CSU_CSL31_ADDR      (REGS_CSU_BASE + 0x7c)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL31           (*(volatile hw_csu_csl31_t *) HW_CSU_CSL31_ADDR)
#define HW_CSU_CSL31_RD()      (HW_CSU_CSL31.U)
#define HW_CSU_CSL31_WR(v)     (HW_CSU_CSL31.U = (v))
#define HW_CSU_CSL31_SET(v)    (HW_CSU_CSL31_WR(HW_CSU_CSL31_RD() |  (v)))
#define HW_CSU_CSL31_CLR(v)    (HW_CSU_CSL31_WR(HW_CSU_CSL31_RD() & ~(v)))
#define HW_CSU_CSL31_TOG(v)    (HW_CSU_CSL31_WR(HW_CSU_CSL31_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL31 bitfields
 */

/* --- Register HW_CSU_CSL31, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL31_SUR_S2      (0)      //!< Bit position for CSU_CSL31_SUR_S2.
#define BM_CSU_CSL31_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL31_SUR_S2.

//! @brief Get value of CSU_CSL31_SUR_S2 from a register value.
#define BG_CSU_CSL31_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_SUR_S2) >> BP_CSU_CSL31_SUR_S2)

//! @brief Format value for bitfield CSU_CSL31_SUR_S2.
#define BF_CSU_CSL31_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_SUR_S2) & BM_CSU_CSL31_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL31_SUR_S2(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_SUR_S2) | BF_CSU_CSL31_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL31, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL31_SSR_S2      (1)      //!< Bit position for CSU_CSL31_SSR_S2.
#define BM_CSU_CSL31_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL31_SSR_S2.

//! @brief Get value of CSU_CSL31_SSR_S2 from a register value.
#define BG_CSU_CSL31_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_SSR_S2) >> BP_CSU_CSL31_SSR_S2)

//! @brief Format value for bitfield CSU_CSL31_SSR_S2.
#define BF_CSU_CSL31_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_SSR_S2) & BM_CSU_CSL31_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL31_SSR_S2(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_SSR_S2) | BF_CSU_CSL31_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL31, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL31_NUR_S2      (2)      //!< Bit position for CSU_CSL31_NUR_S2.
#define BM_CSU_CSL31_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL31_NUR_S2.

//! @brief Get value of CSU_CSL31_NUR_S2 from a register value.
#define BG_CSU_CSL31_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_NUR_S2) >> BP_CSU_CSL31_NUR_S2)

//! @brief Format value for bitfield CSU_CSL31_NUR_S2.
#define BF_CSU_CSL31_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_NUR_S2) & BM_CSU_CSL31_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL31_NUR_S2(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_NUR_S2) | BF_CSU_CSL31_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL31, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL31_NSR_S2      (3)      //!< Bit position for CSU_CSL31_NSR_S2.
#define BM_CSU_CSL31_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL31_NSR_S2.

//! @brief Get value of CSU_CSL31_NSR_S2 from a register value.
#define BG_CSU_CSL31_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_NSR_S2) >> BP_CSU_CSL31_NSR_S2)

//! @brief Format value for bitfield CSU_CSL31_NSR_S2.
#define BF_CSU_CSL31_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_NSR_S2) & BM_CSU_CSL31_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL31_NSR_S2(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_NSR_S2) | BF_CSU_CSL31_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL31, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL31_SUW_S2      (4)      //!< Bit position for CSU_CSL31_SUW_S2.
#define BM_CSU_CSL31_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL31_SUW_S2.

//! @brief Get value of CSU_CSL31_SUW_S2 from a register value.
#define BG_CSU_CSL31_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_SUW_S2) >> BP_CSU_CSL31_SUW_S2)

//! @brief Format value for bitfield CSU_CSL31_SUW_S2.
#define BF_CSU_CSL31_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_SUW_S2) & BM_CSU_CSL31_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL31_SUW_S2(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_SUW_S2) | BF_CSU_CSL31_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL31, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL31_SSW_S2      (5)      //!< Bit position for CSU_CSL31_SSW_S2.
#define BM_CSU_CSL31_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL31_SSW_S2.

//! @brief Get value of CSU_CSL31_SSW_S2 from a register value.
#define BG_CSU_CSL31_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_SSW_S2) >> BP_CSU_CSL31_SSW_S2)

//! @brief Format value for bitfield CSU_CSL31_SSW_S2.
#define BF_CSU_CSL31_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_SSW_S2) & BM_CSU_CSL31_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL31_SSW_S2(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_SSW_S2) | BF_CSU_CSL31_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL31, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL31_NUW_S2      (6)      //!< Bit position for CSU_CSL31_NUW_S2.
#define BM_CSU_CSL31_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL31_NUW_S2.

//! @brief Get value of CSU_CSL31_NUW_S2 from a register value.
#define BG_CSU_CSL31_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_NUW_S2) >> BP_CSU_CSL31_NUW_S2)

//! @brief Format value for bitfield CSU_CSL31_NUW_S2.
#define BF_CSU_CSL31_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_NUW_S2) & BM_CSU_CSL31_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL31_NUW_S2(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_NUW_S2) | BF_CSU_CSL31_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL31, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL31_NSW_S2      (7)      //!< Bit position for CSU_CSL31_NSW_S2.
#define BM_CSU_CSL31_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL31_NSW_S2.

//! @brief Get value of CSU_CSL31_NSW_S2 from a register value.
#define BG_CSU_CSL31_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_NSW_S2) >> BP_CSU_CSL31_NSW_S2)

//! @brief Format value for bitfield CSU_CSL31_NSW_S2.
#define BF_CSU_CSL31_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_NSW_S2) & BM_CSU_CSL31_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL31_NSW_S2(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_NSW_S2) | BF_CSU_CSL31_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL31, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL31_LOCK_S2      (8)      //!< Bit position for CSU_CSL31_LOCK_S2.
#define BM_CSU_CSL31_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL31_LOCK_S2.

//! @brief Get value of CSU_CSL31_LOCK_S2 from a register value.
#define BG_CSU_CSL31_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_LOCK_S2) >> BP_CSU_CSL31_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL31_LOCK_S2.
#define BF_CSU_CSL31_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_LOCK_S2) & BM_CSU_CSL31_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL31_LOCK_S2(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_LOCK_S2) | BF_CSU_CSL31_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL31, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL31_SUR_S1      (16)      //!< Bit position for CSU_CSL31_SUR_S1.
#define BM_CSU_CSL31_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL31_SUR_S1.

//! @brief Get value of CSU_CSL31_SUR_S1 from a register value.
#define BG_CSU_CSL31_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_SUR_S1) >> BP_CSU_CSL31_SUR_S1)

//! @brief Format value for bitfield CSU_CSL31_SUR_S1.
#define BF_CSU_CSL31_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_SUR_S1) & BM_CSU_CSL31_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL31_SUR_S1(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_SUR_S1) | BF_CSU_CSL31_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL31, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL31_SSR_S1      (17)      //!< Bit position for CSU_CSL31_SSR_S1.
#define BM_CSU_CSL31_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL31_SSR_S1.

//! @brief Get value of CSU_CSL31_SSR_S1 from a register value.
#define BG_CSU_CSL31_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_SSR_S1) >> BP_CSU_CSL31_SSR_S1)

//! @brief Format value for bitfield CSU_CSL31_SSR_S1.
#define BF_CSU_CSL31_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_SSR_S1) & BM_CSU_CSL31_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL31_SSR_S1(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_SSR_S1) | BF_CSU_CSL31_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL31, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL31_NUR_S1      (18)      //!< Bit position for CSU_CSL31_NUR_S1.
#define BM_CSU_CSL31_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL31_NUR_S1.

//! @brief Get value of CSU_CSL31_NUR_S1 from a register value.
#define BG_CSU_CSL31_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_NUR_S1) >> BP_CSU_CSL31_NUR_S1)

//! @brief Format value for bitfield CSU_CSL31_NUR_S1.
#define BF_CSU_CSL31_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_NUR_S1) & BM_CSU_CSL31_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL31_NUR_S1(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_NUR_S1) | BF_CSU_CSL31_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL31, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL31_NSR_S1      (19)      //!< Bit position for CSU_CSL31_NSR_S1.
#define BM_CSU_CSL31_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL31_NSR_S1.

//! @brief Get value of CSU_CSL31_NSR_S1 from a register value.
#define BG_CSU_CSL31_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_NSR_S1) >> BP_CSU_CSL31_NSR_S1)

//! @brief Format value for bitfield CSU_CSL31_NSR_S1.
#define BF_CSU_CSL31_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_NSR_S1) & BM_CSU_CSL31_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL31_NSR_S1(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_NSR_S1) | BF_CSU_CSL31_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL31, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL31_SUW_S1      (20)      //!< Bit position for CSU_CSL31_SUW_S1.
#define BM_CSU_CSL31_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL31_SUW_S1.

//! @brief Get value of CSU_CSL31_SUW_S1 from a register value.
#define BG_CSU_CSL31_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_SUW_S1) >> BP_CSU_CSL31_SUW_S1)

//! @brief Format value for bitfield CSU_CSL31_SUW_S1.
#define BF_CSU_CSL31_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_SUW_S1) & BM_CSU_CSL31_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL31_SUW_S1(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_SUW_S1) | BF_CSU_CSL31_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL31, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL31_SSW_S1      (21)      //!< Bit position for CSU_CSL31_SSW_S1.
#define BM_CSU_CSL31_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL31_SSW_S1.

//! @brief Get value of CSU_CSL31_SSW_S1 from a register value.
#define BG_CSU_CSL31_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_SSW_S1) >> BP_CSU_CSL31_SSW_S1)

//! @brief Format value for bitfield CSU_CSL31_SSW_S1.
#define BF_CSU_CSL31_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_SSW_S1) & BM_CSU_CSL31_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL31_SSW_S1(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_SSW_S1) | BF_CSU_CSL31_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL31, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL31_NUW_S1      (22)      //!< Bit position for CSU_CSL31_NUW_S1.
#define BM_CSU_CSL31_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL31_NUW_S1.

//! @brief Get value of CSU_CSL31_NUW_S1 from a register value.
#define BG_CSU_CSL31_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_NUW_S1) >> BP_CSU_CSL31_NUW_S1)

//! @brief Format value for bitfield CSU_CSL31_NUW_S1.
#define BF_CSU_CSL31_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_NUW_S1) & BM_CSU_CSL31_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL31_NUW_S1(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_NUW_S1) | BF_CSU_CSL31_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL31, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL31_NSW_S1      (23)      //!< Bit position for CSU_CSL31_NSW_S1.
#define BM_CSU_CSL31_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL31_NSW_S1.

//! @brief Get value of CSU_CSL31_NSW_S1 from a register value.
#define BG_CSU_CSL31_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_NSW_S1) >> BP_CSU_CSL31_NSW_S1)

//! @brief Format value for bitfield CSU_CSL31_NSW_S1.
#define BF_CSU_CSL31_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_NSW_S1) & BM_CSU_CSL31_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL31_NSW_S1(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_NSW_S1) | BF_CSU_CSL31_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL31, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL31_LOCK_S1      (24)      //!< Bit position for CSU_CSL31_LOCK_S1.
#define BM_CSU_CSL31_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL31_LOCK_S1.

//! @brief Get value of CSU_CSL31_LOCK_S1 from a register value.
#define BG_CSU_CSL31_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL31_LOCK_S1) >> BP_CSU_CSL31_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL31_LOCK_S1.
#define BF_CSU_CSL31_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL31_LOCK_S1) & BM_CSU_CSL31_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL31_LOCK_S1(v)   (HW_CSU_CSL31_WR((HW_CSU_CSL31_RD() & ~BM_CSU_CSL31_LOCK_S1) | BF_CSU_CSL31_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL32 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL32 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl32
{
    reg32_t U;
    struct _hw_csu_csl32_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl32_t;
#endif

/*
 * constants & macros for entire CSU_CSL32 register
 */
#define HW_CSU_CSL32_ADDR      (REGS_CSU_BASE + 0x80)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL32           (*(volatile hw_csu_csl32_t *) HW_CSU_CSL32_ADDR)
#define HW_CSU_CSL32_RD()      (HW_CSU_CSL32.U)
#define HW_CSU_CSL32_WR(v)     (HW_CSU_CSL32.U = (v))
#define HW_CSU_CSL32_SET(v)    (HW_CSU_CSL32_WR(HW_CSU_CSL32_RD() |  (v)))
#define HW_CSU_CSL32_CLR(v)    (HW_CSU_CSL32_WR(HW_CSU_CSL32_RD() & ~(v)))
#define HW_CSU_CSL32_TOG(v)    (HW_CSU_CSL32_WR(HW_CSU_CSL32_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL32 bitfields
 */

/* --- Register HW_CSU_CSL32, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL32_SUR_S2      (0)      //!< Bit position for CSU_CSL32_SUR_S2.
#define BM_CSU_CSL32_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL32_SUR_S2.

//! @brief Get value of CSU_CSL32_SUR_S2 from a register value.
#define BG_CSU_CSL32_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_SUR_S2) >> BP_CSU_CSL32_SUR_S2)

//! @brief Format value for bitfield CSU_CSL32_SUR_S2.
#define BF_CSU_CSL32_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_SUR_S2) & BM_CSU_CSL32_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL32_SUR_S2(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_SUR_S2) | BF_CSU_CSL32_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL32, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL32_SSR_S2      (1)      //!< Bit position for CSU_CSL32_SSR_S2.
#define BM_CSU_CSL32_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL32_SSR_S2.

//! @brief Get value of CSU_CSL32_SSR_S2 from a register value.
#define BG_CSU_CSL32_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_SSR_S2) >> BP_CSU_CSL32_SSR_S2)

//! @brief Format value for bitfield CSU_CSL32_SSR_S2.
#define BF_CSU_CSL32_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_SSR_S2) & BM_CSU_CSL32_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL32_SSR_S2(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_SSR_S2) | BF_CSU_CSL32_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL32, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL32_NUR_S2      (2)      //!< Bit position for CSU_CSL32_NUR_S2.
#define BM_CSU_CSL32_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL32_NUR_S2.

//! @brief Get value of CSU_CSL32_NUR_S2 from a register value.
#define BG_CSU_CSL32_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_NUR_S2) >> BP_CSU_CSL32_NUR_S2)

//! @brief Format value for bitfield CSU_CSL32_NUR_S2.
#define BF_CSU_CSL32_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_NUR_S2) & BM_CSU_CSL32_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL32_NUR_S2(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_NUR_S2) | BF_CSU_CSL32_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL32, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL32_NSR_S2      (3)      //!< Bit position for CSU_CSL32_NSR_S2.
#define BM_CSU_CSL32_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL32_NSR_S2.

//! @brief Get value of CSU_CSL32_NSR_S2 from a register value.
#define BG_CSU_CSL32_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_NSR_S2) >> BP_CSU_CSL32_NSR_S2)

//! @brief Format value for bitfield CSU_CSL32_NSR_S2.
#define BF_CSU_CSL32_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_NSR_S2) & BM_CSU_CSL32_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL32_NSR_S2(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_NSR_S2) | BF_CSU_CSL32_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL32, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL32_SUW_S2      (4)      //!< Bit position for CSU_CSL32_SUW_S2.
#define BM_CSU_CSL32_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL32_SUW_S2.

//! @brief Get value of CSU_CSL32_SUW_S2 from a register value.
#define BG_CSU_CSL32_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_SUW_S2) >> BP_CSU_CSL32_SUW_S2)

//! @brief Format value for bitfield CSU_CSL32_SUW_S2.
#define BF_CSU_CSL32_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_SUW_S2) & BM_CSU_CSL32_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL32_SUW_S2(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_SUW_S2) | BF_CSU_CSL32_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL32, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL32_SSW_S2      (5)      //!< Bit position for CSU_CSL32_SSW_S2.
#define BM_CSU_CSL32_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL32_SSW_S2.

//! @brief Get value of CSU_CSL32_SSW_S2 from a register value.
#define BG_CSU_CSL32_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_SSW_S2) >> BP_CSU_CSL32_SSW_S2)

//! @brief Format value for bitfield CSU_CSL32_SSW_S2.
#define BF_CSU_CSL32_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_SSW_S2) & BM_CSU_CSL32_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL32_SSW_S2(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_SSW_S2) | BF_CSU_CSL32_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL32, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL32_NUW_S2      (6)      //!< Bit position for CSU_CSL32_NUW_S2.
#define BM_CSU_CSL32_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL32_NUW_S2.

//! @brief Get value of CSU_CSL32_NUW_S2 from a register value.
#define BG_CSU_CSL32_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_NUW_S2) >> BP_CSU_CSL32_NUW_S2)

//! @brief Format value for bitfield CSU_CSL32_NUW_S2.
#define BF_CSU_CSL32_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_NUW_S2) & BM_CSU_CSL32_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL32_NUW_S2(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_NUW_S2) | BF_CSU_CSL32_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL32, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL32_NSW_S2      (7)      //!< Bit position for CSU_CSL32_NSW_S2.
#define BM_CSU_CSL32_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL32_NSW_S2.

//! @brief Get value of CSU_CSL32_NSW_S2 from a register value.
#define BG_CSU_CSL32_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_NSW_S2) >> BP_CSU_CSL32_NSW_S2)

//! @brief Format value for bitfield CSU_CSL32_NSW_S2.
#define BF_CSU_CSL32_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_NSW_S2) & BM_CSU_CSL32_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL32_NSW_S2(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_NSW_S2) | BF_CSU_CSL32_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL32, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL32_LOCK_S2      (8)      //!< Bit position for CSU_CSL32_LOCK_S2.
#define BM_CSU_CSL32_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL32_LOCK_S2.

//! @brief Get value of CSU_CSL32_LOCK_S2 from a register value.
#define BG_CSU_CSL32_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_LOCK_S2) >> BP_CSU_CSL32_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL32_LOCK_S2.
#define BF_CSU_CSL32_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_LOCK_S2) & BM_CSU_CSL32_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL32_LOCK_S2(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_LOCK_S2) | BF_CSU_CSL32_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL32, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL32_SUR_S1      (16)      //!< Bit position for CSU_CSL32_SUR_S1.
#define BM_CSU_CSL32_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL32_SUR_S1.

//! @brief Get value of CSU_CSL32_SUR_S1 from a register value.
#define BG_CSU_CSL32_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_SUR_S1) >> BP_CSU_CSL32_SUR_S1)

//! @brief Format value for bitfield CSU_CSL32_SUR_S1.
#define BF_CSU_CSL32_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_SUR_S1) & BM_CSU_CSL32_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL32_SUR_S1(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_SUR_S1) | BF_CSU_CSL32_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL32, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL32_SSR_S1      (17)      //!< Bit position for CSU_CSL32_SSR_S1.
#define BM_CSU_CSL32_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL32_SSR_S1.

//! @brief Get value of CSU_CSL32_SSR_S1 from a register value.
#define BG_CSU_CSL32_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_SSR_S1) >> BP_CSU_CSL32_SSR_S1)

//! @brief Format value for bitfield CSU_CSL32_SSR_S1.
#define BF_CSU_CSL32_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_SSR_S1) & BM_CSU_CSL32_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL32_SSR_S1(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_SSR_S1) | BF_CSU_CSL32_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL32, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL32_NUR_S1      (18)      //!< Bit position for CSU_CSL32_NUR_S1.
#define BM_CSU_CSL32_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL32_NUR_S1.

//! @brief Get value of CSU_CSL32_NUR_S1 from a register value.
#define BG_CSU_CSL32_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_NUR_S1) >> BP_CSU_CSL32_NUR_S1)

//! @brief Format value for bitfield CSU_CSL32_NUR_S1.
#define BF_CSU_CSL32_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_NUR_S1) & BM_CSU_CSL32_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL32_NUR_S1(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_NUR_S1) | BF_CSU_CSL32_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL32, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL32_NSR_S1      (19)      //!< Bit position for CSU_CSL32_NSR_S1.
#define BM_CSU_CSL32_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL32_NSR_S1.

//! @brief Get value of CSU_CSL32_NSR_S1 from a register value.
#define BG_CSU_CSL32_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_NSR_S1) >> BP_CSU_CSL32_NSR_S1)

//! @brief Format value for bitfield CSU_CSL32_NSR_S1.
#define BF_CSU_CSL32_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_NSR_S1) & BM_CSU_CSL32_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL32_NSR_S1(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_NSR_S1) | BF_CSU_CSL32_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL32, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL32_SUW_S1      (20)      //!< Bit position for CSU_CSL32_SUW_S1.
#define BM_CSU_CSL32_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL32_SUW_S1.

//! @brief Get value of CSU_CSL32_SUW_S1 from a register value.
#define BG_CSU_CSL32_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_SUW_S1) >> BP_CSU_CSL32_SUW_S1)

//! @brief Format value for bitfield CSU_CSL32_SUW_S1.
#define BF_CSU_CSL32_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_SUW_S1) & BM_CSU_CSL32_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL32_SUW_S1(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_SUW_S1) | BF_CSU_CSL32_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL32, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL32_SSW_S1      (21)      //!< Bit position for CSU_CSL32_SSW_S1.
#define BM_CSU_CSL32_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL32_SSW_S1.

//! @brief Get value of CSU_CSL32_SSW_S1 from a register value.
#define BG_CSU_CSL32_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_SSW_S1) >> BP_CSU_CSL32_SSW_S1)

//! @brief Format value for bitfield CSU_CSL32_SSW_S1.
#define BF_CSU_CSL32_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_SSW_S1) & BM_CSU_CSL32_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL32_SSW_S1(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_SSW_S1) | BF_CSU_CSL32_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL32, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL32_NUW_S1      (22)      //!< Bit position for CSU_CSL32_NUW_S1.
#define BM_CSU_CSL32_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL32_NUW_S1.

//! @brief Get value of CSU_CSL32_NUW_S1 from a register value.
#define BG_CSU_CSL32_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_NUW_S1) >> BP_CSU_CSL32_NUW_S1)

//! @brief Format value for bitfield CSU_CSL32_NUW_S1.
#define BF_CSU_CSL32_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_NUW_S1) & BM_CSU_CSL32_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL32_NUW_S1(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_NUW_S1) | BF_CSU_CSL32_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL32, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL32_NSW_S1      (23)      //!< Bit position for CSU_CSL32_NSW_S1.
#define BM_CSU_CSL32_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL32_NSW_S1.

//! @brief Get value of CSU_CSL32_NSW_S1 from a register value.
#define BG_CSU_CSL32_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_NSW_S1) >> BP_CSU_CSL32_NSW_S1)

//! @brief Format value for bitfield CSU_CSL32_NSW_S1.
#define BF_CSU_CSL32_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_NSW_S1) & BM_CSU_CSL32_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL32_NSW_S1(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_NSW_S1) | BF_CSU_CSL32_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL32, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL32_LOCK_S1      (24)      //!< Bit position for CSU_CSL32_LOCK_S1.
#define BM_CSU_CSL32_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL32_LOCK_S1.

//! @brief Get value of CSU_CSL32_LOCK_S1 from a register value.
#define BG_CSU_CSL32_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL32_LOCK_S1) >> BP_CSU_CSL32_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL32_LOCK_S1.
#define BF_CSU_CSL32_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL32_LOCK_S1) & BM_CSU_CSL32_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL32_LOCK_S1(v)   (HW_CSU_CSL32_WR((HW_CSU_CSL32_RD() & ~BM_CSU_CSL32_LOCK_S1) | BF_CSU_CSL32_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL33 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL33 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl33
{
    reg32_t U;
    struct _hw_csu_csl33_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl33_t;
#endif

/*
 * constants & macros for entire CSU_CSL33 register
 */
#define HW_CSU_CSL33_ADDR      (REGS_CSU_BASE + 0x84)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL33           (*(volatile hw_csu_csl33_t *) HW_CSU_CSL33_ADDR)
#define HW_CSU_CSL33_RD()      (HW_CSU_CSL33.U)
#define HW_CSU_CSL33_WR(v)     (HW_CSU_CSL33.U = (v))
#define HW_CSU_CSL33_SET(v)    (HW_CSU_CSL33_WR(HW_CSU_CSL33_RD() |  (v)))
#define HW_CSU_CSL33_CLR(v)    (HW_CSU_CSL33_WR(HW_CSU_CSL33_RD() & ~(v)))
#define HW_CSU_CSL33_TOG(v)    (HW_CSU_CSL33_WR(HW_CSU_CSL33_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL33 bitfields
 */

/* --- Register HW_CSU_CSL33, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL33_SUR_S2      (0)      //!< Bit position for CSU_CSL33_SUR_S2.
#define BM_CSU_CSL33_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL33_SUR_S2.

//! @brief Get value of CSU_CSL33_SUR_S2 from a register value.
#define BG_CSU_CSL33_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_SUR_S2) >> BP_CSU_CSL33_SUR_S2)

//! @brief Format value for bitfield CSU_CSL33_SUR_S2.
#define BF_CSU_CSL33_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_SUR_S2) & BM_CSU_CSL33_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL33_SUR_S2(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_SUR_S2) | BF_CSU_CSL33_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL33, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL33_SSR_S2      (1)      //!< Bit position for CSU_CSL33_SSR_S2.
#define BM_CSU_CSL33_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL33_SSR_S2.

//! @brief Get value of CSU_CSL33_SSR_S2 from a register value.
#define BG_CSU_CSL33_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_SSR_S2) >> BP_CSU_CSL33_SSR_S2)

//! @brief Format value for bitfield CSU_CSL33_SSR_S2.
#define BF_CSU_CSL33_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_SSR_S2) & BM_CSU_CSL33_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL33_SSR_S2(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_SSR_S2) | BF_CSU_CSL33_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL33, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL33_NUR_S2      (2)      //!< Bit position for CSU_CSL33_NUR_S2.
#define BM_CSU_CSL33_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL33_NUR_S2.

//! @brief Get value of CSU_CSL33_NUR_S2 from a register value.
#define BG_CSU_CSL33_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_NUR_S2) >> BP_CSU_CSL33_NUR_S2)

//! @brief Format value for bitfield CSU_CSL33_NUR_S2.
#define BF_CSU_CSL33_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_NUR_S2) & BM_CSU_CSL33_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL33_NUR_S2(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_NUR_S2) | BF_CSU_CSL33_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL33, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL33_NSR_S2      (3)      //!< Bit position for CSU_CSL33_NSR_S2.
#define BM_CSU_CSL33_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL33_NSR_S2.

//! @brief Get value of CSU_CSL33_NSR_S2 from a register value.
#define BG_CSU_CSL33_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_NSR_S2) >> BP_CSU_CSL33_NSR_S2)

//! @brief Format value for bitfield CSU_CSL33_NSR_S2.
#define BF_CSU_CSL33_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_NSR_S2) & BM_CSU_CSL33_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL33_NSR_S2(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_NSR_S2) | BF_CSU_CSL33_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL33, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL33_SUW_S2      (4)      //!< Bit position for CSU_CSL33_SUW_S2.
#define BM_CSU_CSL33_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL33_SUW_S2.

//! @brief Get value of CSU_CSL33_SUW_S2 from a register value.
#define BG_CSU_CSL33_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_SUW_S2) >> BP_CSU_CSL33_SUW_S2)

//! @brief Format value for bitfield CSU_CSL33_SUW_S2.
#define BF_CSU_CSL33_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_SUW_S2) & BM_CSU_CSL33_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL33_SUW_S2(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_SUW_S2) | BF_CSU_CSL33_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL33, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL33_SSW_S2      (5)      //!< Bit position for CSU_CSL33_SSW_S2.
#define BM_CSU_CSL33_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL33_SSW_S2.

//! @brief Get value of CSU_CSL33_SSW_S2 from a register value.
#define BG_CSU_CSL33_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_SSW_S2) >> BP_CSU_CSL33_SSW_S2)

//! @brief Format value for bitfield CSU_CSL33_SSW_S2.
#define BF_CSU_CSL33_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_SSW_S2) & BM_CSU_CSL33_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL33_SSW_S2(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_SSW_S2) | BF_CSU_CSL33_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL33, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL33_NUW_S2      (6)      //!< Bit position for CSU_CSL33_NUW_S2.
#define BM_CSU_CSL33_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL33_NUW_S2.

//! @brief Get value of CSU_CSL33_NUW_S2 from a register value.
#define BG_CSU_CSL33_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_NUW_S2) >> BP_CSU_CSL33_NUW_S2)

//! @brief Format value for bitfield CSU_CSL33_NUW_S2.
#define BF_CSU_CSL33_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_NUW_S2) & BM_CSU_CSL33_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL33_NUW_S2(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_NUW_S2) | BF_CSU_CSL33_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL33, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL33_NSW_S2      (7)      //!< Bit position for CSU_CSL33_NSW_S2.
#define BM_CSU_CSL33_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL33_NSW_S2.

//! @brief Get value of CSU_CSL33_NSW_S2 from a register value.
#define BG_CSU_CSL33_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_NSW_S2) >> BP_CSU_CSL33_NSW_S2)

//! @brief Format value for bitfield CSU_CSL33_NSW_S2.
#define BF_CSU_CSL33_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_NSW_S2) & BM_CSU_CSL33_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL33_NSW_S2(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_NSW_S2) | BF_CSU_CSL33_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL33, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL33_LOCK_S2      (8)      //!< Bit position for CSU_CSL33_LOCK_S2.
#define BM_CSU_CSL33_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL33_LOCK_S2.

//! @brief Get value of CSU_CSL33_LOCK_S2 from a register value.
#define BG_CSU_CSL33_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_LOCK_S2) >> BP_CSU_CSL33_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL33_LOCK_S2.
#define BF_CSU_CSL33_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_LOCK_S2) & BM_CSU_CSL33_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL33_LOCK_S2(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_LOCK_S2) | BF_CSU_CSL33_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL33, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL33_SUR_S1      (16)      //!< Bit position for CSU_CSL33_SUR_S1.
#define BM_CSU_CSL33_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL33_SUR_S1.

//! @brief Get value of CSU_CSL33_SUR_S1 from a register value.
#define BG_CSU_CSL33_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_SUR_S1) >> BP_CSU_CSL33_SUR_S1)

//! @brief Format value for bitfield CSU_CSL33_SUR_S1.
#define BF_CSU_CSL33_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_SUR_S1) & BM_CSU_CSL33_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL33_SUR_S1(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_SUR_S1) | BF_CSU_CSL33_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL33, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL33_SSR_S1      (17)      //!< Bit position for CSU_CSL33_SSR_S1.
#define BM_CSU_CSL33_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL33_SSR_S1.

//! @brief Get value of CSU_CSL33_SSR_S1 from a register value.
#define BG_CSU_CSL33_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_SSR_S1) >> BP_CSU_CSL33_SSR_S1)

//! @brief Format value for bitfield CSU_CSL33_SSR_S1.
#define BF_CSU_CSL33_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_SSR_S1) & BM_CSU_CSL33_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL33_SSR_S1(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_SSR_S1) | BF_CSU_CSL33_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL33, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL33_NUR_S1      (18)      //!< Bit position for CSU_CSL33_NUR_S1.
#define BM_CSU_CSL33_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL33_NUR_S1.

//! @brief Get value of CSU_CSL33_NUR_S1 from a register value.
#define BG_CSU_CSL33_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_NUR_S1) >> BP_CSU_CSL33_NUR_S1)

//! @brief Format value for bitfield CSU_CSL33_NUR_S1.
#define BF_CSU_CSL33_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_NUR_S1) & BM_CSU_CSL33_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL33_NUR_S1(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_NUR_S1) | BF_CSU_CSL33_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL33, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL33_NSR_S1      (19)      //!< Bit position for CSU_CSL33_NSR_S1.
#define BM_CSU_CSL33_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL33_NSR_S1.

//! @brief Get value of CSU_CSL33_NSR_S1 from a register value.
#define BG_CSU_CSL33_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_NSR_S1) >> BP_CSU_CSL33_NSR_S1)

//! @brief Format value for bitfield CSU_CSL33_NSR_S1.
#define BF_CSU_CSL33_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_NSR_S1) & BM_CSU_CSL33_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL33_NSR_S1(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_NSR_S1) | BF_CSU_CSL33_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL33, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL33_SUW_S1      (20)      //!< Bit position for CSU_CSL33_SUW_S1.
#define BM_CSU_CSL33_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL33_SUW_S1.

//! @brief Get value of CSU_CSL33_SUW_S1 from a register value.
#define BG_CSU_CSL33_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_SUW_S1) >> BP_CSU_CSL33_SUW_S1)

//! @brief Format value for bitfield CSU_CSL33_SUW_S1.
#define BF_CSU_CSL33_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_SUW_S1) & BM_CSU_CSL33_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL33_SUW_S1(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_SUW_S1) | BF_CSU_CSL33_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL33, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL33_SSW_S1      (21)      //!< Bit position for CSU_CSL33_SSW_S1.
#define BM_CSU_CSL33_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL33_SSW_S1.

//! @brief Get value of CSU_CSL33_SSW_S1 from a register value.
#define BG_CSU_CSL33_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_SSW_S1) >> BP_CSU_CSL33_SSW_S1)

//! @brief Format value for bitfield CSU_CSL33_SSW_S1.
#define BF_CSU_CSL33_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_SSW_S1) & BM_CSU_CSL33_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL33_SSW_S1(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_SSW_S1) | BF_CSU_CSL33_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL33, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL33_NUW_S1      (22)      //!< Bit position for CSU_CSL33_NUW_S1.
#define BM_CSU_CSL33_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL33_NUW_S1.

//! @brief Get value of CSU_CSL33_NUW_S1 from a register value.
#define BG_CSU_CSL33_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_NUW_S1) >> BP_CSU_CSL33_NUW_S1)

//! @brief Format value for bitfield CSU_CSL33_NUW_S1.
#define BF_CSU_CSL33_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_NUW_S1) & BM_CSU_CSL33_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL33_NUW_S1(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_NUW_S1) | BF_CSU_CSL33_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL33, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL33_NSW_S1      (23)      //!< Bit position for CSU_CSL33_NSW_S1.
#define BM_CSU_CSL33_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL33_NSW_S1.

//! @brief Get value of CSU_CSL33_NSW_S1 from a register value.
#define BG_CSU_CSL33_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_NSW_S1) >> BP_CSU_CSL33_NSW_S1)

//! @brief Format value for bitfield CSU_CSL33_NSW_S1.
#define BF_CSU_CSL33_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_NSW_S1) & BM_CSU_CSL33_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL33_NSW_S1(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_NSW_S1) | BF_CSU_CSL33_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL33, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL33_LOCK_S1      (24)      //!< Bit position for CSU_CSL33_LOCK_S1.
#define BM_CSU_CSL33_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL33_LOCK_S1.

//! @brief Get value of CSU_CSL33_LOCK_S1 from a register value.
#define BG_CSU_CSL33_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL33_LOCK_S1) >> BP_CSU_CSL33_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL33_LOCK_S1.
#define BF_CSU_CSL33_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL33_LOCK_S1) & BM_CSU_CSL33_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL33_LOCK_S1(v)   (HW_CSU_CSL33_WR((HW_CSU_CSL33_RD() & ~BM_CSU_CSL33_LOCK_S1) | BF_CSU_CSL33_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL34 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL34 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl34
{
    reg32_t U;
    struct _hw_csu_csl34_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl34_t;
#endif

/*
 * constants & macros for entire CSU_CSL34 register
 */
#define HW_CSU_CSL34_ADDR      (REGS_CSU_BASE + 0x88)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL34           (*(volatile hw_csu_csl34_t *) HW_CSU_CSL34_ADDR)
#define HW_CSU_CSL34_RD()      (HW_CSU_CSL34.U)
#define HW_CSU_CSL34_WR(v)     (HW_CSU_CSL34.U = (v))
#define HW_CSU_CSL34_SET(v)    (HW_CSU_CSL34_WR(HW_CSU_CSL34_RD() |  (v)))
#define HW_CSU_CSL34_CLR(v)    (HW_CSU_CSL34_WR(HW_CSU_CSL34_RD() & ~(v)))
#define HW_CSU_CSL34_TOG(v)    (HW_CSU_CSL34_WR(HW_CSU_CSL34_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL34 bitfields
 */

/* --- Register HW_CSU_CSL34, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL34_SUR_S2      (0)      //!< Bit position for CSU_CSL34_SUR_S2.
#define BM_CSU_CSL34_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL34_SUR_S2.

//! @brief Get value of CSU_CSL34_SUR_S2 from a register value.
#define BG_CSU_CSL34_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_SUR_S2) >> BP_CSU_CSL34_SUR_S2)

//! @brief Format value for bitfield CSU_CSL34_SUR_S2.
#define BF_CSU_CSL34_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_SUR_S2) & BM_CSU_CSL34_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL34_SUR_S2(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_SUR_S2) | BF_CSU_CSL34_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL34, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL34_SSR_S2      (1)      //!< Bit position for CSU_CSL34_SSR_S2.
#define BM_CSU_CSL34_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL34_SSR_S2.

//! @brief Get value of CSU_CSL34_SSR_S2 from a register value.
#define BG_CSU_CSL34_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_SSR_S2) >> BP_CSU_CSL34_SSR_S2)

//! @brief Format value for bitfield CSU_CSL34_SSR_S2.
#define BF_CSU_CSL34_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_SSR_S2) & BM_CSU_CSL34_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL34_SSR_S2(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_SSR_S2) | BF_CSU_CSL34_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL34, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL34_NUR_S2      (2)      //!< Bit position for CSU_CSL34_NUR_S2.
#define BM_CSU_CSL34_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL34_NUR_S2.

//! @brief Get value of CSU_CSL34_NUR_S2 from a register value.
#define BG_CSU_CSL34_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_NUR_S2) >> BP_CSU_CSL34_NUR_S2)

//! @brief Format value for bitfield CSU_CSL34_NUR_S2.
#define BF_CSU_CSL34_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_NUR_S2) & BM_CSU_CSL34_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL34_NUR_S2(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_NUR_S2) | BF_CSU_CSL34_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL34, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL34_NSR_S2      (3)      //!< Bit position for CSU_CSL34_NSR_S2.
#define BM_CSU_CSL34_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL34_NSR_S2.

//! @brief Get value of CSU_CSL34_NSR_S2 from a register value.
#define BG_CSU_CSL34_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_NSR_S2) >> BP_CSU_CSL34_NSR_S2)

//! @brief Format value for bitfield CSU_CSL34_NSR_S2.
#define BF_CSU_CSL34_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_NSR_S2) & BM_CSU_CSL34_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL34_NSR_S2(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_NSR_S2) | BF_CSU_CSL34_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL34, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL34_SUW_S2      (4)      //!< Bit position for CSU_CSL34_SUW_S2.
#define BM_CSU_CSL34_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL34_SUW_S2.

//! @brief Get value of CSU_CSL34_SUW_S2 from a register value.
#define BG_CSU_CSL34_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_SUW_S2) >> BP_CSU_CSL34_SUW_S2)

//! @brief Format value for bitfield CSU_CSL34_SUW_S2.
#define BF_CSU_CSL34_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_SUW_S2) & BM_CSU_CSL34_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL34_SUW_S2(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_SUW_S2) | BF_CSU_CSL34_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL34, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL34_SSW_S2      (5)      //!< Bit position for CSU_CSL34_SSW_S2.
#define BM_CSU_CSL34_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL34_SSW_S2.

//! @brief Get value of CSU_CSL34_SSW_S2 from a register value.
#define BG_CSU_CSL34_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_SSW_S2) >> BP_CSU_CSL34_SSW_S2)

//! @brief Format value for bitfield CSU_CSL34_SSW_S2.
#define BF_CSU_CSL34_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_SSW_S2) & BM_CSU_CSL34_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL34_SSW_S2(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_SSW_S2) | BF_CSU_CSL34_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL34, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL34_NUW_S2      (6)      //!< Bit position for CSU_CSL34_NUW_S2.
#define BM_CSU_CSL34_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL34_NUW_S2.

//! @brief Get value of CSU_CSL34_NUW_S2 from a register value.
#define BG_CSU_CSL34_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_NUW_S2) >> BP_CSU_CSL34_NUW_S2)

//! @brief Format value for bitfield CSU_CSL34_NUW_S2.
#define BF_CSU_CSL34_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_NUW_S2) & BM_CSU_CSL34_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL34_NUW_S2(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_NUW_S2) | BF_CSU_CSL34_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL34, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL34_NSW_S2      (7)      //!< Bit position for CSU_CSL34_NSW_S2.
#define BM_CSU_CSL34_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL34_NSW_S2.

//! @brief Get value of CSU_CSL34_NSW_S2 from a register value.
#define BG_CSU_CSL34_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_NSW_S2) >> BP_CSU_CSL34_NSW_S2)

//! @brief Format value for bitfield CSU_CSL34_NSW_S2.
#define BF_CSU_CSL34_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_NSW_S2) & BM_CSU_CSL34_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL34_NSW_S2(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_NSW_S2) | BF_CSU_CSL34_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL34, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL34_LOCK_S2      (8)      //!< Bit position for CSU_CSL34_LOCK_S2.
#define BM_CSU_CSL34_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL34_LOCK_S2.

//! @brief Get value of CSU_CSL34_LOCK_S2 from a register value.
#define BG_CSU_CSL34_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_LOCK_S2) >> BP_CSU_CSL34_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL34_LOCK_S2.
#define BF_CSU_CSL34_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_LOCK_S2) & BM_CSU_CSL34_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL34_LOCK_S2(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_LOCK_S2) | BF_CSU_CSL34_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL34, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL34_SUR_S1      (16)      //!< Bit position for CSU_CSL34_SUR_S1.
#define BM_CSU_CSL34_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL34_SUR_S1.

//! @brief Get value of CSU_CSL34_SUR_S1 from a register value.
#define BG_CSU_CSL34_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_SUR_S1) >> BP_CSU_CSL34_SUR_S1)

//! @brief Format value for bitfield CSU_CSL34_SUR_S1.
#define BF_CSU_CSL34_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_SUR_S1) & BM_CSU_CSL34_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL34_SUR_S1(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_SUR_S1) | BF_CSU_CSL34_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL34, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL34_SSR_S1      (17)      //!< Bit position for CSU_CSL34_SSR_S1.
#define BM_CSU_CSL34_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL34_SSR_S1.

//! @brief Get value of CSU_CSL34_SSR_S1 from a register value.
#define BG_CSU_CSL34_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_SSR_S1) >> BP_CSU_CSL34_SSR_S1)

//! @brief Format value for bitfield CSU_CSL34_SSR_S1.
#define BF_CSU_CSL34_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_SSR_S1) & BM_CSU_CSL34_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL34_SSR_S1(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_SSR_S1) | BF_CSU_CSL34_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL34, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL34_NUR_S1      (18)      //!< Bit position for CSU_CSL34_NUR_S1.
#define BM_CSU_CSL34_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL34_NUR_S1.

//! @brief Get value of CSU_CSL34_NUR_S1 from a register value.
#define BG_CSU_CSL34_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_NUR_S1) >> BP_CSU_CSL34_NUR_S1)

//! @brief Format value for bitfield CSU_CSL34_NUR_S1.
#define BF_CSU_CSL34_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_NUR_S1) & BM_CSU_CSL34_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL34_NUR_S1(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_NUR_S1) | BF_CSU_CSL34_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL34, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL34_NSR_S1      (19)      //!< Bit position for CSU_CSL34_NSR_S1.
#define BM_CSU_CSL34_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL34_NSR_S1.

//! @brief Get value of CSU_CSL34_NSR_S1 from a register value.
#define BG_CSU_CSL34_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_NSR_S1) >> BP_CSU_CSL34_NSR_S1)

//! @brief Format value for bitfield CSU_CSL34_NSR_S1.
#define BF_CSU_CSL34_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_NSR_S1) & BM_CSU_CSL34_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL34_NSR_S1(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_NSR_S1) | BF_CSU_CSL34_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL34, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL34_SUW_S1      (20)      //!< Bit position for CSU_CSL34_SUW_S1.
#define BM_CSU_CSL34_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL34_SUW_S1.

//! @brief Get value of CSU_CSL34_SUW_S1 from a register value.
#define BG_CSU_CSL34_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_SUW_S1) >> BP_CSU_CSL34_SUW_S1)

//! @brief Format value for bitfield CSU_CSL34_SUW_S1.
#define BF_CSU_CSL34_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_SUW_S1) & BM_CSU_CSL34_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL34_SUW_S1(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_SUW_S1) | BF_CSU_CSL34_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL34, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL34_SSW_S1      (21)      //!< Bit position for CSU_CSL34_SSW_S1.
#define BM_CSU_CSL34_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL34_SSW_S1.

//! @brief Get value of CSU_CSL34_SSW_S1 from a register value.
#define BG_CSU_CSL34_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_SSW_S1) >> BP_CSU_CSL34_SSW_S1)

//! @brief Format value for bitfield CSU_CSL34_SSW_S1.
#define BF_CSU_CSL34_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_SSW_S1) & BM_CSU_CSL34_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL34_SSW_S1(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_SSW_S1) | BF_CSU_CSL34_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL34, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL34_NUW_S1      (22)      //!< Bit position for CSU_CSL34_NUW_S1.
#define BM_CSU_CSL34_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL34_NUW_S1.

//! @brief Get value of CSU_CSL34_NUW_S1 from a register value.
#define BG_CSU_CSL34_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_NUW_S1) >> BP_CSU_CSL34_NUW_S1)

//! @brief Format value for bitfield CSU_CSL34_NUW_S1.
#define BF_CSU_CSL34_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_NUW_S1) & BM_CSU_CSL34_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL34_NUW_S1(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_NUW_S1) | BF_CSU_CSL34_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL34, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL34_NSW_S1      (23)      //!< Bit position for CSU_CSL34_NSW_S1.
#define BM_CSU_CSL34_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL34_NSW_S1.

//! @brief Get value of CSU_CSL34_NSW_S1 from a register value.
#define BG_CSU_CSL34_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_NSW_S1) >> BP_CSU_CSL34_NSW_S1)

//! @brief Format value for bitfield CSU_CSL34_NSW_S1.
#define BF_CSU_CSL34_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_NSW_S1) & BM_CSU_CSL34_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL34_NSW_S1(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_NSW_S1) | BF_CSU_CSL34_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL34, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL34_LOCK_S1      (24)      //!< Bit position for CSU_CSL34_LOCK_S1.
#define BM_CSU_CSL34_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL34_LOCK_S1.

//! @brief Get value of CSU_CSL34_LOCK_S1 from a register value.
#define BG_CSU_CSL34_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL34_LOCK_S1) >> BP_CSU_CSL34_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL34_LOCK_S1.
#define BF_CSU_CSL34_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL34_LOCK_S1) & BM_CSU_CSL34_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL34_LOCK_S1(v)   (HW_CSU_CSL34_WR((HW_CSU_CSL34_RD() & ~BM_CSU_CSL34_LOCK_S1) | BF_CSU_CSL34_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL35 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL35 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl35
{
    reg32_t U;
    struct _hw_csu_csl35_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl35_t;
#endif

/*
 * constants & macros for entire CSU_CSL35 register
 */
#define HW_CSU_CSL35_ADDR      (REGS_CSU_BASE + 0x8c)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL35           (*(volatile hw_csu_csl35_t *) HW_CSU_CSL35_ADDR)
#define HW_CSU_CSL35_RD()      (HW_CSU_CSL35.U)
#define HW_CSU_CSL35_WR(v)     (HW_CSU_CSL35.U = (v))
#define HW_CSU_CSL35_SET(v)    (HW_CSU_CSL35_WR(HW_CSU_CSL35_RD() |  (v)))
#define HW_CSU_CSL35_CLR(v)    (HW_CSU_CSL35_WR(HW_CSU_CSL35_RD() & ~(v)))
#define HW_CSU_CSL35_TOG(v)    (HW_CSU_CSL35_WR(HW_CSU_CSL35_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL35 bitfields
 */

/* --- Register HW_CSU_CSL35, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL35_SUR_S2      (0)      //!< Bit position for CSU_CSL35_SUR_S2.
#define BM_CSU_CSL35_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL35_SUR_S2.

//! @brief Get value of CSU_CSL35_SUR_S2 from a register value.
#define BG_CSU_CSL35_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_SUR_S2) >> BP_CSU_CSL35_SUR_S2)

//! @brief Format value for bitfield CSU_CSL35_SUR_S2.
#define BF_CSU_CSL35_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_SUR_S2) & BM_CSU_CSL35_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL35_SUR_S2(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_SUR_S2) | BF_CSU_CSL35_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL35, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL35_SSR_S2      (1)      //!< Bit position for CSU_CSL35_SSR_S2.
#define BM_CSU_CSL35_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL35_SSR_S2.

//! @brief Get value of CSU_CSL35_SSR_S2 from a register value.
#define BG_CSU_CSL35_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_SSR_S2) >> BP_CSU_CSL35_SSR_S2)

//! @brief Format value for bitfield CSU_CSL35_SSR_S2.
#define BF_CSU_CSL35_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_SSR_S2) & BM_CSU_CSL35_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL35_SSR_S2(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_SSR_S2) | BF_CSU_CSL35_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL35, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL35_NUR_S2      (2)      //!< Bit position for CSU_CSL35_NUR_S2.
#define BM_CSU_CSL35_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL35_NUR_S2.

//! @brief Get value of CSU_CSL35_NUR_S2 from a register value.
#define BG_CSU_CSL35_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_NUR_S2) >> BP_CSU_CSL35_NUR_S2)

//! @brief Format value for bitfield CSU_CSL35_NUR_S2.
#define BF_CSU_CSL35_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_NUR_S2) & BM_CSU_CSL35_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL35_NUR_S2(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_NUR_S2) | BF_CSU_CSL35_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL35, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL35_NSR_S2      (3)      //!< Bit position for CSU_CSL35_NSR_S2.
#define BM_CSU_CSL35_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL35_NSR_S2.

//! @brief Get value of CSU_CSL35_NSR_S2 from a register value.
#define BG_CSU_CSL35_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_NSR_S2) >> BP_CSU_CSL35_NSR_S2)

//! @brief Format value for bitfield CSU_CSL35_NSR_S2.
#define BF_CSU_CSL35_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_NSR_S2) & BM_CSU_CSL35_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL35_NSR_S2(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_NSR_S2) | BF_CSU_CSL35_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL35, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL35_SUW_S2      (4)      //!< Bit position for CSU_CSL35_SUW_S2.
#define BM_CSU_CSL35_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL35_SUW_S2.

//! @brief Get value of CSU_CSL35_SUW_S2 from a register value.
#define BG_CSU_CSL35_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_SUW_S2) >> BP_CSU_CSL35_SUW_S2)

//! @brief Format value for bitfield CSU_CSL35_SUW_S2.
#define BF_CSU_CSL35_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_SUW_S2) & BM_CSU_CSL35_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL35_SUW_S2(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_SUW_S2) | BF_CSU_CSL35_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL35, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL35_SSW_S2      (5)      //!< Bit position for CSU_CSL35_SSW_S2.
#define BM_CSU_CSL35_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL35_SSW_S2.

//! @brief Get value of CSU_CSL35_SSW_S2 from a register value.
#define BG_CSU_CSL35_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_SSW_S2) >> BP_CSU_CSL35_SSW_S2)

//! @brief Format value for bitfield CSU_CSL35_SSW_S2.
#define BF_CSU_CSL35_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_SSW_S2) & BM_CSU_CSL35_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL35_SSW_S2(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_SSW_S2) | BF_CSU_CSL35_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL35, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL35_NUW_S2      (6)      //!< Bit position for CSU_CSL35_NUW_S2.
#define BM_CSU_CSL35_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL35_NUW_S2.

//! @brief Get value of CSU_CSL35_NUW_S2 from a register value.
#define BG_CSU_CSL35_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_NUW_S2) >> BP_CSU_CSL35_NUW_S2)

//! @brief Format value for bitfield CSU_CSL35_NUW_S2.
#define BF_CSU_CSL35_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_NUW_S2) & BM_CSU_CSL35_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL35_NUW_S2(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_NUW_S2) | BF_CSU_CSL35_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL35, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL35_NSW_S2      (7)      //!< Bit position for CSU_CSL35_NSW_S2.
#define BM_CSU_CSL35_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL35_NSW_S2.

//! @brief Get value of CSU_CSL35_NSW_S2 from a register value.
#define BG_CSU_CSL35_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_NSW_S2) >> BP_CSU_CSL35_NSW_S2)

//! @brief Format value for bitfield CSU_CSL35_NSW_S2.
#define BF_CSU_CSL35_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_NSW_S2) & BM_CSU_CSL35_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL35_NSW_S2(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_NSW_S2) | BF_CSU_CSL35_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL35, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL35_LOCK_S2      (8)      //!< Bit position for CSU_CSL35_LOCK_S2.
#define BM_CSU_CSL35_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL35_LOCK_S2.

//! @brief Get value of CSU_CSL35_LOCK_S2 from a register value.
#define BG_CSU_CSL35_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_LOCK_S2) >> BP_CSU_CSL35_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL35_LOCK_S2.
#define BF_CSU_CSL35_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_LOCK_S2) & BM_CSU_CSL35_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL35_LOCK_S2(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_LOCK_S2) | BF_CSU_CSL35_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL35, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL35_SUR_S1      (16)      //!< Bit position for CSU_CSL35_SUR_S1.
#define BM_CSU_CSL35_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL35_SUR_S1.

//! @brief Get value of CSU_CSL35_SUR_S1 from a register value.
#define BG_CSU_CSL35_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_SUR_S1) >> BP_CSU_CSL35_SUR_S1)

//! @brief Format value for bitfield CSU_CSL35_SUR_S1.
#define BF_CSU_CSL35_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_SUR_S1) & BM_CSU_CSL35_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL35_SUR_S1(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_SUR_S1) | BF_CSU_CSL35_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL35, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL35_SSR_S1      (17)      //!< Bit position for CSU_CSL35_SSR_S1.
#define BM_CSU_CSL35_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL35_SSR_S1.

//! @brief Get value of CSU_CSL35_SSR_S1 from a register value.
#define BG_CSU_CSL35_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_SSR_S1) >> BP_CSU_CSL35_SSR_S1)

//! @brief Format value for bitfield CSU_CSL35_SSR_S1.
#define BF_CSU_CSL35_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_SSR_S1) & BM_CSU_CSL35_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL35_SSR_S1(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_SSR_S1) | BF_CSU_CSL35_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL35, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL35_NUR_S1      (18)      //!< Bit position for CSU_CSL35_NUR_S1.
#define BM_CSU_CSL35_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL35_NUR_S1.

//! @brief Get value of CSU_CSL35_NUR_S1 from a register value.
#define BG_CSU_CSL35_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_NUR_S1) >> BP_CSU_CSL35_NUR_S1)

//! @brief Format value for bitfield CSU_CSL35_NUR_S1.
#define BF_CSU_CSL35_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_NUR_S1) & BM_CSU_CSL35_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL35_NUR_S1(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_NUR_S1) | BF_CSU_CSL35_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL35, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL35_NSR_S1      (19)      //!< Bit position for CSU_CSL35_NSR_S1.
#define BM_CSU_CSL35_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL35_NSR_S1.

//! @brief Get value of CSU_CSL35_NSR_S1 from a register value.
#define BG_CSU_CSL35_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_NSR_S1) >> BP_CSU_CSL35_NSR_S1)

//! @brief Format value for bitfield CSU_CSL35_NSR_S1.
#define BF_CSU_CSL35_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_NSR_S1) & BM_CSU_CSL35_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL35_NSR_S1(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_NSR_S1) | BF_CSU_CSL35_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL35, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL35_SUW_S1      (20)      //!< Bit position for CSU_CSL35_SUW_S1.
#define BM_CSU_CSL35_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL35_SUW_S1.

//! @brief Get value of CSU_CSL35_SUW_S1 from a register value.
#define BG_CSU_CSL35_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_SUW_S1) >> BP_CSU_CSL35_SUW_S1)

//! @brief Format value for bitfield CSU_CSL35_SUW_S1.
#define BF_CSU_CSL35_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_SUW_S1) & BM_CSU_CSL35_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL35_SUW_S1(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_SUW_S1) | BF_CSU_CSL35_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL35, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL35_SSW_S1      (21)      //!< Bit position for CSU_CSL35_SSW_S1.
#define BM_CSU_CSL35_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL35_SSW_S1.

//! @brief Get value of CSU_CSL35_SSW_S1 from a register value.
#define BG_CSU_CSL35_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_SSW_S1) >> BP_CSU_CSL35_SSW_S1)

//! @brief Format value for bitfield CSU_CSL35_SSW_S1.
#define BF_CSU_CSL35_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_SSW_S1) & BM_CSU_CSL35_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL35_SSW_S1(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_SSW_S1) | BF_CSU_CSL35_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL35, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL35_NUW_S1      (22)      //!< Bit position for CSU_CSL35_NUW_S1.
#define BM_CSU_CSL35_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL35_NUW_S1.

//! @brief Get value of CSU_CSL35_NUW_S1 from a register value.
#define BG_CSU_CSL35_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_NUW_S1) >> BP_CSU_CSL35_NUW_S1)

//! @brief Format value for bitfield CSU_CSL35_NUW_S1.
#define BF_CSU_CSL35_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_NUW_S1) & BM_CSU_CSL35_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL35_NUW_S1(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_NUW_S1) | BF_CSU_CSL35_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL35, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL35_NSW_S1      (23)      //!< Bit position for CSU_CSL35_NSW_S1.
#define BM_CSU_CSL35_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL35_NSW_S1.

//! @brief Get value of CSU_CSL35_NSW_S1 from a register value.
#define BG_CSU_CSL35_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_NSW_S1) >> BP_CSU_CSL35_NSW_S1)

//! @brief Format value for bitfield CSU_CSL35_NSW_S1.
#define BF_CSU_CSL35_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_NSW_S1) & BM_CSU_CSL35_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL35_NSW_S1(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_NSW_S1) | BF_CSU_CSL35_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL35, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL35_LOCK_S1      (24)      //!< Bit position for CSU_CSL35_LOCK_S1.
#define BM_CSU_CSL35_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL35_LOCK_S1.

//! @brief Get value of CSU_CSL35_LOCK_S1 from a register value.
#define BG_CSU_CSL35_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL35_LOCK_S1) >> BP_CSU_CSL35_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL35_LOCK_S1.
#define BF_CSU_CSL35_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL35_LOCK_S1) & BM_CSU_CSL35_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL35_LOCK_S1(v)   (HW_CSU_CSL35_WR((HW_CSU_CSL35_RD() & ~BM_CSU_CSL35_LOCK_S1) | BF_CSU_CSL35_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL36 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL36 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl36
{
    reg32_t U;
    struct _hw_csu_csl36_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl36_t;
#endif

/*
 * constants & macros for entire CSU_CSL36 register
 */
#define HW_CSU_CSL36_ADDR      (REGS_CSU_BASE + 0x90)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL36           (*(volatile hw_csu_csl36_t *) HW_CSU_CSL36_ADDR)
#define HW_CSU_CSL36_RD()      (HW_CSU_CSL36.U)
#define HW_CSU_CSL36_WR(v)     (HW_CSU_CSL36.U = (v))
#define HW_CSU_CSL36_SET(v)    (HW_CSU_CSL36_WR(HW_CSU_CSL36_RD() |  (v)))
#define HW_CSU_CSL36_CLR(v)    (HW_CSU_CSL36_WR(HW_CSU_CSL36_RD() & ~(v)))
#define HW_CSU_CSL36_TOG(v)    (HW_CSU_CSL36_WR(HW_CSU_CSL36_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL36 bitfields
 */

/* --- Register HW_CSU_CSL36, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL36_SUR_S2      (0)      //!< Bit position for CSU_CSL36_SUR_S2.
#define BM_CSU_CSL36_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL36_SUR_S2.

//! @brief Get value of CSU_CSL36_SUR_S2 from a register value.
#define BG_CSU_CSL36_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_SUR_S2) >> BP_CSU_CSL36_SUR_S2)

//! @brief Format value for bitfield CSU_CSL36_SUR_S2.
#define BF_CSU_CSL36_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_SUR_S2) & BM_CSU_CSL36_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL36_SUR_S2(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_SUR_S2) | BF_CSU_CSL36_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL36, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL36_SSR_S2      (1)      //!< Bit position for CSU_CSL36_SSR_S2.
#define BM_CSU_CSL36_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL36_SSR_S2.

//! @brief Get value of CSU_CSL36_SSR_S2 from a register value.
#define BG_CSU_CSL36_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_SSR_S2) >> BP_CSU_CSL36_SSR_S2)

//! @brief Format value for bitfield CSU_CSL36_SSR_S2.
#define BF_CSU_CSL36_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_SSR_S2) & BM_CSU_CSL36_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL36_SSR_S2(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_SSR_S2) | BF_CSU_CSL36_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL36, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL36_NUR_S2      (2)      //!< Bit position for CSU_CSL36_NUR_S2.
#define BM_CSU_CSL36_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL36_NUR_S2.

//! @brief Get value of CSU_CSL36_NUR_S2 from a register value.
#define BG_CSU_CSL36_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_NUR_S2) >> BP_CSU_CSL36_NUR_S2)

//! @brief Format value for bitfield CSU_CSL36_NUR_S2.
#define BF_CSU_CSL36_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_NUR_S2) & BM_CSU_CSL36_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL36_NUR_S2(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_NUR_S2) | BF_CSU_CSL36_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL36, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL36_NSR_S2      (3)      //!< Bit position for CSU_CSL36_NSR_S2.
#define BM_CSU_CSL36_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL36_NSR_S2.

//! @brief Get value of CSU_CSL36_NSR_S2 from a register value.
#define BG_CSU_CSL36_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_NSR_S2) >> BP_CSU_CSL36_NSR_S2)

//! @brief Format value for bitfield CSU_CSL36_NSR_S2.
#define BF_CSU_CSL36_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_NSR_S2) & BM_CSU_CSL36_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL36_NSR_S2(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_NSR_S2) | BF_CSU_CSL36_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL36, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL36_SUW_S2      (4)      //!< Bit position for CSU_CSL36_SUW_S2.
#define BM_CSU_CSL36_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL36_SUW_S2.

//! @brief Get value of CSU_CSL36_SUW_S2 from a register value.
#define BG_CSU_CSL36_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_SUW_S2) >> BP_CSU_CSL36_SUW_S2)

//! @brief Format value for bitfield CSU_CSL36_SUW_S2.
#define BF_CSU_CSL36_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_SUW_S2) & BM_CSU_CSL36_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL36_SUW_S2(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_SUW_S2) | BF_CSU_CSL36_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL36, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL36_SSW_S2      (5)      //!< Bit position for CSU_CSL36_SSW_S2.
#define BM_CSU_CSL36_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL36_SSW_S2.

//! @brief Get value of CSU_CSL36_SSW_S2 from a register value.
#define BG_CSU_CSL36_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_SSW_S2) >> BP_CSU_CSL36_SSW_S2)

//! @brief Format value for bitfield CSU_CSL36_SSW_S2.
#define BF_CSU_CSL36_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_SSW_S2) & BM_CSU_CSL36_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL36_SSW_S2(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_SSW_S2) | BF_CSU_CSL36_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL36, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL36_NUW_S2      (6)      //!< Bit position for CSU_CSL36_NUW_S2.
#define BM_CSU_CSL36_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL36_NUW_S2.

//! @brief Get value of CSU_CSL36_NUW_S2 from a register value.
#define BG_CSU_CSL36_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_NUW_S2) >> BP_CSU_CSL36_NUW_S2)

//! @brief Format value for bitfield CSU_CSL36_NUW_S2.
#define BF_CSU_CSL36_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_NUW_S2) & BM_CSU_CSL36_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL36_NUW_S2(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_NUW_S2) | BF_CSU_CSL36_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL36, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL36_NSW_S2      (7)      //!< Bit position for CSU_CSL36_NSW_S2.
#define BM_CSU_CSL36_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL36_NSW_S2.

//! @brief Get value of CSU_CSL36_NSW_S2 from a register value.
#define BG_CSU_CSL36_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_NSW_S2) >> BP_CSU_CSL36_NSW_S2)

//! @brief Format value for bitfield CSU_CSL36_NSW_S2.
#define BF_CSU_CSL36_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_NSW_S2) & BM_CSU_CSL36_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL36_NSW_S2(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_NSW_S2) | BF_CSU_CSL36_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL36, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL36_LOCK_S2      (8)      //!< Bit position for CSU_CSL36_LOCK_S2.
#define BM_CSU_CSL36_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL36_LOCK_S2.

//! @brief Get value of CSU_CSL36_LOCK_S2 from a register value.
#define BG_CSU_CSL36_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_LOCK_S2) >> BP_CSU_CSL36_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL36_LOCK_S2.
#define BF_CSU_CSL36_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_LOCK_S2) & BM_CSU_CSL36_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL36_LOCK_S2(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_LOCK_S2) | BF_CSU_CSL36_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL36, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL36_SUR_S1      (16)      //!< Bit position for CSU_CSL36_SUR_S1.
#define BM_CSU_CSL36_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL36_SUR_S1.

//! @brief Get value of CSU_CSL36_SUR_S1 from a register value.
#define BG_CSU_CSL36_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_SUR_S1) >> BP_CSU_CSL36_SUR_S1)

//! @brief Format value for bitfield CSU_CSL36_SUR_S1.
#define BF_CSU_CSL36_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_SUR_S1) & BM_CSU_CSL36_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL36_SUR_S1(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_SUR_S1) | BF_CSU_CSL36_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL36, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL36_SSR_S1      (17)      //!< Bit position for CSU_CSL36_SSR_S1.
#define BM_CSU_CSL36_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL36_SSR_S1.

//! @brief Get value of CSU_CSL36_SSR_S1 from a register value.
#define BG_CSU_CSL36_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_SSR_S1) >> BP_CSU_CSL36_SSR_S1)

//! @brief Format value for bitfield CSU_CSL36_SSR_S1.
#define BF_CSU_CSL36_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_SSR_S1) & BM_CSU_CSL36_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL36_SSR_S1(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_SSR_S1) | BF_CSU_CSL36_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL36, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL36_NUR_S1      (18)      //!< Bit position for CSU_CSL36_NUR_S1.
#define BM_CSU_CSL36_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL36_NUR_S1.

//! @brief Get value of CSU_CSL36_NUR_S1 from a register value.
#define BG_CSU_CSL36_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_NUR_S1) >> BP_CSU_CSL36_NUR_S1)

//! @brief Format value for bitfield CSU_CSL36_NUR_S1.
#define BF_CSU_CSL36_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_NUR_S1) & BM_CSU_CSL36_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL36_NUR_S1(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_NUR_S1) | BF_CSU_CSL36_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL36, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL36_NSR_S1      (19)      //!< Bit position for CSU_CSL36_NSR_S1.
#define BM_CSU_CSL36_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL36_NSR_S1.

//! @brief Get value of CSU_CSL36_NSR_S1 from a register value.
#define BG_CSU_CSL36_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_NSR_S1) >> BP_CSU_CSL36_NSR_S1)

//! @brief Format value for bitfield CSU_CSL36_NSR_S1.
#define BF_CSU_CSL36_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_NSR_S1) & BM_CSU_CSL36_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL36_NSR_S1(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_NSR_S1) | BF_CSU_CSL36_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL36, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL36_SUW_S1      (20)      //!< Bit position for CSU_CSL36_SUW_S1.
#define BM_CSU_CSL36_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL36_SUW_S1.

//! @brief Get value of CSU_CSL36_SUW_S1 from a register value.
#define BG_CSU_CSL36_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_SUW_S1) >> BP_CSU_CSL36_SUW_S1)

//! @brief Format value for bitfield CSU_CSL36_SUW_S1.
#define BF_CSU_CSL36_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_SUW_S1) & BM_CSU_CSL36_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL36_SUW_S1(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_SUW_S1) | BF_CSU_CSL36_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL36, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL36_SSW_S1      (21)      //!< Bit position for CSU_CSL36_SSW_S1.
#define BM_CSU_CSL36_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL36_SSW_S1.

//! @brief Get value of CSU_CSL36_SSW_S1 from a register value.
#define BG_CSU_CSL36_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_SSW_S1) >> BP_CSU_CSL36_SSW_S1)

//! @brief Format value for bitfield CSU_CSL36_SSW_S1.
#define BF_CSU_CSL36_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_SSW_S1) & BM_CSU_CSL36_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL36_SSW_S1(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_SSW_S1) | BF_CSU_CSL36_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL36, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL36_NUW_S1      (22)      //!< Bit position for CSU_CSL36_NUW_S1.
#define BM_CSU_CSL36_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL36_NUW_S1.

//! @brief Get value of CSU_CSL36_NUW_S1 from a register value.
#define BG_CSU_CSL36_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_NUW_S1) >> BP_CSU_CSL36_NUW_S1)

//! @brief Format value for bitfield CSU_CSL36_NUW_S1.
#define BF_CSU_CSL36_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_NUW_S1) & BM_CSU_CSL36_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL36_NUW_S1(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_NUW_S1) | BF_CSU_CSL36_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL36, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL36_NSW_S1      (23)      //!< Bit position for CSU_CSL36_NSW_S1.
#define BM_CSU_CSL36_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL36_NSW_S1.

//! @brief Get value of CSU_CSL36_NSW_S1 from a register value.
#define BG_CSU_CSL36_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_NSW_S1) >> BP_CSU_CSL36_NSW_S1)

//! @brief Format value for bitfield CSU_CSL36_NSW_S1.
#define BF_CSU_CSL36_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_NSW_S1) & BM_CSU_CSL36_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL36_NSW_S1(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_NSW_S1) | BF_CSU_CSL36_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL36, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL36_LOCK_S1      (24)      //!< Bit position for CSU_CSL36_LOCK_S1.
#define BM_CSU_CSL36_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL36_LOCK_S1.

//! @brief Get value of CSU_CSL36_LOCK_S1 from a register value.
#define BG_CSU_CSL36_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL36_LOCK_S1) >> BP_CSU_CSL36_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL36_LOCK_S1.
#define BF_CSU_CSL36_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL36_LOCK_S1) & BM_CSU_CSL36_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL36_LOCK_S1(v)   (HW_CSU_CSL36_WR((HW_CSU_CSL36_RD() & ~BM_CSU_CSL36_LOCK_S1) | BF_CSU_CSL36_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL37 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL37 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl37
{
    reg32_t U;
    struct _hw_csu_csl37_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl37_t;
#endif

/*
 * constants & macros for entire CSU_CSL37 register
 */
#define HW_CSU_CSL37_ADDR      (REGS_CSU_BASE + 0x94)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL37           (*(volatile hw_csu_csl37_t *) HW_CSU_CSL37_ADDR)
#define HW_CSU_CSL37_RD()      (HW_CSU_CSL37.U)
#define HW_CSU_CSL37_WR(v)     (HW_CSU_CSL37.U = (v))
#define HW_CSU_CSL37_SET(v)    (HW_CSU_CSL37_WR(HW_CSU_CSL37_RD() |  (v)))
#define HW_CSU_CSL37_CLR(v)    (HW_CSU_CSL37_WR(HW_CSU_CSL37_RD() & ~(v)))
#define HW_CSU_CSL37_TOG(v)    (HW_CSU_CSL37_WR(HW_CSU_CSL37_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL37 bitfields
 */

/* --- Register HW_CSU_CSL37, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL37_SUR_S2      (0)      //!< Bit position for CSU_CSL37_SUR_S2.
#define BM_CSU_CSL37_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL37_SUR_S2.

//! @brief Get value of CSU_CSL37_SUR_S2 from a register value.
#define BG_CSU_CSL37_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_SUR_S2) >> BP_CSU_CSL37_SUR_S2)

//! @brief Format value for bitfield CSU_CSL37_SUR_S2.
#define BF_CSU_CSL37_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_SUR_S2) & BM_CSU_CSL37_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL37_SUR_S2(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_SUR_S2) | BF_CSU_CSL37_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL37, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL37_SSR_S2      (1)      //!< Bit position for CSU_CSL37_SSR_S2.
#define BM_CSU_CSL37_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL37_SSR_S2.

//! @brief Get value of CSU_CSL37_SSR_S2 from a register value.
#define BG_CSU_CSL37_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_SSR_S2) >> BP_CSU_CSL37_SSR_S2)

//! @brief Format value for bitfield CSU_CSL37_SSR_S2.
#define BF_CSU_CSL37_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_SSR_S2) & BM_CSU_CSL37_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL37_SSR_S2(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_SSR_S2) | BF_CSU_CSL37_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL37, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL37_NUR_S2      (2)      //!< Bit position for CSU_CSL37_NUR_S2.
#define BM_CSU_CSL37_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL37_NUR_S2.

//! @brief Get value of CSU_CSL37_NUR_S2 from a register value.
#define BG_CSU_CSL37_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_NUR_S2) >> BP_CSU_CSL37_NUR_S2)

//! @brief Format value for bitfield CSU_CSL37_NUR_S2.
#define BF_CSU_CSL37_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_NUR_S2) & BM_CSU_CSL37_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL37_NUR_S2(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_NUR_S2) | BF_CSU_CSL37_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL37, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL37_NSR_S2      (3)      //!< Bit position for CSU_CSL37_NSR_S2.
#define BM_CSU_CSL37_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL37_NSR_S2.

//! @brief Get value of CSU_CSL37_NSR_S2 from a register value.
#define BG_CSU_CSL37_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_NSR_S2) >> BP_CSU_CSL37_NSR_S2)

//! @brief Format value for bitfield CSU_CSL37_NSR_S2.
#define BF_CSU_CSL37_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_NSR_S2) & BM_CSU_CSL37_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL37_NSR_S2(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_NSR_S2) | BF_CSU_CSL37_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL37, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL37_SUW_S2      (4)      //!< Bit position for CSU_CSL37_SUW_S2.
#define BM_CSU_CSL37_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL37_SUW_S2.

//! @brief Get value of CSU_CSL37_SUW_S2 from a register value.
#define BG_CSU_CSL37_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_SUW_S2) >> BP_CSU_CSL37_SUW_S2)

//! @brief Format value for bitfield CSU_CSL37_SUW_S2.
#define BF_CSU_CSL37_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_SUW_S2) & BM_CSU_CSL37_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL37_SUW_S2(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_SUW_S2) | BF_CSU_CSL37_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL37, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL37_SSW_S2      (5)      //!< Bit position for CSU_CSL37_SSW_S2.
#define BM_CSU_CSL37_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL37_SSW_S2.

//! @brief Get value of CSU_CSL37_SSW_S2 from a register value.
#define BG_CSU_CSL37_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_SSW_S2) >> BP_CSU_CSL37_SSW_S2)

//! @brief Format value for bitfield CSU_CSL37_SSW_S2.
#define BF_CSU_CSL37_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_SSW_S2) & BM_CSU_CSL37_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL37_SSW_S2(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_SSW_S2) | BF_CSU_CSL37_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL37, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL37_NUW_S2      (6)      //!< Bit position for CSU_CSL37_NUW_S2.
#define BM_CSU_CSL37_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL37_NUW_S2.

//! @brief Get value of CSU_CSL37_NUW_S2 from a register value.
#define BG_CSU_CSL37_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_NUW_S2) >> BP_CSU_CSL37_NUW_S2)

//! @brief Format value for bitfield CSU_CSL37_NUW_S2.
#define BF_CSU_CSL37_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_NUW_S2) & BM_CSU_CSL37_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL37_NUW_S2(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_NUW_S2) | BF_CSU_CSL37_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL37, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL37_NSW_S2      (7)      //!< Bit position for CSU_CSL37_NSW_S2.
#define BM_CSU_CSL37_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL37_NSW_S2.

//! @brief Get value of CSU_CSL37_NSW_S2 from a register value.
#define BG_CSU_CSL37_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_NSW_S2) >> BP_CSU_CSL37_NSW_S2)

//! @brief Format value for bitfield CSU_CSL37_NSW_S2.
#define BF_CSU_CSL37_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_NSW_S2) & BM_CSU_CSL37_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL37_NSW_S2(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_NSW_S2) | BF_CSU_CSL37_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL37, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL37_LOCK_S2      (8)      //!< Bit position for CSU_CSL37_LOCK_S2.
#define BM_CSU_CSL37_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL37_LOCK_S2.

//! @brief Get value of CSU_CSL37_LOCK_S2 from a register value.
#define BG_CSU_CSL37_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_LOCK_S2) >> BP_CSU_CSL37_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL37_LOCK_S2.
#define BF_CSU_CSL37_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_LOCK_S2) & BM_CSU_CSL37_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL37_LOCK_S2(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_LOCK_S2) | BF_CSU_CSL37_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL37, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL37_SUR_S1      (16)      //!< Bit position for CSU_CSL37_SUR_S1.
#define BM_CSU_CSL37_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL37_SUR_S1.

//! @brief Get value of CSU_CSL37_SUR_S1 from a register value.
#define BG_CSU_CSL37_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_SUR_S1) >> BP_CSU_CSL37_SUR_S1)

//! @brief Format value for bitfield CSU_CSL37_SUR_S1.
#define BF_CSU_CSL37_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_SUR_S1) & BM_CSU_CSL37_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL37_SUR_S1(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_SUR_S1) | BF_CSU_CSL37_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL37, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL37_SSR_S1      (17)      //!< Bit position for CSU_CSL37_SSR_S1.
#define BM_CSU_CSL37_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL37_SSR_S1.

//! @brief Get value of CSU_CSL37_SSR_S1 from a register value.
#define BG_CSU_CSL37_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_SSR_S1) >> BP_CSU_CSL37_SSR_S1)

//! @brief Format value for bitfield CSU_CSL37_SSR_S1.
#define BF_CSU_CSL37_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_SSR_S1) & BM_CSU_CSL37_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL37_SSR_S1(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_SSR_S1) | BF_CSU_CSL37_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL37, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL37_NUR_S1      (18)      //!< Bit position for CSU_CSL37_NUR_S1.
#define BM_CSU_CSL37_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL37_NUR_S1.

//! @brief Get value of CSU_CSL37_NUR_S1 from a register value.
#define BG_CSU_CSL37_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_NUR_S1) >> BP_CSU_CSL37_NUR_S1)

//! @brief Format value for bitfield CSU_CSL37_NUR_S1.
#define BF_CSU_CSL37_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_NUR_S1) & BM_CSU_CSL37_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL37_NUR_S1(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_NUR_S1) | BF_CSU_CSL37_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL37, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL37_NSR_S1      (19)      //!< Bit position for CSU_CSL37_NSR_S1.
#define BM_CSU_CSL37_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL37_NSR_S1.

//! @brief Get value of CSU_CSL37_NSR_S1 from a register value.
#define BG_CSU_CSL37_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_NSR_S1) >> BP_CSU_CSL37_NSR_S1)

//! @brief Format value for bitfield CSU_CSL37_NSR_S1.
#define BF_CSU_CSL37_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_NSR_S1) & BM_CSU_CSL37_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL37_NSR_S1(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_NSR_S1) | BF_CSU_CSL37_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL37, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL37_SUW_S1      (20)      //!< Bit position for CSU_CSL37_SUW_S1.
#define BM_CSU_CSL37_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL37_SUW_S1.

//! @brief Get value of CSU_CSL37_SUW_S1 from a register value.
#define BG_CSU_CSL37_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_SUW_S1) >> BP_CSU_CSL37_SUW_S1)

//! @brief Format value for bitfield CSU_CSL37_SUW_S1.
#define BF_CSU_CSL37_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_SUW_S1) & BM_CSU_CSL37_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL37_SUW_S1(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_SUW_S1) | BF_CSU_CSL37_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL37, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL37_SSW_S1      (21)      //!< Bit position for CSU_CSL37_SSW_S1.
#define BM_CSU_CSL37_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL37_SSW_S1.

//! @brief Get value of CSU_CSL37_SSW_S1 from a register value.
#define BG_CSU_CSL37_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_SSW_S1) >> BP_CSU_CSL37_SSW_S1)

//! @brief Format value for bitfield CSU_CSL37_SSW_S1.
#define BF_CSU_CSL37_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_SSW_S1) & BM_CSU_CSL37_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL37_SSW_S1(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_SSW_S1) | BF_CSU_CSL37_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL37, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL37_NUW_S1      (22)      //!< Bit position for CSU_CSL37_NUW_S1.
#define BM_CSU_CSL37_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL37_NUW_S1.

//! @brief Get value of CSU_CSL37_NUW_S1 from a register value.
#define BG_CSU_CSL37_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_NUW_S1) >> BP_CSU_CSL37_NUW_S1)

//! @brief Format value for bitfield CSU_CSL37_NUW_S1.
#define BF_CSU_CSL37_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_NUW_S1) & BM_CSU_CSL37_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL37_NUW_S1(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_NUW_S1) | BF_CSU_CSL37_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL37, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL37_NSW_S1      (23)      //!< Bit position for CSU_CSL37_NSW_S1.
#define BM_CSU_CSL37_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL37_NSW_S1.

//! @brief Get value of CSU_CSL37_NSW_S1 from a register value.
#define BG_CSU_CSL37_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_NSW_S1) >> BP_CSU_CSL37_NSW_S1)

//! @brief Format value for bitfield CSU_CSL37_NSW_S1.
#define BF_CSU_CSL37_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_NSW_S1) & BM_CSU_CSL37_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL37_NSW_S1(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_NSW_S1) | BF_CSU_CSL37_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL37, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL37_LOCK_S1      (24)      //!< Bit position for CSU_CSL37_LOCK_S1.
#define BM_CSU_CSL37_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL37_LOCK_S1.

//! @brief Get value of CSU_CSL37_LOCK_S1 from a register value.
#define BG_CSU_CSL37_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL37_LOCK_S1) >> BP_CSU_CSL37_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL37_LOCK_S1.
#define BF_CSU_CSL37_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL37_LOCK_S1) & BM_CSU_CSL37_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL37_LOCK_S1(v)   (HW_CSU_CSL37_WR((HW_CSU_CSL37_RD() & ~BM_CSU_CSL37_LOCK_S1) | BF_CSU_CSL37_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL38 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL38 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl38
{
    reg32_t U;
    struct _hw_csu_csl38_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl38_t;
#endif

/*
 * constants & macros for entire CSU_CSL38 register
 */
#define HW_CSU_CSL38_ADDR      (REGS_CSU_BASE + 0x98)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL38           (*(volatile hw_csu_csl38_t *) HW_CSU_CSL38_ADDR)
#define HW_CSU_CSL38_RD()      (HW_CSU_CSL38.U)
#define HW_CSU_CSL38_WR(v)     (HW_CSU_CSL38.U = (v))
#define HW_CSU_CSL38_SET(v)    (HW_CSU_CSL38_WR(HW_CSU_CSL38_RD() |  (v)))
#define HW_CSU_CSL38_CLR(v)    (HW_CSU_CSL38_WR(HW_CSU_CSL38_RD() & ~(v)))
#define HW_CSU_CSL38_TOG(v)    (HW_CSU_CSL38_WR(HW_CSU_CSL38_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL38 bitfields
 */

/* --- Register HW_CSU_CSL38, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL38_SUR_S2      (0)      //!< Bit position for CSU_CSL38_SUR_S2.
#define BM_CSU_CSL38_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL38_SUR_S2.

//! @brief Get value of CSU_CSL38_SUR_S2 from a register value.
#define BG_CSU_CSL38_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_SUR_S2) >> BP_CSU_CSL38_SUR_S2)

//! @brief Format value for bitfield CSU_CSL38_SUR_S2.
#define BF_CSU_CSL38_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_SUR_S2) & BM_CSU_CSL38_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL38_SUR_S2(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_SUR_S2) | BF_CSU_CSL38_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL38, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL38_SSR_S2      (1)      //!< Bit position for CSU_CSL38_SSR_S2.
#define BM_CSU_CSL38_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL38_SSR_S2.

//! @brief Get value of CSU_CSL38_SSR_S2 from a register value.
#define BG_CSU_CSL38_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_SSR_S2) >> BP_CSU_CSL38_SSR_S2)

//! @brief Format value for bitfield CSU_CSL38_SSR_S2.
#define BF_CSU_CSL38_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_SSR_S2) & BM_CSU_CSL38_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL38_SSR_S2(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_SSR_S2) | BF_CSU_CSL38_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL38, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL38_NUR_S2      (2)      //!< Bit position for CSU_CSL38_NUR_S2.
#define BM_CSU_CSL38_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL38_NUR_S2.

//! @brief Get value of CSU_CSL38_NUR_S2 from a register value.
#define BG_CSU_CSL38_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_NUR_S2) >> BP_CSU_CSL38_NUR_S2)

//! @brief Format value for bitfield CSU_CSL38_NUR_S2.
#define BF_CSU_CSL38_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_NUR_S2) & BM_CSU_CSL38_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL38_NUR_S2(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_NUR_S2) | BF_CSU_CSL38_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL38, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL38_NSR_S2      (3)      //!< Bit position for CSU_CSL38_NSR_S2.
#define BM_CSU_CSL38_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL38_NSR_S2.

//! @brief Get value of CSU_CSL38_NSR_S2 from a register value.
#define BG_CSU_CSL38_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_NSR_S2) >> BP_CSU_CSL38_NSR_S2)

//! @brief Format value for bitfield CSU_CSL38_NSR_S2.
#define BF_CSU_CSL38_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_NSR_S2) & BM_CSU_CSL38_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL38_NSR_S2(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_NSR_S2) | BF_CSU_CSL38_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL38, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL38_SUW_S2      (4)      //!< Bit position for CSU_CSL38_SUW_S2.
#define BM_CSU_CSL38_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL38_SUW_S2.

//! @brief Get value of CSU_CSL38_SUW_S2 from a register value.
#define BG_CSU_CSL38_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_SUW_S2) >> BP_CSU_CSL38_SUW_S2)

//! @brief Format value for bitfield CSU_CSL38_SUW_S2.
#define BF_CSU_CSL38_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_SUW_S2) & BM_CSU_CSL38_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL38_SUW_S2(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_SUW_S2) | BF_CSU_CSL38_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL38, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL38_SSW_S2      (5)      //!< Bit position for CSU_CSL38_SSW_S2.
#define BM_CSU_CSL38_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL38_SSW_S2.

//! @brief Get value of CSU_CSL38_SSW_S2 from a register value.
#define BG_CSU_CSL38_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_SSW_S2) >> BP_CSU_CSL38_SSW_S2)

//! @brief Format value for bitfield CSU_CSL38_SSW_S2.
#define BF_CSU_CSL38_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_SSW_S2) & BM_CSU_CSL38_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL38_SSW_S2(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_SSW_S2) | BF_CSU_CSL38_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL38, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL38_NUW_S2      (6)      //!< Bit position for CSU_CSL38_NUW_S2.
#define BM_CSU_CSL38_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL38_NUW_S2.

//! @brief Get value of CSU_CSL38_NUW_S2 from a register value.
#define BG_CSU_CSL38_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_NUW_S2) >> BP_CSU_CSL38_NUW_S2)

//! @brief Format value for bitfield CSU_CSL38_NUW_S2.
#define BF_CSU_CSL38_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_NUW_S2) & BM_CSU_CSL38_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL38_NUW_S2(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_NUW_S2) | BF_CSU_CSL38_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL38, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL38_NSW_S2      (7)      //!< Bit position for CSU_CSL38_NSW_S2.
#define BM_CSU_CSL38_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL38_NSW_S2.

//! @brief Get value of CSU_CSL38_NSW_S2 from a register value.
#define BG_CSU_CSL38_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_NSW_S2) >> BP_CSU_CSL38_NSW_S2)

//! @brief Format value for bitfield CSU_CSL38_NSW_S2.
#define BF_CSU_CSL38_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_NSW_S2) & BM_CSU_CSL38_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL38_NSW_S2(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_NSW_S2) | BF_CSU_CSL38_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL38, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL38_LOCK_S2      (8)      //!< Bit position for CSU_CSL38_LOCK_S2.
#define BM_CSU_CSL38_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL38_LOCK_S2.

//! @brief Get value of CSU_CSL38_LOCK_S2 from a register value.
#define BG_CSU_CSL38_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_LOCK_S2) >> BP_CSU_CSL38_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL38_LOCK_S2.
#define BF_CSU_CSL38_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_LOCK_S2) & BM_CSU_CSL38_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL38_LOCK_S2(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_LOCK_S2) | BF_CSU_CSL38_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL38, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL38_SUR_S1      (16)      //!< Bit position for CSU_CSL38_SUR_S1.
#define BM_CSU_CSL38_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL38_SUR_S1.

//! @brief Get value of CSU_CSL38_SUR_S1 from a register value.
#define BG_CSU_CSL38_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_SUR_S1) >> BP_CSU_CSL38_SUR_S1)

//! @brief Format value for bitfield CSU_CSL38_SUR_S1.
#define BF_CSU_CSL38_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_SUR_S1) & BM_CSU_CSL38_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL38_SUR_S1(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_SUR_S1) | BF_CSU_CSL38_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL38, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL38_SSR_S1      (17)      //!< Bit position for CSU_CSL38_SSR_S1.
#define BM_CSU_CSL38_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL38_SSR_S1.

//! @brief Get value of CSU_CSL38_SSR_S1 from a register value.
#define BG_CSU_CSL38_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_SSR_S1) >> BP_CSU_CSL38_SSR_S1)

//! @brief Format value for bitfield CSU_CSL38_SSR_S1.
#define BF_CSU_CSL38_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_SSR_S1) & BM_CSU_CSL38_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL38_SSR_S1(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_SSR_S1) | BF_CSU_CSL38_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL38, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL38_NUR_S1      (18)      //!< Bit position for CSU_CSL38_NUR_S1.
#define BM_CSU_CSL38_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL38_NUR_S1.

//! @brief Get value of CSU_CSL38_NUR_S1 from a register value.
#define BG_CSU_CSL38_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_NUR_S1) >> BP_CSU_CSL38_NUR_S1)

//! @brief Format value for bitfield CSU_CSL38_NUR_S1.
#define BF_CSU_CSL38_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_NUR_S1) & BM_CSU_CSL38_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL38_NUR_S1(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_NUR_S1) | BF_CSU_CSL38_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL38, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL38_NSR_S1      (19)      //!< Bit position for CSU_CSL38_NSR_S1.
#define BM_CSU_CSL38_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL38_NSR_S1.

//! @brief Get value of CSU_CSL38_NSR_S1 from a register value.
#define BG_CSU_CSL38_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_NSR_S1) >> BP_CSU_CSL38_NSR_S1)

//! @brief Format value for bitfield CSU_CSL38_NSR_S1.
#define BF_CSU_CSL38_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_NSR_S1) & BM_CSU_CSL38_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL38_NSR_S1(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_NSR_S1) | BF_CSU_CSL38_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL38, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL38_SUW_S1      (20)      //!< Bit position for CSU_CSL38_SUW_S1.
#define BM_CSU_CSL38_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL38_SUW_S1.

//! @brief Get value of CSU_CSL38_SUW_S1 from a register value.
#define BG_CSU_CSL38_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_SUW_S1) >> BP_CSU_CSL38_SUW_S1)

//! @brief Format value for bitfield CSU_CSL38_SUW_S1.
#define BF_CSU_CSL38_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_SUW_S1) & BM_CSU_CSL38_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL38_SUW_S1(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_SUW_S1) | BF_CSU_CSL38_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL38, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL38_SSW_S1      (21)      //!< Bit position for CSU_CSL38_SSW_S1.
#define BM_CSU_CSL38_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL38_SSW_S1.

//! @brief Get value of CSU_CSL38_SSW_S1 from a register value.
#define BG_CSU_CSL38_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_SSW_S1) >> BP_CSU_CSL38_SSW_S1)

//! @brief Format value for bitfield CSU_CSL38_SSW_S1.
#define BF_CSU_CSL38_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_SSW_S1) & BM_CSU_CSL38_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL38_SSW_S1(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_SSW_S1) | BF_CSU_CSL38_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL38, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL38_NUW_S1      (22)      //!< Bit position for CSU_CSL38_NUW_S1.
#define BM_CSU_CSL38_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL38_NUW_S1.

//! @brief Get value of CSU_CSL38_NUW_S1 from a register value.
#define BG_CSU_CSL38_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_NUW_S1) >> BP_CSU_CSL38_NUW_S1)

//! @brief Format value for bitfield CSU_CSL38_NUW_S1.
#define BF_CSU_CSL38_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_NUW_S1) & BM_CSU_CSL38_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL38_NUW_S1(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_NUW_S1) | BF_CSU_CSL38_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL38, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL38_NSW_S1      (23)      //!< Bit position for CSU_CSL38_NSW_S1.
#define BM_CSU_CSL38_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL38_NSW_S1.

//! @brief Get value of CSU_CSL38_NSW_S1 from a register value.
#define BG_CSU_CSL38_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_NSW_S1) >> BP_CSU_CSL38_NSW_S1)

//! @brief Format value for bitfield CSU_CSL38_NSW_S1.
#define BF_CSU_CSL38_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_NSW_S1) & BM_CSU_CSL38_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL38_NSW_S1(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_NSW_S1) | BF_CSU_CSL38_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL38, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL38_LOCK_S1      (24)      //!< Bit position for CSU_CSL38_LOCK_S1.
#define BM_CSU_CSL38_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL38_LOCK_S1.

//! @brief Get value of CSU_CSL38_LOCK_S1 from a register value.
#define BG_CSU_CSL38_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL38_LOCK_S1) >> BP_CSU_CSL38_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL38_LOCK_S1.
#define BF_CSU_CSL38_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL38_LOCK_S1) & BM_CSU_CSL38_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL38_LOCK_S1(v)   (HW_CSU_CSL38_WR((HW_CSU_CSL38_RD() & ~BM_CSU_CSL38_LOCK_S1) | BF_CSU_CSL38_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_CSL39 - Config security level register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_CSL39 - Config security level register (RW)
 *
 * Reset value: 0x00330033
 *
 * There are 40 Config Security Level (CSU_CSL0-CSU_CSL39) registers. Each CSU_CSL is comprised of
 * two fields, each field used to determine the read and write access permissions for a slave
 * peripheral. These 8-bit fields for the first and second slaves are in the locations b23-b16 and
 * bits b7-b0, respectively.  Permission Access Table shows security levels and csu_sec_level signal
 * levels corresponding to different values of the 8-bit CSU_CSL field for a given slave.  Memory
 * space has been reserved for 128 slaves since each of the sixty-four 32-bit register can
 * accommodate CSL fields of two slaves. However, actual number of registers inferred in a design
 * would depend on the following Parameter --- Name - No_Of_Slaves Min. Value - 48 Max. Value - 128
 * Possible Values - 48,64,80,96,112,128  Most slaves have unique CSL registers. Some slaves are
 * grouped together in USB, Timers, PowerUp and Audio groups. The following table shows allocation
 * of CSL register per slave or group of slave modules.   CSL Slave Modules Mapping         Slave
 * Module    Corresponding CSL register and bit field   Comments       PWM1  PWM2  PWM3  PWM4
 * CSL0 [7:0]    Audio group shared control      CAN1    CSL0 [23:16]       CAN2    CSL1 [7:0]
 * GPT  EPIT1  EPIT2    CSL1 [23:16]    Timers group      GPIO1  GPIO2    CSL2 [7:0]    GPIO1 and
 * GPIO2 group      GPIO3  GPIO4    CSL2 [23:16]    GPIO3 and GPIO4 group      GPIO5  GPIO6    CSL3
 * [7:0]    GPIO5 and GPIO6 group      GPIO7    CSL3 [23:16]       KPP    CSL4 [7:0]       WDOG1
 * CSL4 [23:16]       WDOG2    CSL5 [7:0]       CCM  SNVS_HP  SRC  GPC    CSL5 [23:16]    Power
 * group      IP2APB_ANATOP    CSL6 [7:0]       IOMUXC    CSL6 [23:16]       DCIC1  DCIC2    CSL7
 * [7:0]       SDMA (port IPS_HOST)  EPDC for i.MX6SDL only   LCDIF for i.MX6SDL only   PXP for
 * i.MX6SDL only     CSL7 [23:16]       USBOH3 (port PL301)  USBOH3 (port USB)    CSL8 [7:0]
 * ENET    CSL8 [23:16]       MLB150    CSL9 [7:0]       USDHC1    CSL9 [23:16]       USDHC2
 * CSL10 [7:0]       USDHC3    CSL10 [23:16]       USDHC4    CSL11 [7:0]       I2C1    CSL11 [23:16]
 * I2C2    CSL12 [7:0]       I2C3    CSL12 [23:16]       ROMCP    CSL13[7:0]      VPU MMDC_CORE
 * (port IPS_P0) MMDC_CORE (port IPS_P1)   CSL13 [23:16]    MMDC Group      WEIM    CSL14 [7:0]
 * OCOTP_CTRL    CSL14 [23:16]       Reserved    CSL15 [7:0]       PERFMON1  PERFMON2  PERFMON3
 * CSL15 [23:16]    PerfMon group      TZASC1    CSL16 [7:0]       TZASC2    CSL16 [23:16]
 * AUDMUX    CSL17 [7:0]       CAAM    CSL17 [23:16]       SPDIF    CSL18 [7:0]       eCSPI1
 * CSL18 [23:16]       eCSPI2    CSL19 [7:0]       eCSPI3    CSL19 [23:16]       eCSPI4    CSL20
 * [7:0]       eCSPI5  Reserved for i.MX6SDL     CSL20 [23:16]       UART1    CSL21 [7:0]
 * ESAI1    CSL21 [23:16]       SSI1    CSL22 [7:0]       SSI2    CSL22 [23:16]       SSI3    CSL23
 * [7:0]       ASRC (VIA IPSYNC)    CSL23 [23:16]       Reserved    CSL24 [7:0]       ROMCP    CSL24
 * [23:16]       Reserved    CSL25 [7:0]       Reserved    CSL25 [23:16]       OCRAM    CSL26 [7:0]
 * CAAM    CSL26 [23:16]       APBH_DMA    CSL27 [7:0]       HDMI    CSL27 [23:16]       GPU3D
 * CSL28[7:0]       SATA  Reserved for i.MX6SDL     CSL28 [23:16]       OPENVG  Reserved for
 * i.MX6SDL     CSL29 [7:0]       ARM core platform DAP and platform controller    CSL29 [23:16]
 * HSI    CSL30 [7:0]       IPU1    CSL30 [23:16]       IPU2  Reserved for i.MX6SDL     CSL31 [7:0]
 * WEIM    CSL31 [23:16]       PCIE    CSL32 [7:0]       GPU2D    CSL32 [23:16]       MIPI_CORE_CSI
 * CSL33 [7:0]       MIPI_CORE_HSI    CSL33 [23:16]       VDOA    CSL34 [7:0]       UART2    CSL34
 * [23:16]       UART3    CSL35 [7:0]       UART4    CSL35 [23:16]       UART5  I2C4 for i.MX6SDL
 * only     CSL36 [7:0]       DTCP    CSL36 [23:16]       Reserved    CSL37 [7:0]       Reserved
 * CSL37 [23:16]       Reserved    CSL38 [7:0]       Reserved    CSL38 [23:16]       SPBA    CSL39
 * [7:0]       Reserved    CSL39 [23:16]        Do not modify the following peripherals' CSL
 * register bits while they are being accessed through the AHB/AXI slave bus: EIM, IPU, DTCP,
 * APBHDMA and PCIe.
 */
typedef union _hw_csu_csl39
{
    reg32_t U;
    struct _hw_csu_csl39_bitfields
    {
        unsigned SUR_S2 : 1; //!< [0] Secure user read access control for the second slave
        unsigned SSR_S2 : 1; //!< [1] Secure supervisor read access control for the second slave
        unsigned NUR_S2 : 1; //!< [2] Non-secure user read access control for the second slave
        unsigned NSR_S2 : 1; //!< [3] Non-secure supervisor read access control for the second slave
        unsigned SUW_S2 : 1; //!< [4] Secure user write access control for the second slave
        unsigned SSW_S2 : 1; //!< [5] Secure supervisor write access control for the second slave
        unsigned NUW_S2 : 1; //!< [6] Non-secure user write access control for the second slave
        unsigned NSW_S2 : 1; //!< [7] Non-secure supervisor write access control for the second slave
        unsigned LOCK_S2 : 1; //!< [8] Lock bit corresponding to the second slave. Written by secure software.
        unsigned RESERVED0 : 7; //!< [15:9] Reserved
        unsigned SUR_S1 : 1; //!< [16] Secure user read access control for the first slave
        unsigned SSR_S1 : 1; //!< [17] Secure supervisor read access control for the first slave
        unsigned NUR_S1 : 1; //!< [18] Non-secure user read access control for the first slave
        unsigned NSR_S1 : 1; //!< [19] Non-secure supervisor read access control for the first slave
        unsigned SUW_S1 : 1; //!< [20] Secure user write access control for the first slave
        unsigned SSW_S1 : 1; //!< [21] Secure supervisor write access control for the first slave
        unsigned NUW_S1 : 1; //!< [22] Non-secure user write access control for the first slave
        unsigned NSW_S1 : 1; //!< [23] Non-secure supervisor write access control for the first slave
        unsigned LOCK_S1 : 1; //!< [24] Lock bit corresponding to the first slave. Written by secure software.
        unsigned RESERVED1 : 7; //!< [31:25] Reserved
    } B;
} hw_csu_csl39_t;
#endif

/*
 * constants & macros for entire CSU_CSL39 register
 */
#define HW_CSU_CSL39_ADDR      (REGS_CSU_BASE + 0x9c)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_CSL39           (*(volatile hw_csu_csl39_t *) HW_CSU_CSL39_ADDR)
#define HW_CSU_CSL39_RD()      (HW_CSU_CSL39.U)
#define HW_CSU_CSL39_WR(v)     (HW_CSU_CSL39.U = (v))
#define HW_CSU_CSL39_SET(v)    (HW_CSU_CSL39_WR(HW_CSU_CSL39_RD() |  (v)))
#define HW_CSU_CSL39_CLR(v)    (HW_CSU_CSL39_WR(HW_CSU_CSL39_RD() & ~(v)))
#define HW_CSU_CSL39_TOG(v)    (HW_CSU_CSL39_WR(HW_CSU_CSL39_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_CSL39 bitfields
 */

/* --- Register HW_CSU_CSL39, field SUR_S2[0] (RW)
 *
 * Secure user read access control for the second slave
 *
 * Values:
 * 0 - Secure user read access disabled for the second slave.
 * 1 - Secure user read access enabled for the second slave
 */

#define BP_CSU_CSL39_SUR_S2      (0)      //!< Bit position for CSU_CSL39_SUR_S2.
#define BM_CSU_CSL39_SUR_S2      (0x00000001)  //!< Bit mask for CSU_CSL39_SUR_S2.

//! @brief Get value of CSU_CSL39_SUR_S2 from a register value.
#define BG_CSU_CSL39_SUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_SUR_S2) >> BP_CSU_CSL39_SUR_S2)

//! @brief Format value for bitfield CSU_CSL39_SUR_S2.
#define BF_CSU_CSL39_SUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_SUR_S2) & BM_CSU_CSL39_SUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S2 field to a new value.
#define BW_CSU_CSL39_SUR_S2(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_SUR_S2) | BF_CSU_CSL39_SUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL39, field SSR_S2[1] (RW)
 *
 * Secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the second slave.
 * 1 - Secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL39_SSR_S2      (1)      //!< Bit position for CSU_CSL39_SSR_S2.
#define BM_CSU_CSL39_SSR_S2      (0x00000002)  //!< Bit mask for CSU_CSL39_SSR_S2.

//! @brief Get value of CSU_CSL39_SSR_S2 from a register value.
#define BG_CSU_CSL39_SSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_SSR_S2) >> BP_CSU_CSL39_SSR_S2)

//! @brief Format value for bitfield CSU_CSL39_SSR_S2.
#define BF_CSU_CSL39_SSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_SSR_S2) & BM_CSU_CSL39_SSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S2 field to a new value.
#define BW_CSU_CSL39_SSR_S2(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_SSR_S2) | BF_CSU_CSL39_SSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL39, field NUR_S2[2] (RW)
 *
 * Non-secure user read access control for the second slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the second slave.
 * 1 - Non-secure user read access enabled for the second slave.
 */

#define BP_CSU_CSL39_NUR_S2      (2)      //!< Bit position for CSU_CSL39_NUR_S2.
#define BM_CSU_CSL39_NUR_S2      (0x00000004)  //!< Bit mask for CSU_CSL39_NUR_S2.

//! @brief Get value of CSU_CSL39_NUR_S2 from a register value.
#define BG_CSU_CSL39_NUR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_NUR_S2) >> BP_CSU_CSL39_NUR_S2)

//! @brief Format value for bitfield CSU_CSL39_NUR_S2.
#define BF_CSU_CSL39_NUR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_NUR_S2) & BM_CSU_CSL39_NUR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S2 field to a new value.
#define BW_CSU_CSL39_NUR_S2(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_NUR_S2) | BF_CSU_CSL39_NUR_S2(v)))
#endif


/* --- Register HW_CSU_CSL39, field NSR_S2[3] (RW)
 *
 * Non-secure supervisor read access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the second slave.
 * 1 - Non-secure supervisor read access enabled for the second slave.
 */

#define BP_CSU_CSL39_NSR_S2      (3)      //!< Bit position for CSU_CSL39_NSR_S2.
#define BM_CSU_CSL39_NSR_S2      (0x00000008)  //!< Bit mask for CSU_CSL39_NSR_S2.

//! @brief Get value of CSU_CSL39_NSR_S2 from a register value.
#define BG_CSU_CSL39_NSR_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_NSR_S2) >> BP_CSU_CSL39_NSR_S2)

//! @brief Format value for bitfield CSU_CSL39_NSR_S2.
#define BF_CSU_CSL39_NSR_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_NSR_S2) & BM_CSU_CSL39_NSR_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S2 field to a new value.
#define BW_CSU_CSL39_NSR_S2(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_NSR_S2) | BF_CSU_CSL39_NSR_S2(v)))
#endif


/* --- Register HW_CSU_CSL39, field SUW_S2[4] (RW)
 *
 * Secure user write access control for the second slave
 *
 * Values:
 * 0 - Secure user write access disabled for the second slave.
 * 1 - Secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL39_SUW_S2      (4)      //!< Bit position for CSU_CSL39_SUW_S2.
#define BM_CSU_CSL39_SUW_S2      (0x00000010)  //!< Bit mask for CSU_CSL39_SUW_S2.

//! @brief Get value of CSU_CSL39_SUW_S2 from a register value.
#define BG_CSU_CSL39_SUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_SUW_S2) >> BP_CSU_CSL39_SUW_S2)

//! @brief Format value for bitfield CSU_CSL39_SUW_S2.
#define BF_CSU_CSL39_SUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_SUW_S2) & BM_CSU_CSL39_SUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S2 field to a new value.
#define BW_CSU_CSL39_SUW_S2(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_SUW_S2) | BF_CSU_CSL39_SUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL39, field SSW_S2[5] (RW)
 *
 * Secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the second slave.
 * 1 - Secure supervisor write access enabled for the second slave.
 */

#define BP_CSU_CSL39_SSW_S2      (5)      //!< Bit position for CSU_CSL39_SSW_S2.
#define BM_CSU_CSL39_SSW_S2      (0x00000020)  //!< Bit mask for CSU_CSL39_SSW_S2.

//! @brief Get value of CSU_CSL39_SSW_S2 from a register value.
#define BG_CSU_CSL39_SSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_SSW_S2) >> BP_CSU_CSL39_SSW_S2)

//! @brief Format value for bitfield CSU_CSL39_SSW_S2.
#define BF_CSU_CSL39_SSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_SSW_S2) & BM_CSU_CSL39_SSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S2 field to a new value.
#define BW_CSU_CSL39_SSW_S2(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_SSW_S2) | BF_CSU_CSL39_SSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL39, field NUW_S2[6] (RW)
 *
 * Non-secure user write access control for the second slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the second slave.
 * 1 - Non-secure user write access enabled for the second slave.
 */

#define BP_CSU_CSL39_NUW_S2      (6)      //!< Bit position for CSU_CSL39_NUW_S2.
#define BM_CSU_CSL39_NUW_S2      (0x00000040)  //!< Bit mask for CSU_CSL39_NUW_S2.

//! @brief Get value of CSU_CSL39_NUW_S2 from a register value.
#define BG_CSU_CSL39_NUW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_NUW_S2) >> BP_CSU_CSL39_NUW_S2)

//! @brief Format value for bitfield CSU_CSL39_NUW_S2.
#define BF_CSU_CSL39_NUW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_NUW_S2) & BM_CSU_CSL39_NUW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S2 field to a new value.
#define BW_CSU_CSL39_NUW_S2(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_NUW_S2) | BF_CSU_CSL39_NUW_S2(v)))
#endif


/* --- Register HW_CSU_CSL39, field NSW_S2[7] (RW)
 *
 * Non-secure supervisor write access control for the second slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the second slave.
 * 1 - Non-secure supervisor write access enabled for the second slave
 */

#define BP_CSU_CSL39_NSW_S2      (7)      //!< Bit position for CSU_CSL39_NSW_S2.
#define BM_CSU_CSL39_NSW_S2      (0x00000080)  //!< Bit mask for CSU_CSL39_NSW_S2.

//! @brief Get value of CSU_CSL39_NSW_S2 from a register value.
#define BG_CSU_CSL39_NSW_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_NSW_S2) >> BP_CSU_CSL39_NSW_S2)

//! @brief Format value for bitfield CSU_CSL39_NSW_S2.
#define BF_CSU_CSL39_NSW_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_NSW_S2) & BM_CSU_CSL39_NSW_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S2 field to a new value.
#define BW_CSU_CSL39_NSW_S2(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_NSW_S2) | BF_CSU_CSL39_NSW_S2(v)))
#endif


/* --- Register HW_CSU_CSL39, field LOCK_S2[8] (RW)
 *
 * Lock bit corresponding to the second slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 7-0 may be written by software
 * 1 - Bits 7-0 locked and cannot be written by software
 */

#define BP_CSU_CSL39_LOCK_S2      (8)      //!< Bit position for CSU_CSL39_LOCK_S2.
#define BM_CSU_CSL39_LOCK_S2      (0x00000100)  //!< Bit mask for CSU_CSL39_LOCK_S2.

//! @brief Get value of CSU_CSL39_LOCK_S2 from a register value.
#define BG_CSU_CSL39_LOCK_S2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_LOCK_S2) >> BP_CSU_CSL39_LOCK_S2)

//! @brief Format value for bitfield CSU_CSL39_LOCK_S2.
#define BF_CSU_CSL39_LOCK_S2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_LOCK_S2) & BM_CSU_CSL39_LOCK_S2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S2 field to a new value.
#define BW_CSU_CSL39_LOCK_S2(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_LOCK_S2) | BF_CSU_CSL39_LOCK_S2(v)))
#endif


/* --- Register HW_CSU_CSL39, field SUR_S1[16] (RW)
 *
 * Secure user read access control for the first slave
 *
 * Values:
 * 0 - Secure user read access disabled for the first slave.
 * 1 - Secure user read access enabled for the first slave
 */

#define BP_CSU_CSL39_SUR_S1      (16)      //!< Bit position for CSU_CSL39_SUR_S1.
#define BM_CSU_CSL39_SUR_S1      (0x00010000)  //!< Bit mask for CSU_CSL39_SUR_S1.

//! @brief Get value of CSU_CSL39_SUR_S1 from a register value.
#define BG_CSU_CSL39_SUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_SUR_S1) >> BP_CSU_CSL39_SUR_S1)

//! @brief Format value for bitfield CSU_CSL39_SUR_S1.
#define BF_CSU_CSL39_SUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_SUR_S1) & BM_CSU_CSL39_SUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUR_S1 field to a new value.
#define BW_CSU_CSL39_SUR_S1(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_SUR_S1) | BF_CSU_CSL39_SUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL39, field SSR_S1[17] (RW)
 *
 * Secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor read access disabled for the first slave.
 * 1 - Secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL39_SSR_S1      (17)      //!< Bit position for CSU_CSL39_SSR_S1.
#define BM_CSU_CSL39_SSR_S1      (0x00020000)  //!< Bit mask for CSU_CSL39_SSR_S1.

//! @brief Get value of CSU_CSL39_SSR_S1 from a register value.
#define BG_CSU_CSL39_SSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_SSR_S1) >> BP_CSU_CSL39_SSR_S1)

//! @brief Format value for bitfield CSU_CSL39_SSR_S1.
#define BF_CSU_CSL39_SSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_SSR_S1) & BM_CSU_CSL39_SSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSR_S1 field to a new value.
#define BW_CSU_CSL39_SSR_S1(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_SSR_S1) | BF_CSU_CSL39_SSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL39, field NUR_S1[18] (RW)
 *
 * Non-secure user read access control for the first slave
 *
 * Values:
 * 0 - Non-secure user read access disabled for the first slave.
 * 1 - Non-secure user read access enabled for the first slave.
 */

#define BP_CSU_CSL39_NUR_S1      (18)      //!< Bit position for CSU_CSL39_NUR_S1.
#define BM_CSU_CSL39_NUR_S1      (0x00040000)  //!< Bit mask for CSU_CSL39_NUR_S1.

//! @brief Get value of CSU_CSL39_NUR_S1 from a register value.
#define BG_CSU_CSL39_NUR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_NUR_S1) >> BP_CSU_CSL39_NUR_S1)

//! @brief Format value for bitfield CSU_CSL39_NUR_S1.
#define BF_CSU_CSL39_NUR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_NUR_S1) & BM_CSU_CSL39_NUR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUR_S1 field to a new value.
#define BW_CSU_CSL39_NUR_S1(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_NUR_S1) | BF_CSU_CSL39_NUR_S1(v)))
#endif


/* --- Register HW_CSU_CSL39, field NSR_S1[19] (RW)
 *
 * Non-secure supervisor read access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor read access disabled for the first slave.
 * 1 - Non-secure supervisor read access enabled for the first slave.
 */

#define BP_CSU_CSL39_NSR_S1      (19)      //!< Bit position for CSU_CSL39_NSR_S1.
#define BM_CSU_CSL39_NSR_S1      (0x00080000)  //!< Bit mask for CSU_CSL39_NSR_S1.

//! @brief Get value of CSU_CSL39_NSR_S1 from a register value.
#define BG_CSU_CSL39_NSR_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_NSR_S1) >> BP_CSU_CSL39_NSR_S1)

//! @brief Format value for bitfield CSU_CSL39_NSR_S1.
#define BF_CSU_CSL39_NSR_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_NSR_S1) & BM_CSU_CSL39_NSR_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSR_S1 field to a new value.
#define BW_CSU_CSL39_NSR_S1(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_NSR_S1) | BF_CSU_CSL39_NSR_S1(v)))
#endif


/* --- Register HW_CSU_CSL39, field SUW_S1[20] (RW)
 *
 * Secure user write access control for the first slave
 *
 * Values:
 * 0 - Secure user write access disabled for the first slave.
 * 1 - Secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL39_SUW_S1      (20)      //!< Bit position for CSU_CSL39_SUW_S1.
#define BM_CSU_CSL39_SUW_S1      (0x00100000)  //!< Bit mask for CSU_CSL39_SUW_S1.

//! @brief Get value of CSU_CSL39_SUW_S1 from a register value.
#define BG_CSU_CSL39_SUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_SUW_S1) >> BP_CSU_CSL39_SUW_S1)

//! @brief Format value for bitfield CSU_CSL39_SUW_S1.
#define BF_CSU_CSL39_SUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_SUW_S1) & BM_CSU_CSL39_SUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SUW_S1 field to a new value.
#define BW_CSU_CSL39_SUW_S1(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_SUW_S1) | BF_CSU_CSL39_SUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL39, field SSW_S1[21] (RW)
 *
 * Secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Secure supervisor write access disabled for the first slave.
 * 1 - Secure supervisor write access enabled for the first slave.
 */

#define BP_CSU_CSL39_SSW_S1      (21)      //!< Bit position for CSU_CSL39_SSW_S1.
#define BM_CSU_CSL39_SSW_S1      (0x00200000)  //!< Bit mask for CSU_CSL39_SSW_S1.

//! @brief Get value of CSU_CSL39_SSW_S1 from a register value.
#define BG_CSU_CSL39_SSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_SSW_S1) >> BP_CSU_CSL39_SSW_S1)

//! @brief Format value for bitfield CSU_CSL39_SSW_S1.
#define BF_CSU_CSL39_SSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_SSW_S1) & BM_CSU_CSL39_SSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SSW_S1 field to a new value.
#define BW_CSU_CSL39_SSW_S1(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_SSW_S1) | BF_CSU_CSL39_SSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL39, field NUW_S1[22] (RW)
 *
 * Non-secure user write access control for the first slave
 *
 * Values:
 * 0 - Non-secure user write access disabled for the first slave.
 * 1 - Non-secure user write access enabled for the first slave.
 */

#define BP_CSU_CSL39_NUW_S1      (22)      //!< Bit position for CSU_CSL39_NUW_S1.
#define BM_CSU_CSL39_NUW_S1      (0x00400000)  //!< Bit mask for CSU_CSL39_NUW_S1.

//! @brief Get value of CSU_CSL39_NUW_S1 from a register value.
#define BG_CSU_CSL39_NUW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_NUW_S1) >> BP_CSU_CSL39_NUW_S1)

//! @brief Format value for bitfield CSU_CSL39_NUW_S1.
#define BF_CSU_CSL39_NUW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_NUW_S1) & BM_CSU_CSL39_NUW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NUW_S1 field to a new value.
#define BW_CSU_CSL39_NUW_S1(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_NUW_S1) | BF_CSU_CSL39_NUW_S1(v)))
#endif


/* --- Register HW_CSU_CSL39, field NSW_S1[23] (RW)
 *
 * Non-secure supervisor write access control for the first slave
 *
 * Values:
 * 0 - Non-secure supervisor write access disabled for the first slave.
 * 1 - Non-secure supervisor write access enabled for the first slave
 */

#define BP_CSU_CSL39_NSW_S1      (23)      //!< Bit position for CSU_CSL39_NSW_S1.
#define BM_CSU_CSL39_NSW_S1      (0x00800000)  //!< Bit mask for CSU_CSL39_NSW_S1.

//! @brief Get value of CSU_CSL39_NSW_S1 from a register value.
#define BG_CSU_CSL39_NSW_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_NSW_S1) >> BP_CSU_CSL39_NSW_S1)

//! @brief Format value for bitfield CSU_CSL39_NSW_S1.
#define BF_CSU_CSL39_NSW_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_NSW_S1) & BM_CSU_CSL39_NSW_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the NSW_S1 field to a new value.
#define BW_CSU_CSL39_NSW_S1(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_NSW_S1) | BF_CSU_CSL39_NSW_S1(v)))
#endif


/* --- Register HW_CSU_CSL39, field LOCK_S1[24] (RW)
 *
 * Lock bit corresponding to the first slave. Written by secure software.
 *
 * Values:
 * 0 - Not locked. Bits 16-23 may be written by software
 * 1 - Bits 16-23 locked and cannot be written by software
 */

#define BP_CSU_CSL39_LOCK_S1      (24)      //!< Bit position for CSU_CSL39_LOCK_S1.
#define BM_CSU_CSL39_LOCK_S1      (0x01000000)  //!< Bit mask for CSU_CSL39_LOCK_S1.

//! @brief Get value of CSU_CSL39_LOCK_S1 from a register value.
#define BG_CSU_CSL39_LOCK_S1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_CSL39_LOCK_S1) >> BP_CSU_CSL39_LOCK_S1)

//! @brief Format value for bitfield CSU_CSL39_LOCK_S1.
#define BF_CSU_CSL39_LOCK_S1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_CSL39_LOCK_S1) & BM_CSU_CSL39_LOCK_S1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the LOCK_S1 field to a new value.
#define BW_CSU_CSL39_LOCK_S1(v)   (HW_CSU_CSL39_WR((HW_CSU_CSL39_RD() & ~BM_CSU_CSL39_LOCK_S1) | BF_CSU_CSL39_LOCK_S1(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_HP0 - HP0 register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_HP0 - HP0 register (RW)
 *
 * Reset value: 0x00000000
 *
 * The SCU_HP0 and SCU_HP1 registers may be programmed to determine the privilege (either User Mode
 * or Supervisor Mode) for seventeen different master groups. The privilege of a particular master
 * group may be overridden by muxing it with the corresponding bit in this register.  The even bit
 * positions (CSU_HP0[30,28,...0] and CSU_HP1[0]) in the registers hold the privilege indicator
 * bits; while the odd bit positions (CSU_HP0[31,29,...,1] and CSU_HP1[1]) contain lock bits which
 * enable/disable writing to the corresponding privilege indicator bits.  Memory Space has been
 * reserved for 32 Masters. Since, one 32 bit register can accommodate HP fields corresponding to 16
 * masters, hence for 32 masters memory equivalent of 2 registers is reserved.However, actual number
 * of registers(flops) inferred in a design would depend on the following Parameter --- Name -
 * No_Of_Masters Min. Value -1 Max. Value - 32 Possible Values - 1 to 32
 */
typedef union _hw_csu_hp0
{
    reg32_t U;
    struct _hw_csu_hp0_bitfields
    {
        unsigned HP_PCIE : 1; //!< [0] Indicate the Privilege/User Mode for PCIE.
        unsigned L_PCIE : 1; //!< [1] Lock bit set by TZ software for HP_PCIE.
        unsigned RESERVED0 : 2; //!< [3:2] Reserved.
        unsigned HP_SDMA : 1; //!< [4] Indicate the Privilege/User Mode for SDMA.
        unsigned L_SDMA : 1; //!< [5] Lock bit set by TZ software for HP_SDMA.
        unsigned HP_PU : 1; //!< [6] Indicate the Privilege/User Mode for GPU3D, GPU2D, VPU, IPU1, IPU2, OpenVG EPDC, PXP, LCDIF and VDOA. NOTE: IPU2 and OpenVG on i.MX6DQ only; EPDC, PXP and LCDIF on i.MX6SDL only
        unsigned L_PU : 1; //!< [7] Lock bit set by TZ software for HP_PU.
        unsigned HP_USB : 1; //!< [8] Indicate the Privilege/User Mode for USB.
        unsigned L_USB : 1; //!< [9] Lock bit set by TZ software for HP_USB.
        unsigned HP_TEST : 1; //!< [10] Indicate the Privilege/User Mode for IOMUX Test Port.
        unsigned L_TEST : 1; //!< [11] Lock bit set by TZ software for HP_TEST.
        unsigned HP_MLB : 1; //!< [12] Indicate the mode Privilege/User Mode for MLB.
        unsigned L_MLB : 1; //!< [13] Lock bit set by TZ software for HP_MLB.
        unsigned HP_CAAM : 1; //!< [14] Indicate the Privilege/User Mode for CAAM.
        unsigned L_CAAM : 1; //!< [15] Lock bit set by TZ software for HP_CAAM.
        unsigned HP_RAWNAND : 1; //!< [16] Indicate the Privilege/User Mode for RawNAND.
        unsigned L_RAWNAND : 1; //!< [17] Lock bit set by TZ software for HP_RAWNAND.
        unsigned HP_APBHDMA : 1; //!< [18] Indicate the Privilege/User Mode for apbhdma.
        unsigned L_ABPHDMA : 1; //!< [19] Lock bit set by TZ software for HP_APBHDMA.
        unsigned HP_ENET : 1; //!< [20] Indicate the Privilege/User Mode for ENET.
        unsigned L_ENET : 1; //!< [21] Lock bit set by TZ software for HP_ENET.
        unsigned HP_DAP : 1; //!< [22] Indicate the Privilege/User Mode for DAP.
        unsigned L_DAP : 1; //!< [23] Lock bit set by TZ software for HP_DAP.
        unsigned HP_USDHC1 : 1; //!< [24] Indicate the Privilege/User Mode for USDHC1.
        unsigned L_USDHC1 : 1; //!< [25] Lock bit set by TZ software for HP_USDHC1.
        unsigned HP_USDHC2 : 1; //!< [26] Indicate the Privilege/User Mode for USDHC2.
        unsigned L_USDHC2 : 1; //!< [27] Lock bit set by TZ software for HP_USDHC2.
        unsigned HP_USDHC3 : 1; //!< [28] Indicate the Privilege/User Mode for USDHC3.
        unsigned L_USDHC3 : 1; //!< [29] Lock bit set by TZ software for HP_USDHC3.
        unsigned HP_USDHC4 : 1; //!< [30] Indicate the Privilege/User Mode for USDHC4.
        unsigned L_USDHC4 : 1; //!< [31] Lock bit set by TZ software for HP_USDHC4.
    } B;
} hw_csu_hp0_t;
#endif

/*
 * constants & macros for entire CSU_HP0 register
 */
#define HW_CSU_HP0_ADDR      (REGS_CSU_BASE + 0x200)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_HP0           (*(volatile hw_csu_hp0_t *) HW_CSU_HP0_ADDR)
#define HW_CSU_HP0_RD()      (HW_CSU_HP0.U)
#define HW_CSU_HP0_WR(v)     (HW_CSU_HP0.U = (v))
#define HW_CSU_HP0_SET(v)    (HW_CSU_HP0_WR(HW_CSU_HP0_RD() |  (v)))
#define HW_CSU_HP0_CLR(v)    (HW_CSU_HP0_WR(HW_CSU_HP0_RD() & ~(v)))
#define HW_CSU_HP0_TOG(v)    (HW_CSU_HP0_WR(HW_CSU_HP0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_HP0 bitfields
 */

/* --- Register HW_CSU_HP0, field HP_PCIE[0] (RW)
 *
 * Indicate the Privilege/User Mode for PCIE.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_PCIE      (0)      //!< Bit position for CSU_HP0_HP_PCIE.
#define BM_CSU_HP0_HP_PCIE      (0x00000001)  //!< Bit mask for CSU_HP0_HP_PCIE.

//! @brief Get value of CSU_HP0_HP_PCIE from a register value.
#define BG_CSU_HP0_HP_PCIE(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_PCIE) >> BP_CSU_HP0_HP_PCIE)

//! @brief Format value for bitfield CSU_HP0_HP_PCIE.
#define BF_CSU_HP0_HP_PCIE(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_PCIE) & BM_CSU_HP0_HP_PCIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_PCIE field to a new value.
#define BW_CSU_HP0_HP_PCIE(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_PCIE) | BF_CSU_HP0_HP_PCIE(v)))
#endif


/* --- Register HW_CSU_HP0, field L_PCIE[1] (RW)
 *
 * Lock bit set by TZ software for HP_PCIE.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_PCIE      (1)      //!< Bit position for CSU_HP0_L_PCIE.
#define BM_CSU_HP0_L_PCIE      (0x00000002)  //!< Bit mask for CSU_HP0_L_PCIE.

//! @brief Get value of CSU_HP0_L_PCIE from a register value.
#define BG_CSU_HP0_L_PCIE(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_PCIE) >> BP_CSU_HP0_L_PCIE)

//! @brief Format value for bitfield CSU_HP0_L_PCIE.
#define BF_CSU_HP0_L_PCIE(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_PCIE) & BM_CSU_HP0_L_PCIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_PCIE field to a new value.
#define BW_CSU_HP0_L_PCIE(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_PCIE) | BF_CSU_HP0_L_PCIE(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_SDMA[4] (RW)
 *
 * Indicate the Privilege/User Mode for SDMA.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_SDMA      (4)      //!< Bit position for CSU_HP0_HP_SDMA.
#define BM_CSU_HP0_HP_SDMA      (0x00000010)  //!< Bit mask for CSU_HP0_HP_SDMA.

//! @brief Get value of CSU_HP0_HP_SDMA from a register value.
#define BG_CSU_HP0_HP_SDMA(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_SDMA) >> BP_CSU_HP0_HP_SDMA)

//! @brief Format value for bitfield CSU_HP0_HP_SDMA.
#define BF_CSU_HP0_HP_SDMA(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_SDMA) & BM_CSU_HP0_HP_SDMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_SDMA field to a new value.
#define BW_CSU_HP0_HP_SDMA(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_SDMA) | BF_CSU_HP0_HP_SDMA(v)))
#endif


/* --- Register HW_CSU_HP0, field L_SDMA[5] (RW)
 *
 * Lock bit set by TZ software for HP_SDMA.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_SDMA      (5)      //!< Bit position for CSU_HP0_L_SDMA.
#define BM_CSU_HP0_L_SDMA      (0x00000020)  //!< Bit mask for CSU_HP0_L_SDMA.

//! @brief Get value of CSU_HP0_L_SDMA from a register value.
#define BG_CSU_HP0_L_SDMA(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_SDMA) >> BP_CSU_HP0_L_SDMA)

//! @brief Format value for bitfield CSU_HP0_L_SDMA.
#define BF_CSU_HP0_L_SDMA(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_SDMA) & BM_CSU_HP0_L_SDMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_SDMA field to a new value.
#define BW_CSU_HP0_L_SDMA(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_SDMA) | BF_CSU_HP0_L_SDMA(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_PU[6] (RW)
 *
 * Indicate the Privilege/User Mode for GPU3D, GPU2D, VPU, IPU1, IPU2, OpenVG EPDC, PXP, LCDIF and
 * VDOA. NOTE: IPU2 and OpenVG on i.MX6DQ only; EPDC, PXP and LCDIF on i.MX6SDL only
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_PU      (6)      //!< Bit position for CSU_HP0_HP_PU.
#define BM_CSU_HP0_HP_PU      (0x00000040)  //!< Bit mask for CSU_HP0_HP_PU.

//! @brief Get value of CSU_HP0_HP_PU from a register value.
#define BG_CSU_HP0_HP_PU(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_PU) >> BP_CSU_HP0_HP_PU)

//! @brief Format value for bitfield CSU_HP0_HP_PU.
#define BF_CSU_HP0_HP_PU(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_PU) & BM_CSU_HP0_HP_PU)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_PU field to a new value.
#define BW_CSU_HP0_HP_PU(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_PU) | BF_CSU_HP0_HP_PU(v)))
#endif


/* --- Register HW_CSU_HP0, field L_PU[7] (RW)
 *
 * Lock bit set by TZ software for HP_PU.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_PU      (7)      //!< Bit position for CSU_HP0_L_PU.
#define BM_CSU_HP0_L_PU      (0x00000080)  //!< Bit mask for CSU_HP0_L_PU.

//! @brief Get value of CSU_HP0_L_PU from a register value.
#define BG_CSU_HP0_L_PU(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_PU) >> BP_CSU_HP0_L_PU)

//! @brief Format value for bitfield CSU_HP0_L_PU.
#define BF_CSU_HP0_L_PU(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_PU) & BM_CSU_HP0_L_PU)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_PU field to a new value.
#define BW_CSU_HP0_L_PU(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_PU) | BF_CSU_HP0_L_PU(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_USB[8] (RW)
 *
 * Indicate the Privilege/User Mode for USB.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_USB      (8)      //!< Bit position for CSU_HP0_HP_USB.
#define BM_CSU_HP0_HP_USB      (0x00000100)  //!< Bit mask for CSU_HP0_HP_USB.

//! @brief Get value of CSU_HP0_HP_USB from a register value.
#define BG_CSU_HP0_HP_USB(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_USB) >> BP_CSU_HP0_HP_USB)

//! @brief Format value for bitfield CSU_HP0_HP_USB.
#define BF_CSU_HP0_HP_USB(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_USB) & BM_CSU_HP0_HP_USB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_USB field to a new value.
#define BW_CSU_HP0_HP_USB(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_USB) | BF_CSU_HP0_HP_USB(v)))
#endif


/* --- Register HW_CSU_HP0, field L_USB[9] (RW)
 *
 * Lock bit set by TZ software for HP_USB.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_USB      (9)      //!< Bit position for CSU_HP0_L_USB.
#define BM_CSU_HP0_L_USB      (0x00000200)  //!< Bit mask for CSU_HP0_L_USB.

//! @brief Get value of CSU_HP0_L_USB from a register value.
#define BG_CSU_HP0_L_USB(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_USB) >> BP_CSU_HP0_L_USB)

//! @brief Format value for bitfield CSU_HP0_L_USB.
#define BF_CSU_HP0_L_USB(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_USB) & BM_CSU_HP0_L_USB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USB field to a new value.
#define BW_CSU_HP0_L_USB(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_USB) | BF_CSU_HP0_L_USB(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_TEST[10] (RW)
 *
 * Indicate the Privilege/User Mode for IOMUX Test Port.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_TEST      (10)      //!< Bit position for CSU_HP0_HP_TEST.
#define BM_CSU_HP0_HP_TEST      (0x00000400)  //!< Bit mask for CSU_HP0_HP_TEST.

//! @brief Get value of CSU_HP0_HP_TEST from a register value.
#define BG_CSU_HP0_HP_TEST(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_TEST) >> BP_CSU_HP0_HP_TEST)

//! @brief Format value for bitfield CSU_HP0_HP_TEST.
#define BF_CSU_HP0_HP_TEST(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_TEST) & BM_CSU_HP0_HP_TEST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_TEST field to a new value.
#define BW_CSU_HP0_HP_TEST(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_TEST) | BF_CSU_HP0_HP_TEST(v)))
#endif


/* --- Register HW_CSU_HP0, field L_TEST[11] (RW)
 *
 * Lock bit set by TZ software for HP_TEST.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_TEST      (11)      //!< Bit position for CSU_HP0_L_TEST.
#define BM_CSU_HP0_L_TEST      (0x00000800)  //!< Bit mask for CSU_HP0_L_TEST.

//! @brief Get value of CSU_HP0_L_TEST from a register value.
#define BG_CSU_HP0_L_TEST(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_TEST) >> BP_CSU_HP0_L_TEST)

//! @brief Format value for bitfield CSU_HP0_L_TEST.
#define BF_CSU_HP0_L_TEST(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_TEST) & BM_CSU_HP0_L_TEST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_TEST field to a new value.
#define BW_CSU_HP0_L_TEST(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_TEST) | BF_CSU_HP0_L_TEST(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_MLB[12] (RW)
 *
 * Indicate the mode Privilege/User Mode for MLB.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_MLB      (12)      //!< Bit position for CSU_HP0_HP_MLB.
#define BM_CSU_HP0_HP_MLB      (0x00001000)  //!< Bit mask for CSU_HP0_HP_MLB.

//! @brief Get value of CSU_HP0_HP_MLB from a register value.
#define BG_CSU_HP0_HP_MLB(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_MLB) >> BP_CSU_HP0_HP_MLB)

//! @brief Format value for bitfield CSU_HP0_HP_MLB.
#define BF_CSU_HP0_HP_MLB(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_MLB) & BM_CSU_HP0_HP_MLB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_MLB field to a new value.
#define BW_CSU_HP0_HP_MLB(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_MLB) | BF_CSU_HP0_HP_MLB(v)))
#endif


/* --- Register HW_CSU_HP0, field L_MLB[13] (RW)
 *
 * Lock bit set by TZ software for HP_MLB.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_MLB      (13)      //!< Bit position for CSU_HP0_L_MLB.
#define BM_CSU_HP0_L_MLB      (0x00002000)  //!< Bit mask for CSU_HP0_L_MLB.

//! @brief Get value of CSU_HP0_L_MLB from a register value.
#define BG_CSU_HP0_L_MLB(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_MLB) >> BP_CSU_HP0_L_MLB)

//! @brief Format value for bitfield CSU_HP0_L_MLB.
#define BF_CSU_HP0_L_MLB(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_MLB) & BM_CSU_HP0_L_MLB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_MLB field to a new value.
#define BW_CSU_HP0_L_MLB(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_MLB) | BF_CSU_HP0_L_MLB(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_CAAM[14] (RW)
 *
 * Indicate the Privilege/User Mode for CAAM.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_CAAM      (14)      //!< Bit position for CSU_HP0_HP_CAAM.
#define BM_CSU_HP0_HP_CAAM      (0x00004000)  //!< Bit mask for CSU_HP0_HP_CAAM.

//! @brief Get value of CSU_HP0_HP_CAAM from a register value.
#define BG_CSU_HP0_HP_CAAM(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_CAAM) >> BP_CSU_HP0_HP_CAAM)

//! @brief Format value for bitfield CSU_HP0_HP_CAAM.
#define BF_CSU_HP0_HP_CAAM(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_CAAM) & BM_CSU_HP0_HP_CAAM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_CAAM field to a new value.
#define BW_CSU_HP0_HP_CAAM(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_CAAM) | BF_CSU_HP0_HP_CAAM(v)))
#endif


/* --- Register HW_CSU_HP0, field L_CAAM[15] (RW)
 *
 * Lock bit set by TZ software for HP_CAAM.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_CAAM      (15)      //!< Bit position for CSU_HP0_L_CAAM.
#define BM_CSU_HP0_L_CAAM      (0x00008000)  //!< Bit mask for CSU_HP0_L_CAAM.

//! @brief Get value of CSU_HP0_L_CAAM from a register value.
#define BG_CSU_HP0_L_CAAM(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_CAAM) >> BP_CSU_HP0_L_CAAM)

//! @brief Format value for bitfield CSU_HP0_L_CAAM.
#define BF_CSU_HP0_L_CAAM(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_CAAM) & BM_CSU_HP0_L_CAAM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_CAAM field to a new value.
#define BW_CSU_HP0_L_CAAM(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_CAAM) | BF_CSU_HP0_L_CAAM(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_RAWNAND[16] (RW)
 *
 * Indicate the Privilege/User Mode for RawNAND.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_RAWNAND      (16)      //!< Bit position for CSU_HP0_HP_RAWNAND.
#define BM_CSU_HP0_HP_RAWNAND      (0x00010000)  //!< Bit mask for CSU_HP0_HP_RAWNAND.

//! @brief Get value of CSU_HP0_HP_RAWNAND from a register value.
#define BG_CSU_HP0_HP_RAWNAND(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_RAWNAND) >> BP_CSU_HP0_HP_RAWNAND)

//! @brief Format value for bitfield CSU_HP0_HP_RAWNAND.
#define BF_CSU_HP0_HP_RAWNAND(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_RAWNAND) & BM_CSU_HP0_HP_RAWNAND)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_RAWNAND field to a new value.
#define BW_CSU_HP0_HP_RAWNAND(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_RAWNAND) | BF_CSU_HP0_HP_RAWNAND(v)))
#endif


/* --- Register HW_CSU_HP0, field L_RAWNAND[17] (RW)
 *
 * Lock bit set by TZ software for HP_RAWNAND.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_RAWNAND      (17)      //!< Bit position for CSU_HP0_L_RAWNAND.
#define BM_CSU_HP0_L_RAWNAND      (0x00020000)  //!< Bit mask for CSU_HP0_L_RAWNAND.

//! @brief Get value of CSU_HP0_L_RAWNAND from a register value.
#define BG_CSU_HP0_L_RAWNAND(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_RAWNAND) >> BP_CSU_HP0_L_RAWNAND)

//! @brief Format value for bitfield CSU_HP0_L_RAWNAND.
#define BF_CSU_HP0_L_RAWNAND(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_RAWNAND) & BM_CSU_HP0_L_RAWNAND)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_RAWNAND field to a new value.
#define BW_CSU_HP0_L_RAWNAND(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_RAWNAND) | BF_CSU_HP0_L_RAWNAND(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_APBHDMA[18] (RW)
 *
 * Indicate the Privilege/User Mode for apbhdma.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_APBHDMA      (18)      //!< Bit position for CSU_HP0_HP_APBHDMA.
#define BM_CSU_HP0_HP_APBHDMA      (0x00040000)  //!< Bit mask for CSU_HP0_HP_APBHDMA.

//! @brief Get value of CSU_HP0_HP_APBHDMA from a register value.
#define BG_CSU_HP0_HP_APBHDMA(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_APBHDMA) >> BP_CSU_HP0_HP_APBHDMA)

//! @brief Format value for bitfield CSU_HP0_HP_APBHDMA.
#define BF_CSU_HP0_HP_APBHDMA(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_APBHDMA) & BM_CSU_HP0_HP_APBHDMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_APBHDMA field to a new value.
#define BW_CSU_HP0_HP_APBHDMA(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_APBHDMA) | BF_CSU_HP0_HP_APBHDMA(v)))
#endif


/* --- Register HW_CSU_HP0, field L_ABPHDMA[19] (RW)
 *
 * Lock bit set by TZ software for HP_APBHDMA.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_ABPHDMA      (19)      //!< Bit position for CSU_HP0_L_ABPHDMA.
#define BM_CSU_HP0_L_ABPHDMA      (0x00080000)  //!< Bit mask for CSU_HP0_L_ABPHDMA.

//! @brief Get value of CSU_HP0_L_ABPHDMA from a register value.
#define BG_CSU_HP0_L_ABPHDMA(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_ABPHDMA) >> BP_CSU_HP0_L_ABPHDMA)

//! @brief Format value for bitfield CSU_HP0_L_ABPHDMA.
#define BF_CSU_HP0_L_ABPHDMA(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_ABPHDMA) & BM_CSU_HP0_L_ABPHDMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_ABPHDMA field to a new value.
#define BW_CSU_HP0_L_ABPHDMA(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_ABPHDMA) | BF_CSU_HP0_L_ABPHDMA(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_ENET[20] (RW)
 *
 * Indicate the Privilege/User Mode for ENET.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_ENET      (20)      //!< Bit position for CSU_HP0_HP_ENET.
#define BM_CSU_HP0_HP_ENET      (0x00100000)  //!< Bit mask for CSU_HP0_HP_ENET.

//! @brief Get value of CSU_HP0_HP_ENET from a register value.
#define BG_CSU_HP0_HP_ENET(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_ENET) >> BP_CSU_HP0_HP_ENET)

//! @brief Format value for bitfield CSU_HP0_HP_ENET.
#define BF_CSU_HP0_HP_ENET(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_ENET) & BM_CSU_HP0_HP_ENET)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_ENET field to a new value.
#define BW_CSU_HP0_HP_ENET(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_ENET) | BF_CSU_HP0_HP_ENET(v)))
#endif


/* --- Register HW_CSU_HP0, field L_ENET[21] (RW)
 *
 * Lock bit set by TZ software for HP_ENET.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_ENET      (21)      //!< Bit position for CSU_HP0_L_ENET.
#define BM_CSU_HP0_L_ENET      (0x00200000)  //!< Bit mask for CSU_HP0_L_ENET.

//! @brief Get value of CSU_HP0_L_ENET from a register value.
#define BG_CSU_HP0_L_ENET(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_ENET) >> BP_CSU_HP0_L_ENET)

//! @brief Format value for bitfield CSU_HP0_L_ENET.
#define BF_CSU_HP0_L_ENET(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_ENET) & BM_CSU_HP0_L_ENET)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_ENET field to a new value.
#define BW_CSU_HP0_L_ENET(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_ENET) | BF_CSU_HP0_L_ENET(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_DAP[22] (RW)
 *
 * Indicate the Privilege/User Mode for DAP.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_DAP      (22)      //!< Bit position for CSU_HP0_HP_DAP.
#define BM_CSU_HP0_HP_DAP      (0x00400000)  //!< Bit mask for CSU_HP0_HP_DAP.

//! @brief Get value of CSU_HP0_HP_DAP from a register value.
#define BG_CSU_HP0_HP_DAP(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_DAP) >> BP_CSU_HP0_HP_DAP)

//! @brief Format value for bitfield CSU_HP0_HP_DAP.
#define BF_CSU_HP0_HP_DAP(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_DAP) & BM_CSU_HP0_HP_DAP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_DAP field to a new value.
#define BW_CSU_HP0_HP_DAP(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_DAP) | BF_CSU_HP0_HP_DAP(v)))
#endif


/* --- Register HW_CSU_HP0, field L_DAP[23] (RW)
 *
 * Lock bit set by TZ software for HP_DAP.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_DAP      (23)      //!< Bit position for CSU_HP0_L_DAP.
#define BM_CSU_HP0_L_DAP      (0x00800000)  //!< Bit mask for CSU_HP0_L_DAP.

//! @brief Get value of CSU_HP0_L_DAP from a register value.
#define BG_CSU_HP0_L_DAP(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_DAP) >> BP_CSU_HP0_L_DAP)

//! @brief Format value for bitfield CSU_HP0_L_DAP.
#define BF_CSU_HP0_L_DAP(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_DAP) & BM_CSU_HP0_L_DAP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_DAP field to a new value.
#define BW_CSU_HP0_L_DAP(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_DAP) | BF_CSU_HP0_L_DAP(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_USDHC1[24] (RW)
 *
 * Indicate the Privilege/User Mode for USDHC1.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_USDHC1      (24)      //!< Bit position for CSU_HP0_HP_USDHC1.
#define BM_CSU_HP0_HP_USDHC1      (0x01000000)  //!< Bit mask for CSU_HP0_HP_USDHC1.

//! @brief Get value of CSU_HP0_HP_USDHC1 from a register value.
#define BG_CSU_HP0_HP_USDHC1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_USDHC1) >> BP_CSU_HP0_HP_USDHC1)

//! @brief Format value for bitfield CSU_HP0_HP_USDHC1.
#define BF_CSU_HP0_HP_USDHC1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_USDHC1) & BM_CSU_HP0_HP_USDHC1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_USDHC1 field to a new value.
#define BW_CSU_HP0_HP_USDHC1(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_USDHC1) | BF_CSU_HP0_HP_USDHC1(v)))
#endif


/* --- Register HW_CSU_HP0, field L_USDHC1[25] (RW)
 *
 * Lock bit set by TZ software for HP_USDHC1.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_USDHC1      (25)      //!< Bit position for CSU_HP0_L_USDHC1.
#define BM_CSU_HP0_L_USDHC1      (0x02000000)  //!< Bit mask for CSU_HP0_L_USDHC1.

//! @brief Get value of CSU_HP0_L_USDHC1 from a register value.
#define BG_CSU_HP0_L_USDHC1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_USDHC1) >> BP_CSU_HP0_L_USDHC1)

//! @brief Format value for bitfield CSU_HP0_L_USDHC1.
#define BF_CSU_HP0_L_USDHC1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_USDHC1) & BM_CSU_HP0_L_USDHC1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USDHC1 field to a new value.
#define BW_CSU_HP0_L_USDHC1(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_USDHC1) | BF_CSU_HP0_L_USDHC1(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_USDHC2[26] (RW)
 *
 * Indicate the Privilege/User Mode for USDHC2.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_USDHC2      (26)      //!< Bit position for CSU_HP0_HP_USDHC2.
#define BM_CSU_HP0_HP_USDHC2      (0x04000000)  //!< Bit mask for CSU_HP0_HP_USDHC2.

//! @brief Get value of CSU_HP0_HP_USDHC2 from a register value.
#define BG_CSU_HP0_HP_USDHC2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_USDHC2) >> BP_CSU_HP0_HP_USDHC2)

//! @brief Format value for bitfield CSU_HP0_HP_USDHC2.
#define BF_CSU_HP0_HP_USDHC2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_USDHC2) & BM_CSU_HP0_HP_USDHC2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_USDHC2 field to a new value.
#define BW_CSU_HP0_HP_USDHC2(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_USDHC2) | BF_CSU_HP0_HP_USDHC2(v)))
#endif


/* --- Register HW_CSU_HP0, field L_USDHC2[27] (RW)
 *
 * Lock bit set by TZ software for HP_USDHC2.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_USDHC2      (27)      //!< Bit position for CSU_HP0_L_USDHC2.
#define BM_CSU_HP0_L_USDHC2      (0x08000000)  //!< Bit mask for CSU_HP0_L_USDHC2.

//! @brief Get value of CSU_HP0_L_USDHC2 from a register value.
#define BG_CSU_HP0_L_USDHC2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_USDHC2) >> BP_CSU_HP0_L_USDHC2)

//! @brief Format value for bitfield CSU_HP0_L_USDHC2.
#define BF_CSU_HP0_L_USDHC2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_USDHC2) & BM_CSU_HP0_L_USDHC2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USDHC2 field to a new value.
#define BW_CSU_HP0_L_USDHC2(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_USDHC2) | BF_CSU_HP0_L_USDHC2(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_USDHC3[28] (RW)
 *
 * Indicate the Privilege/User Mode for USDHC3.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_USDHC3      (28)      //!< Bit position for CSU_HP0_HP_USDHC3.
#define BM_CSU_HP0_HP_USDHC3      (0x10000000)  //!< Bit mask for CSU_HP0_HP_USDHC3.

//! @brief Get value of CSU_HP0_HP_USDHC3 from a register value.
#define BG_CSU_HP0_HP_USDHC3(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_USDHC3) >> BP_CSU_HP0_HP_USDHC3)

//! @brief Format value for bitfield CSU_HP0_HP_USDHC3.
#define BF_CSU_HP0_HP_USDHC3(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_USDHC3) & BM_CSU_HP0_HP_USDHC3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_USDHC3 field to a new value.
#define BW_CSU_HP0_HP_USDHC3(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_USDHC3) | BF_CSU_HP0_HP_USDHC3(v)))
#endif


/* --- Register HW_CSU_HP0, field L_USDHC3[29] (RW)
 *
 * Lock bit set by TZ software for HP_USDHC3.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_USDHC3      (29)      //!< Bit position for CSU_HP0_L_USDHC3.
#define BM_CSU_HP0_L_USDHC3      (0x20000000)  //!< Bit mask for CSU_HP0_L_USDHC3.

//! @brief Get value of CSU_HP0_L_USDHC3 from a register value.
#define BG_CSU_HP0_L_USDHC3(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_USDHC3) >> BP_CSU_HP0_L_USDHC3)

//! @brief Format value for bitfield CSU_HP0_L_USDHC3.
#define BF_CSU_HP0_L_USDHC3(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_USDHC3) & BM_CSU_HP0_L_USDHC3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USDHC3 field to a new value.
#define BW_CSU_HP0_L_USDHC3(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_USDHC3) | BF_CSU_HP0_L_USDHC3(v)))
#endif


/* --- Register HW_CSU_HP0, field HP_USDHC4[30] (RW)
 *
 * Indicate the Privilege/User Mode for USDHC4.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP0_HP_USDHC4      (30)      //!< Bit position for CSU_HP0_HP_USDHC4.
#define BM_CSU_HP0_HP_USDHC4      (0x40000000)  //!< Bit mask for CSU_HP0_HP_USDHC4.

//! @brief Get value of CSU_HP0_HP_USDHC4 from a register value.
#define BG_CSU_HP0_HP_USDHC4(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_HP_USDHC4) >> BP_CSU_HP0_HP_USDHC4)

//! @brief Format value for bitfield CSU_HP0_HP_USDHC4.
#define BF_CSU_HP0_HP_USDHC4(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_HP_USDHC4) & BM_CSU_HP0_HP_USDHC4)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_USDHC4 field to a new value.
#define BW_CSU_HP0_HP_USDHC4(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_HP_USDHC4) | BF_CSU_HP0_HP_USDHC4(v)))
#endif


/* --- Register HW_CSU_HP0, field L_USDHC4[31] (RW)
 *
 * Lock bit set by TZ software for HP_USDHC4.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP0_L_USDHC4      (31)      //!< Bit position for CSU_HP0_L_USDHC4.
#define BM_CSU_HP0_L_USDHC4      (0x80000000)  //!< Bit mask for CSU_HP0_L_USDHC4.

//! @brief Get value of CSU_HP0_L_USDHC4 from a register value.
#define BG_CSU_HP0_L_USDHC4(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP0_L_USDHC4) >> BP_CSU_HP0_L_USDHC4)

//! @brief Format value for bitfield CSU_HP0_L_USDHC4.
#define BF_CSU_HP0_L_USDHC4(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP0_L_USDHC4) & BM_CSU_HP0_L_USDHC4)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USDHC4 field to a new value.
#define BW_CSU_HP0_L_USDHC4(v)   (HW_CSU_HP0_WR((HW_CSU_HP0_RD() & ~BM_CSU_HP0_L_USDHC4) | BF_CSU_HP0_L_USDHC4(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_HP1 - HP1 register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_HP1 - HP1 register (RW)
 *
 * Reset value: 0x00000000
 *
 * The SCU_HP1 register is an expansion of the SCU_HP0 register. See SCU_HP0 register definition.
 */
typedef union _hw_csu_hp1
{
    reg32_t U;
    struct _hw_csu_hp1_bitfields
    {
        unsigned HP_HDMI_HSI : 1; //!< [0] Indicate the Privilege/User Mode for HDMI Tx and HSI.
        unsigned L_HDMI_HSI : 1; //!< [1] Lock bit set by TZ software for HP_HDMI_HSI.
        unsigned RESERVED0 : 30; //!< [31:2] Reserved.
    } B;
} hw_csu_hp1_t;
#endif

/*
 * constants & macros for entire CSU_HP1 register
 */
#define HW_CSU_HP1_ADDR      (REGS_CSU_BASE + 0x204)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_HP1           (*(volatile hw_csu_hp1_t *) HW_CSU_HP1_ADDR)
#define HW_CSU_HP1_RD()      (HW_CSU_HP1.U)
#define HW_CSU_HP1_WR(v)     (HW_CSU_HP1.U = (v))
#define HW_CSU_HP1_SET(v)    (HW_CSU_HP1_WR(HW_CSU_HP1_RD() |  (v)))
#define HW_CSU_HP1_CLR(v)    (HW_CSU_HP1_WR(HW_CSU_HP1_RD() & ~(v)))
#define HW_CSU_HP1_TOG(v)    (HW_CSU_HP1_WR(HW_CSU_HP1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_HP1 bitfields
 */

/* --- Register HW_CSU_HP1, field HP_HDMI_HSI[0] (RW)
 *
 * Indicate the Privilege/User Mode for HDMI Tx and HSI.
 *
 * Values:
 * 0 - User Mode for the corresponding master
 * 1 - Supervisor Mode for the corresponding master
 */

#define BP_CSU_HP1_HP_HDMI_HSI      (0)      //!< Bit position for CSU_HP1_HP_HDMI_HSI.
#define BM_CSU_HP1_HP_HDMI_HSI      (0x00000001)  //!< Bit mask for CSU_HP1_HP_HDMI_HSI.

//! @brief Get value of CSU_HP1_HP_HDMI_HSI from a register value.
#define BG_CSU_HP1_HP_HDMI_HSI(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP1_HP_HDMI_HSI) >> BP_CSU_HP1_HP_HDMI_HSI)

//! @brief Format value for bitfield CSU_HP1_HP_HDMI_HSI.
#define BF_CSU_HP1_HP_HDMI_HSI(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP1_HP_HDMI_HSI) & BM_CSU_HP1_HP_HDMI_HSI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HP_HDMI_HSI field to a new value.
#define BW_CSU_HP1_HP_HDMI_HSI(v)   (HW_CSU_HP1_WR((HW_CSU_HP1_RD() & ~BM_CSU_HP1_HP_HDMI_HSI) | BF_CSU_HP1_HP_HDMI_HSI(v)))
#endif


/* --- Register HW_CSU_HP1, field L_HDMI_HSI[1] (RW)
 *
 * Lock bit set by TZ software for HP_HDMI_HSI.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HP1_L_HDMI_HSI      (1)      //!< Bit position for CSU_HP1_L_HDMI_HSI.
#define BM_CSU_HP1_L_HDMI_HSI      (0x00000002)  //!< Bit mask for CSU_HP1_L_HDMI_HSI.

//! @brief Get value of CSU_HP1_L_HDMI_HSI from a register value.
#define BG_CSU_HP1_L_HDMI_HSI(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HP1_L_HDMI_HSI) >> BP_CSU_HP1_L_HDMI_HSI)

//! @brief Format value for bitfield CSU_HP1_L_HDMI_HSI.
#define BF_CSU_HP1_L_HDMI_HSI(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HP1_L_HDMI_HSI) & BM_CSU_HP1_L_HDMI_HSI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_HDMI_HSI field to a new value.
#define BW_CSU_HP1_L_HDMI_HSI(v)   (HW_CSU_HP1_WR((HW_CSU_HP1_RD() & ~BM_CSU_HP1_L_HDMI_HSI) | BF_CSU_HP1_L_HDMI_HSI(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_SA - Secure access register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_SA - Secure access register (RW)
 *
 * Reset value: 0x55555555
 *
 * The Secure Access register may be programmed to specify the access policy (either Secure or Non-
 * secure) for up to sixteen different masters. This register is used to set the access policy for
 * Type 1 masters which are incapable of setting the policy by themselves.  The sixteen even bit
 * positions (CSU_SA[30,28,...,0]) in the register hold the policy indicator bits; while the odd bit
 * positions (CSU_SA[31,29,...,1]) contain lock bits which enable/disable writing to the
 * corresponding policy indicator bits.  Memory Space has been reserved for 32 Type 1 Masters.
 * Since, one 32 bit register can accommodate SA fields corresponding to 16 masters, hence for 32
 * masters memory equivalent of 2 registers is reserved.However, actual number of registers(flops)
 * inferred in a design would depend on the following Parameter --- Name - No_Of_TP1_Masters Min.
 * Value -1 Max. Value - 32 Possible Values - 1 to 32
 */
typedef union _hw_csu_sa
{
    reg32_t U;
    struct _hw_csu_sa_bitfields
    {
        unsigned SA_CP15 : 1; //!< [0] Indicate the Type (Secured/Non-Secured) Access to ARM CP15 register.
        unsigned L_CP15 : 1; //!< [1] Lock bit set by TZ software for SA_CP15.
        unsigned RESERVED0 : 2; //!< [3:2] Reserved.
        unsigned SA_SDMA : 1; //!< [4] Indicate the Type (Secured/Non-Secured) Access for SDMA.
        unsigned L_SDMA : 1; //!< [5] Lock bit set by TZ software for SA_SDMA.
        unsigned SA_PU : 1; //!< [6] Indicate the Type (Secured/Non-Secured) Access for GPU3D, VDOA, GPU2D, IPU1, IPU2, OPENVG EPDC, PXP, LCDIF and VPU. NOTE: IPU2 and OpenVG on i.MX6DQ only; EPDC, PXP and LCDIF on i.MX6SDL only
        unsigned L_PU : 1; //!< [7] Lock bit set by TZ software for SA_PU.
        unsigned SA_USB_MLB : 1; //!< [8] Indicate the Type (Secured/Non-Secured) Access for USB and MLB.
        unsigned L_USB_MLB : 1; //!< [9] Lock bit set by TZ software for SA_USB_MLB.
        unsigned SA_PCIE_TEST : 1; //!< [10] Indicate the Type (Secured/Non-Secured) Access for PCIe and IOMUX Test Port.
        unsigned L_PCIE_TEST : 1; //!< [11] Lock bit set by TZ software for SA_PCIE_TEST.
        unsigned RESERVED1 : 2; //!< [13:12] Reserved
        unsigned SA_RAWNAND_APBHDMA : 1; //!< [14] Indicate the Type (Secured/Non-Secured) Access for RawNAND and apbhdmat.
        unsigned L_RAWNAND_APBHDMA : 1; //!< [15] Lock bit set by TZ software for SA_RAWNAND_APBHDMA.
        unsigned SA_ENET : 1; //!< [16] Indicate the Type (Secured/Non-Secured) Access for ENET.
        unsigned L_ENET : 1; //!< [17] Lock bit set by TZ software for SA_ENET.
        unsigned SA_DAP : 1; //!< [18] Access Policy indicator bits
        unsigned L_DAP : 1; //!< [19] Lock bit set by TZ software for SA_DAP.
        unsigned SA_USDHC1 : 1; //!< [20] Indicate the Type (Secured/Non-Secured) Access for USDHC1.
        unsigned L_USDHC1 : 1; //!< [21] Lock bit set by TZ software for SA_.USDHC1
        unsigned SA_USDHC2 : 1; //!< [22] Indicate the Type (Secured/Non-Secured) Access for USDHC2.
        unsigned L_USDHC2 : 1; //!< [23] Lock bit set by TZ software for SA_.USDHC2
        unsigned SA_USDHC3 : 1; //!< [24] Indicate the Type (Secured/Non-Secured) Access for USDHC3.
        unsigned L_USDHC3 : 1; //!< [25] Lock bit set by TZ software for SA_.USDHC3
        unsigned SA_USDHC4 : 1; //!< [26] Indicate the Type (Secured/Non-Secured) Access for USDHC4.
        unsigned L_USDHC4 : 1; //!< [27] Lock bit set by TZ software for SA_.USDHC14
        unsigned SA_HDMI_HSI : 1; //!< [28] Indicate the Type (Secured/Non-Secured) Access for HDMI Tx and HSI.
        unsigned L_HDMI_HSI : 1; //!< [29] Lock bit set by TZ software for SA_.HDMI_HSI
        unsigned RESERVED2 : 2; //!< [31:30] Reserved
    } B;
} hw_csu_sa_t;
#endif

/*
 * constants & macros for entire CSU_SA register
 */
#define HW_CSU_SA_ADDR      (REGS_CSU_BASE + 0x218)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_SA           (*(volatile hw_csu_sa_t *) HW_CSU_SA_ADDR)
#define HW_CSU_SA_RD()      (HW_CSU_SA.U)
#define HW_CSU_SA_WR(v)     (HW_CSU_SA.U = (v))
#define HW_CSU_SA_SET(v)    (HW_CSU_SA_WR(HW_CSU_SA_RD() |  (v)))
#define HW_CSU_SA_CLR(v)    (HW_CSU_SA_WR(HW_CSU_SA_RD() & ~(v)))
#define HW_CSU_SA_TOG(v)    (HW_CSU_SA_WR(HW_CSU_SA_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_SA bitfields
 */

/* --- Register HW_CSU_SA, field SA_CP15[0] (RW)
 *
 * Indicate the Type (Secured/Non-Secured) Access to ARM CP15 register.
 *
 * Values:
 * 0 - ARM CP15 register is accesible
 * 1 - ARM CP15 register is not accesible
 */

#define BP_CSU_SA_SA_CP15      (0)      //!< Bit position for CSU_SA_SA_CP15.
#define BM_CSU_SA_SA_CP15      (0x00000001)  //!< Bit mask for CSU_SA_SA_CP15.

//! @brief Get value of CSU_SA_SA_CP15 from a register value.
#define BG_CSU_SA_SA_CP15(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_CP15) >> BP_CSU_SA_SA_CP15)

//! @brief Format value for bitfield CSU_SA_SA_CP15.
#define BF_CSU_SA_SA_CP15(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_CP15) & BM_CSU_SA_SA_CP15)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_CP15 field to a new value.
#define BW_CSU_SA_SA_CP15(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_CP15) | BF_CSU_SA_SA_CP15(v)))
#endif


/* --- Register HW_CSU_SA, field L_CP15[1] (RW)
 *
 * Lock bit set by TZ software for SA_CP15.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_CP15      (1)      //!< Bit position for CSU_SA_L_CP15.
#define BM_CSU_SA_L_CP15      (0x00000002)  //!< Bit mask for CSU_SA_L_CP15.

//! @brief Get value of CSU_SA_L_CP15 from a register value.
#define BG_CSU_SA_L_CP15(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_CP15) >> BP_CSU_SA_L_CP15)

//! @brief Format value for bitfield CSU_SA_L_CP15.
#define BF_CSU_SA_L_CP15(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_CP15) & BM_CSU_SA_L_CP15)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_CP15 field to a new value.
#define BW_CSU_SA_L_CP15(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_CP15) | BF_CSU_SA_L_CP15(v)))
#endif


/* --- Register HW_CSU_SA, field SA_SDMA[4] (RW)
 *
 * Indicate the Type (Secured/Non-Secured) Access for SDMA.
 *
 * Values:
 * 0 - Secure access for the corresponding Type 1 master
 * 1 - Non-secure access for the corresponding Type 1 master
 */

#define BP_CSU_SA_SA_SDMA      (4)      //!< Bit position for CSU_SA_SA_SDMA.
#define BM_CSU_SA_SA_SDMA      (0x00000010)  //!< Bit mask for CSU_SA_SA_SDMA.

//! @brief Get value of CSU_SA_SA_SDMA from a register value.
#define BG_CSU_SA_SA_SDMA(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_SDMA) >> BP_CSU_SA_SA_SDMA)

//! @brief Format value for bitfield CSU_SA_SA_SDMA.
#define BF_CSU_SA_SA_SDMA(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_SDMA) & BM_CSU_SA_SA_SDMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_SDMA field to a new value.
#define BW_CSU_SA_SA_SDMA(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_SDMA) | BF_CSU_SA_SA_SDMA(v)))
#endif


/* --- Register HW_CSU_SA, field L_SDMA[5] (RW)
 *
 * Lock bit set by TZ software for SA_SDMA.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_SDMA      (5)      //!< Bit position for CSU_SA_L_SDMA.
#define BM_CSU_SA_L_SDMA      (0x00000020)  //!< Bit mask for CSU_SA_L_SDMA.

//! @brief Get value of CSU_SA_L_SDMA from a register value.
#define BG_CSU_SA_L_SDMA(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_SDMA) >> BP_CSU_SA_L_SDMA)

//! @brief Format value for bitfield CSU_SA_L_SDMA.
#define BF_CSU_SA_L_SDMA(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_SDMA) & BM_CSU_SA_L_SDMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_SDMA field to a new value.
#define BW_CSU_SA_L_SDMA(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_SDMA) | BF_CSU_SA_L_SDMA(v)))
#endif


/* --- Register HW_CSU_SA, field SA_PU[6] (RW)
 *
 * Indicate the Type (Secured/Non-Secured) Access for GPU3D, VDOA, GPU2D, IPU1, IPU2, OPENVG EPDC,
 * PXP, LCDIF and VPU. NOTE: IPU2 and OpenVG on i.MX6DQ only; EPDC, PXP and LCDIF on i.MX6SDL only
 *
 * Values:
 * 0 - Secure access for the corresponding Type 1 master
 * 1 - Non-secure access for the corresponding Type 1 master
 */

#define BP_CSU_SA_SA_PU      (6)      //!< Bit position for CSU_SA_SA_PU.
#define BM_CSU_SA_SA_PU      (0x00000040)  //!< Bit mask for CSU_SA_SA_PU.

//! @brief Get value of CSU_SA_SA_PU from a register value.
#define BG_CSU_SA_SA_PU(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_PU) >> BP_CSU_SA_SA_PU)

//! @brief Format value for bitfield CSU_SA_SA_PU.
#define BF_CSU_SA_SA_PU(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_PU) & BM_CSU_SA_SA_PU)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_PU field to a new value.
#define BW_CSU_SA_SA_PU(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_PU) | BF_CSU_SA_SA_PU(v)))
#endif


/* --- Register HW_CSU_SA, field L_PU[7] (RW)
 *
 * Lock bit set by TZ software for SA_PU.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_PU      (7)      //!< Bit position for CSU_SA_L_PU.
#define BM_CSU_SA_L_PU      (0x00000080)  //!< Bit mask for CSU_SA_L_PU.

//! @brief Get value of CSU_SA_L_PU from a register value.
#define BG_CSU_SA_L_PU(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_PU) >> BP_CSU_SA_L_PU)

//! @brief Format value for bitfield CSU_SA_L_PU.
#define BF_CSU_SA_L_PU(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_PU) & BM_CSU_SA_L_PU)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_PU field to a new value.
#define BW_CSU_SA_L_PU(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_PU) | BF_CSU_SA_L_PU(v)))
#endif


/* --- Register HW_CSU_SA, field SA_USB_MLB[8] (RW)
 *
 * Indicate the Type (Secured/Non-Secured) Access for USB and MLB.
 *
 * Values:
 * 0 - Secure access for the corresponding Type 1 master
 * 1 - Non-secure access for the corresponding Type 1 master
 */

#define BP_CSU_SA_SA_USB_MLB      (8)      //!< Bit position for CSU_SA_SA_USB_MLB.
#define BM_CSU_SA_SA_USB_MLB      (0x00000100)  //!< Bit mask for CSU_SA_SA_USB_MLB.

//! @brief Get value of CSU_SA_SA_USB_MLB from a register value.
#define BG_CSU_SA_SA_USB_MLB(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_USB_MLB) >> BP_CSU_SA_SA_USB_MLB)

//! @brief Format value for bitfield CSU_SA_SA_USB_MLB.
#define BF_CSU_SA_SA_USB_MLB(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_USB_MLB) & BM_CSU_SA_SA_USB_MLB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_USB_MLB field to a new value.
#define BW_CSU_SA_SA_USB_MLB(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_USB_MLB) | BF_CSU_SA_SA_USB_MLB(v)))
#endif


/* --- Register HW_CSU_SA, field L_USB_MLB[9] (RW)
 *
 * Lock bit set by TZ software for SA_USB_MLB.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_USB_MLB      (9)      //!< Bit position for CSU_SA_L_USB_MLB.
#define BM_CSU_SA_L_USB_MLB      (0x00000200)  //!< Bit mask for CSU_SA_L_USB_MLB.

//! @brief Get value of CSU_SA_L_USB_MLB from a register value.
#define BG_CSU_SA_L_USB_MLB(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_USB_MLB) >> BP_CSU_SA_L_USB_MLB)

//! @brief Format value for bitfield CSU_SA_L_USB_MLB.
#define BF_CSU_SA_L_USB_MLB(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_USB_MLB) & BM_CSU_SA_L_USB_MLB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USB_MLB field to a new value.
#define BW_CSU_SA_L_USB_MLB(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_USB_MLB) | BF_CSU_SA_L_USB_MLB(v)))
#endif


/* --- Register HW_CSU_SA, field SA_PCIE_TEST[10] (RW)
 *
 * Indicate the Type (Secured/Non-Secured) Access for PCIe and IOMUX Test Port.
 *
 * Values:
 * 0 - Secure access for the corresponding Type 1 master
 * 1 - Non-secure access for the corresponding Type 1 master
 */

#define BP_CSU_SA_SA_PCIE_TEST      (10)      //!< Bit position for CSU_SA_SA_PCIE_TEST.
#define BM_CSU_SA_SA_PCIE_TEST      (0x00000400)  //!< Bit mask for CSU_SA_SA_PCIE_TEST.

//! @brief Get value of CSU_SA_SA_PCIE_TEST from a register value.
#define BG_CSU_SA_SA_PCIE_TEST(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_PCIE_TEST) >> BP_CSU_SA_SA_PCIE_TEST)

//! @brief Format value for bitfield CSU_SA_SA_PCIE_TEST.
#define BF_CSU_SA_SA_PCIE_TEST(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_PCIE_TEST) & BM_CSU_SA_SA_PCIE_TEST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_PCIE_TEST field to a new value.
#define BW_CSU_SA_SA_PCIE_TEST(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_PCIE_TEST) | BF_CSU_SA_SA_PCIE_TEST(v)))
#endif


/* --- Register HW_CSU_SA, field L_PCIE_TEST[11] (RW)
 *
 * Lock bit set by TZ software for SA_PCIE_TEST.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_PCIE_TEST      (11)      //!< Bit position for CSU_SA_L_PCIE_TEST.
#define BM_CSU_SA_L_PCIE_TEST      (0x00000800)  //!< Bit mask for CSU_SA_L_PCIE_TEST.

//! @brief Get value of CSU_SA_L_PCIE_TEST from a register value.
#define BG_CSU_SA_L_PCIE_TEST(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_PCIE_TEST) >> BP_CSU_SA_L_PCIE_TEST)

//! @brief Format value for bitfield CSU_SA_L_PCIE_TEST.
#define BF_CSU_SA_L_PCIE_TEST(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_PCIE_TEST) & BM_CSU_SA_L_PCIE_TEST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_PCIE_TEST field to a new value.
#define BW_CSU_SA_L_PCIE_TEST(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_PCIE_TEST) | BF_CSU_SA_L_PCIE_TEST(v)))
#endif


/* --- Register HW_CSU_SA, field SA_RAWNAND_APBHDMA[14] (RW)
 *
 * Indicate the Type (Secured/Non-Secured) Access for RawNAND and apbhdmat.
 *
 * Values:
 * 0 - Secure access for the corresponding Type 1 master
 * 1 - Non-secure access for the corresponding Type 1 master
 */

#define BP_CSU_SA_SA_RAWNAND_APBHDMA      (14)      //!< Bit position for CSU_SA_SA_RAWNAND_APBHDMA.
#define BM_CSU_SA_SA_RAWNAND_APBHDMA      (0x00004000)  //!< Bit mask for CSU_SA_SA_RAWNAND_APBHDMA.

//! @brief Get value of CSU_SA_SA_RAWNAND_APBHDMA from a register value.
#define BG_CSU_SA_SA_RAWNAND_APBHDMA(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_RAWNAND_APBHDMA) >> BP_CSU_SA_SA_RAWNAND_APBHDMA)

//! @brief Format value for bitfield CSU_SA_SA_RAWNAND_APBHDMA.
#define BF_CSU_SA_SA_RAWNAND_APBHDMA(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_RAWNAND_APBHDMA) & BM_CSU_SA_SA_RAWNAND_APBHDMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_RAWNAND_APBHDMA field to a new value.
#define BW_CSU_SA_SA_RAWNAND_APBHDMA(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_RAWNAND_APBHDMA) | BF_CSU_SA_SA_RAWNAND_APBHDMA(v)))
#endif


/* --- Register HW_CSU_SA, field L_RAWNAND_APBHDMA[15] (RW)
 *
 * Lock bit set by TZ software for SA_RAWNAND_APBHDMA.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_RAWNAND_APBHDMA      (15)      //!< Bit position for CSU_SA_L_RAWNAND_APBHDMA.
#define BM_CSU_SA_L_RAWNAND_APBHDMA      (0x00008000)  //!< Bit mask for CSU_SA_L_RAWNAND_APBHDMA.

//! @brief Get value of CSU_SA_L_RAWNAND_APBHDMA from a register value.
#define BG_CSU_SA_L_RAWNAND_APBHDMA(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_RAWNAND_APBHDMA) >> BP_CSU_SA_L_RAWNAND_APBHDMA)

//! @brief Format value for bitfield CSU_SA_L_RAWNAND_APBHDMA.
#define BF_CSU_SA_L_RAWNAND_APBHDMA(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_RAWNAND_APBHDMA) & BM_CSU_SA_L_RAWNAND_APBHDMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_RAWNAND_APBHDMA field to a new value.
#define BW_CSU_SA_L_RAWNAND_APBHDMA(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_RAWNAND_APBHDMA) | BF_CSU_SA_L_RAWNAND_APBHDMA(v)))
#endif


/* --- Register HW_CSU_SA, field SA_ENET[16] (RW)
 *
 * Indicate the Type (Secured/Non-Secured) Access for ENET.
 *
 * Values:
 * 0 - Secure access for the corresponding Type 1 master
 * 1 - Non-secure access for the corresponding Type 1 master
 */

#define BP_CSU_SA_SA_ENET      (16)      //!< Bit position for CSU_SA_SA_ENET.
#define BM_CSU_SA_SA_ENET      (0x00010000)  //!< Bit mask for CSU_SA_SA_ENET.

//! @brief Get value of CSU_SA_SA_ENET from a register value.
#define BG_CSU_SA_SA_ENET(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_ENET) >> BP_CSU_SA_SA_ENET)

//! @brief Format value for bitfield CSU_SA_SA_ENET.
#define BF_CSU_SA_SA_ENET(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_ENET) & BM_CSU_SA_SA_ENET)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_ENET field to a new value.
#define BW_CSU_SA_SA_ENET(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_ENET) | BF_CSU_SA_SA_ENET(v)))
#endif


/* --- Register HW_CSU_SA, field L_ENET[17] (RW)
 *
 * Lock bit set by TZ software for SA_ENET.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_ENET      (17)      //!< Bit position for CSU_SA_L_ENET.
#define BM_CSU_SA_L_ENET      (0x00020000)  //!< Bit mask for CSU_SA_L_ENET.

//! @brief Get value of CSU_SA_L_ENET from a register value.
#define BG_CSU_SA_L_ENET(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_ENET) >> BP_CSU_SA_L_ENET)

//! @brief Format value for bitfield CSU_SA_L_ENET.
#define BF_CSU_SA_L_ENET(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_ENET) & BM_CSU_SA_L_ENET)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_ENET field to a new value.
#define BW_CSU_SA_L_ENET(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_ENET) | BF_CSU_SA_L_ENET(v)))
#endif


/* --- Register HW_CSU_SA, field SA_DAP[18] (RW)
 *
 * Access Policy indicator bits
 *
 * Values:
 * 0 - Secure access for the corresponding Type 1 master
 * 1 - Non-secure access for the corresponding Type 1 master
 */

#define BP_CSU_SA_SA_DAP      (18)      //!< Bit position for CSU_SA_SA_DAP.
#define BM_CSU_SA_SA_DAP      (0x00040000)  //!< Bit mask for CSU_SA_SA_DAP.

//! @brief Get value of CSU_SA_SA_DAP from a register value.
#define BG_CSU_SA_SA_DAP(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_DAP) >> BP_CSU_SA_SA_DAP)

//! @brief Format value for bitfield CSU_SA_SA_DAP.
#define BF_CSU_SA_SA_DAP(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_DAP) & BM_CSU_SA_SA_DAP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_DAP field to a new value.
#define BW_CSU_SA_SA_DAP(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_DAP) | BF_CSU_SA_SA_DAP(v)))
#endif


/* --- Register HW_CSU_SA, field L_DAP[19] (RW)
 *
 * Lock bit set by TZ software for SA_DAP.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_DAP      (19)      //!< Bit position for CSU_SA_L_DAP.
#define BM_CSU_SA_L_DAP      (0x00080000)  //!< Bit mask for CSU_SA_L_DAP.

//! @brief Get value of CSU_SA_L_DAP from a register value.
#define BG_CSU_SA_L_DAP(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_DAP) >> BP_CSU_SA_L_DAP)

//! @brief Format value for bitfield CSU_SA_L_DAP.
#define BF_CSU_SA_L_DAP(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_DAP) & BM_CSU_SA_L_DAP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_DAP field to a new value.
#define BW_CSU_SA_L_DAP(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_DAP) | BF_CSU_SA_L_DAP(v)))
#endif


/* --- Register HW_CSU_SA, field SA_USDHC1[20] (RW)
 *
 * Indicate the Type (Secured/Non-Secured) Access for USDHC1.
 *
 * Values:
 * 0 - Secure access for the corresponding Type 1 master
 * 1 - Non-secure access for the corresponding Type 1 master
 */

#define BP_CSU_SA_SA_USDHC1      (20)      //!< Bit position for CSU_SA_SA_USDHC1.
#define BM_CSU_SA_SA_USDHC1      (0x00100000)  //!< Bit mask for CSU_SA_SA_USDHC1.

//! @brief Get value of CSU_SA_SA_USDHC1 from a register value.
#define BG_CSU_SA_SA_USDHC1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_USDHC1) >> BP_CSU_SA_SA_USDHC1)

//! @brief Format value for bitfield CSU_SA_SA_USDHC1.
#define BF_CSU_SA_SA_USDHC1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_USDHC1) & BM_CSU_SA_SA_USDHC1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_USDHC1 field to a new value.
#define BW_CSU_SA_SA_USDHC1(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_USDHC1) | BF_CSU_SA_SA_USDHC1(v)))
#endif


/* --- Register HW_CSU_SA, field L_USDHC1[21] (RW)
 *
 * Lock bit set by TZ software for SA_.USDHC1
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_USDHC1      (21)      //!< Bit position for CSU_SA_L_USDHC1.
#define BM_CSU_SA_L_USDHC1      (0x00200000)  //!< Bit mask for CSU_SA_L_USDHC1.

//! @brief Get value of CSU_SA_L_USDHC1 from a register value.
#define BG_CSU_SA_L_USDHC1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_USDHC1) >> BP_CSU_SA_L_USDHC1)

//! @brief Format value for bitfield CSU_SA_L_USDHC1.
#define BF_CSU_SA_L_USDHC1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_USDHC1) & BM_CSU_SA_L_USDHC1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USDHC1 field to a new value.
#define BW_CSU_SA_L_USDHC1(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_USDHC1) | BF_CSU_SA_L_USDHC1(v)))
#endif


/* --- Register HW_CSU_SA, field SA_USDHC2[22] (RW)
 *
 * Indicate the Type (Secured/Non-Secured) Access for USDHC2.
 *
 * Values:
 * 0 - Secure access for the corresponding Type 1 master
 * 1 - Non-secure access for the corresponding Type 1 master
 */

#define BP_CSU_SA_SA_USDHC2      (22)      //!< Bit position for CSU_SA_SA_USDHC2.
#define BM_CSU_SA_SA_USDHC2      (0x00400000)  //!< Bit mask for CSU_SA_SA_USDHC2.

//! @brief Get value of CSU_SA_SA_USDHC2 from a register value.
#define BG_CSU_SA_SA_USDHC2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_USDHC2) >> BP_CSU_SA_SA_USDHC2)

//! @brief Format value for bitfield CSU_SA_SA_USDHC2.
#define BF_CSU_SA_SA_USDHC2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_USDHC2) & BM_CSU_SA_SA_USDHC2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_USDHC2 field to a new value.
#define BW_CSU_SA_SA_USDHC2(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_USDHC2) | BF_CSU_SA_SA_USDHC2(v)))
#endif


/* --- Register HW_CSU_SA, field L_USDHC2[23] (RW)
 *
 * Lock bit set by TZ software for SA_.USDHC2
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_USDHC2      (23)      //!< Bit position for CSU_SA_L_USDHC2.
#define BM_CSU_SA_L_USDHC2      (0x00800000)  //!< Bit mask for CSU_SA_L_USDHC2.

//! @brief Get value of CSU_SA_L_USDHC2 from a register value.
#define BG_CSU_SA_L_USDHC2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_USDHC2) >> BP_CSU_SA_L_USDHC2)

//! @brief Format value for bitfield CSU_SA_L_USDHC2.
#define BF_CSU_SA_L_USDHC2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_USDHC2) & BM_CSU_SA_L_USDHC2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USDHC2 field to a new value.
#define BW_CSU_SA_L_USDHC2(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_USDHC2) | BF_CSU_SA_L_USDHC2(v)))
#endif


/* --- Register HW_CSU_SA, field SA_USDHC3[24] (RW)
 *
 * Indicate the Type (Secured/Non-Secured) Access for USDHC3.
 *
 * Values:
 * 0 - Secure access for the corresponding Type 1 master
 * 1 - Non-secure access for the corresponding Type 1 master
 */

#define BP_CSU_SA_SA_USDHC3      (24)      //!< Bit position for CSU_SA_SA_USDHC3.
#define BM_CSU_SA_SA_USDHC3      (0x01000000)  //!< Bit mask for CSU_SA_SA_USDHC3.

//! @brief Get value of CSU_SA_SA_USDHC3 from a register value.
#define BG_CSU_SA_SA_USDHC3(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_USDHC3) >> BP_CSU_SA_SA_USDHC3)

//! @brief Format value for bitfield CSU_SA_SA_USDHC3.
#define BF_CSU_SA_SA_USDHC3(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_USDHC3) & BM_CSU_SA_SA_USDHC3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_USDHC3 field to a new value.
#define BW_CSU_SA_SA_USDHC3(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_USDHC3) | BF_CSU_SA_SA_USDHC3(v)))
#endif


/* --- Register HW_CSU_SA, field L_USDHC3[25] (RW)
 *
 * Lock bit set by TZ software for SA_.USDHC3
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_USDHC3      (25)      //!< Bit position for CSU_SA_L_USDHC3.
#define BM_CSU_SA_L_USDHC3      (0x02000000)  //!< Bit mask for CSU_SA_L_USDHC3.

//! @brief Get value of CSU_SA_L_USDHC3 from a register value.
#define BG_CSU_SA_L_USDHC3(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_USDHC3) >> BP_CSU_SA_L_USDHC3)

//! @brief Format value for bitfield CSU_SA_L_USDHC3.
#define BF_CSU_SA_L_USDHC3(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_USDHC3) & BM_CSU_SA_L_USDHC3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USDHC3 field to a new value.
#define BW_CSU_SA_L_USDHC3(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_USDHC3) | BF_CSU_SA_L_USDHC3(v)))
#endif


/* --- Register HW_CSU_SA, field SA_USDHC4[26] (RW)
 *
 * Indicate the Type (Secured/Non-Secured) Access for USDHC4.
 *
 * Values:
 * 0 - Secure access for the corresponding Type 1 master
 * 1 - Non-secure access for the corresponding Type 1 master
 */

#define BP_CSU_SA_SA_USDHC4      (26)      //!< Bit position for CSU_SA_SA_USDHC4.
#define BM_CSU_SA_SA_USDHC4      (0x04000000)  //!< Bit mask for CSU_SA_SA_USDHC4.

//! @brief Get value of CSU_SA_SA_USDHC4 from a register value.
#define BG_CSU_SA_SA_USDHC4(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_USDHC4) >> BP_CSU_SA_SA_USDHC4)

//! @brief Format value for bitfield CSU_SA_SA_USDHC4.
#define BF_CSU_SA_SA_USDHC4(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_USDHC4) & BM_CSU_SA_SA_USDHC4)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_USDHC4 field to a new value.
#define BW_CSU_SA_SA_USDHC4(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_USDHC4) | BF_CSU_SA_SA_USDHC4(v)))
#endif


/* --- Register HW_CSU_SA, field L_USDHC4[27] (RW)
 *
 * Lock bit set by TZ software for SA_.USDHC14
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_USDHC4      (27)      //!< Bit position for CSU_SA_L_USDHC4.
#define BM_CSU_SA_L_USDHC4      (0x08000000)  //!< Bit mask for CSU_SA_L_USDHC4.

//! @brief Get value of CSU_SA_L_USDHC4 from a register value.
#define BG_CSU_SA_L_USDHC4(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_USDHC4) >> BP_CSU_SA_L_USDHC4)

//! @brief Format value for bitfield CSU_SA_L_USDHC4.
#define BF_CSU_SA_L_USDHC4(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_USDHC4) & BM_CSU_SA_L_USDHC4)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USDHC4 field to a new value.
#define BW_CSU_SA_L_USDHC4(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_USDHC4) | BF_CSU_SA_L_USDHC4(v)))
#endif


/* --- Register HW_CSU_SA, field SA_HDMI_HSI[28] (RW)
 *
 * Indicate the Type (Secured/Non-Secured) Access for HDMI Tx and HSI.
 *
 * Values:
 * 0 - Secure access for the corresponding Type 1 master
 * 1 - Non-secure access for the corresponding Type 1 master
 */

#define BP_CSU_SA_SA_HDMI_HSI      (28)      //!< Bit position for CSU_SA_SA_HDMI_HSI.
#define BM_CSU_SA_SA_HDMI_HSI      (0x10000000)  //!< Bit mask for CSU_SA_SA_HDMI_HSI.

//! @brief Get value of CSU_SA_SA_HDMI_HSI from a register value.
#define BG_CSU_SA_SA_HDMI_HSI(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_SA_HDMI_HSI) >> BP_CSU_SA_SA_HDMI_HSI)

//! @brief Format value for bitfield CSU_SA_SA_HDMI_HSI.
#define BF_CSU_SA_SA_HDMI_HSI(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_SA_HDMI_HSI) & BM_CSU_SA_SA_HDMI_HSI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the SA_HDMI_HSI field to a new value.
#define BW_CSU_SA_SA_HDMI_HSI(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_SA_HDMI_HSI) | BF_CSU_SA_SA_HDMI_HSI(v)))
#endif


/* --- Register HW_CSU_SA, field L_HDMI_HSI[29] (RW)
 *
 * Lock bit set by TZ software for SA_.HDMI_HSI
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_SA_L_HDMI_HSI      (29)      //!< Bit position for CSU_SA_L_HDMI_HSI.
#define BM_CSU_SA_L_HDMI_HSI      (0x20000000)  //!< Bit mask for CSU_SA_L_HDMI_HSI.

//! @brief Get value of CSU_SA_L_HDMI_HSI from a register value.
#define BG_CSU_SA_L_HDMI_HSI(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_SA_L_HDMI_HSI) >> BP_CSU_SA_L_HDMI_HSI)

//! @brief Format value for bitfield CSU_SA_L_HDMI_HSI.
#define BF_CSU_SA_L_HDMI_HSI(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_SA_L_HDMI_HSI) & BM_CSU_SA_L_HDMI_HSI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_HDMI_HSI field to a new value.
#define BW_CSU_SA_L_HDMI_HSI(v)   (HW_CSU_SA_WR((HW_CSU_SA_RD() & ~BM_CSU_SA_L_HDMI_HSI) | BF_CSU_SA_L_HDMI_HSI(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_HPCONTROL0 - HPCONTROL0 register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_HPCONTROL0 - HPCONTROL0 register (RW)
 *
 * Reset value: 0x00000000
 *
 * The HP Control registers CSU_HPCONTROL0 and CSU_HPCONTROL1 enable CSU to control the
 * USER/SUPERVISOR mode state for the specified masters. The register toggles the output signal
 * csu_hprot1 for system masters. The two possibilities sources for the csu_hprot1 output are:   the
 * hprot1 input signal, or  the corresponding bit in the HP register.   The even bits in the
 * registers are used for locking the control bit values.
 */
typedef union _hw_csu_hpcontrol0
{
    reg32_t U;
    struct _hw_csu_hpcontrol0_bitfields
    {
        unsigned HPC_PCIE : 1; //!< [0] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of PCIE.
        unsigned L_PCIE : 1; //!< [1] Lock bit set by TZ software for HPC_PCIE.
        unsigned RESERVED0 : 2; //!< [3:2] Reserved.
        unsigned HPC_SDMA : 1; //!< [4] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of SDMA.
        unsigned L_SDMA : 1; //!< [5] Lock bit set by TZ software for HPC_SDMA.
        unsigned HPC_PU : 1; //!< [6] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of GPU3D, GPU2D, VPU, IPU1, IPU2, OpenVG EPDC, PXP, LCDIF and VDOA. NOTE: IPU2 and OpenVG on i.MX6DQ only; EPDC, PXP and LCDIF on i.MX6SDL only
        unsigned L_PU : 1; //!< [7] Lock bit set by TZ software for HPC_PU.
        unsigned HPC_USB : 1; //!< [8] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of USB.
        unsigned L_USB : 1; //!< [9] Lock bit set by TZ software for HPC_USB.
        unsigned HPC_TEST : 1; //!< [10] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of IOMUX Test Port.
        unsigned L_TEST : 1; //!< [11] Lock bit set by TZ software for HPC_TEST.
        unsigned HPC_MLB : 1; //!< [12] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of MLB.
        unsigned L_MLB : 1; //!< [13] Lock bit set by TZ software for HPC_MLB.
        unsigned HPC_CAAM : 1; //!< [14] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of CAAM.
        unsigned L_CAAM : 1; //!< [15] Lock bit set by TZ software for HPC_CAAM.
        unsigned HPC_RAWNAND : 1; //!< [16] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of RawNAND.
        unsigned L_RAWNAND : 1; //!< [17] Lock bit set by TZ software for HPC_RAWNAND.
        unsigned HPC_APBHDMA : 1; //!< [18] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of apbhdma.
        unsigned L_ABPHDMA : 1; //!< [19] Lock bit set by TZ software for HPC_APBHDMA.
        unsigned HPC_ENET : 1; //!< [20] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of ENET.
        unsigned L_ENET : 1; //!< [21] Lock bit set by TZ software for HPC_ENET.
        unsigned HPC_DAP : 1; //!< [22] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of DAP.
        unsigned L_DAP : 1; //!< [23] Lock bit set by TZ software for HPC_DAP.
        unsigned HPC_USDHC1 : 1; //!< [24] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of USDHC1.
        unsigned L_USDHC1 : 1; //!< [25] Lock bit set by TZ software for HPC_USDHC1.
        unsigned HPC_USDHC2 : 1; //!< [26] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of USDHC2.
        unsigned L_USDHC2 : 1; //!< [27] Lock bit set by TZ software for HPC_USDHC2.
        unsigned HPC_USDHC3 : 1; //!< [28] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of USDHC3.
        unsigned L_USDHC3 : 1; //!< [29] Lock bit set by TZ software for HPC_USDHC3.
        unsigned HPC_USDHC4 : 1; //!< [30] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of USDHC4.
        unsigned L_USDHC4 : 1; //!< [31] Lock bit set by TZ software for HPC_USDHC4.
    } B;
} hw_csu_hpcontrol0_t;
#endif

/*
 * constants & macros for entire CSU_HPCONTROL0 register
 */
#define HW_CSU_HPCONTROL0_ADDR      (REGS_CSU_BASE + 0x358)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_HPCONTROL0           (*(volatile hw_csu_hpcontrol0_t *) HW_CSU_HPCONTROL0_ADDR)
#define HW_CSU_HPCONTROL0_RD()      (HW_CSU_HPCONTROL0.U)
#define HW_CSU_HPCONTROL0_WR(v)     (HW_CSU_HPCONTROL0.U = (v))
#define HW_CSU_HPCONTROL0_SET(v)    (HW_CSU_HPCONTROL0_WR(HW_CSU_HPCONTROL0_RD() |  (v)))
#define HW_CSU_HPCONTROL0_CLR(v)    (HW_CSU_HPCONTROL0_WR(HW_CSU_HPCONTROL0_RD() & ~(v)))
#define HW_CSU_HPCONTROL0_TOG(v)    (HW_CSU_HPCONTROL0_WR(HW_CSU_HPCONTROL0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_HPCONTROL0 bitfields
 */

/* --- Register HW_CSU_HPCONTROL0, field HPC_PCIE[0] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * PCIE.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_PCIE      (0)      //!< Bit position for CSU_HPCONTROL0_HPC_PCIE.
#define BM_CSU_HPCONTROL0_HPC_PCIE      (0x00000001)  //!< Bit mask for CSU_HPCONTROL0_HPC_PCIE.

//! @brief Get value of CSU_HPCONTROL0_HPC_PCIE from a register value.
#define BG_CSU_HPCONTROL0_HPC_PCIE(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_PCIE) >> BP_CSU_HPCONTROL0_HPC_PCIE)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_PCIE.
#define BF_CSU_HPCONTROL0_HPC_PCIE(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_PCIE) & BM_CSU_HPCONTROL0_HPC_PCIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_PCIE field to a new value.
#define BW_CSU_HPCONTROL0_HPC_PCIE(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_PCIE) | BF_CSU_HPCONTROL0_HPC_PCIE(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_PCIE[1] (RW)
 *
 * Lock bit set by TZ software for HPC_PCIE.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_PCIE      (1)      //!< Bit position for CSU_HPCONTROL0_L_PCIE.
#define BM_CSU_HPCONTROL0_L_PCIE      (0x00000002)  //!< Bit mask for CSU_HPCONTROL0_L_PCIE.

//! @brief Get value of CSU_HPCONTROL0_L_PCIE from a register value.
#define BG_CSU_HPCONTROL0_L_PCIE(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_PCIE) >> BP_CSU_HPCONTROL0_L_PCIE)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_PCIE.
#define BF_CSU_HPCONTROL0_L_PCIE(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_PCIE) & BM_CSU_HPCONTROL0_L_PCIE)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_PCIE field to a new value.
#define BW_CSU_HPCONTROL0_L_PCIE(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_PCIE) | BF_CSU_HPCONTROL0_L_PCIE(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_SDMA[4] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * SDMA.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_SDMA      (4)      //!< Bit position for CSU_HPCONTROL0_HPC_SDMA.
#define BM_CSU_HPCONTROL0_HPC_SDMA      (0x00000010)  //!< Bit mask for CSU_HPCONTROL0_HPC_SDMA.

//! @brief Get value of CSU_HPCONTROL0_HPC_SDMA from a register value.
#define BG_CSU_HPCONTROL0_HPC_SDMA(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_SDMA) >> BP_CSU_HPCONTROL0_HPC_SDMA)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_SDMA.
#define BF_CSU_HPCONTROL0_HPC_SDMA(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_SDMA) & BM_CSU_HPCONTROL0_HPC_SDMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_SDMA field to a new value.
#define BW_CSU_HPCONTROL0_HPC_SDMA(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_SDMA) | BF_CSU_HPCONTROL0_HPC_SDMA(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_SDMA[5] (RW)
 *
 * Lock bit set by TZ software for HPC_SDMA.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_SDMA      (5)      //!< Bit position for CSU_HPCONTROL0_L_SDMA.
#define BM_CSU_HPCONTROL0_L_SDMA      (0x00000020)  //!< Bit mask for CSU_HPCONTROL0_L_SDMA.

//! @brief Get value of CSU_HPCONTROL0_L_SDMA from a register value.
#define BG_CSU_HPCONTROL0_L_SDMA(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_SDMA) >> BP_CSU_HPCONTROL0_L_SDMA)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_SDMA.
#define BF_CSU_HPCONTROL0_L_SDMA(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_SDMA) & BM_CSU_HPCONTROL0_L_SDMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_SDMA field to a new value.
#define BW_CSU_HPCONTROL0_L_SDMA(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_SDMA) | BF_CSU_HPCONTROL0_L_SDMA(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_PU[6] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * GPU3D, GPU2D, VPU, IPU1, IPU2, OpenVG EPDC, PXP, LCDIF and VDOA. NOTE: IPU2 and OpenVG on i.MX6DQ
 * only; EPDC, PXP and LCDIF on i.MX6SDL only
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_PU      (6)      //!< Bit position for CSU_HPCONTROL0_HPC_PU.
#define BM_CSU_HPCONTROL0_HPC_PU      (0x00000040)  //!< Bit mask for CSU_HPCONTROL0_HPC_PU.

//! @brief Get value of CSU_HPCONTROL0_HPC_PU from a register value.
#define BG_CSU_HPCONTROL0_HPC_PU(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_PU) >> BP_CSU_HPCONTROL0_HPC_PU)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_PU.
#define BF_CSU_HPCONTROL0_HPC_PU(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_PU) & BM_CSU_HPCONTROL0_HPC_PU)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_PU field to a new value.
#define BW_CSU_HPCONTROL0_HPC_PU(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_PU) | BF_CSU_HPCONTROL0_HPC_PU(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_PU[7] (RW)
 *
 * Lock bit set by TZ software for HPC_PU.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_PU      (7)      //!< Bit position for CSU_HPCONTROL0_L_PU.
#define BM_CSU_HPCONTROL0_L_PU      (0x00000080)  //!< Bit mask for CSU_HPCONTROL0_L_PU.

//! @brief Get value of CSU_HPCONTROL0_L_PU from a register value.
#define BG_CSU_HPCONTROL0_L_PU(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_PU) >> BP_CSU_HPCONTROL0_L_PU)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_PU.
#define BF_CSU_HPCONTROL0_L_PU(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_PU) & BM_CSU_HPCONTROL0_L_PU)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_PU field to a new value.
#define BW_CSU_HPCONTROL0_L_PU(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_PU) | BF_CSU_HPCONTROL0_L_PU(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_USB[8] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * USB.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_USB      (8)      //!< Bit position for CSU_HPCONTROL0_HPC_USB.
#define BM_CSU_HPCONTROL0_HPC_USB      (0x00000100)  //!< Bit mask for CSU_HPCONTROL0_HPC_USB.

//! @brief Get value of CSU_HPCONTROL0_HPC_USB from a register value.
#define BG_CSU_HPCONTROL0_HPC_USB(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_USB) >> BP_CSU_HPCONTROL0_HPC_USB)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_USB.
#define BF_CSU_HPCONTROL0_HPC_USB(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_USB) & BM_CSU_HPCONTROL0_HPC_USB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_USB field to a new value.
#define BW_CSU_HPCONTROL0_HPC_USB(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_USB) | BF_CSU_HPCONTROL0_HPC_USB(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_USB[9] (RW)
 *
 * Lock bit set by TZ software for HPC_USB.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_USB      (9)      //!< Bit position for CSU_HPCONTROL0_L_USB.
#define BM_CSU_HPCONTROL0_L_USB      (0x00000200)  //!< Bit mask for CSU_HPCONTROL0_L_USB.

//! @brief Get value of CSU_HPCONTROL0_L_USB from a register value.
#define BG_CSU_HPCONTROL0_L_USB(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_USB) >> BP_CSU_HPCONTROL0_L_USB)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_USB.
#define BF_CSU_HPCONTROL0_L_USB(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_USB) & BM_CSU_HPCONTROL0_L_USB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USB field to a new value.
#define BW_CSU_HPCONTROL0_L_USB(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_USB) | BF_CSU_HPCONTROL0_L_USB(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_TEST[10] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * IOMUX Test Port.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_TEST      (10)      //!< Bit position for CSU_HPCONTROL0_HPC_TEST.
#define BM_CSU_HPCONTROL0_HPC_TEST      (0x00000400)  //!< Bit mask for CSU_HPCONTROL0_HPC_TEST.

//! @brief Get value of CSU_HPCONTROL0_HPC_TEST from a register value.
#define BG_CSU_HPCONTROL0_HPC_TEST(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_TEST) >> BP_CSU_HPCONTROL0_HPC_TEST)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_TEST.
#define BF_CSU_HPCONTROL0_HPC_TEST(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_TEST) & BM_CSU_HPCONTROL0_HPC_TEST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_TEST field to a new value.
#define BW_CSU_HPCONTROL0_HPC_TEST(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_TEST) | BF_CSU_HPCONTROL0_HPC_TEST(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_TEST[11] (RW)
 *
 * Lock bit set by TZ software for HPC_TEST.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_TEST      (11)      //!< Bit position for CSU_HPCONTROL0_L_TEST.
#define BM_CSU_HPCONTROL0_L_TEST      (0x00000800)  //!< Bit mask for CSU_HPCONTROL0_L_TEST.

//! @brief Get value of CSU_HPCONTROL0_L_TEST from a register value.
#define BG_CSU_HPCONTROL0_L_TEST(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_TEST) >> BP_CSU_HPCONTROL0_L_TEST)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_TEST.
#define BF_CSU_HPCONTROL0_L_TEST(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_TEST) & BM_CSU_HPCONTROL0_L_TEST)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_TEST field to a new value.
#define BW_CSU_HPCONTROL0_L_TEST(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_TEST) | BF_CSU_HPCONTROL0_L_TEST(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_MLB[12] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * MLB.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_MLB      (12)      //!< Bit position for CSU_HPCONTROL0_HPC_MLB.
#define BM_CSU_HPCONTROL0_HPC_MLB      (0x00001000)  //!< Bit mask for CSU_HPCONTROL0_HPC_MLB.

//! @brief Get value of CSU_HPCONTROL0_HPC_MLB from a register value.
#define BG_CSU_HPCONTROL0_HPC_MLB(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_MLB) >> BP_CSU_HPCONTROL0_HPC_MLB)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_MLB.
#define BF_CSU_HPCONTROL0_HPC_MLB(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_MLB) & BM_CSU_HPCONTROL0_HPC_MLB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_MLB field to a new value.
#define BW_CSU_HPCONTROL0_HPC_MLB(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_MLB) | BF_CSU_HPCONTROL0_HPC_MLB(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_MLB[13] (RW)
 *
 * Lock bit set by TZ software for HPC_MLB.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_MLB      (13)      //!< Bit position for CSU_HPCONTROL0_L_MLB.
#define BM_CSU_HPCONTROL0_L_MLB      (0x00002000)  //!< Bit mask for CSU_HPCONTROL0_L_MLB.

//! @brief Get value of CSU_HPCONTROL0_L_MLB from a register value.
#define BG_CSU_HPCONTROL0_L_MLB(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_MLB) >> BP_CSU_HPCONTROL0_L_MLB)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_MLB.
#define BF_CSU_HPCONTROL0_L_MLB(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_MLB) & BM_CSU_HPCONTROL0_L_MLB)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_MLB field to a new value.
#define BW_CSU_HPCONTROL0_L_MLB(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_MLB) | BF_CSU_HPCONTROL0_L_MLB(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_CAAM[14] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * CAAM.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_CAAM      (14)      //!< Bit position for CSU_HPCONTROL0_HPC_CAAM.
#define BM_CSU_HPCONTROL0_HPC_CAAM      (0x00004000)  //!< Bit mask for CSU_HPCONTROL0_HPC_CAAM.

//! @brief Get value of CSU_HPCONTROL0_HPC_CAAM from a register value.
#define BG_CSU_HPCONTROL0_HPC_CAAM(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_CAAM) >> BP_CSU_HPCONTROL0_HPC_CAAM)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_CAAM.
#define BF_CSU_HPCONTROL0_HPC_CAAM(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_CAAM) & BM_CSU_HPCONTROL0_HPC_CAAM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_CAAM field to a new value.
#define BW_CSU_HPCONTROL0_HPC_CAAM(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_CAAM) | BF_CSU_HPCONTROL0_HPC_CAAM(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_CAAM[15] (RW)
 *
 * Lock bit set by TZ software for HPC_CAAM.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_CAAM      (15)      //!< Bit position for CSU_HPCONTROL0_L_CAAM.
#define BM_CSU_HPCONTROL0_L_CAAM      (0x00008000)  //!< Bit mask for CSU_HPCONTROL0_L_CAAM.

//! @brief Get value of CSU_HPCONTROL0_L_CAAM from a register value.
#define BG_CSU_HPCONTROL0_L_CAAM(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_CAAM) >> BP_CSU_HPCONTROL0_L_CAAM)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_CAAM.
#define BF_CSU_HPCONTROL0_L_CAAM(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_CAAM) & BM_CSU_HPCONTROL0_L_CAAM)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_CAAM field to a new value.
#define BW_CSU_HPCONTROL0_L_CAAM(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_CAAM) | BF_CSU_HPCONTROL0_L_CAAM(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_RAWNAND[16] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * RawNAND.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_RAWNAND      (16)      //!< Bit position for CSU_HPCONTROL0_HPC_RAWNAND.
#define BM_CSU_HPCONTROL0_HPC_RAWNAND      (0x00010000)  //!< Bit mask for CSU_HPCONTROL0_HPC_RAWNAND.

//! @brief Get value of CSU_HPCONTROL0_HPC_RAWNAND from a register value.
#define BG_CSU_HPCONTROL0_HPC_RAWNAND(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_RAWNAND) >> BP_CSU_HPCONTROL0_HPC_RAWNAND)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_RAWNAND.
#define BF_CSU_HPCONTROL0_HPC_RAWNAND(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_RAWNAND) & BM_CSU_HPCONTROL0_HPC_RAWNAND)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_RAWNAND field to a new value.
#define BW_CSU_HPCONTROL0_HPC_RAWNAND(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_RAWNAND) | BF_CSU_HPCONTROL0_HPC_RAWNAND(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_RAWNAND[17] (RW)
 *
 * Lock bit set by TZ software for HPC_RAWNAND.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_RAWNAND      (17)      //!< Bit position for CSU_HPCONTROL0_L_RAWNAND.
#define BM_CSU_HPCONTROL0_L_RAWNAND      (0x00020000)  //!< Bit mask for CSU_HPCONTROL0_L_RAWNAND.

//! @brief Get value of CSU_HPCONTROL0_L_RAWNAND from a register value.
#define BG_CSU_HPCONTROL0_L_RAWNAND(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_RAWNAND) >> BP_CSU_HPCONTROL0_L_RAWNAND)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_RAWNAND.
#define BF_CSU_HPCONTROL0_L_RAWNAND(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_RAWNAND) & BM_CSU_HPCONTROL0_L_RAWNAND)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_RAWNAND field to a new value.
#define BW_CSU_HPCONTROL0_L_RAWNAND(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_RAWNAND) | BF_CSU_HPCONTROL0_L_RAWNAND(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_APBHDMA[18] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * apbhdma.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_APBHDMA      (18)      //!< Bit position for CSU_HPCONTROL0_HPC_APBHDMA.
#define BM_CSU_HPCONTROL0_HPC_APBHDMA      (0x00040000)  //!< Bit mask for CSU_HPCONTROL0_HPC_APBHDMA.

//! @brief Get value of CSU_HPCONTROL0_HPC_APBHDMA from a register value.
#define BG_CSU_HPCONTROL0_HPC_APBHDMA(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_APBHDMA) >> BP_CSU_HPCONTROL0_HPC_APBHDMA)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_APBHDMA.
#define BF_CSU_HPCONTROL0_HPC_APBHDMA(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_APBHDMA) & BM_CSU_HPCONTROL0_HPC_APBHDMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_APBHDMA field to a new value.
#define BW_CSU_HPCONTROL0_HPC_APBHDMA(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_APBHDMA) | BF_CSU_HPCONTROL0_HPC_APBHDMA(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_ABPHDMA[19] (RW)
 *
 * Lock bit set by TZ software for HPC_APBHDMA.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_ABPHDMA      (19)      //!< Bit position for CSU_HPCONTROL0_L_ABPHDMA.
#define BM_CSU_HPCONTROL0_L_ABPHDMA      (0x00080000)  //!< Bit mask for CSU_HPCONTROL0_L_ABPHDMA.

//! @brief Get value of CSU_HPCONTROL0_L_ABPHDMA from a register value.
#define BG_CSU_HPCONTROL0_L_ABPHDMA(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_ABPHDMA) >> BP_CSU_HPCONTROL0_L_ABPHDMA)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_ABPHDMA.
#define BF_CSU_HPCONTROL0_L_ABPHDMA(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_ABPHDMA) & BM_CSU_HPCONTROL0_L_ABPHDMA)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_ABPHDMA field to a new value.
#define BW_CSU_HPCONTROL0_L_ABPHDMA(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_ABPHDMA) | BF_CSU_HPCONTROL0_L_ABPHDMA(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_ENET[20] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * ENET.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_ENET      (20)      //!< Bit position for CSU_HPCONTROL0_HPC_ENET.
#define BM_CSU_HPCONTROL0_HPC_ENET      (0x00100000)  //!< Bit mask for CSU_HPCONTROL0_HPC_ENET.

//! @brief Get value of CSU_HPCONTROL0_HPC_ENET from a register value.
#define BG_CSU_HPCONTROL0_HPC_ENET(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_ENET) >> BP_CSU_HPCONTROL0_HPC_ENET)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_ENET.
#define BF_CSU_HPCONTROL0_HPC_ENET(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_ENET) & BM_CSU_HPCONTROL0_HPC_ENET)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_ENET field to a new value.
#define BW_CSU_HPCONTROL0_HPC_ENET(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_ENET) | BF_CSU_HPCONTROL0_HPC_ENET(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_ENET[21] (RW)
 *
 * Lock bit set by TZ software for HPC_ENET.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_ENET      (21)      //!< Bit position for CSU_HPCONTROL0_L_ENET.
#define BM_CSU_HPCONTROL0_L_ENET      (0x00200000)  //!< Bit mask for CSU_HPCONTROL0_L_ENET.

//! @brief Get value of CSU_HPCONTROL0_L_ENET from a register value.
#define BG_CSU_HPCONTROL0_L_ENET(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_ENET) >> BP_CSU_HPCONTROL0_L_ENET)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_ENET.
#define BF_CSU_HPCONTROL0_L_ENET(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_ENET) & BM_CSU_HPCONTROL0_L_ENET)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_ENET field to a new value.
#define BW_CSU_HPCONTROL0_L_ENET(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_ENET) | BF_CSU_HPCONTROL0_L_ENET(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_DAP[22] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * DAP.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_DAP      (22)      //!< Bit position for CSU_HPCONTROL0_HPC_DAP.
#define BM_CSU_HPCONTROL0_HPC_DAP      (0x00400000)  //!< Bit mask for CSU_HPCONTROL0_HPC_DAP.

//! @brief Get value of CSU_HPCONTROL0_HPC_DAP from a register value.
#define BG_CSU_HPCONTROL0_HPC_DAP(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_DAP) >> BP_CSU_HPCONTROL0_HPC_DAP)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_DAP.
#define BF_CSU_HPCONTROL0_HPC_DAP(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_DAP) & BM_CSU_HPCONTROL0_HPC_DAP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_DAP field to a new value.
#define BW_CSU_HPCONTROL0_HPC_DAP(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_DAP) | BF_CSU_HPCONTROL0_HPC_DAP(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_DAP[23] (RW)
 *
 * Lock bit set by TZ software for HPC_DAP.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_DAP      (23)      //!< Bit position for CSU_HPCONTROL0_L_DAP.
#define BM_CSU_HPCONTROL0_L_DAP      (0x00800000)  //!< Bit mask for CSU_HPCONTROL0_L_DAP.

//! @brief Get value of CSU_HPCONTROL0_L_DAP from a register value.
#define BG_CSU_HPCONTROL0_L_DAP(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_DAP) >> BP_CSU_HPCONTROL0_L_DAP)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_DAP.
#define BF_CSU_HPCONTROL0_L_DAP(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_DAP) & BM_CSU_HPCONTROL0_L_DAP)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_DAP field to a new value.
#define BW_CSU_HPCONTROL0_L_DAP(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_DAP) | BF_CSU_HPCONTROL0_L_DAP(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_USDHC1[24] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * USDHC1.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_USDHC1      (24)      //!< Bit position for CSU_HPCONTROL0_HPC_USDHC1.
#define BM_CSU_HPCONTROL0_HPC_USDHC1      (0x01000000)  //!< Bit mask for CSU_HPCONTROL0_HPC_USDHC1.

//! @brief Get value of CSU_HPCONTROL0_HPC_USDHC1 from a register value.
#define BG_CSU_HPCONTROL0_HPC_USDHC1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_USDHC1) >> BP_CSU_HPCONTROL0_HPC_USDHC1)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_USDHC1.
#define BF_CSU_HPCONTROL0_HPC_USDHC1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_USDHC1) & BM_CSU_HPCONTROL0_HPC_USDHC1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_USDHC1 field to a new value.
#define BW_CSU_HPCONTROL0_HPC_USDHC1(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_USDHC1) | BF_CSU_HPCONTROL0_HPC_USDHC1(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_USDHC1[25] (RW)
 *
 * Lock bit set by TZ software for HPC_USDHC1.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_USDHC1      (25)      //!< Bit position for CSU_HPCONTROL0_L_USDHC1.
#define BM_CSU_HPCONTROL0_L_USDHC1      (0x02000000)  //!< Bit mask for CSU_HPCONTROL0_L_USDHC1.

//! @brief Get value of CSU_HPCONTROL0_L_USDHC1 from a register value.
#define BG_CSU_HPCONTROL0_L_USDHC1(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_USDHC1) >> BP_CSU_HPCONTROL0_L_USDHC1)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_USDHC1.
#define BF_CSU_HPCONTROL0_L_USDHC1(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_USDHC1) & BM_CSU_HPCONTROL0_L_USDHC1)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USDHC1 field to a new value.
#define BW_CSU_HPCONTROL0_L_USDHC1(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_USDHC1) | BF_CSU_HPCONTROL0_L_USDHC1(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_USDHC2[26] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * USDHC2.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_USDHC2      (26)      //!< Bit position for CSU_HPCONTROL0_HPC_USDHC2.
#define BM_CSU_HPCONTROL0_HPC_USDHC2      (0x04000000)  //!< Bit mask for CSU_HPCONTROL0_HPC_USDHC2.

//! @brief Get value of CSU_HPCONTROL0_HPC_USDHC2 from a register value.
#define BG_CSU_HPCONTROL0_HPC_USDHC2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_USDHC2) >> BP_CSU_HPCONTROL0_HPC_USDHC2)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_USDHC2.
#define BF_CSU_HPCONTROL0_HPC_USDHC2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_USDHC2) & BM_CSU_HPCONTROL0_HPC_USDHC2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_USDHC2 field to a new value.
#define BW_CSU_HPCONTROL0_HPC_USDHC2(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_USDHC2) | BF_CSU_HPCONTROL0_HPC_USDHC2(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_USDHC2[27] (RW)
 *
 * Lock bit set by TZ software for HPC_USDHC2.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_USDHC2      (27)      //!< Bit position for CSU_HPCONTROL0_L_USDHC2.
#define BM_CSU_HPCONTROL0_L_USDHC2      (0x08000000)  //!< Bit mask for CSU_HPCONTROL0_L_USDHC2.

//! @brief Get value of CSU_HPCONTROL0_L_USDHC2 from a register value.
#define BG_CSU_HPCONTROL0_L_USDHC2(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_USDHC2) >> BP_CSU_HPCONTROL0_L_USDHC2)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_USDHC2.
#define BF_CSU_HPCONTROL0_L_USDHC2(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_USDHC2) & BM_CSU_HPCONTROL0_L_USDHC2)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USDHC2 field to a new value.
#define BW_CSU_HPCONTROL0_L_USDHC2(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_USDHC2) | BF_CSU_HPCONTROL0_L_USDHC2(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_USDHC3[28] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * USDHC3.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_USDHC3      (28)      //!< Bit position for CSU_HPCONTROL0_HPC_USDHC3.
#define BM_CSU_HPCONTROL0_HPC_USDHC3      (0x10000000)  //!< Bit mask for CSU_HPCONTROL0_HPC_USDHC3.

//! @brief Get value of CSU_HPCONTROL0_HPC_USDHC3 from a register value.
#define BG_CSU_HPCONTROL0_HPC_USDHC3(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_USDHC3) >> BP_CSU_HPCONTROL0_HPC_USDHC3)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_USDHC3.
#define BF_CSU_HPCONTROL0_HPC_USDHC3(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_USDHC3) & BM_CSU_HPCONTROL0_HPC_USDHC3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_USDHC3 field to a new value.
#define BW_CSU_HPCONTROL0_HPC_USDHC3(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_USDHC3) | BF_CSU_HPCONTROL0_HPC_USDHC3(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_USDHC3[29] (RW)
 *
 * Lock bit set by TZ software for HPC_USDHC3.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_USDHC3      (29)      //!< Bit position for CSU_HPCONTROL0_L_USDHC3.
#define BM_CSU_HPCONTROL0_L_USDHC3      (0x20000000)  //!< Bit mask for CSU_HPCONTROL0_L_USDHC3.

//! @brief Get value of CSU_HPCONTROL0_L_USDHC3 from a register value.
#define BG_CSU_HPCONTROL0_L_USDHC3(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_USDHC3) >> BP_CSU_HPCONTROL0_L_USDHC3)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_USDHC3.
#define BF_CSU_HPCONTROL0_L_USDHC3(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_USDHC3) & BM_CSU_HPCONTROL0_L_USDHC3)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USDHC3 field to a new value.
#define BW_CSU_HPCONTROL0_L_USDHC3(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_USDHC3) | BF_CSU_HPCONTROL0_L_USDHC3(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field HPC_USDHC4[30] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * USDHC4.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL0_HPC_USDHC4      (30)      //!< Bit position for CSU_HPCONTROL0_HPC_USDHC4.
#define BM_CSU_HPCONTROL0_HPC_USDHC4      (0x40000000)  //!< Bit mask for CSU_HPCONTROL0_HPC_USDHC4.

//! @brief Get value of CSU_HPCONTROL0_HPC_USDHC4 from a register value.
#define BG_CSU_HPCONTROL0_HPC_USDHC4(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_HPC_USDHC4) >> BP_CSU_HPCONTROL0_HPC_USDHC4)

//! @brief Format value for bitfield CSU_HPCONTROL0_HPC_USDHC4.
#define BF_CSU_HPCONTROL0_HPC_USDHC4(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_HPC_USDHC4) & BM_CSU_HPCONTROL0_HPC_USDHC4)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_USDHC4 field to a new value.
#define BW_CSU_HPCONTROL0_HPC_USDHC4(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_HPC_USDHC4) | BF_CSU_HPCONTROL0_HPC_USDHC4(v)))
#endif


/* --- Register HW_CSU_HPCONTROL0, field L_USDHC4[31] (RW)
 *
 * Lock bit set by TZ software for HPC_USDHC4.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL0_L_USDHC4      (31)      //!< Bit position for CSU_HPCONTROL0_L_USDHC4.
#define BM_CSU_HPCONTROL0_L_USDHC4      (0x80000000)  //!< Bit mask for CSU_HPCONTROL0_L_USDHC4.

//! @brief Get value of CSU_HPCONTROL0_L_USDHC4 from a register value.
#define BG_CSU_HPCONTROL0_L_USDHC4(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL0_L_USDHC4) >> BP_CSU_HPCONTROL0_L_USDHC4)

//! @brief Format value for bitfield CSU_HPCONTROL0_L_USDHC4.
#define BF_CSU_HPCONTROL0_L_USDHC4(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL0_L_USDHC4) & BM_CSU_HPCONTROL0_L_USDHC4)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_USDHC4 field to a new value.
#define BW_CSU_HPCONTROL0_L_USDHC4(v)   (HW_CSU_HPCONTROL0_WR((HW_CSU_HPCONTROL0_RD() & ~BM_CSU_HPCONTROL0_L_USDHC4) | BF_CSU_HPCONTROL0_L_USDHC4(v)))
#endif


//-------------------------------------------------------------------------------------------
// HW_CSU_HPCONTROL1 - HPCONTROL1 register
//-------------------------------------------------------------------------------------------

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_CSU_HPCONTROL1 - HPCONTROL1 register (RW)
 *
 * Reset value: 0x00000000
 *
 * The SCU_HPCONTROL1 register is expansion of SCU_HPCONTROL0 register. See SCU_HPCONTROL0 register
 * definition.
 */
typedef union _hw_csu_hpcontrol1
{
    reg32_t U;
    struct _hw_csu_hpcontrol1_bitfields
    {
        unsigned HPC_HDMI_HSI : 1; //!< [0] Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of HDMI Tx and HSI.
        unsigned L_HDMI_HSI : 1; //!< [1] Lock bit set by TZ software for HPC_HDMI_HSI.
        unsigned RESERVED0 : 30; //!< [31:2] Reserved.
    } B;
} hw_csu_hpcontrol1_t;
#endif

/*
 * constants & macros for entire CSU_HPCONTROL1 register
 */
#define HW_CSU_HPCONTROL1_ADDR      (REGS_CSU_BASE + 0x35c)

#ifndef __LANGUAGE_ASM__
#define HW_CSU_HPCONTROL1           (*(volatile hw_csu_hpcontrol1_t *) HW_CSU_HPCONTROL1_ADDR)
#define HW_CSU_HPCONTROL1_RD()      (HW_CSU_HPCONTROL1.U)
#define HW_CSU_HPCONTROL1_WR(v)     (HW_CSU_HPCONTROL1.U = (v))
#define HW_CSU_HPCONTROL1_SET(v)    (HW_CSU_HPCONTROL1_WR(HW_CSU_HPCONTROL1_RD() |  (v)))
#define HW_CSU_HPCONTROL1_CLR(v)    (HW_CSU_HPCONTROL1_WR(HW_CSU_HPCONTROL1_RD() & ~(v)))
#define HW_CSU_HPCONTROL1_TOG(v)    (HW_CSU_HPCONTROL1_WR(HW_CSU_HPCONTROL1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual CSU_HPCONTROL1 bitfields
 */

/* --- Register HW_CSU_HPCONTROL1, field HPC_HDMI_HSI[0] (RW)
 *
 * Determines if the Register value of the HP field corresponding will be pass as the hprot[1] of
 * HDMI Tx and HSI.
 *
 * Values:
 * 0 - Input signal hprot1 value is routed to csu_hprot1 output for the corresponding master
 * 1 - HP register bit is routed to csu_hprot1 output for the corresponding master
 */

#define BP_CSU_HPCONTROL1_HPC_HDMI_HSI      (0)      //!< Bit position for CSU_HPCONTROL1_HPC_HDMI_HSI.
#define BM_CSU_HPCONTROL1_HPC_HDMI_HSI      (0x00000001)  //!< Bit mask for CSU_HPCONTROL1_HPC_HDMI_HSI.

//! @brief Get value of CSU_HPCONTROL1_HPC_HDMI_HSI from a register value.
#define BG_CSU_HPCONTROL1_HPC_HDMI_HSI(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL1_HPC_HDMI_HSI) >> BP_CSU_HPCONTROL1_HPC_HDMI_HSI)

//! @brief Format value for bitfield CSU_HPCONTROL1_HPC_HDMI_HSI.
#define BF_CSU_HPCONTROL1_HPC_HDMI_HSI(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL1_HPC_HDMI_HSI) & BM_CSU_HPCONTROL1_HPC_HDMI_HSI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the HPC_HDMI_HSI field to a new value.
#define BW_CSU_HPCONTROL1_HPC_HDMI_HSI(v)   (HW_CSU_HPCONTROL1_WR((HW_CSU_HPCONTROL1_RD() & ~BM_CSU_HPCONTROL1_HPC_HDMI_HSI) | BF_CSU_HPCONTROL1_HPC_HDMI_HSI(v)))
#endif


/* --- Register HW_CSU_HPCONTROL1, field L_HDMI_HSI[1] (RW)
 *
 * Lock bit set by TZ software for HPC_HDMI_HSI.
 *
 * Values:
 * 0 - No lock -- adjacent (next lower) bit can be written by software
 * 1 - Lock -- adjacent (next lower) bit cannot be written by software
 */

#define BP_CSU_HPCONTROL1_L_HDMI_HSI      (1)      //!< Bit position for CSU_HPCONTROL1_L_HDMI_HSI.
#define BM_CSU_HPCONTROL1_L_HDMI_HSI      (0x00000002)  //!< Bit mask for CSU_HPCONTROL1_L_HDMI_HSI.

//! @brief Get value of CSU_HPCONTROL1_L_HDMI_HSI from a register value.
#define BG_CSU_HPCONTROL1_L_HDMI_HSI(r)   ((__REG_VALUE_TYPE((r), reg32_t) & BM_CSU_HPCONTROL1_L_HDMI_HSI) >> BP_CSU_HPCONTROL1_L_HDMI_HSI)

//! @brief Format value for bitfield CSU_HPCONTROL1_L_HDMI_HSI.
#define BF_CSU_HPCONTROL1_L_HDMI_HSI(v)   ((__REG_VALUE_TYPE((v), reg32_t) << BP_CSU_HPCONTROL1_L_HDMI_HSI) & BM_CSU_HPCONTROL1_L_HDMI_HSI)

#ifndef __LANGUAGE_ASM__
//! @brief Set the L_HDMI_HSI field to a new value.
#define BW_CSU_HPCONTROL1_L_HDMI_HSI(v)   (HW_CSU_HPCONTROL1_WR((HW_CSU_HPCONTROL1_RD() & ~BM_CSU_HPCONTROL1_L_HDMI_HSI) | BF_CSU_HPCONTROL1_L_HDMI_HSI(v)))
#endif



/*!
 * @brief All CSU module registers.
 */
#ifndef __LANGUAGE_ASM__
#pragma pack(1)
typedef struct _hw_csu
{
    volatile hw_csu_csl0_t CSL0; //!< Config security level register
    volatile hw_csu_csl1_t CSL1; //!< Config security level register
    volatile hw_csu_csl2_t CSL2; //!< Config security level register
    volatile hw_csu_csl3_t CSL3; //!< Config security level register
    volatile hw_csu_csl4_t CSL4; //!< Config security level register
    volatile hw_csu_csl5_t CSL5; //!< Config security level register
    volatile hw_csu_csl6_t CSL6; //!< Config security level register
    volatile hw_csu_csl7_t CSL7; //!< Config security level register
    volatile hw_csu_csl8_t CSL8; //!< Config security level register
    volatile hw_csu_csl9_t CSL9; //!< Config security level register
    volatile hw_csu_csl10_t CSL10; //!< Config security level register
    volatile hw_csu_csl11_t CSL11; //!< Config security level register
    volatile hw_csu_csl12_t CSL12; //!< Config security level register
    volatile hw_csu_csl13_t CSL13; //!< Config security level register
    volatile hw_csu_csl14_t CSL14; //!< Config security level register
    volatile hw_csu_csl15_t CSL15; //!< Config security level register
    volatile hw_csu_csl16_t CSL16; //!< Config security level register
    volatile hw_csu_csl17_t CSL17; //!< Config security level register
    volatile hw_csu_csl18_t CSL18; //!< Config security level register
    volatile hw_csu_csl19_t CSL19; //!< Config security level register
    volatile hw_csu_csl20_t CSL20; //!< Config security level register
    volatile hw_csu_csl21_t CSL21; //!< Config security level register
    volatile hw_csu_csl22_t CSL22; //!< Config security level register
    volatile hw_csu_csl23_t CSL23; //!< Config security level register
    volatile hw_csu_csl24_t CSL24; //!< Config security level register
    volatile hw_csu_csl25_t CSL25; //!< Config security level register
    volatile hw_csu_csl26_t CSL26; //!< Config security level register
    volatile hw_csu_csl27_t CSL27; //!< Config security level register
    volatile hw_csu_csl28_t CSL28; //!< Config security level register
    volatile hw_csu_csl29_t CSL29; //!< Config security level register
    volatile hw_csu_csl30_t CSL30; //!< Config security level register
    volatile hw_csu_csl31_t CSL31; //!< Config security level register
    volatile hw_csu_csl32_t CSL32; //!< Config security level register
    volatile hw_csu_csl33_t CSL33; //!< Config security level register
    volatile hw_csu_csl34_t CSL34; //!< Config security level register
    volatile hw_csu_csl35_t CSL35; //!< Config security level register
    volatile hw_csu_csl36_t CSL36; //!< Config security level register
    volatile hw_csu_csl37_t CSL37; //!< Config security level register
    volatile hw_csu_csl38_t CSL38; //!< Config security level register
    volatile hw_csu_csl39_t CSL39; //!< Config security level register
    reg32_t _reserved0[88];
    volatile hw_csu_hp0_t HP0; //!< HP0 register
    volatile hw_csu_hp1_t HP1; //!< HP1 register
    reg32_t _reserved1[4];
    volatile hw_csu_sa_t SA; //!< Secure access register
    reg32_t _reserved2[79];
    volatile hw_csu_hpcontrol0_t HPCONTROL0; //!< HPCONTROL0 register
    volatile hw_csu_hpcontrol1_t HPCONTROL1; //!< HPCONTROL1 register
} hw_csu_t;
#pragma pack()

//! @brief Macro to access all CSU registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_CSU(0)</code>.
#define HW_CSU     (*(volatile hw_csu_t *) REGS_CSU_BASE)

#endif


#endif // __HW_CSU_REGISTERS_H__
