/*
 * Copyright (C) 2012, Freescale Semiconductor, Inc. All Rights Reserved
 * THIS SOURCE CODE IS CONFIDENTIAL AND PROPRIETARY AND MAY NOT
 * BE USED OR DISTRIBUTED WITHOUT THE WRITTEN PERMISSION OF
 * Freescale Semiconductor, Inc.
 */

#ifndef _IOMUXC_H
#define _IOMUXC_H

#include "regs.h"

/*
 * Registers defined in this header file.
 *
 * - HW_IOMUXC_IOMUXC_GPR0 - GPR
 * - HW_IOMUXC_IOMUXC_GPR1 - GPR
 * - HW_IOMUXC_IOMUXC_GPR2 - GPR
 * - HW_IOMUXC_IOMUXC_GPR3 - GPR
 * - HW_IOMUXC_IOMUXC_GPR4 - GPR
 * - HW_IOMUXC_IOMUXC_GPR5 - GPR
 * - HW_IOMUXC_IOMUXC_GPR6 - GPR
 * - HW_IOMUXC_IOMUXC_GPR7 - GPR
 * - HW_IOMUXC_IOMUXC_GPR8 - GPR
 * - HW_IOMUXC_IOMUXC_GPR9 - GPR
 * - HW_IOMUXC_IOMUXC_GPR10 - GPR
 * - HW_IOMUXC_IOMUXC_GPR11 - GPR
 * - HW_IOMUXC_IOMUXC_GPR12 - GPR
 * - HW_IOMUXC_IOMUXC_GPR13 - GPR
 * - HW_IOMUXC_IOMUXC_OBSERVE_MUX_0 - OBSRV
 * - HW_IOMUXC_IOMUXC_OBSERVE_MUX_1 - OBSRV
 * - HW_IOMUXC_IOMUXC_OBSERVE_MUX_2 - OBSRV
 * - HW_IOMUXC_IOMUXC_OBSERVE_MUX_3 - OBSRV
 * - HW_IOMUXC_IOMUXC_OBSERVE_MUX_4 - OBSRV
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3 - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B - SW_MUX_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3 - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B - SW_PAD_CTL
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS - SW_GRP
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL - SW_GRP
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE - SW_GRP
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK - SW_GRP
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS - SW_GRP
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE - SW_GRP
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS - SW_GRP
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS - SW_GRP
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS - SW_GRP
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - SW_GRP
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS - SW_GRP
 * - HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS - SW_GRP
 * - HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT - DAISY
 * - HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT - DAISY
 *
 * hw_iomuxc_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_IOMUXC_BASE
#define REGS_IOMUXC_BASE (0x020e0000) //!< Base address for IOMUXC.
#endif
//@}

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR0 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR : 32; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
    } B;
} hw_iomuxc_iomuxc_gpr0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR0 register
 */
#define HW_IOMUXC_IOMUXC_GPR0_ADDR      (REGS_IOMUXC_BASE + 0x0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR0           (*(volatile hw_iomuxc_iomuxc_gpr0_t *) HW_IOMUXC_IOMUXC_GPR0_ADDR)
#define HW_IOMUXC_IOMUXC_GPR0_RD()      (HW_IOMUXC_IOMUXC_GPR0.U)
#define HW_IOMUXC_IOMUXC_GPR0_WR(v)     (HW_IOMUXC_IOMUXC_GPR0.U = (v))
#define HW_IOMUXC_IOMUXC_GPR0_SET(v)    (HW_IOMUXC_IOMUXC_GPR0_WR(HW_IOMUXC_IOMUXC_GPR0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR0_CLR(v)    (HW_IOMUXC_IOMUXC_GPR0_WR(HW_IOMUXC_IOMUXC_GPR0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR0_TOG(v)    (HW_IOMUXC_IOMUXC_GPR0_WR(HW_IOMUXC_IOMUXC_GPR0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR0, field GPR[31:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR0_GPR      (0)
#define BM_IOMUXC_IOMUXC_GPR0_GPR      (0xffffffff)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR0_GPR(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR0_GPR)
#else
#define BF_IOMUXC_IOMUXC_GPR0_GPR(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR0_GPR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR field to a new value.
#define BW_IOMUXC_IOMUXC_GPR0_GPR(v)   BF_CS1(IOMUXC_IOMUXC_GPR0, GPR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR1 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR : 32; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
    } B;
} hw_iomuxc_iomuxc_gpr1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR1 register
 */
#define HW_IOMUXC_IOMUXC_GPR1_ADDR      (REGS_IOMUXC_BASE + 0x4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR1           (*(volatile hw_iomuxc_iomuxc_gpr1_t *) HW_IOMUXC_IOMUXC_GPR1_ADDR)
#define HW_IOMUXC_IOMUXC_GPR1_RD()      (HW_IOMUXC_IOMUXC_GPR1.U)
#define HW_IOMUXC_IOMUXC_GPR1_WR(v)     (HW_IOMUXC_IOMUXC_GPR1.U = (v))
#define HW_IOMUXC_IOMUXC_GPR1_SET(v)    (HW_IOMUXC_IOMUXC_GPR1_WR(HW_IOMUXC_IOMUXC_GPR1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR1_CLR(v)    (HW_IOMUXC_IOMUXC_GPR1_WR(HW_IOMUXC_IOMUXC_GPR1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR1_TOG(v)    (HW_IOMUXC_IOMUXC_GPR1_WR(HW_IOMUXC_IOMUXC_GPR1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR1, field GPR[31:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR1_GPR      (0)
#define BM_IOMUXC_IOMUXC_GPR1_GPR      (0xffffffff)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR1_GPR(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR1_GPR)
#else
#define BF_IOMUXC_IOMUXC_GPR1_GPR(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR1_GPR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR field to a new value.
#define BW_IOMUXC_IOMUXC_GPR1_GPR(v)   BF_CS1(IOMUXC_IOMUXC_GPR1, GPR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR2 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR : 32; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
    } B;
} hw_iomuxc_iomuxc_gpr2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR2 register
 */
#define HW_IOMUXC_IOMUXC_GPR2_ADDR      (REGS_IOMUXC_BASE + 0x8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR2           (*(volatile hw_iomuxc_iomuxc_gpr2_t *) HW_IOMUXC_IOMUXC_GPR2_ADDR)
#define HW_IOMUXC_IOMUXC_GPR2_RD()      (HW_IOMUXC_IOMUXC_GPR2.U)
#define HW_IOMUXC_IOMUXC_GPR2_WR(v)     (HW_IOMUXC_IOMUXC_GPR2.U = (v))
#define HW_IOMUXC_IOMUXC_GPR2_SET(v)    (HW_IOMUXC_IOMUXC_GPR2_WR(HW_IOMUXC_IOMUXC_GPR2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR2_CLR(v)    (HW_IOMUXC_IOMUXC_GPR2_WR(HW_IOMUXC_IOMUXC_GPR2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR2_TOG(v)    (HW_IOMUXC_IOMUXC_GPR2_WR(HW_IOMUXC_IOMUXC_GPR2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR2, field GPR[31:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR2_GPR      (0)
#define BM_IOMUXC_IOMUXC_GPR2_GPR      (0xffffffff)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR2_GPR(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR2_GPR)
#else
#define BF_IOMUXC_IOMUXC_GPR2_GPR(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR2_GPR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR field to a new value.
#define BW_IOMUXC_IOMUXC_GPR2_GPR(v)   BF_CS1(IOMUXC_IOMUXC_GPR2, GPR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR3 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR_4 : 4; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
        unsigned GPR_3 : 4; //!< General Purpose bits to be used by SoC integration. Bit Type: R
        unsigned GPR_2 : 9; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
        unsigned GPR_1 : 4; //!< General Purpose bits to be used by SoC integration. Bit Type: R
        unsigned GPR_0 : 11; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
    } B;
} hw_iomuxc_iomuxc_gpr3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR3 register
 */
#define HW_IOMUXC_IOMUXC_GPR3_ADDR      (REGS_IOMUXC_BASE + 0xc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR3           (*(volatile hw_iomuxc_iomuxc_gpr3_t *) HW_IOMUXC_IOMUXC_GPR3_ADDR)
#define HW_IOMUXC_IOMUXC_GPR3_RD()      (HW_IOMUXC_IOMUXC_GPR3.U)
#define HW_IOMUXC_IOMUXC_GPR3_WR(v)     (HW_IOMUXC_IOMUXC_GPR3.U = (v))
#define HW_IOMUXC_IOMUXC_GPR3_SET(v)    (HW_IOMUXC_IOMUXC_GPR3_WR(HW_IOMUXC_IOMUXC_GPR3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR3_CLR(v)    (HW_IOMUXC_IOMUXC_GPR3_WR(HW_IOMUXC_IOMUXC_GPR3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR3_TOG(v)    (HW_IOMUXC_IOMUXC_GPR3_WR(HW_IOMUXC_IOMUXC_GPR3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR3, field GPR_4[3:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR3_GPR_4      (0)
#define BM_IOMUXC_IOMUXC_GPR3_GPR_4      (0x0000000f)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR3_GPR_4(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR3_GPR_4)
#else
#define BF_IOMUXC_IOMUXC_GPR3_GPR_4(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR3_GPR_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR_4 field to a new value.
#define BW_IOMUXC_IOMUXC_GPR3_GPR_4(v)   BF_CS1(IOMUXC_IOMUXC_GPR3, GPR_4, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_GPR3, field GPR_3[7:4] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: R
 */

#define BP_IOMUXC_IOMUXC_GPR3_GPR_3      (4)
#define BM_IOMUXC_IOMUXC_GPR3_GPR_3      (0x000000f0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR3_GPR_3(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_GPR3_GPR_3)
#else
#define BF_IOMUXC_IOMUXC_GPR3_GPR_3(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_GPR3_GPR_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR_3 field to a new value.
#define BW_IOMUXC_IOMUXC_GPR3_GPR_3(v)   BF_CS1(IOMUXC_IOMUXC_GPR3, GPR_3, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_GPR3, field GPR_2[16:8] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR3_GPR_2      (8)
#define BM_IOMUXC_IOMUXC_GPR3_GPR_2      (0x0001ff00)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR3_GPR_2(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_GPR3_GPR_2)
#else
#define BF_IOMUXC_IOMUXC_GPR3_GPR_2(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_GPR3_GPR_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR_2 field to a new value.
#define BW_IOMUXC_IOMUXC_GPR3_GPR_2(v)   BF_CS1(IOMUXC_IOMUXC_GPR3, GPR_2, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_GPR3, field GPR_1[20:17] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: R
 */

#define BP_IOMUXC_IOMUXC_GPR3_GPR_1      (17)
#define BM_IOMUXC_IOMUXC_GPR3_GPR_1      (0x001e0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR3_GPR_1(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_GPR3_GPR_1)
#else
#define BF_IOMUXC_IOMUXC_GPR3_GPR_1(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_GPR3_GPR_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR_1 field to a new value.
#define BW_IOMUXC_IOMUXC_GPR3_GPR_1(v)   BF_CS1(IOMUXC_IOMUXC_GPR3, GPR_1, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_GPR3, field GPR_0[31:21] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR3_GPR_0      (21)
#define BM_IOMUXC_IOMUXC_GPR3_GPR_0      (0xffe00000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR3_GPR_0(v)   ((((reg32_t) v) << 21) & BM_IOMUXC_IOMUXC_GPR3_GPR_0)
#else
#define BF_IOMUXC_IOMUXC_GPR3_GPR_0(v)   (((v) << 21) & BM_IOMUXC_IOMUXC_GPR3_GPR_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR_0 field to a new value.
#define BW_IOMUXC_IOMUXC_GPR3_GPR_0(v)   BF_CS1(IOMUXC_IOMUXC_GPR3, GPR_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR4 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR_3 : 7; //!< General Purpose bits to be used by SoC integration.
        unsigned GPR_2 : 1; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
        unsigned GPR_1 : 16; //!< General Purpose bits to be used by SoC integration. Bit Type: R
        unsigned GPR_0 : 8; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
    } B;
} hw_iomuxc_iomuxc_gpr4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR4 register
 */
#define HW_IOMUXC_IOMUXC_GPR4_ADDR      (REGS_IOMUXC_BASE + 0x10)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR4           (*(volatile hw_iomuxc_iomuxc_gpr4_t *) HW_IOMUXC_IOMUXC_GPR4_ADDR)
#define HW_IOMUXC_IOMUXC_GPR4_RD()      (HW_IOMUXC_IOMUXC_GPR4.U)
#define HW_IOMUXC_IOMUXC_GPR4_WR(v)     (HW_IOMUXC_IOMUXC_GPR4.U = (v))
#define HW_IOMUXC_IOMUXC_GPR4_SET(v)    (HW_IOMUXC_IOMUXC_GPR4_WR(HW_IOMUXC_IOMUXC_GPR4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR4_CLR(v)    (HW_IOMUXC_IOMUXC_GPR4_WR(HW_IOMUXC_IOMUXC_GPR4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR4_TOG(v)    (HW_IOMUXC_IOMUXC_GPR4_WR(HW_IOMUXC_IOMUXC_GPR4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR4, field GPR_3[6:0] (RW)
 *
 * General Purpose bits to be used by SoC integration.
 */

#define BP_IOMUXC_IOMUXC_GPR4_GPR_3      (0)
#define BM_IOMUXC_IOMUXC_GPR4_GPR_3      (0x0000007f)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR4_GPR_3(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR4_GPR_3)
#else
#define BF_IOMUXC_IOMUXC_GPR4_GPR_3(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR4_GPR_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR_3 field to a new value.
#define BW_IOMUXC_IOMUXC_GPR4_GPR_3(v)   BF_CS1(IOMUXC_IOMUXC_GPR4, GPR_3, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_GPR4, field GPR_2[7:7] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR4_GPR_2      (7)
#define BM_IOMUXC_IOMUXC_GPR4_GPR_2      (0x00000080)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR4_GPR_2(v)   ((((reg32_t) v) << 7) & BM_IOMUXC_IOMUXC_GPR4_GPR_2)
#else
#define BF_IOMUXC_IOMUXC_GPR4_GPR_2(v)   (((v) << 7) & BM_IOMUXC_IOMUXC_GPR4_GPR_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR_2 field to a new value.
#define BW_IOMUXC_IOMUXC_GPR4_GPR_2(v)   BF_CS1(IOMUXC_IOMUXC_GPR4, GPR_2, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_GPR4, field GPR_1[23:8] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: R
 */

#define BP_IOMUXC_IOMUXC_GPR4_GPR_1      (8)
#define BM_IOMUXC_IOMUXC_GPR4_GPR_1      (0x00ffff00)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR4_GPR_1(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_GPR4_GPR_1)
#else
#define BF_IOMUXC_IOMUXC_GPR4_GPR_1(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_GPR4_GPR_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR_1 field to a new value.
#define BW_IOMUXC_IOMUXC_GPR4_GPR_1(v)   BF_CS1(IOMUXC_IOMUXC_GPR4, GPR_1, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_GPR4, field GPR_0[31:24] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR4_GPR_0      (24)
#define BM_IOMUXC_IOMUXC_GPR4_GPR_0      (0xff000000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR4_GPR_0(v)   ((((reg32_t) v) << 24) & BM_IOMUXC_IOMUXC_GPR4_GPR_0)
#else
#define BF_IOMUXC_IOMUXC_GPR4_GPR_0(v)   (((v) << 24) & BM_IOMUXC_IOMUXC_GPR4_GPR_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR_0 field to a new value.
#define BW_IOMUXC_IOMUXC_GPR4_GPR_0(v)   BF_CS1(IOMUXC_IOMUXC_GPR4, GPR_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR5 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR_1 : 9; //!< General Purpose bits to be used by SoC integration. Bit Type: R
        unsigned GPR_0 : 23; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
    } B;
} hw_iomuxc_iomuxc_gpr5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR5 register
 */
#define HW_IOMUXC_IOMUXC_GPR5_ADDR      (REGS_IOMUXC_BASE + 0x14)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR5           (*(volatile hw_iomuxc_iomuxc_gpr5_t *) HW_IOMUXC_IOMUXC_GPR5_ADDR)
#define HW_IOMUXC_IOMUXC_GPR5_RD()      (HW_IOMUXC_IOMUXC_GPR5.U)
#define HW_IOMUXC_IOMUXC_GPR5_WR(v)     (HW_IOMUXC_IOMUXC_GPR5.U = (v))
#define HW_IOMUXC_IOMUXC_GPR5_SET(v)    (HW_IOMUXC_IOMUXC_GPR5_WR(HW_IOMUXC_IOMUXC_GPR5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR5_CLR(v)    (HW_IOMUXC_IOMUXC_GPR5_WR(HW_IOMUXC_IOMUXC_GPR5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR5_TOG(v)    (HW_IOMUXC_IOMUXC_GPR5_WR(HW_IOMUXC_IOMUXC_GPR5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR5, field GPR_1[8:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: R
 */

#define BP_IOMUXC_IOMUXC_GPR5_GPR_1      (0)
#define BM_IOMUXC_IOMUXC_GPR5_GPR_1      (0x000001ff)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR5_GPR_1(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR5_GPR_1)
#else
#define BF_IOMUXC_IOMUXC_GPR5_GPR_1(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR5_GPR_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR_1 field to a new value.
#define BW_IOMUXC_IOMUXC_GPR5_GPR_1(v)   BF_CS1(IOMUXC_IOMUXC_GPR5, GPR_1, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_GPR5, field GPR_0[31:9] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR5_GPR_0      (9)
#define BM_IOMUXC_IOMUXC_GPR5_GPR_0      (0xfffffe00)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR5_GPR_0(v)   ((((reg32_t) v) << 9) & BM_IOMUXC_IOMUXC_GPR5_GPR_0)
#else
#define BF_IOMUXC_IOMUXC_GPR5_GPR_0(v)   (((v) << 9) & BM_IOMUXC_IOMUXC_GPR5_GPR_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR_0 field to a new value.
#define BW_IOMUXC_IOMUXC_GPR5_GPR_0(v)   BF_CS1(IOMUXC_IOMUXC_GPR5, GPR_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR6 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR : 32; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
    } B;
} hw_iomuxc_iomuxc_gpr6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR6 register
 */
#define HW_IOMUXC_IOMUXC_GPR6_ADDR      (REGS_IOMUXC_BASE + 0x18)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR6           (*(volatile hw_iomuxc_iomuxc_gpr6_t *) HW_IOMUXC_IOMUXC_GPR6_ADDR)
#define HW_IOMUXC_IOMUXC_GPR6_RD()      (HW_IOMUXC_IOMUXC_GPR6.U)
#define HW_IOMUXC_IOMUXC_GPR6_WR(v)     (HW_IOMUXC_IOMUXC_GPR6.U = (v))
#define HW_IOMUXC_IOMUXC_GPR6_SET(v)    (HW_IOMUXC_IOMUXC_GPR6_WR(HW_IOMUXC_IOMUXC_GPR6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR6_CLR(v)    (HW_IOMUXC_IOMUXC_GPR6_WR(HW_IOMUXC_IOMUXC_GPR6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR6_TOG(v)    (HW_IOMUXC_IOMUXC_GPR6_WR(HW_IOMUXC_IOMUXC_GPR6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR6, field GPR[31:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR6_GPR      (0)
#define BM_IOMUXC_IOMUXC_GPR6_GPR      (0xffffffff)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR6_GPR(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR6_GPR)
#else
#define BF_IOMUXC_IOMUXC_GPR6_GPR(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR6_GPR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR field to a new value.
#define BW_IOMUXC_IOMUXC_GPR6_GPR(v)   BF_CS1(IOMUXC_IOMUXC_GPR6, GPR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR7 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR : 32; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
    } B;
} hw_iomuxc_iomuxc_gpr7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR7 register
 */
#define HW_IOMUXC_IOMUXC_GPR7_ADDR      (REGS_IOMUXC_BASE + 0x1c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR7           (*(volatile hw_iomuxc_iomuxc_gpr7_t *) HW_IOMUXC_IOMUXC_GPR7_ADDR)
#define HW_IOMUXC_IOMUXC_GPR7_RD()      (HW_IOMUXC_IOMUXC_GPR7.U)
#define HW_IOMUXC_IOMUXC_GPR7_WR(v)     (HW_IOMUXC_IOMUXC_GPR7.U = (v))
#define HW_IOMUXC_IOMUXC_GPR7_SET(v)    (HW_IOMUXC_IOMUXC_GPR7_WR(HW_IOMUXC_IOMUXC_GPR7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR7_CLR(v)    (HW_IOMUXC_IOMUXC_GPR7_WR(HW_IOMUXC_IOMUXC_GPR7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR7_TOG(v)    (HW_IOMUXC_IOMUXC_GPR7_WR(HW_IOMUXC_IOMUXC_GPR7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR7, field GPR[31:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR7_GPR      (0)
#define BM_IOMUXC_IOMUXC_GPR7_GPR      (0xffffffff)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR7_GPR(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR7_GPR)
#else
#define BF_IOMUXC_IOMUXC_GPR7_GPR(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR7_GPR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR field to a new value.
#define BW_IOMUXC_IOMUXC_GPR7_GPR(v)   BF_CS1(IOMUXC_IOMUXC_GPR7, GPR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR8 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR : 32; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
    } B;
} hw_iomuxc_iomuxc_gpr8_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR8 register
 */
#define HW_IOMUXC_IOMUXC_GPR8_ADDR      (REGS_IOMUXC_BASE + 0x20)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR8           (*(volatile hw_iomuxc_iomuxc_gpr8_t *) HW_IOMUXC_IOMUXC_GPR8_ADDR)
#define HW_IOMUXC_IOMUXC_GPR8_RD()      (HW_IOMUXC_IOMUXC_GPR8.U)
#define HW_IOMUXC_IOMUXC_GPR8_WR(v)     (HW_IOMUXC_IOMUXC_GPR8.U = (v))
#define HW_IOMUXC_IOMUXC_GPR8_SET(v)    (HW_IOMUXC_IOMUXC_GPR8_WR(HW_IOMUXC_IOMUXC_GPR8_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR8_CLR(v)    (HW_IOMUXC_IOMUXC_GPR8_WR(HW_IOMUXC_IOMUXC_GPR8_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR8_TOG(v)    (HW_IOMUXC_IOMUXC_GPR8_WR(HW_IOMUXC_IOMUXC_GPR8_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR8 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR8, field GPR[31:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR8_GPR      (0)
#define BM_IOMUXC_IOMUXC_GPR8_GPR      (0xffffffff)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR8_GPR(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR8_GPR)
#else
#define BF_IOMUXC_IOMUXC_GPR8_GPR(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR8_GPR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR field to a new value.
#define BW_IOMUXC_IOMUXC_GPR8_GPR(v)   BF_CS1(IOMUXC_IOMUXC_GPR8, GPR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR9 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR : 32; //!< General Purpose bits to be used by SoC integration. Bit Type: STICKY
    } B;
} hw_iomuxc_iomuxc_gpr9_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR9 register
 */
#define HW_IOMUXC_IOMUXC_GPR9_ADDR      (REGS_IOMUXC_BASE + 0x24)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR9           (*(volatile hw_iomuxc_iomuxc_gpr9_t *) HW_IOMUXC_IOMUXC_GPR9_ADDR)
#define HW_IOMUXC_IOMUXC_GPR9_RD()      (HW_IOMUXC_IOMUXC_GPR9.U)
#define HW_IOMUXC_IOMUXC_GPR9_WR(v)     (HW_IOMUXC_IOMUXC_GPR9.U = (v))
#define HW_IOMUXC_IOMUXC_GPR9_SET(v)    (HW_IOMUXC_IOMUXC_GPR9_WR(HW_IOMUXC_IOMUXC_GPR9_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR9_CLR(v)    (HW_IOMUXC_IOMUXC_GPR9_WR(HW_IOMUXC_IOMUXC_GPR9_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR9_TOG(v)    (HW_IOMUXC_IOMUXC_GPR9_WR(HW_IOMUXC_IOMUXC_GPR9_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR9 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR9, field GPR[31:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: STICKY
 */

#define BP_IOMUXC_IOMUXC_GPR9_GPR      (0)
#define BM_IOMUXC_IOMUXC_GPR9_GPR      (0xffffffff)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR9_GPR(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR9_GPR)
#else
#define BF_IOMUXC_IOMUXC_GPR9_GPR(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR9_GPR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR field to a new value.
#define BW_IOMUXC_IOMUXC_GPR9_GPR(v)   BF_CS1(IOMUXC_IOMUXC_GPR9, GPR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR10 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR : 32; //!< General Purpose bits to be used by SoC integration. Bit Type: LOCK
    } B;
} hw_iomuxc_iomuxc_gpr10_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR10 register
 */
#define HW_IOMUXC_IOMUXC_GPR10_ADDR      (REGS_IOMUXC_BASE + 0x28)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR10           (*(volatile hw_iomuxc_iomuxc_gpr10_t *) HW_IOMUXC_IOMUXC_GPR10_ADDR)
#define HW_IOMUXC_IOMUXC_GPR10_RD()      (HW_IOMUXC_IOMUXC_GPR10.U)
#define HW_IOMUXC_IOMUXC_GPR10_WR(v)     (HW_IOMUXC_IOMUXC_GPR10.U = (v))
#define HW_IOMUXC_IOMUXC_GPR10_SET(v)    (HW_IOMUXC_IOMUXC_GPR10_WR(HW_IOMUXC_IOMUXC_GPR10_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR10_CLR(v)    (HW_IOMUXC_IOMUXC_GPR10_WR(HW_IOMUXC_IOMUXC_GPR10_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR10_TOG(v)    (HW_IOMUXC_IOMUXC_GPR10_WR(HW_IOMUXC_IOMUXC_GPR10_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR10 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR10, field GPR[31:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: LOCK
 */

#define BP_IOMUXC_IOMUXC_GPR10_GPR      (0)
#define BM_IOMUXC_IOMUXC_GPR10_GPR      (0xffffffff)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR10_GPR(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR10_GPR)
#else
#define BF_IOMUXC_IOMUXC_GPR10_GPR(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR10_GPR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR field to a new value.
#define BW_IOMUXC_IOMUXC_GPR10_GPR(v)   BF_CS1(IOMUXC_IOMUXC_GPR10, GPR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR11 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR : 32; //!< General Purpose bits to be used by SoC integration. Bit Type: LOCK
    } B;
} hw_iomuxc_iomuxc_gpr11_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR11 register
 */
#define HW_IOMUXC_IOMUXC_GPR11_ADDR      (REGS_IOMUXC_BASE + 0x2c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR11           (*(volatile hw_iomuxc_iomuxc_gpr11_t *) HW_IOMUXC_IOMUXC_GPR11_ADDR)
#define HW_IOMUXC_IOMUXC_GPR11_RD()      (HW_IOMUXC_IOMUXC_GPR11.U)
#define HW_IOMUXC_IOMUXC_GPR11_WR(v)     (HW_IOMUXC_IOMUXC_GPR11.U = (v))
#define HW_IOMUXC_IOMUXC_GPR11_SET(v)    (HW_IOMUXC_IOMUXC_GPR11_WR(HW_IOMUXC_IOMUXC_GPR11_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR11_CLR(v)    (HW_IOMUXC_IOMUXC_GPR11_WR(HW_IOMUXC_IOMUXC_GPR11_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR11_TOG(v)    (HW_IOMUXC_IOMUXC_GPR11_WR(HW_IOMUXC_IOMUXC_GPR11_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR11 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR11, field GPR[31:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: LOCK
 */

#define BP_IOMUXC_IOMUXC_GPR11_GPR      (0)
#define BM_IOMUXC_IOMUXC_GPR11_GPR      (0xffffffff)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR11_GPR(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR11_GPR)
#else
#define BF_IOMUXC_IOMUXC_GPR11_GPR(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR11_GPR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR field to a new value.
#define BW_IOMUXC_IOMUXC_GPR11_GPR(v)   BF_CS1(IOMUXC_IOMUXC_GPR11, GPR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR12 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR : 32; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
    } B;
} hw_iomuxc_iomuxc_gpr12_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR12 register
 */
#define HW_IOMUXC_IOMUXC_GPR12_ADDR      (REGS_IOMUXC_BASE + 0x30)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR12           (*(volatile hw_iomuxc_iomuxc_gpr12_t *) HW_IOMUXC_IOMUXC_GPR12_ADDR)
#define HW_IOMUXC_IOMUXC_GPR12_RD()      (HW_IOMUXC_IOMUXC_GPR12.U)
#define HW_IOMUXC_IOMUXC_GPR12_WR(v)     (HW_IOMUXC_IOMUXC_GPR12.U = (v))
#define HW_IOMUXC_IOMUXC_GPR12_SET(v)    (HW_IOMUXC_IOMUXC_GPR12_WR(HW_IOMUXC_IOMUXC_GPR12_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR12_CLR(v)    (HW_IOMUXC_IOMUXC_GPR12_WR(HW_IOMUXC_IOMUXC_GPR12_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR12_TOG(v)    (HW_IOMUXC_IOMUXC_GPR12_WR(HW_IOMUXC_IOMUXC_GPR12_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR12 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR12, field GPR[31:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR12_GPR      (0)
#define BM_IOMUXC_IOMUXC_GPR12_GPR      (0xffffffff)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR12_GPR(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR12_GPR)
#else
#define BF_IOMUXC_IOMUXC_GPR12_GPR(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR12_GPR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR field to a new value.
#define BW_IOMUXC_IOMUXC_GPR12_GPR(v)   BF_CS1(IOMUXC_IOMUXC_GPR12, GPR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPR13 - GPR (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned GPR : 32; //!< General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
    } B;
} hw_iomuxc_iomuxc_gpr13_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPR13 register
 */
#define HW_IOMUXC_IOMUXC_GPR13_ADDR      (REGS_IOMUXC_BASE + 0x34)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPR13           (*(volatile hw_iomuxc_iomuxc_gpr13_t *) HW_IOMUXC_IOMUXC_GPR13_ADDR)
#define HW_IOMUXC_IOMUXC_GPR13_RD()      (HW_IOMUXC_IOMUXC_GPR13.U)
#define HW_IOMUXC_IOMUXC_GPR13_WR(v)     (HW_IOMUXC_IOMUXC_GPR13.U = (v))
#define HW_IOMUXC_IOMUXC_GPR13_SET(v)    (HW_IOMUXC_IOMUXC_GPR13_WR(HW_IOMUXC_IOMUXC_GPR13_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPR13_CLR(v)    (HW_IOMUXC_IOMUXC_GPR13_WR(HW_IOMUXC_IOMUXC_GPR13_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPR13_TOG(v)    (HW_IOMUXC_IOMUXC_GPR13_WR(HW_IOMUXC_IOMUXC_GPR13_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPR13 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPR13, field GPR[31:0] (RW)
 *
 * General Purpose bits to be used by SoC integration. Bit Type: DEFAULT
 */

#define BP_IOMUXC_IOMUXC_GPR13_GPR      (0)
#define BM_IOMUXC_IOMUXC_GPR13_GPR      (0xffffffff)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPR13_GPR(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPR13_GPR)
#else
#define BF_IOMUXC_IOMUXC_GPR13_GPR(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPR13_GPR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the GPR field to a new value.
#define BW_IOMUXC_IOMUXC_GPR13_GPR(v)   BF_CS1(IOMUXC_IOMUXC_GPR13, GPR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_OBSERVE_MUX_0 - OBSRV (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned OBSRV : 6; //!< 101100 Select Instance sdma, Pin events[3] 101101 Select Instance sdma, Pin events[2] 101110 Select Instance sdma, Pin events[1] 101111 Select Instance sdma, Pin events[0]
        unsigned RESERVED0 : 26; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_observe_mux_0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_OBSERVE_MUX_0 register
 */
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_ADDR      (REGS_IOMUXC_BASE + 0x38)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_0           (*(volatile hw_iomuxc_iomuxc_observe_mux_0_t *) HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_ADDR)
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_RD()      (HW_IOMUXC_IOMUXC_OBSERVE_MUX_0.U)
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_WR(v)     (HW_IOMUXC_IOMUXC_OBSERVE_MUX_0.U = (v))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_SET(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_CLR(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_TOG(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_OBSERVE_MUX_0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_OBSERVE_MUX_0, field OBSRV[5:0] (RW)
 *
 * 101100 Select Instance sdma, Pin events[3] 101101 Select Instance sdma, Pin events[2] 101110
 * Select Instance sdma, Pin events[1] 101111 Select Instance sdma, Pin events[0]
 */

#define BP_IOMUXC_IOMUXC_OBSERVE_MUX_0_OBSRV      (0)
#define BM_IOMUXC_IOMUXC_OBSERVE_MUX_0_OBSRV      (0x0000003f)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_OBSERVE_MUX_0_OBSRV(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_OBSERVE_MUX_0_OBSRV)
#else
#define BF_IOMUXC_IOMUXC_OBSERVE_MUX_0_OBSRV(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_OBSERVE_MUX_0_OBSRV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OBSRV field to a new value.
#define BW_IOMUXC_IOMUXC_OBSERVE_MUX_0_OBSRV(v)   BF_CS1(IOMUXC_IOMUXC_OBSERVE_MUX_0, OBSRV, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_OBSERVE_MUX_1 - OBSRV (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned OBSRV : 6; //!< Select Instance Pin for Observability IOMUXC_OBSERVE_MUX_1 000000 Select Instance kitten, Pin ipi_cortexa9_irqs[127] 000001 Select Instance kitten, Pin ipi_cortexa9_irqs[126] 000010 Select Instance kitten, Pin ipi_cortexa9_irqs[125] 000011 Select Instance kitten, Pin ipi_cortexa9_irqs[124] 000100 Select Instance kitten, Pin ipi_cortexa9_irqs[123] 000101 Select Instance kitten, Pin ipi_cortexa9_irqs[122] 000110 Select Instance kitten, Pin ipi_cortexa9_irqs[121] 000111 Select Instance kitten, Pin ipi_cortexa9_irqs[120] 001000 Select Instance kitten, Pin ipi_cortexa9_irqs[119] 001001 Select Instance kitten, Pin ipi_cortexa9_irqs[118] 001010 Select Instance kitten, Pin ipi_cortexa9_irqs[117] 001011 Select Instance kitten, Pin ipi_cortexa9_irqs[116] 001100 Select Instance kitten, Pin ipi_cortexa9_irqs[115] 001101 Select Instance kitten, Pin ipi_cortexa9_irqs[114] 001110 Select Instance kitten, Pin ipi_cortexa9_irqs[113] 001111 Select Instance kitten, Pin ipi_cortexa9_irqs[112] 010000 Select Instance kitten, Pin ipi_cortexa9_irqs[111] 010001 Select Instance kitten, Pin ipi_cortexa9_irqs[110] 010010 Select Instance kitten, Pin ipi_cortexa9_irqs[109] 010011 Select Instance kitten, Pin ipi_cortexa9_irqs[108] 010100 Select Instance kitten, Pin ipi_cortexa9_irqs[107] 010101 Select Instance kitten, Pin ipi_cortexa9_irqs[106] 010110 Select Instance kitten, Pin ipi_cortexa9_irqs[105] 010111 Select Instance kitten, Pin ipi_cortexa9_irqs[104] 011000 Select Instance kitten, Pin ipi_cortexa9_irqs[103] 011001 Select Instance kitten, Pin ipi_cortexa9_irqs[102] 011010 Select Instance kitten, Pin ipi_cortexa9_irqs[101] 011011 Select Instance kitten, Pin ipi_cortexa9_irqs[100] 011100 Select Instance kitten, Pin ipi_cortexa9_irqs[99] 011101 Select Instance kitten, Pin ipi_cortexa9_irqs[98] 011110 Select Instance kitten, Pin ipi_cortexa9_irqs[97] 011111 Select Instance kitten, Pin ipi_cortexa9_irqs[96] 100000 Select Instance kitten, Pin ipi_cortexa9_irqs[95] 100001 Select Instance kitten, Pin ipi_cortexa9_irqs[94] 100010 Select Instance kitten, Pin ipi_cortexa9_irqs[93] 100011 Select Instance kitten, Pin ipi_cortexa9_irqs[92] 100100 Select Instance kitten, Pin ipi_cortexa9_irqs[91] 100101 Select Instance kitten, Pin ipi_cortexa9_irqs[90] 100110 Select Instance kitten, Pin ipi_cortexa9_irqs[89] 100111 Select Instance kitten, Pin ipi_cortexa9_irqs[88] 101000 Select Instance kitten, Pin ipi_cortexa9_irqs[87]
        unsigned RESERVED0 : 26; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_observe_mux_1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_OBSERVE_MUX_1 register
 */
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_ADDR      (REGS_IOMUXC_BASE + 0x3c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_1           (*(volatile hw_iomuxc_iomuxc_observe_mux_1_t *) HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_ADDR)
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_RD()      (HW_IOMUXC_IOMUXC_OBSERVE_MUX_1.U)
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_WR(v)     (HW_IOMUXC_IOMUXC_OBSERVE_MUX_1.U = (v))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_SET(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_CLR(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_TOG(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_OBSERVE_MUX_1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_OBSERVE_MUX_1, field OBSRV[5:0] (RW)
 *
 * Select Instance Pin for Observability IOMUXC_OBSERVE_MUX_1 000000 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[127] 000001 Select Instance kitten, Pin ipi_cortexa9_irqs[126] 000010 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[125] 000011 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[124] 000100 Select Instance kitten, Pin ipi_cortexa9_irqs[123] 000101 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[122] 000110 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[121] 000111 Select Instance kitten, Pin ipi_cortexa9_irqs[120] 001000 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[119] 001001 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[118] 001010 Select Instance kitten, Pin ipi_cortexa9_irqs[117] 001011 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[116] 001100 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[115] 001101 Select Instance kitten, Pin ipi_cortexa9_irqs[114] 001110 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[113] 001111 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[112] 010000 Select Instance kitten, Pin ipi_cortexa9_irqs[111] 010001 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[110] 010010 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[109] 010011 Select Instance kitten, Pin ipi_cortexa9_irqs[108] 010100 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[107] 010101 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[106] 010110 Select Instance kitten, Pin ipi_cortexa9_irqs[105] 010111 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[104] 011000 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[103] 011001 Select Instance kitten, Pin ipi_cortexa9_irqs[102] 011010 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[101] 011011 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[100] 011100 Select Instance kitten, Pin ipi_cortexa9_irqs[99] 011101 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[98] 011110 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[97] 011111 Select Instance kitten, Pin ipi_cortexa9_irqs[96] 100000 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[95] 100001 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[94] 100010 Select Instance kitten, Pin ipi_cortexa9_irqs[93] 100011 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[92] 100100 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[91] 100101 Select Instance kitten, Pin ipi_cortexa9_irqs[90] 100110 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[89] 100111 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[88] 101000 Select Instance kitten, Pin ipi_cortexa9_irqs[87]
 */

#define BP_IOMUXC_IOMUXC_OBSERVE_MUX_1_OBSRV      (0)
#define BM_IOMUXC_IOMUXC_OBSERVE_MUX_1_OBSRV      (0x0000003f)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_OBSERVE_MUX_1_OBSRV(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_OBSERVE_MUX_1_OBSRV)
#else
#define BF_IOMUXC_IOMUXC_OBSERVE_MUX_1_OBSRV(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_OBSERVE_MUX_1_OBSRV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OBSRV field to a new value.
#define BW_IOMUXC_IOMUXC_OBSERVE_MUX_1_OBSRV(v)   BF_CS1(IOMUXC_IOMUXC_OBSERVE_MUX_1, OBSRV, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_OBSERVE_MUX_2 - OBSRV (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned OBSRV : 6; //!< Select Instance Pin for Observability IOMUXC_OBSERVE_MUX_2 000000 Select Instance kitten, Pin ipi_cortexa9_irqs[86] 000001 Select Instance kitten, Pin ipi_cortexa9_irqs[85] 000010 Select Instance kitten, Pin ipi_cortexa9_irqs[84] 000011 Select Instance kitten, Pin ipi_cortexa9_irqs[83] 000100 Select Instance kitten, Pin ipi_cortexa9_irqs[82] 000101 Select Instance kitten, Pin ipi_cortexa9_irqs[81] 000110 Select Instance kitten, Pin ipi_cortexa9_irqs[80] 000111 Select Instance kitten, Pin ipi_cortexa9_irqs[79] 001000 Select Instance kitten, Pin ipi_cortexa9_irqs[78] 001001 Select Instance kitten, Pin ipi_cortexa9_irqs[77] 001010 Select Instance kitten, Pin ipi_cortexa9_irqs[76] 001011 Select Instance kitten, Pin ipi_cortexa9_irqs[75] 001100 Select Instance kitten, Pin ipi_cortexa9_irqs[74] 001101 Select Instance kitten, Pin ipi_cortexa9_irqs[73] 001110 Select Instance kitten, Pin ipi_cortexa9_irqs[72] 001111 Select Instance kitten, Pin ipi_cortexa9_irqs[71] 010000 Select Instance kitten, Pin ipi_cortexa9_irqs[70] 010001 Select Instance kitten, Pin ipi_cortexa9_irqs[69] 010010 Select Instance kitten, Pin ipi_cortexa9_irqs[68] 010011 Select Instance kitten, Pin ipi_cortexa9_irqs[67] 010100 Select Instance kitten, Pin ipi_cortexa9_irqs[66] 010101 Select Instance kitten, Pin ipi_cortexa9_irqs[65] 010110 Select Instance kitten, Pin ipi_cortexa9_irqs[64] 010111 Select Instance kitten, Pin ipi_cortexa9_irqs[63] 011000 Select Instance kitten, Pin ipi_cortexa9_irqs[62] 011001 Select Instance kitten, Pin ipi_cortexa9_irqs[61] 011010 Select Instance kitten, Pin ipi_cortexa9_irqs[60] 011011 Select Instance kitten, Pin ipi_cortexa9_irqs[59] 011100 Select Instance kitten, Pin ipi_cortexa9_irqs[58] 011101 Select Instance kitten, Pin ipi_cortexa9_irqs[57] 011110 Select Instance kitten, Pin ipi_cortexa9_irqs[56] 011111 Select Instance kitten, Pin ipi_cortexa9_irqs[55] 100000 Select Instance kitten, Pin ipi_cortexa9_irqs[54] 100001 Select Instance kitten, Pin ipi_cortexa9_irqs[53] 100010 Select Instance kitten, Pin ipi_cortexa9_irqs[52] 100011 Select Instance kitten, Pin ipi_cortexa9_irqs[51] 100100 Select Instance kitten, Pin ipi_cortexa9_irqs[50] 100101 Select Instance kitten, Pin ipi_cortexa9_irqs[49] 100110 Select Instance kitten, Pin ipi_cortexa9_irqs[48]
        unsigned RESERVED0 : 26; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_observe_mux_2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_OBSERVE_MUX_2 register
 */
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_ADDR      (REGS_IOMUXC_BASE + 0x40)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_2           (*(volatile hw_iomuxc_iomuxc_observe_mux_2_t *) HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_ADDR)
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_RD()      (HW_IOMUXC_IOMUXC_OBSERVE_MUX_2.U)
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_WR(v)     (HW_IOMUXC_IOMUXC_OBSERVE_MUX_2.U = (v))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_SET(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_CLR(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_TOG(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_OBSERVE_MUX_2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_OBSERVE_MUX_2, field OBSRV[5:0] (RW)
 *
 * Select Instance Pin for Observability IOMUXC_OBSERVE_MUX_2 000000 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[86] 000001 Select Instance kitten, Pin ipi_cortexa9_irqs[85] 000010 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[84] 000011 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[83] 000100 Select Instance kitten, Pin ipi_cortexa9_irqs[82] 000101 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[81] 000110 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[80] 000111 Select Instance kitten, Pin ipi_cortexa9_irqs[79] 001000 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[78] 001001 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[77] 001010 Select Instance kitten, Pin ipi_cortexa9_irqs[76] 001011 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[75] 001100 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[74] 001101 Select Instance kitten, Pin ipi_cortexa9_irqs[73] 001110 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[72] 001111 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[71] 010000 Select Instance kitten, Pin ipi_cortexa9_irqs[70] 010001 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[69] 010010 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[68] 010011 Select Instance kitten, Pin ipi_cortexa9_irqs[67] 010100 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[66] 010101 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[65] 010110 Select Instance kitten, Pin ipi_cortexa9_irqs[64] 010111 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[63] 011000 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[62] 011001 Select Instance kitten, Pin ipi_cortexa9_irqs[61] 011010 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[60] 011011 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[59] 011100 Select Instance kitten, Pin ipi_cortexa9_irqs[58] 011101 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[57] 011110 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[56] 011111 Select Instance kitten, Pin ipi_cortexa9_irqs[55] 100000 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[54] 100001 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[53] 100010 Select Instance kitten, Pin ipi_cortexa9_irqs[52] 100011 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[51] 100100 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[50] 100101 Select Instance kitten, Pin ipi_cortexa9_irqs[49] 100110 Select
 * Instance kitten, Pin ipi_cortexa9_irqs[48]
 */

#define BP_IOMUXC_IOMUXC_OBSERVE_MUX_2_OBSRV      (0)
#define BM_IOMUXC_IOMUXC_OBSERVE_MUX_2_OBSRV      (0x0000003f)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_OBSERVE_MUX_2_OBSRV(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_OBSERVE_MUX_2_OBSRV)
#else
#define BF_IOMUXC_IOMUXC_OBSERVE_MUX_2_OBSRV(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_OBSERVE_MUX_2_OBSRV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OBSRV field to a new value.
#define BW_IOMUXC_IOMUXC_OBSERVE_MUX_2_OBSRV(v)   BF_CS1(IOMUXC_IOMUXC_OBSERVE_MUX_2, OBSRV, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_OBSERVE_MUX_3 - OBSRV (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned OBSRV : 6; //!< 101100 Select Instance kitten, Pin ipi_cortexa9_irqs[3] 101101 Select Instance kitten, Pin ipi_cortexa9_irqs[2] 101110 Select Instance kitten, Pin ipi_cortexa9_irqs[1]
        unsigned RESERVED0 : 26; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_observe_mux_3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_OBSERVE_MUX_3 register
 */
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_ADDR      (REGS_IOMUXC_BASE + 0x44)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_3           (*(volatile hw_iomuxc_iomuxc_observe_mux_3_t *) HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_ADDR)
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_RD()      (HW_IOMUXC_IOMUXC_OBSERVE_MUX_3.U)
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_WR(v)     (HW_IOMUXC_IOMUXC_OBSERVE_MUX_3.U = (v))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_SET(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_CLR(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_TOG(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_OBSERVE_MUX_3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_OBSERVE_MUX_3, field OBSRV[5:0] (RW)
 *
 * 101100 Select Instance kitten, Pin ipi_cortexa9_irqs[3] 101101 Select Instance kitten, Pin
 * ipi_cortexa9_irqs[2] 101110 Select Instance kitten, Pin ipi_cortexa9_irqs[1]
 */

#define BP_IOMUXC_IOMUXC_OBSERVE_MUX_3_OBSRV      (0)
#define BM_IOMUXC_IOMUXC_OBSERVE_MUX_3_OBSRV      (0x0000003f)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_OBSERVE_MUX_3_OBSRV(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_OBSERVE_MUX_3_OBSRV)
#else
#define BF_IOMUXC_IOMUXC_OBSERVE_MUX_3_OBSRV(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_OBSERVE_MUX_3_OBSRV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OBSRV field to a new value.
#define BW_IOMUXC_IOMUXC_OBSERVE_MUX_3_OBSRV(v)   BF_CS1(IOMUXC_IOMUXC_OBSERVE_MUX_3, OBSRV, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_OBSERVE_MUX_4 - OBSRV (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned OBSRV : 5; //!< Select Instance Pin for Observability IOMUXC_OBSERVE_MUX_4 00000 Select Instance gpc, Pin gpc_dsm_wakup 00001 Select Instance anatop, Pin global_pll_lrf 00010 Select Instance ccm, Pin ccm_ipg_stop 00011 Select Instance ccm, Pin ccm_ipg_wait 00100 Select Instance ccm, Pin ccm_system_in_stop_mode 00101 Select Instance ccm, Pin ccm_system_in_wait_mode 00110 Select Instance ccm, Pin pll2_400m_pfd_dis_masked 00111 Select Instance ccm, Pin pll2_352m_pfd_dis_masked 01000 Select Instance ccm, Pin pll2_594m_pfd_dis_masked 01001 Select Instance ccm, Pin pll3_508m_pfd_dis_masked 01010 Select Instance ccm, Pin pll3_454m_pfd_dis_masked 01011 Select Instance ccm, Pin pll3_720m_pfd_dis_masked 01100 Select Instance ccm, Pin pll3_540m_pfd_dis_masked 01101 Select Instance ccm, Pin mmdc_ch1_clk_change_req 01110 Select Instance ccm, Pin mmdc_stop_req 01111 Select Instance ccm, Pin wb_per_en 10000 Select Instance ccm, Pin wb_core_en 10001 Select Instance kitten, Pin l2cc_idle 10010 Select Instance kitten, Pin scu_idle 10011 Select Instance kitten, Pin standbywfi 10100 Select Instance kitten, Pin l2cc_idle 10101 Select Instance kitten, Pin scu_idle 10110 Select Instance kitten, Pin standbywfi 10111 Select Instance kitten, Pin dbg_ack
        unsigned RESERVED0 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_observe_mux_4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_OBSERVE_MUX_4 register
 */
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_ADDR      (REGS_IOMUXC_BASE + 0x48)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_4           (*(volatile hw_iomuxc_iomuxc_observe_mux_4_t *) HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_ADDR)
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_RD()      (HW_IOMUXC_IOMUXC_OBSERVE_MUX_4.U)
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_WR(v)     (HW_IOMUXC_IOMUXC_OBSERVE_MUX_4.U = (v))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_SET(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_CLR(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_TOG(v)    (HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_WR(HW_IOMUXC_IOMUXC_OBSERVE_MUX_4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_OBSERVE_MUX_4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_OBSERVE_MUX_4, field OBSRV[4:0] (RW)
 *
 * Select Instance Pin for Observability IOMUXC_OBSERVE_MUX_4 00000 Select Instance gpc, Pin
 * gpc_dsm_wakup 00001 Select Instance anatop, Pin global_pll_lrf 00010 Select Instance ccm, Pin
 * ccm_ipg_stop 00011 Select Instance ccm, Pin ccm_ipg_wait 00100 Select Instance ccm, Pin
 * ccm_system_in_stop_mode 00101 Select Instance ccm, Pin ccm_system_in_wait_mode 00110 Select
 * Instance ccm, Pin pll2_400m_pfd_dis_masked 00111 Select Instance ccm, Pin
 * pll2_352m_pfd_dis_masked 01000 Select Instance ccm, Pin pll2_594m_pfd_dis_masked 01001 Select
 * Instance ccm, Pin pll3_508m_pfd_dis_masked 01010 Select Instance ccm, Pin
 * pll3_454m_pfd_dis_masked 01011 Select Instance ccm, Pin pll3_720m_pfd_dis_masked 01100 Select
 * Instance ccm, Pin pll3_540m_pfd_dis_masked 01101 Select Instance ccm, Pin mmdc_ch1_clk_change_req
 * 01110 Select Instance ccm, Pin mmdc_stop_req 01111 Select Instance ccm, Pin wb_per_en 10000
 * Select Instance ccm, Pin wb_core_en 10001 Select Instance kitten, Pin l2cc_idle 10010 Select
 * Instance kitten, Pin scu_idle 10011 Select Instance kitten, Pin standbywfi 10100 Select Instance
 * kitten, Pin l2cc_idle 10101 Select Instance kitten, Pin scu_idle 10110 Select Instance kitten,
 * Pin standbywfi 10111 Select Instance kitten, Pin dbg_ack
 */

#define BP_IOMUXC_IOMUXC_OBSERVE_MUX_4_OBSRV      (0)
#define BM_IOMUXC_IOMUXC_OBSERVE_MUX_4_OBSRV      (0x0000001f)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_OBSERVE_MUX_4_OBSRV(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_OBSERVE_MUX_4_OBSRV)
#else
#define BF_IOMUXC_IOMUXC_OBSERVE_MUX_4_OBSRV(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_OBSERVE_MUX_4_OBSRV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OBSRV field to a new value.
#define BW_IOMUXC_IOMUXC_OBSERVE_MUX_4_OBSRV(v)   BF_CS1(IOMUXC_IOMUXC_OBSERVE_MUX_4, OBSRV, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_MCLK. NOTE: Pad AUD_MCLK is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: AUDIO_CLK_OUT of instance: audmux. 001 Select mux mode: ALT1 mux port: PWMO of instance: pwm4. 010 Select mux mode: ALT2 mux port: RDY of instance: ecspi3. 011 Select mux mode: ALT3 mux port: MDC of instance: fec. 100 Select mux mode: ALT4 mux port: WDOG_RST_B_DEB of instance: wdog2. 101 Select mux mode: ALT5 mux port: GPIO[6] of instance: gpio1. 110 Select mux mode: ALT6 mux port: SPDIF_EXT_CLK of instance: spdif. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad AUD_MCLK. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_mclk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_ADDR      (REGS_IOMUXC_BASE + 0x4c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_mclk_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_MCLK. NOTE: Pad AUD_MCLK
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT for mode ALT6. 000 Select mux
 * mode: ALT0 mux port: AUDIO_CLK_OUT of instance: audmux. 001 Select mux mode: ALT1 mux port: PWMO
 * of instance: pwm4. 010 Select mux mode: ALT2 mux port: RDY of instance: ecspi3. 011 Select mux
 * mode: ALT3 mux port: MDC of instance: fec. 100 Select mux mode: ALT4 mux port: WDOG_RST_B_DEB of
 * instance: wdog2. 101 Select mux mode: ALT5 mux port: GPIO[6] of instance: gpio1. 110 Select mux
 * mode: ALT6 mux port: SPDIF_EXT_CLK of instance: spdif. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad AUD_MCLK. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_RXC. NOTE: Pad AUD_RXC is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: AUD3_RXC of instance: audmux. 001 Select mux mode: ALT1 mux port: SDA of instance: i2c1. 010 Select mux mode: ALT2 mux port: TXD_MUX of instance: uart3. 011 Select mux mode: ALT3 mux port: TX_CLK of instance: fec. 100 Select mux mode: ALT4 mux port: SDA of instance: i2c3. 101 Select mux mode: ALT5 mux port: GPIO[1] of instance: gpio1. 110 Select mux mode: ALT6 mux port: SS1 of instance: ecspi3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad AUD_RXC. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_rxc_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_ADDR      (REGS_IOMUXC_BASE + 0x50)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_rxc_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_RXC. NOTE: Pad AUD_RXC
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT for mode
 * ALT6. - Config Register IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * AUD3_RXC of instance: audmux. 001 Select mux mode: ALT1 mux port: SDA of instance: i2c1. 010
 * Select mux mode: ALT2 mux port: TXD_MUX of instance: uart3. 011 Select mux mode: ALT3 mux port:
 * TX_CLK of instance: fec. 100 Select mux mode: ALT4 mux port: SDA of instance: i2c3. 101 Select
 * mux mode: ALT5 mux port: GPIO[1] of instance: gpio1. 110 Select mux mode: ALT6 mux port: SS1 of
 * instance: ecspi3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad AUD_RXC. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXC, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_RXD. NOTE: Pad AUD_RXD is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: AUD3_RXD of instance: audmux. 001 Select mux mode: ALT1 mux port: MOSI of instance: ecspi3. 010 Select mux mode: ALT2 mux port: RXD_MUX of instance: uart4. 011 Select mux mode: ALT3 mux port: RX_ER of instance: fec. 100 Select mux mode: ALT4 mux port: LCTL of instance: usdhc1. 101 Select mux mode: ALT5 mux port: GPIO[2] of instance: gpio1. 110 Select mux mode: ALT6 mux port: INT_BOOT of instance: src. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad AUD_RXD. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_rxd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_ADDR      (REGS_IOMUXC_BASE + 0x54)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_rxd_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_RXD. NOTE: Pad AUD_RXD
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * AUD3_RXD of instance: audmux. 001 Select mux mode: ALT1 mux port: MOSI of instance: ecspi3. 010
 * Select mux mode: ALT2 mux port: RXD_MUX of instance: uart4. 011 Select mux mode: ALT3 mux port:
 * RX_ER of instance: fec. 100 Select mux mode: ALT4 mux port: LCTL of instance: usdhc1. 101 Select
 * mux mode: ALT5 mux port: GPIO[2] of instance: gpio1. 110 Select mux mode: ALT6 mux port: INT_BOOT
 * of instance: src. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad AUD_RXD. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXD, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_RXFS. NOTE: Pad AUD_RXFS is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_FEC_FEC_MDI_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT for mode ALT7. - Config Register IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: AUD3_RXFS of instance: audmux. 001 Select mux mode: ALT1 mux port: SCL of instance: i2c1. 010 Select mux mode: ALT2 mux port: RXD_MUX of instance: uart3. 011 Select mux mode: ALT3 mux port: MDIO of instance: fec. 100 Select mux mode: ALT4 mux port: SCL of instance: i2c3. 101 Select mux mode: ALT5 mux port: GPIO[0] of instance: gpio1. 110 Select mux mode: ALT6 mux port: SS0 of instance: ecspi3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad AUD_RXFS. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_rxfs_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_ADDR      (REGS_IOMUXC_BASE + 0x58)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_rxfs_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_RXFS. NOTE: Pad AUD_RXFS
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT for mode
 * ALT6. - Config Register IOMUXC_FEC_FEC_MDI_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT for mode ALT7. - Config Register
 * IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * AUD3_RXFS of instance: audmux. 001 Select mux mode: ALT1 mux port: SCL of instance: i2c1. 010
 * Select mux mode: ALT2 mux port: RXD_MUX of instance: uart3. 011 Select mux mode: ALT3 mux port:
 * MDIO of instance: fec. 100 Select mux mode: ALT4 mux port: SCL of instance: i2c3. 101 Select mux
 * mode: ALT5 mux port: GPIO[0] of instance: gpio1. 110 Select mux mode: ALT6 mux port: SS0 of
 * instance: ecspi3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad AUD_RXFS. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_TXC. NOTE: Pad AUD_TXC is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: AUD3_TXC of instance: audmux. 001 Select mux mode: ALT1 mux port: MISO of instance: ecspi3. 010 Select mux mode: ALT2 mux port: TXD_MUX of instance: uart4. 011 Select mux mode: ALT3 mux port: RX_DV of instance: fec. 100 Select mux mode: ALT4 mux port: LCTL of instance: usdhc2. 101 Select mux mode: ALT5 mux port: GPIO[3] of instance: gpio1. 110 Select mux mode: ALT6 mux port: SYSTEM_RST of instance: src. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad AUD_TXC. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_txc_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_ADDR      (REGS_IOMUXC_BASE + 0x5c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_txc_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_TXC. NOTE: Pad AUD_TXC
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * AUD3_TXC of instance: audmux. 001 Select mux mode: ALT1 mux port: MISO of instance: ecspi3. 010
 * Select mux mode: ALT2 mux port: TXD_MUX of instance: uart4. 011 Select mux mode: ALT3 mux port:
 * RX_DV of instance: fec. 100 Select mux mode: ALT4 mux port: LCTL of instance: usdhc2. 101 Select
 * mux mode: ALT5 mux port: GPIO[3] of instance: gpio1. 110 Select mux mode: ALT6 mux port:
 * SYSTEM_RST of instance: src. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad AUD_TXC. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXC, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_TXD. NOTE: Pad AUD_TXD is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: AUD3_TXD of instance: audmux. 001 Select mux mode: ALT1 mux port: SCLK of instance: ecspi3. 010 Select mux mode: ALT2 mux port: CTS of instance: uart4. 011 Select mux mode: ALT3 mux port: TDATA[0] of instance: fec. 100 Select mux mode: ALT4 mux port: LCTL of instance: usdhc4. 101 Select mux mode: ALT5 mux port: GPIO[5] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad AUD_TXD. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_txd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_ADDR      (REGS_IOMUXC_BASE + 0x60)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_txd_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_TXD. NOTE: Pad AUD_TXD
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. 000 Select mux
 * mode: ALT0 mux port: AUD3_TXD of instance: audmux. 001 Select mux mode: ALT1 mux port: SCLK of
 * instance: ecspi3. 010 Select mux mode: ALT2 mux port: CTS of instance: uart4. 011 Select mux
 * mode: ALT3 mux port: TDATA[0] of instance: fec. 100 Select mux mode: ALT4 mux port: LCTL of
 * instance: usdhc4. 101 Select mux mode: ALT5 mux port: GPIO[5] of instance: gpio1. 110 Reserved.
 * 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad AUD_TXD. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXD, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_TXFS. NOTE: Pad AUD_TXFS is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: AUD3_TXFS of instance: audmux. 001 Select mux mode: ALT1 mux port: PWMO of instance: pwm3. 010 Select mux mode: ALT2 mux port: RTS of instance: uart4. 011 Select mux mode: ALT3 mux port: RDATA[1] of instance: fec. 100 Select mux mode: ALT4 mux port: LCTL of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[4] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad AUD_TXFS. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_txfs_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_ADDR      (REGS_IOMUXC_BASE + 0x64)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_txfs_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: AUD_TXFS. NOTE: Pad AUD_TXFS
 * is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT for mode ALT3.
 * - Config Register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. 000 Select mux mode:
 * ALT0 mux port: AUD3_TXFS of instance: audmux. 001 Select mux mode: ALT1 mux port: PWMO of
 * instance: pwm3. 010 Select mux mode: ALT2 mux port: RTS of instance: uart4. 011 Select mux mode:
 * ALT3 mux port: RDATA[1] of instance: fec. 100 Select mux mode: ALT4 mux port: LCTL of instance:
 * usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[4] of instance: gpio1. 110 Reserved. 111
 * Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad AUD_TXFS. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI1_MISO. NOTE: Pad ECSPI1_MISO is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: MISO of instance: ecspi1. 001 Select mux mode: ALT1 mux port: AUD4_TXFS of instance: audmux. 010 Select mux mode: ALT2 mux port: RTS of instance: uart5. 011 Select mux mode: ALT3 mux port: BDR[0] of instance: epdc. 100 Select mux mode: ALT4 mux port: WP of instance: usdhc2. 101 Select mux mode: ALT5 mux port: GPIO[10] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad ECSPI1_MISO. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi1_miso_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_ADDR      (REGS_IOMUXC_BASE + 0x68)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi1_miso_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI1_MISO. NOTE: Pad
 * ECSPI1_MISO is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: MISO of
 * instance: ecspi1. 001 Select mux mode: ALT1 mux port: AUD4_TXFS of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: RTS of instance: uart5. 011 Select mux mode: ALT3 mux port: BDR[0] of
 * instance: epdc. 100 Select mux mode: ALT4 mux port: WP of instance: usdhc2. 101 Select mux mode:
 * ALT5 mux port: GPIO[10] of instance: gpio4. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad ECSPI1_MISO. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI1_MOSI. NOTE: Pad ECSPI1_MOSI is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: MOSI of instance: ecspi1. 001 Select mux mode: ALT1 mux port: AUD4_TXC of instance: audmux. 010 Select mux mode: ALT2 mux port: TXD_MUX of instance: uart5. 011 Select mux mode: ALT3 mux port: VCOM[1] of instance: epdc. 100 Select mux mode: ALT4 mux port: VSELECT of instance: usdhc2. 101 Select mux mode: ALT5 mux port: GPIO[9] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad ECSPI1_MOSI. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi1_mosi_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_ADDR      (REGS_IOMUXC_BASE + 0x6c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi1_mosi_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI1_MOSI. NOTE: Pad
 * ECSPI1_MOSI is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * MOSI of instance: ecspi1. 001 Select mux mode: ALT1 mux port: AUD4_TXC of instance: audmux. 010
 * Select mux mode: ALT2 mux port: TXD_MUX of instance: uart5. 011 Select mux mode: ALT3 mux port:
 * VCOM[1] of instance: epdc. 100 Select mux mode: ALT4 mux port: VSELECT of instance: usdhc2. 101
 * Select mux mode: ALT5 mux port: GPIO[9] of instance: gpio4. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad ECSPI1_MOSI. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI1_SCLK. NOTE: Pad ECSPI1_SCLK is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: SCLK of instance: ecspi1. 001 Select mux mode: ALT1 mux port: AUD4_TXD of instance: audmux. 010 Select mux mode: ALT2 mux port: RXD_MUX of instance: uart5. 011 Select mux mode: ALT3 mux port: VCOM[0] of instance: epdc. 100 Select mux mode: ALT4 mux port: RST of instance: usdhc2. 101 Select mux mode: ALT5 mux port: GPIO[8] of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG2_OC of instance: usb. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad ECSPI1_SCLK. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi1_sclk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_ADDR      (REGS_IOMUXC_BASE + 0x70)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi1_sclk_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI1_SCLK. NOTE: Pad
 * ECSPI1_SCLK is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: SCLK
 * of instance: ecspi1. 001 Select mux mode: ALT1 mux port: AUD4_TXD of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: RXD_MUX of instance: uart5. 011 Select mux mode: ALT3 mux port: VCOM[0]
 * of instance: epdc. 100 Select mux mode: ALT4 mux port: RST of instance: usdhc2. 101 Select mux
 * mode: ALT5 mux port: GPIO[8] of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG2_OC
 * of instance: usb. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad ECSPI1_SCLK. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI1_SS0. NOTE: Pad ECSPI1_SS0 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: SS0 of instance: ecspi1. 001 Select mux mode: ALT1 mux port: AUD4_RXD of instance: audmux. 010 Select mux mode: ALT2 mux port: CTS of instance: uart5. 011 Select mux mode: ALT3 mux port: BDR[1] of instance: epdc. 100 Select mux mode: ALT4 mux port: CD of instance: usdhc2. 101 Select mux mode: ALT5 mux port: GPIO[11] of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG2_PWR of instance: usb. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad ECSPI1_SS0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi1_ss0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_ADDR      (REGS_IOMUXC_BASE + 0x74)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi1_ss0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI1_SS0. NOTE: Pad
 * ECSPI1_SS0 is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: SS0 of
 * instance: ecspi1. 001 Select mux mode: ALT1 mux port: AUD4_RXD of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: CTS of instance: uart5. 011 Select mux mode: ALT3 mux port: BDR[1] of
 * instance: epdc. 100 Select mux mode: ALT4 mux port: CD of instance: usdhc2. 101 Select mux mode:
 * ALT5 mux port: GPIO[11] of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG2_PWR of
 * instance: usb. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad ECSPI1_SS0. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI2_MISO. NOTE: Pad ECSPI2_MISO is involved in Daisy Chain. - Config Register IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT for mode ALT4. 101 Select mux mode: ALT5 mux port: GPIO[14] of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG1_OC of instance: usb. 111 Reserved. 000 Select mux mode: ALT0 mux port: MISO of instance: ecspi2. 001 Select mux mode: ALT1 mux port: SDMA_EXT_EVENT[0] of instance: sdma. 010 Select mux mode: ALT2 mux port: RTS of instance: uart3. 011 Select mux mode: ALT3 mux port: MCLK of instance: csi. 100 Select mux mode: ALT4 mux port: WP of instance: usdhc1.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad ECSPI2_MISO. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi2_miso_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_ADDR      (REGS_IOMUXC_BASE + 0x78)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi2_miso_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI2_MISO. NOTE: Pad
 * ECSPI2_MISO is involved in Daisy Chain. - Config Register IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT
 * for mode ALT0. - Config Register IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config
 * Register IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT for mode ALT4. 101 Select mux mode: ALT5 mux port: GPIO[14]
 * of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG1_OC of instance: usb. 111
 * Reserved. 000 Select mux mode: ALT0 mux port: MISO of instance: ecspi2. 001 Select mux mode: ALT1
 * mux port: SDMA_EXT_EVENT[0] of instance: sdma. 010 Select mux mode: ALT2 mux port: RTS of
 * instance: uart3. 011 Select mux mode: ALT3 mux port: MCLK of instance: csi. 100 Select mux mode:
 * ALT4 mux port: WP of instance: usdhc1.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad ECSPI2_MISO. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI2_MOSI. NOTE: Pad ECSPI2_MOSI is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: MOSI of instance: ecspi2. 001 Select mux mode: ALT1 mux port: SDMA_EXT_EVENT[1] of instance: sdma. 010 Select mux mode: ALT2 mux port: TXD_MUX of instance: uart3. 011 Select mux mode: ALT3 mux port: HSYNC of instance: csi. 100 Select mux mode: ALT4 mux port: VSELECT of instance: usdhc1. 101 Select mux mode: ALT5 mux port: GPIO[13] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad ECSPI2_MOSI. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi2_mosi_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_ADDR      (REGS_IOMUXC_BASE + 0x7c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi2_mosi_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI2_MOSI. NOTE: Pad
 * ECSPI2_MOSI is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT
 * for mode ALT3. - Config Register IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT for mode ALT0. - Config
 * Register IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux
 * port: MOSI of instance: ecspi2. 001 Select mux mode: ALT1 mux port: SDMA_EXT_EVENT[1] of
 * instance: sdma. 010 Select mux mode: ALT2 mux port: TXD_MUX of instance: uart3. 011 Select mux
 * mode: ALT3 mux port: HSYNC of instance: csi. 100 Select mux mode: ALT4 mux port: VSELECT of
 * instance: usdhc1. 101 Select mux mode: ALT5 mux port: GPIO[13] of instance: gpio4. 110 Reserved.
 * 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad ECSPI2_MOSI. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI2_SCLK. NOTE: Pad ECSPI2_SCLK is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: SCLK of instance: ecspi2. 001 Select mux mode: ALT1 mux port: SPDIF_EXT_CLK of instance: spdif. 010 Select mux mode: ALT2 mux port: RXD_MUX of instance: uart3. 011 Select mux mode: ALT3 mux port: PIXCLK of instance: csi. 100 Select mux mode: ALT4 mux port: RST of instance: usdhc1. 101 Select mux mode: ALT5 mux port: GPIO[12] of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG2_OC of instance: usb. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad ECSPI2_SCLK. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi2_sclk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_ADDR      (REGS_IOMUXC_BASE + 0x80)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi2_sclk_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI2_SCLK. NOTE: Pad
 * ECSPI2_SCLK is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT
 * for mode ALT3. - Config Register IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT0. -
 * Config Register IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: SCLK
 * of instance: ecspi2. 001 Select mux mode: ALT1 mux port: SPDIF_EXT_CLK of instance: spdif. 010
 * Select mux mode: ALT2 mux port: RXD_MUX of instance: uart3. 011 Select mux mode: ALT3 mux port:
 * PIXCLK of instance: csi. 100 Select mux mode: ALT4 mux port: RST of instance: usdhc1. 101 Select
 * mux mode: ALT5 mux port: GPIO[12] of instance: gpio4. 110 Select mux mode: ALT6 mux port:
 * USBOTG2_OC of instance: usb. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad ECSPI2_SCLK. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI2_SS0. NOTE: Pad ECSPI2_SS0 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: SS0 of instance: ecspi2. 001 Select mux mode: ALT1 mux port: SS3 of instance: ecspi1. 010 Select mux mode: ALT2 mux port: CTS of instance: uart3. 011 Select mux mode: ALT3 mux port: VSYNC of instance: csi. 100 Select mux mode: ALT4 mux port: CD of instance: usdhc1. 101 Select mux mode: ALT5 mux port: GPIO[15] of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG1_PWR of instance: usb. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad ECSPI2_SS0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi2_ss0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_ADDR      (REGS_IOMUXC_BASE + 0x84)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi2_ss0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: ECSPI2_SS0. NOTE: Pad
 * ECSPI2_SS0 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT
 * for mode ALT3. - Config Register IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT for mode ALT1. -
 * Config Register IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: SS0 of
 * instance: ecspi2. 001 Select mux mode: ALT1 mux port: SS3 of instance: ecspi1. 010 Select mux
 * mode: ALT2 mux port: CTS of instance: uart3. 011 Select mux mode: ALT3 mux port: VSYNC of
 * instance: csi. 100 Select mux mode: ALT4 mux port: CD of instance: usdhc1. 101 Select mux mode:
 * ALT5 mux port: GPIO[15] of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG1_PWR of
 * instance: usb. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad ECSPI2_SS0. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_BDR0. NOTE: Pad EPDC_BDR0 is involved in Daisy Chain. - Config Register IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: BDR[0] of instance: epdc. 001 Select mux mode: ALT1 mux port: CLK of instance: usdhc4. 010 Select mux mode: ALT2 mux port: RTS of instance: uart3. 011 Select mux mode: ALT3 mux port: WEIM_A[26] of instance: weim. 100 Select mux mode: ALT4 mux port: RL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[5] of instance: gpio2. 110 Select mux mode: ALT6 mux port: SDCE[7] of instance: epdc. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_BDR0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_bdr0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_ADDR      (REGS_IOMUXC_BASE + 0x88)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_bdr0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_BDR0. NOTE: Pad
 * EPDC_BDR0 is involved in Daisy Chain. - Config Register IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT
 * for mode ALT2. - Config Register IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT for mode ALT1. 000
 * Select mux mode: ALT0 mux port: BDR[0] of instance: epdc. 001 Select mux mode: ALT1 mux port: CLK
 * of instance: usdhc4. 010 Select mux mode: ALT2 mux port: RTS of instance: uart3. 011 Select mux
 * mode: ALT3 mux port: WEIM_A[26] of instance: weim. 100 Select mux mode: ALT4 mux port: RL of
 * instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[5] of instance: gpio2. 110 Select mux
 * mode: ALT6 mux port: SDCE[7] of instance: epdc. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_BDR0. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_BDR1. NOTE: Pad EPDC_BDR1 is involved in Daisy Chain. - Config Register IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: BDR[1] of instance: epdc. 001 Select mux mode: ALT1 mux port: CMD of instance: usdhc4. 010 Select mux mode: ALT2 mux port: CTS of instance: uart3. 011 Select mux mode: ALT3 mux port: WEIM_CRE of instance: weim. 100 Select mux mode: ALT4 mux port: UD of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[6] of instance: gpio2. 110 Select mux mode: ALT6 mux port: SDCE[8] of instance: epdc. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_BDR1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_bdr1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_ADDR      (REGS_IOMUXC_BASE + 0x8c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_bdr1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_BDR1. NOTE: Pad
 * EPDC_BDR1 is involved in Daisy Chain. - Config Register IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT
 * for mode ALT2. - Config Register IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT for mode ALT1. 000 Select
 * mux mode: ALT0 mux port: BDR[1] of instance: epdc. 001 Select mux mode: ALT1 mux port: CMD of
 * instance: usdhc4. 010 Select mux mode: ALT2 mux port: CTS of instance: uart3. 011 Select mux
 * mode: ALT3 mux port: WEIM_CRE of instance: weim. 100 Select mux mode: ALT4 mux port: UD of
 * instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[6] of instance: gpio2. 110 Select mux
 * mode: ALT6 mux port: SDCE[8] of instance: epdc. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_BDR1. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D0. NOTE: Pad EPDC_D0 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDDO[0] of instance: epdc. 001 Select mux mode: ALT1 mux port: MOSI of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[24] of instance: lcdif. 011 Select mux mode: ALT3 mux port: D[0] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[0] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[7] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_ADDR      (REGS_IOMUXC_BASE + 0x90)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D0. NOTE: Pad EPDC_D0
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT for mode ALT3.
 * - Config Register IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT for mode ALT1. 000 Select mux mode:
 * ALT0 mux port: SDDO[0] of instance: epdc. 001 Select mux mode: ALT1 mux port: MOSI of instance:
 * ecspi4. 010 Select mux mode: ALT2 mux port: DAT[24] of instance: lcdif. 011 Select mux mode: ALT3
 * mux port: D[0] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[0] of instance: tcon.
 * 101 Select mux mode: ALT5 mux port: GPIO[7] of instance: gpio1. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D0. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D1. NOTE: Pad EPDC_D1 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDDO[1] of instance: epdc. 001 Select mux mode: ALT1 mux port: MISO of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[25] of instance: lcdif. 011 Select mux mode: ALT3 mux port: D[1] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[1] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[8] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_ADDR      (REGS_IOMUXC_BASE + 0x94)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D1. NOTE: Pad EPDC_D1
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT for mode ALT3.
 * - Config Register IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT for mode ALT1. 000 Select mux mode:
 * ALT0 mux port: SDDO[1] of instance: epdc. 001 Select mux mode: ALT1 mux port: MISO of instance:
 * ecspi4. 010 Select mux mode: ALT2 mux port: DAT[25] of instance: lcdif. 011 Select mux mode: ALT3
 * mux port: D[1] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[1] of instance: tcon.
 * 101 Select mux mode: ALT5 mux port: GPIO[8] of instance: gpio1. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D1. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D10. NOTE: Pad EPDC_D10 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: SDDO[10] of instance: epdc. 001 Select mux mode: ALT1 mux port: SS0 of instance: ecspi3. 010 Select mux mode: ALT2 mux port: PWRCTRL[2] of instance: epdc. 011 Select mux mode: ALT3 mux port: WEIM_A[18] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[10] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[17] of instance: gpio1. 110 Select mux mode: ALT6 mux port: WP of instance: usdhc4. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D10. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d10_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_ADDR      (REGS_IOMUXC_BASE + 0x98)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d10_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D10. NOTE: Pad EPDC_D10
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT for mode ALT6. 000 Select mux mode:
 * ALT0 mux port: SDDO[10] of instance: epdc. 001 Select mux mode: ALT1 mux port: SS0 of instance:
 * ecspi3. 010 Select mux mode: ALT2 mux port: PWRCTRL[2] of instance: epdc. 011 Select mux mode:
 * ALT3 mux port: WEIM_A[18] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[10] of
 * instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[17] of instance: gpio1. 110 Select mux
 * mode: ALT6 mux port: WP of instance: usdhc4. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D10. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D10, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D11. NOTE: Pad EPDC_D11 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: SDDO[11] of instance: epdc. 001 Select mux mode: ALT1 mux port: SCLK of instance: ecspi3. 010 Select mux mode: ALT2 mux port: PWRCTRL[3] of instance: epdc. 011 Select mux mode: ALT3 mux port: WEIM_A[19] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[11] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[18] of instance: gpio1. 110 Select mux mode: ALT6 mux port: CD of instance: usdhc4. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D11. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d11_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_ADDR      (REGS_IOMUXC_BASE + 0x9c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d11_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D11. NOTE: Pad EPDC_D11
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT for mode ALT6. 000 Select mux
 * mode: ALT0 mux port: SDDO[11] of instance: epdc. 001 Select mux mode: ALT1 mux port: SCLK of
 * instance: ecspi3. 010 Select mux mode: ALT2 mux port: PWRCTRL[3] of instance: epdc. 011 Select
 * mux mode: ALT3 mux port: WEIM_A[19] of instance: weim. 100 Select mux mode: ALT4 mux port:
 * E_DATA[11] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[18] of instance: gpio1.
 * 110 Select mux mode: ALT6 mux port: CD of instance: usdhc4. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D11. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D11, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D12. NOTE: Pad EPDC_D12 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDDO[12] of instance: epdc. 001 Select mux mode: ALT1 mux port: RXD_MUX of instance: uart2. 010 Select mux mode: ALT2 mux port: PWRCOM of instance: epdc. 011 Select mux mode: ALT3 mux port: WEIM_A[20] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[12] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[19] of instance: gpio1. 110 Select mux mode: ALT6 mux port: SS1 of instance: ecspi3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D12. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d12_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_ADDR      (REGS_IOMUXC_BASE + 0xa0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d12_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D12. NOTE: Pad EPDC_D12
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT for mode
 * ALT6. - Config Register IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT1. 000 Select mux
 * mode: ALT0 mux port: SDDO[12] of instance: epdc. 001 Select mux mode: ALT1 mux port: RXD_MUX of
 * instance: uart2. 010 Select mux mode: ALT2 mux port: PWRCOM of instance: epdc. 011 Select mux
 * mode: ALT3 mux port: WEIM_A[20] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[12]
 * of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[19] of instance: gpio1. 110 Select
 * mux mode: ALT6 mux port: SS1 of instance: ecspi3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D12. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D12, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D13. NOTE: Pad EPDC_D13 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDDO[13] of instance: epdc. 001 Select mux mode: ALT1 mux port: TXD_MUX of instance: uart2. 010 Select mux mode: ALT2 mux port: PWRIRQ of instance: epdc. 011 Select mux mode: ALT3 mux port: WEIM_A[21] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[13] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[20] of instance: gpio1. 110 Select mux mode: ALT6 mux port: SS2 of instance: ecspi3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D13. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d13_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_ADDR      (REGS_IOMUXC_BASE + 0xa4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d13_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D13. NOTE: Pad EPDC_D13
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT for mode
 * ALT6. - Config Register IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port:
 * SDDO[13] of instance: epdc. 001 Select mux mode: ALT1 mux port: TXD_MUX of instance: uart2. 010
 * Select mux mode: ALT2 mux port: PWRIRQ of instance: epdc. 011 Select mux mode: ALT3 mux port:
 * WEIM_A[21] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[13] of instance: tcon.
 * 101 Select mux mode: ALT5 mux port: GPIO[20] of instance: gpio1. 110 Select mux mode: ALT6 mux
 * port: SS2 of instance: ecspi3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D13. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D13, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D14. NOTE: Pad EPDC_D14 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDDO[14] of instance: epdc. 001 Select mux mode: ALT1 mux port: RTS of instance: uart2. 010 Select mux mode: ALT2 mux port: PWRSTAT of instance: epdc. 011 Select mux mode: ALT3 mux port: WEIM_A[22] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[14] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[21] of instance: gpio1. 110 Select mux mode: ALT6 mux port: SS3 of instance: ecspi3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D14. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d14_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_ADDR      (REGS_IOMUXC_BASE + 0xa8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d14_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D14. NOTE: Pad EPDC_D14
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT for mode
 * ALT6. - Config Register IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT for mode ALT2. - Config
 * Register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux
 * port: SDDO[14] of instance: epdc. 001 Select mux mode: ALT1 mux port: RTS of instance: uart2. 010
 * Select mux mode: ALT2 mux port: PWRSTAT of instance: epdc. 011 Select mux mode: ALT3 mux port:
 * WEIM_A[22] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[14] of instance: tcon.
 * 101 Select mux mode: ALT5 mux port: GPIO[21] of instance: gpio1. 110 Select mux mode: ALT6 mux
 * port: SS3 of instance: ecspi3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D14. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D14, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D15. NOTE: Pad EPDC_D15 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDDO[15] of instance: epdc. 001 Select mux mode: ALT1 mux port: CTS of instance: uart2. 010 Select mux mode: ALT2 mux port: PWRWAKE of instance: epdc. 011 Select mux mode: ALT3 mux port: WEIM_A[23] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[15] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[22] of instance: gpio1. 110 Select mux mode: ALT6 mux port: RDY of instance: ecspi3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D15. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d15_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_ADDR      (REGS_IOMUXC_BASE + 0xac)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d15_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D15. NOTE: Pad EPDC_D15
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT for
 * mode ALT6. - Config Register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT for mode ALT1. 000 Select
 * mux mode: ALT0 mux port: SDDO[15] of instance: epdc. 001 Select mux mode: ALT1 mux port: CTS of
 * instance: uart2. 010 Select mux mode: ALT2 mux port: PWRWAKE of instance: epdc. 011 Select mux
 * mode: ALT3 mux port: WEIM_A[23] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[15]
 * of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[22] of instance: gpio1. 110 Select
 * mux mode: ALT6 mux port: RDY of instance: ecspi3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D15. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D15, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D2. NOTE: Pad EPDC_D2 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDDO[2] of instance: epdc. 001 Select mux mode: ALT1 mux port: SS0 of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[26] of instance: lcdif. 011 Select mux mode: ALT3 mux port: D[2] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[2] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[9] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D2. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_ADDR      (REGS_IOMUXC_BASE + 0xb0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d2_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D2. NOTE: Pad EPDC_D2
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT for mode ALT3.
 * - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT1. 000 Select mux mode:
 * ALT0 mux port: SDDO[2] of instance: epdc. 001 Select mux mode: ALT1 mux port: SS0 of instance:
 * ecspi4. 010 Select mux mode: ALT2 mux port: DAT[26] of instance: lcdif. 011 Select mux mode: ALT3
 * mux port: D[2] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[2] of instance: tcon.
 * 101 Select mux mode: ALT5 mux port: GPIO[9] of instance: gpio1. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D2. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D2, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D3. NOTE: Pad EPDC_D3 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDDO[3] of instance: epdc. 001 Select mux mode: ALT1 mux port: SCLK of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[27] of instance: lcdif. 011 Select mux mode: ALT3 mux port: D[3] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[3] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[10] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D3. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_ADDR      (REGS_IOMUXC_BASE + 0xb4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d3_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D3. NOTE: Pad EPDC_D3
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT for mode ALT3.
 * - Config Register IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode:
 * ALT0 mux port: SDDO[3] of instance: epdc. 001 Select mux mode: ALT1 mux port: SCLK of instance:
 * ecspi4. 010 Select mux mode: ALT2 mux port: DAT[27] of instance: lcdif. 011 Select mux mode: ALT3
 * mux port: D[3] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[3] of instance: tcon.
 * 101 Select mux mode: ALT5 mux port: GPIO[10] of instance: gpio1. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D3. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D3, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D4. NOTE: Pad EPDC_D4 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDDO[4] of instance: epdc. 001 Select mux mode: ALT1 mux port: SS1 of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[28] of instance: lcdif. 011 Select mux mode: ALT3 mux port: D[4] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[4] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[11] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D4. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_ADDR      (REGS_IOMUXC_BASE + 0xb8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d4_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D4. NOTE: Pad EPDC_D4
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT for mode ALT3.
 * - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT1. 000 Select mux mode:
 * ALT0 mux port: SDDO[4] of instance: epdc. 001 Select mux mode: ALT1 mux port: SS1 of instance:
 * ecspi4. 010 Select mux mode: ALT2 mux port: DAT[28] of instance: lcdif. 011 Select mux mode: ALT3
 * mux port: D[4] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[4] of instance: tcon.
 * 101 Select mux mode: ALT5 mux port: GPIO[11] of instance: gpio1. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D4. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D4, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D5. NOTE: Pad EPDC_D5 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDDO[5] of instance: epdc. 001 Select mux mode: ALT1 mux port: SS2 of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[29] of instance: lcdif. 011 Select mux mode: ALT3 mux port: D[5] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[5] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[12] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D5. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_ADDR      (REGS_IOMUXC_BASE + 0xbc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d5_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D5. NOTE: Pad EPDC_D5
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT for mode ALT3.
 * - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT for mode ALT1. 000 Select mux mode:
 * ALT0 mux port: SDDO[5] of instance: epdc. 001 Select mux mode: ALT1 mux port: SS2 of instance:
 * ecspi4. 010 Select mux mode: ALT2 mux port: DAT[29] of instance: lcdif. 011 Select mux mode: ALT3
 * mux port: D[5] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[5] of instance: tcon.
 * 101 Select mux mode: ALT5 mux port: GPIO[12] of instance: gpio1. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D5. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D5, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D6. NOTE: Pad EPDC_D6 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT for mode ALT3. 000 Select mux mode: ALT0 mux port: SDDO[6] of instance: epdc. 001 Select mux mode: ALT1 mux port: SS3 of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[30] of instance: lcdif. 011 Select mux mode: ALT3 mux port: D[6] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[6] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[13] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D6. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_ADDR      (REGS_IOMUXC_BASE + 0xc0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d6_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D6. NOTE: Pad EPDC_D6
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT for mode ALT3.
 * 000 Select mux mode: ALT0 mux port: SDDO[6] of instance: epdc. 001 Select mux mode: ALT1 mux
 * port: SS3 of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[30] of instance: lcdif.
 * 011 Select mux mode: ALT3 mux port: D[6] of instance: csi. 100 Select mux mode: ALT4 mux port:
 * E_DATA[6] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[13] of instance: gpio1. 110
 * Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D6. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D6, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D7. NOTE: Pad EPDC_D7 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT for mode ALT3. 000 Select mux mode: ALT0 mux port: SDDO[7] of instance: epdc. 001 Select mux mode: ALT1 mux port: RDY of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[31] of instance: lcdif. 011 Select mux mode: ALT3 mux port: D[7] of instance: csi. 100 Select mux mode: ALT4 mux port: E_DATA[7] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[14] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D7. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_ADDR      (REGS_IOMUXC_BASE + 0xc4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d7_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D7. NOTE: Pad EPDC_D7
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT for mode ALT3.
 * 000 Select mux mode: ALT0 mux port: SDDO[7] of instance: epdc. 001 Select mux mode: ALT1 mux
 * port: RDY of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[31] of instance: lcdif.
 * 011 Select mux mode: ALT3 mux port: D[7] of instance: csi. 100 Select mux mode: ALT4 mux port:
 * E_DATA[7] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[14] of instance: gpio1. 110
 * Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D7. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D7, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D8. NOTE: Pad EPDC_D8 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDDO[8] of instance: epdc. 001 Select mux mode: ALT1 mux port: MOSI of instance: ecspi3. 010 Select mux mode: ALT2 mux port: PWRCTRL[0] of instance: epdc. 011 Select mux mode: ALT3 mux port: WEIM_A[16] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[8] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[15] of instance: gpio1. 110 Select mux mode: ALT6 mux port: RST of instance: usdhc4. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D8. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d8_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_ADDR      (REGS_IOMUXC_BASE + 0xc8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d8_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D8. NOTE: Pad EPDC_D8
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT for mode
 * ALT1. 000 Select mux mode: ALT0 mux port: SDDO[8] of instance: epdc. 001 Select mux mode: ALT1
 * mux port: MOSI of instance: ecspi3. 010 Select mux mode: ALT2 mux port: PWRCTRL[0] of instance:
 * epdc. 011 Select mux mode: ALT3 mux port: WEIM_A[16] of instance: weim. 100 Select mux mode: ALT4
 * mux port: E_DATA[8] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[15] of instance:
 * gpio1. 110 Select mux mode: ALT6 mux port: RST of instance: usdhc4. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D8. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D8, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D9. NOTE: Pad EPDC_D9 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDDO[9] of instance: epdc. 001 Select mux mode: ALT1 mux port: MISO of instance: ecspi3. 010 Select mux mode: ALT2 mux port: PWRCTRL[1] of instance: epdc. 011 Select mux mode: ALT3 mux port: WEIM_A[17] of instance: weim. 100 Select mux mode: ALT4 mux port: E_DATA[9] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[16] of instance: gpio1. 110 Select mux mode: ALT6 mux port: VSELECT of instance: usdhc4. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_D9. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d9_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_ADDR      (REGS_IOMUXC_BASE + 0xcc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d9_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_D9. NOTE: Pad EPDC_D9
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT for mode
 * ALT1. 000 Select mux mode: ALT0 mux port: SDDO[9] of instance: epdc. 001 Select mux mode: ALT1
 * mux port: MISO of instance: ecspi3. 010 Select mux mode: ALT2 mux port: PWRCTRL[1] of instance:
 * epdc. 011 Select mux mode: ALT3 mux port: WEIM_A[17] of instance: weim. 100 Select mux mode: ALT4
 * mux port: E_DATA[9] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[16] of instance:
 * gpio1. 110 Select mux mode: ALT6 mux port: VSELECT of instance: usdhc4. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_D9. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_D9, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_GDCLK. NOTE: Pad EPDC_GDCLK is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT for mode ALT3. 000 Select mux mode: ALT0 mux port: GDCLK of instance: epdc. 001 Select mux mode: ALT1 mux port: SS2 of instance: ecspi2. 010 Select mux mode: ALT2 mux port: YCKR of instance: tcon. 011 Select mux mode: ALT3 mux port: PIXCLK of instance: csi. 100 Select mux mode: ALT4 mux port: YCKL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[31] of instance: gpio1. 110 Select mux mode: ALT6 mux port: RST of instance: usdhc2. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_GDCLK. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_gdclk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_ADDR      (REGS_IOMUXC_BASE + 0xd0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_gdclk_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_GDCLK. NOTE: Pad
 * EPDC_GDCLK is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT
 * for mode ALT3. 000 Select mux mode: ALT0 mux port: GDCLK of instance: epdc. 001 Select mux mode:
 * ALT1 mux port: SS2 of instance: ecspi2. 010 Select mux mode: ALT2 mux port: YCKR of instance:
 * tcon. 011 Select mux mode: ALT3 mux port: PIXCLK of instance: csi. 100 Select mux mode: ALT4 mux
 * port: YCKL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[31] of instance: gpio1.
 * 110 Select mux mode: ALT6 mux port: RST of instance: usdhc2. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_GDCLK. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_GDOE. NOTE: Pad EPDC_GDOE is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT for mode ALT3. 000 Select mux mode: ALT0 mux port: GDOE of instance: epdc. 001 Select mux mode: ALT1 mux port: SS3 of instance: ecspi2. 010 Select mux mode: ALT2 mux port: YOER of instance: tcon. 011 Select mux mode: ALT3 mux port: HSYNC of instance: csi. 100 Select mux mode: ALT4 mux port: YOEL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[0] of instance: gpio2. 110 Select mux mode: ALT6 mux port: VSELECT of instance: usdhc2. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_GDOE. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_gdoe_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_ADDR      (REGS_IOMUXC_BASE + 0xd4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_gdoe_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_GDOE. NOTE: Pad
 * EPDC_GDOE is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT for
 * mode ALT3. 000 Select mux mode: ALT0 mux port: GDOE of instance: epdc. 001 Select mux mode: ALT1
 * mux port: SS3 of instance: ecspi2. 010 Select mux mode: ALT2 mux port: YOER of instance: tcon.
 * 011 Select mux mode: ALT3 mux port: HSYNC of instance: csi. 100 Select mux mode: ALT4 mux port:
 * YOEL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[0] of instance: gpio2. 110
 * Select mux mode: ALT6 mux port: VSELECT of instance: usdhc2. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_GDOE. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_GDRL. NOTE: Pad EPDC_GDRL is involved in Daisy Chain. - Config Register IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: GDRL of instance: epdc. 001 Select mux mode: ALT1 mux port: RDY of instance: ecspi2. 010 Select mux mode: ALT2 mux port: YDIOUR of instance: tcon. 011 Select mux mode: ALT3 mux port: MCLK of instance: csi. 100 Select mux mode: ALT4 mux port: YDIOUL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[1] of instance: gpio2. 110 Select mux mode: ALT6 mux port: WP of instance: usdhc2. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_GDRL. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_gdrl_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_ADDR      (REGS_IOMUXC_BASE + 0xd8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_gdrl_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_GDRL. NOTE: Pad
 * EPDC_GDRL is involved in Daisy Chain. - Config Register IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT for
 * mode ALT6. 000 Select mux mode: ALT0 mux port: GDRL of instance: epdc. 001 Select mux mode: ALT1
 * mux port: RDY of instance: ecspi2. 010 Select mux mode: ALT2 mux port: YDIOUR of instance: tcon.
 * 011 Select mux mode: ALT3 mux port: MCLK of instance: csi. 100 Select mux mode: ALT4 mux port:
 * YDIOUL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[1] of instance: gpio2. 110
 * Select mux mode: ALT6 mux port: WP of instance: usdhc2. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_GDRL. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_GDSP. NOTE: Pad EPDC_GDSP is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: GDSP of instance: epdc. 001 Select mux mode: ALT1 mux port: PWMO of instance: pwm4. 010 Select mux mode: ALT2 mux port: YDIODR of instance: tcon. 011 Select mux mode: ALT3 mux port: VSYNC of instance: csi. 100 Select mux mode: ALT4 mux port: YDIODL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[2] of instance: gpio2. 110 Select mux mode: ALT6 mux port: CD of instance: usdhc2. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_GDSP. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_gdsp_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_ADDR      (REGS_IOMUXC_BASE + 0xdc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_gdsp_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_GDSP. NOTE: Pad
 * EPDC_GDSP is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT for
 * mode ALT3. - Config Register IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT for mode ALT6. 000 Select
 * mux mode: ALT0 mux port: GDSP of instance: epdc. 001 Select mux mode: ALT1 mux port: PWMO of
 * instance: pwm4. 010 Select mux mode: ALT2 mux port: YDIODR of instance: tcon. 011 Select mux
 * mode: ALT3 mux port: VSYNC of instance: csi. 100 Select mux mode: ALT4 mux port: YDIODL of
 * instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[2] of instance: gpio2. 110 Select mux
 * mode: ALT6 mux port: CD of instance: usdhc2. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_GDSP. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRCOM. NOTE: Pad EPDC_PWRCOM is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: PWRCOM of instance: epdc. 001 Select mux mode: ALT1 mux port: DAT0 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: DAT[20] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_BCLK of instance: weim. 100 Select mux mode: ALT4 mux port: USBOTG1_ID of instance: anatop. 101 Select mux mode: ALT5 mux port: GPIO[11] of instance: gpio2. 110 Select mux mode: ALT6 mux port: RST of instance: usdhc3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_PWRCOM. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrcom_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_ADDR      (REGS_IOMUXC_BASE + 0xe0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrcom_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRCOM. NOTE: Pad
 * EPDC_PWRCOM is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT
 * for mode ALT4. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT for mode ALT2. -
 * Config Register IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0
 * mux port: PWRCOM of instance: epdc. 001 Select mux mode: ALT1 mux port: DAT0 of instance: usdhc4.
 * 010 Select mux mode: ALT2 mux port: DAT[20] of instance: lcdif. 011 Select mux mode: ALT3 mux
 * port: WEIM_BCLK of instance: weim. 100 Select mux mode: ALT4 mux port: USBOTG1_ID of instance:
 * anatop. 101 Select mux mode: ALT5 mux port: GPIO[11] of instance: gpio2. 110 Select mux mode:
 * ALT6 mux port: RST of instance: usdhc3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_PWRCOM. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRCTRL0. NOTE: Pad EPDC_PWRCTRL0 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: PWRCTRL[0] of instance: epdc. 001 Select mux mode: ALT1 mux port: AUD5_RXC of instance: audmux. 010 Select mux mode: ALT2 mux port: DAT[16] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_RW of instance: weim. 100 Select mux mode: ALT4 mux port: YCKL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[7] of instance: gpio2. 110 Select mux mode: ALT6 mux port: RST of instance: usdhc4. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_PWRCTRL0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_ADDR      (REGS_IOMUXC_BASE + 0xe4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRCTRL0. NOTE: Pad
 * EPDC_PWRCTRL0 is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * PWRCTRL[0] of instance: epdc. 001 Select mux mode: ALT1 mux port: AUD5_RXC of instance: audmux.
 * 010 Select mux mode: ALT2 mux port: DAT[16] of instance: lcdif. 011 Select mux mode: ALT3 mux
 * port: WEIM_RW of instance: weim. 100 Select mux mode: ALT4 mux port: YCKL of instance: tcon. 101
 * Select mux mode: ALT5 mux port: GPIO[7] of instance: gpio2. 110 Select mux mode: ALT6 mux port:
 * RST of instance: usdhc4. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_PWRCTRL0. 0 Input Path is determined by
 * functionality of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRCTRL1. NOTE: Pad EPDC_PWRCTRL1 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: PWRCTRL[1] of instance: epdc. 001 Select mux mode: ALT1 mux port: AUD5_TXFS of instance: audmux. 010 Select mux mode: ALT2 mux port: DAT[17] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_OE of instance: weim. 100 Select mux mode: ALT4 mux port: YOEL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[8] of instance: gpio2. 110 Select mux mode: ALT6 mux port: VSELECT of instance: usdhc4. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_PWRCTRL1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_ADDR      (REGS_IOMUXC_BASE + 0xe8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRCTRL1. NOTE: Pad
 * EPDC_PWRCTRL1 is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * PWRCTRL[1] of instance: epdc. 001 Select mux mode: ALT1 mux port: AUD5_TXFS of instance: audmux.
 * 010 Select mux mode: ALT2 mux port: DAT[17] of instance: lcdif. 011 Select mux mode: ALT3 mux
 * port: WEIM_OE of instance: weim. 100 Select mux mode: ALT4 mux port: YOEL of instance: tcon. 101
 * Select mux mode: ALT5 mux port: GPIO[8] of instance: gpio2. 110 Select mux mode: ALT6 mux port:
 * VSELECT of instance: usdhc4. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_PWRCTRL1. 0 Input Path is determined by
 * functionality of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRCTRL2. NOTE: Pad EPDC_PWRCTRL2 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: PWRCTRL[2] of instance: epdc. 001 Select mux mode: ALT1 mux port: AUD5_TXD of instance: audmux. 010 Select mux mode: ALT2 mux port: DAT[18] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_CS[0] of instance: weim. 100 Select mux mode: ALT4 mux port: YDIOUL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[9] of instance: gpio2. 110 Select mux mode: ALT6 mux port: WP of instance: usdhc4. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_PWRCTRL2. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_ADDR      (REGS_IOMUXC_BASE + 0xec)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl2_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRCTRL2. NOTE: Pad
 * EPDC_PWRCTRL2 is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port:
 * PWRCTRL[2] of instance: epdc. 001 Select mux mode: ALT1 mux port: AUD5_TXD of instance: audmux.
 * 010 Select mux mode: ALT2 mux port: DAT[18] of instance: lcdif. 011 Select mux mode: ALT3 mux
 * port: WEIM_CS[0] of instance: weim. 100 Select mux mode: ALT4 mux port: YDIOUL of instance: tcon.
 * 101 Select mux mode: ALT5 mux port: GPIO[9] of instance: gpio2. 110 Select mux mode: ALT6 mux
 * port: WP of instance: usdhc4. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_PWRCTRL2. 0 Input Path is determined by
 * functionality of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRCTRL3. NOTE: Pad EPDC_PWRCTRL3 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: PWRCTRL[3] of instance: epdc. 001 Select mux mode: ALT1 mux port: AUD5_TXC of instance: audmux. 010 Select mux mode: ALT2 mux port: DAT[19] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_CS[1] of instance: weim. 100 Select mux mode: ALT4 mux port: YDIODL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[10] of instance: gpio2. 110 Select mux mode: ALT6 mux port: CD of instance: usdhc4. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_PWRCTRL3. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_ADDR      (REGS_IOMUXC_BASE + 0xf0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl3_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRCTRL3. NOTE: Pad
 * EPDC_PWRCTRL3 is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port:
 * PWRCTRL[3] of instance: epdc. 001 Select mux mode: ALT1 mux port: AUD5_TXC of instance: audmux.
 * 010 Select mux mode: ALT2 mux port: DAT[19] of instance: lcdif. 011 Select mux mode: ALT3 mux
 * port: WEIM_CS[1] of instance: weim. 100 Select mux mode: ALT4 mux port: YDIODL of instance: tcon.
 * 101 Select mux mode: ALT5 mux port: GPIO[10] of instance: gpio2. 110 Select mux mode: ALT6 mux
 * port: CD of instance: usdhc4. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_PWRCTRL3. 0 Input Path is determined by
 * functionality of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRINT. NOTE: Pad EPDC_PWRINT is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: PWRIRQ of instance: epdc. 001 Select mux mode: ALT1 mux port: DAT1 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: DAT[21] of instance: lcdif. 011 Select mux mode: ALT3 mux port: ACLK_FREERUN of instance: weim. 100 Select mux mode: ALT4 mux port: USBOTG2_ID of instance: anatop. 101 Select mux mode: ALT5 mux port: GPIO[12] of instance: gpio2. 110 Select mux mode: ALT6 mux port: VSELECT of instance: usdhc3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_PWRINT. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrint_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_ADDR      (REGS_IOMUXC_BASE + 0xf4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrint_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRINT. NOTE: Pad
 * EPDC_PWRINT is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT
 * for mode ALT4. - Config Register IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT for mode ALT0. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: PWRIRQ
 * of instance: epdc. 001 Select mux mode: ALT1 mux port: DAT1 of instance: usdhc4. 010 Select mux
 * mode: ALT2 mux port: DAT[21] of instance: lcdif. 011 Select mux mode: ALT3 mux port: ACLK_FREERUN
 * of instance: weim. 100 Select mux mode: ALT4 mux port: USBOTG2_ID of instance: anatop. 101 Select
 * mux mode: ALT5 mux port: GPIO[12] of instance: gpio2. 110 Select mux mode: ALT6 mux port: VSELECT
 * of instance: usdhc3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_PWRINT. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRSTAT. NOTE: Pad EPDC_PWRSTAT is involved in Daisy Chain. - Config Register IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT for mode ALT3. 000 Select mux mode: ALT0 mux port: PWRSTAT of instance: epdc. 001 Select mux mode: ALT1 mux port: DAT2 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: DAT[22] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_WAIT of instance: weim. 100 Select mux mode: ALT4 mux port: EVENTI of instance: kitten. 101 Select mux mode: ALT5 mux port: GPIO[13] of instance: gpio2. 110 Select mux mode: ALT6 mux port: WP of instance: usdhc3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_PWRSTAT. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrstat_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_ADDR      (REGS_IOMUXC_BASE + 0xf8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrstat_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRSTAT. NOTE: Pad
 * EPDC_PWRSTAT is involved in Daisy Chain. - Config Register
 * IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT for mode ALT3. 000 Select mux mode: ALT0 mux port:
 * PWRSTAT of instance: epdc. 001 Select mux mode: ALT1 mux port: DAT2 of instance: usdhc4. 010
 * Select mux mode: ALT2 mux port: DAT[22] of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_WAIT of instance: weim. 100 Select mux mode: ALT4 mux port: EVENTI of instance: kitten. 101
 * Select mux mode: ALT5 mux port: GPIO[13] of instance: gpio2. 110 Select mux mode: ALT6 mux port:
 * WP of instance: usdhc3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_PWRSTAT. 0 Input Path is determined by
 * functionality of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRWAKEUP. NOTE: Pad EPDC_PWRWAKEUP is involved in Daisy Chain. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT for mode ALT3. 000 Select mux mode: ALT0 mux port: PWRWAKE of instance: epdc. 001 Select mux mode: ALT1 mux port: DAT3 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: DAT[23] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DTACK_B of instance: weim. 100 Select mux mode: ALT4 mux port: EVENTO of instance: kitten. 101 Select mux mode: ALT5 mux port: GPIO[14] of instance: gpio2. 110 Select mux mode: ALT6 mux port: CD of instance: usdhc3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_PWRWAKEUP. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrwakeup_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_ADDR      (REGS_IOMUXC_BASE + 0xfc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrwakeup_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_PWRWAKEUP. NOTE: Pad
 * EPDC_PWRWAKEUP is involved in Daisy Chain. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT for mode ALT3. 000 Select mux mode: ALT0 mux port:
 * PWRWAKE of instance: epdc. 001 Select mux mode: ALT1 mux port: DAT3 of instance: usdhc4. 010
 * Select mux mode: ALT2 mux port: DAT[23] of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_DTACK_B of instance: weim. 100 Select mux mode: ALT4 mux port: EVENTO of instance: kitten.
 * 101 Select mux mode: ALT5 mux port: GPIO[14] of instance: gpio2. 110 Select mux mode: ALT6 mux
 * port: CD of instance: usdhc3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_PWRWAKEUP. 0 Input Path is determined by
 * functionality of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDCE0. NOTE: Pad EPDC_SDCE0 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDCE[0] of instance: epdc. 001 Select mux mode: ALT1 mux port: SS1 of instance: ecspi2. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm3. 011 Select mux mode: ALT3 mux port: WEIM_CS[2] of instance: weim. 100 Select mux mode: ALT4 mux port: YCKR of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[27] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_SDCE0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdce0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_ADDR      (REGS_IOMUXC_BASE + 0x100)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdce0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDCE0. NOTE: Pad
 * EPDC_SDCE0 is involved in Daisy Chain. - Config Register
 * IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port:
 * SDCE[0] of instance: epdc. 001 Select mux mode: ALT1 mux port: SS1 of instance: ecspi2. 010
 * Select mux mode: ALT2 mux port: PWMO of instance: pwm3. 011 Select mux mode: ALT3 mux port:
 * WEIM_CS[2] of instance: weim. 100 Select mux mode: ALT4 mux port: YCKR of instance: tcon. 101
 * Select mux mode: ALT5 mux port: GPIO[27] of instance: gpio1. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_SDCE0. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDCE1. 000 Select mux mode: ALT0 mux port: SDCE[1] of instance: epdc. 001 Select mux mode: ALT1 mux port: WDOG_B of instance: wdog2. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm4. 011 Select mux mode: ALT3 mux port: WEIM_LBA of instance: weim. 100 Select mux mode: ALT4 mux port: YOER of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[28] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_SDCE1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdce1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_ADDR      (REGS_IOMUXC_BASE + 0x104)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdce1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDCE1. 000 Select mux
 * mode: ALT0 mux port: SDCE[1] of instance: epdc. 001 Select mux mode: ALT1 mux port: WDOG_B of
 * instance: wdog2. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm4. 011 Select mux mode:
 * ALT3 mux port: WEIM_LBA of instance: weim. 100 Select mux mode: ALT4 mux port: YOER of instance:
 * tcon. 101 Select mux mode: ALT5 mux port: GPIO[28] of instance: gpio1. 110 Reserved. 111
 * Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_SDCE1. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDCE2. NOTE: Pad EPDC_SDCE2 is involved in Daisy Chain. - Config Register IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDCE[2] of instance: epdc. 001 Select mux mode: ALT1 mux port: SCL of instance: i2c3. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm1. 011 Select mux mode: ALT3 mux port: WEIM_EB[0] of instance: weim. 100 Select mux mode: ALT4 mux port: YDIOUR of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[29] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_SDCE2. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdce2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_ADDR      (REGS_IOMUXC_BASE + 0x108)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdce2_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDCE2. NOTE: Pad
 * EPDC_SDCE2 is involved in Daisy Chain. - Config Register IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT for
 * mode ALT1. 000 Select mux mode: ALT0 mux port: SDCE[2] of instance: epdc. 001 Select mux mode:
 * ALT1 mux port: SCL of instance: i2c3. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm1.
 * 011 Select mux mode: ALT3 mux port: WEIM_EB[0] of instance: weim. 100 Select mux mode: ALT4 mux
 * port: YDIOUR of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[29] of instance: gpio1.
 * 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_SDCE2. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDCE3. NOTE: Pad EPDC_SDCE3 is involved in Daisy Chain. - Config Register IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDCE[3] of instance: epdc. 001 Select mux mode: ALT1 mux port: SDA of instance: i2c3. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm2. 011 Select mux mode: ALT3 mux port: WEIM_EB[1] of instance: weim. 100 Select mux mode: ALT4 mux port: YDIODR of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[30] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_SDCE3. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdce3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_ADDR      (REGS_IOMUXC_BASE + 0x10c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdce3_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDCE3. NOTE: Pad
 * EPDC_SDCE3 is involved in Daisy Chain. - Config Register IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT for
 * mode ALT1. 000 Select mux mode: ALT0 mux port: SDCE[3] of instance: epdc. 001 Select mux mode:
 * ALT1 mux port: SDA of instance: i2c3. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm2.
 * 011 Select mux mode: ALT3 mux port: WEIM_EB[1] of instance: weim. 100 Select mux mode: ALT4 mux
 * port: YDIODR of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[30] of instance: gpio1.
 * 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_SDCE3. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDCLK. NOTE: Pad EPDC_SDCLK is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: SDCLK of instance: epdc. 001 Select mux mode: ALT1 mux port: MOSI of instance: ecspi2. 010 Select mux mode: ALT2 mux port: SCL of instance: i2c2. 011 Select mux mode: ALT3 mux port: D[8] of instance: csi. 100 Select mux mode: ALT4 mux port: CL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[23] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_SDCLK. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdclk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_ADDR      (REGS_IOMUXC_BASE + 0x110)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdclk_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDCLK. NOTE: Pad
 * EPDC_SDCLK is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT for
 * mode ALT3. - Config Register IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * SDCLK of instance: epdc. 001 Select mux mode: ALT1 mux port: MOSI of instance: ecspi2. 010 Select
 * mux mode: ALT2 mux port: SCL of instance: i2c2. 011 Select mux mode: ALT3 mux port: D[8] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: CL of instance: tcon. 101 Select mux mode:
 * ALT5 mux port: GPIO[23] of instance: gpio1. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_SDCLK. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDLE. NOTE: Pad EPDC_SDLE is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: SDLE of instance: epdc. 001 Select mux mode: ALT1 mux port: MISO of instance: ecspi2. 010 Select mux mode: ALT2 mux port: SDA of instance: i2c2. 011 Select mux mode: ALT3 mux port: D[9] of instance: csi. 100 Select mux mode: ALT4 mux port: LD of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[24] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_SDLE. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdle_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_ADDR      (REGS_IOMUXC_BASE + 0x114)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdle_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDLE. NOTE: Pad
 * EPDC_SDLE is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT for
 * mode ALT3. - Config Register IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * SDLE of instance: epdc. 001 Select mux mode: ALT1 mux port: MISO of instance: ecspi2. 010 Select
 * mux mode: ALT2 mux port: SDA of instance: i2c2. 011 Select mux mode: ALT3 mux port: D[9] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: LD of instance: tcon. 101 Select mux mode:
 * ALT5 mux port: GPIO[24] of instance: gpio1. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_SDLE. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDOE. NOTE: Pad EPDC_SDOE is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDOE of instance: epdc. 001 Select mux mode: ALT1 mux port: SS0 of instance: ecspi2. 010 Select mux mode: ALT2 mux port: XDIOR of instance: tcon. 011 Select mux mode: ALT3 mux port: D[10] of instance: csi. 100 Select mux mode: ALT4 mux port: XDIOL of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[25] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_SDOE. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdoe_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_ADDR      (REGS_IOMUXC_BASE + 0x118)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdoe_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDOE. NOTE: Pad
 * EPDC_SDOE is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT for
 * mode ALT3. - Config Register IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT1. 000 Select
 * mux mode: ALT0 mux port: SDOE of instance: epdc. 001 Select mux mode: ALT1 mux port: SS0 of
 * instance: ecspi2. 010 Select mux mode: ALT2 mux port: XDIOR of instance: tcon. 011 Select mux
 * mode: ALT3 mux port: D[10] of instance: csi. 100 Select mux mode: ALT4 mux port: XDIOL of
 * instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[25] of instance: gpio1. 110 Reserved.
 * 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_SDOE. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDSHR. NOTE: Pad EPDC_SDSHR is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDSHR of instance: epdc. 001 Select mux mode: ALT1 mux port: SCLK of instance: ecspi2. 010 Select mux mode: ALT2 mux port: SDCE[4] of instance: epdc. 011 Select mux mode: ALT3 mux port: D[11] of instance: csi. 100 Select mux mode: ALT4 mux port: XDIOR of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[26] of instance: gpio1. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_SDSHR. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdshr_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_ADDR      (REGS_IOMUXC_BASE + 0x11c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdshr_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_SDSHR. NOTE: Pad
 * EPDC_SDSHR is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT for
 * mode ALT3. - Config Register IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT1. 000 Select
 * mux mode: ALT0 mux port: SDSHR of instance: epdc. 001 Select mux mode: ALT1 mux port: SCLK of
 * instance: ecspi2. 010 Select mux mode: ALT2 mux port: SDCE[4] of instance: epdc. 011 Select mux
 * mode: ALT3 mux port: D[11] of instance: csi. 100 Select mux mode: ALT4 mux port: XDIOR of
 * instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[26] of instance: gpio1. 110 Reserved.
 * 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_SDSHR. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_VCOM0. NOTE: Pad EPDC_VCOM0 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: VCOM[0] of instance: epdc. 001 Select mux mode: ALT1 mux port: AUD5_RXFS of instance: audmux. 010 Select mux mode: ALT2 mux port: RXD_MUX of instance: uart3. 011 Select mux mode: ALT3 mux port: WEIM_A[24] of instance: weim. 100 Select mux mode: ALT4 mux port: VCOM[0] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[3] of instance: gpio2. 110 Select mux mode: ALT6 mux port: SDCE[5] of instance: epdc. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_VCOM0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_vcom0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_ADDR      (REGS_IOMUXC_BASE + 0x120)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_vcom0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_VCOM0. NOTE: Pad
 * EPDC_VCOM0 is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * VCOM[0] of instance: epdc. 001 Select mux mode: ALT1 mux port: AUD5_RXFS of instance: audmux. 010
 * Select mux mode: ALT2 mux port: RXD_MUX of instance: uart3. 011 Select mux mode: ALT3 mux port:
 * WEIM_A[24] of instance: weim. 100 Select mux mode: ALT4 mux port: VCOM[0] of instance: tcon. 101
 * Select mux mode: ALT5 mux port: GPIO[3] of instance: gpio2. 110 Select mux mode: ALT6 mux port:
 * SDCE[5] of instance: epdc. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_VCOM0. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_VCOM1. NOTE: Pad EPDC_VCOM1 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: VCOM[1] of instance: epdc. 001 Select mux mode: ALT1 mux port: AUD5_RXD of instance: audmux. 010 Select mux mode: ALT2 mux port: TXD_MUX of instance: uart3. 011 Select mux mode: ALT3 mux port: WEIM_A[25] of instance: weim. 100 Select mux mode: ALT4 mux port: VCOM[1] of instance: tcon. 101 Select mux mode: ALT5 mux port: GPIO[4] of instance: gpio2. 110 Select mux mode: ALT6 mux port: SDCE[6] of instance: epdc. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad EPDC_VCOM1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_vcom1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_ADDR      (REGS_IOMUXC_BASE + 0x124)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_vcom1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: EPDC_VCOM1. NOTE: Pad
 * EPDC_VCOM1 is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * VCOM[1] of instance: epdc. 001 Select mux mode: ALT1 mux port: AUD5_RXD of instance: audmux. 010
 * Select mux mode: ALT2 mux port: TXD_MUX of instance: uart3. 011 Select mux mode: ALT3 mux port:
 * WEIM_A[25] of instance: weim. 100 Select mux mode: ALT4 mux port: VCOM[1] of instance: tcon. 101
 * Select mux mode: ALT5 mux port: GPIO[4] of instance: gpio2. 110 Select mux mode: ALT6 mux port:
 * SDCE[6] of instance: epdc. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad EPDC_VCOM1. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_CRS_DV. NOTE: Pad FEC_CRS_DV is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: RX_DV of instance: fec. 001 Select mux mode: ALT1 mux port: DAT1 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: AUD6_TXC of instance: audmux. 011 Select mux mode: ALT3 mux port: MISO of instance: ecspi4. 100 Select mux mode: ALT4 mux port: CMPOUT2 of instance: gpt. 101 Select mux mode: ALT5 mux port: GPIO[25] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad FEC_CRS_DV. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_crs_dv_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_ADDR      (REGS_IOMUXC_BASE + 0x128)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_crs_dv_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_CRS_DV. NOTE: Pad
 * FEC_CRS_DV is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: RX_DV
 * of instance: fec. 001 Select mux mode: ALT1 mux port: DAT1 of instance: usdhc4. 010 Select mux
 * mode: ALT2 mux port: AUD6_TXC of instance: audmux. 011 Select mux mode: ALT3 mux port: MISO of
 * instance: ecspi4. 100 Select mux mode: ALT4 mux port: CMPOUT2 of instance: gpt. 101 Select mux
 * mode: ALT5 mux port: GPIO[25] of instance: gpio4. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad FEC_CRS_DV. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_MDC. NOTE: Pad FEC_MDC is involved in Daisy Chain. - Config Register IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: MDC of instance: fec. 001 Select mux mode: ALT1 mux port: DAT4 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: AUDIO_CLK_OUT of instance: audmux. 011 Select mux mode: ALT3 mux port: RST of instance: usdhc1. 100 Select mux mode: ALT4 mux port: RST of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[23] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad FEC_MDC. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_mdc_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_ADDR      (REGS_IOMUXC_BASE + 0x12c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_mdc_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_MDC. NOTE: Pad FEC_MDC
 * is involved in Daisy Chain. - Config Register IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT for mode
 * ALT1. 000 Select mux mode: ALT0 mux port: MDC of instance: fec. 001 Select mux mode: ALT1 mux
 * port: DAT4 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: AUDIO_CLK_OUT of instance:
 * audmux. 011 Select mux mode: ALT3 mux port: RST of instance: usdhc1. 100 Select mux mode: ALT4
 * mux port: RST of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[23] of instance:
 * gpio4. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad FEC_MDC. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDC, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_MDIO. NOTE: Pad FEC_MDIO is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_FEC_FEC_MDI_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: MDIO of instance: fec. 001 Select mux mode: ALT1 mux port: CLK of instance: usdhc4. 010 Select mux mode: ALT2 mux port: AUD6_RXFS of instance: audmux. 011 Select mux mode: ALT3 mux port: SS0 of instance: ecspi4. 100 Select mux mode: ALT4 mux port: CAPIN1 of instance: gpt. 101 Select mux mode: ALT5 mux port: GPIO[20] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad FEC_MDIO. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_mdio_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_ADDR      (REGS_IOMUXC_BASE + 0x130)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_mdio_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_MDIO. NOTE: Pad FEC_MDIO
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT3. - Config
 * Register IOMUXC_FEC_FEC_MDI_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port:
 * MDIO of instance: fec. 001 Select mux mode: ALT1 mux port: CLK of instance: usdhc4. 010 Select
 * mux mode: ALT2 mux port: AUD6_RXFS of instance: audmux. 011 Select mux mode: ALT3 mux port: SS0
 * of instance: ecspi4. 100 Select mux mode: ALT4 mux port: CAPIN1 of instance: gpt. 101 Select mux
 * mode: ALT5 mux port: GPIO[20] of instance: gpio4. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad FEC_MDIO. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_REF_CLK. NOTE: Pad FEC_REF_CLK is involved in Daisy Chain. - Config Register IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: REF_OUT of instance: fec. 001 Select mux mode: ALT1 mux port: RST of instance: usdhc4. 010 Select mux mode: ALT2 mux port: WDOG_B of instance: wdog1. 011 Select mux mode: ALT3 mux port: PWMO of instance: pwm4. 100 Select mux mode: ALT4 mux port: PMIC_RDY of instance: ccm. 101 Select mux mode: ALT5 mux port: GPIO[26] of instance: gpio4. 110 Select mux mode: ALT6 mux port: SPDIF_EXT_CLK of instance: spdif. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad FEC_REF_CLK. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_ref_clk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_ADDR      (REGS_IOMUXC_BASE + 0x134)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_ref_clk_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_REF_CLK. NOTE: Pad
 * FEC_REF_CLK is involved in Daisy Chain. - Config Register
 * IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: REF_OUT of
 * instance: fec. 001 Select mux mode: ALT1 mux port: RST of instance: usdhc4. 010 Select mux mode:
 * ALT2 mux port: WDOG_B of instance: wdog1. 011 Select mux mode: ALT3 mux port: PWMO of instance:
 * pwm4. 100 Select mux mode: ALT4 mux port: PMIC_RDY of instance: ccm. 101 Select mux mode: ALT5
 * mux port: GPIO[26] of instance: gpio4. 110 Select mux mode: ALT6 mux port: SPDIF_EXT_CLK of
 * instance: spdif. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad FEC_REF_CLK. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_RX_ER. NOTE: Pad FEC_RX_ER is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT for mode ALT1. 101 Select mux mode: ALT5 mux port: GPIO[19] of instance: gpio4. 110 Reserved. 111 Reserved. 000 Select mux mode: ALT0 mux port: RX_ER of instance: fec. 001 Select mux mode: ALT1 mux port: DAT0 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: AUD6_RXD of instance: audmux. 011 Select mux mode: ALT3 mux port: MOSI of instance: ecspi4. 100 Select mux mode: ALT4 mux port: CMPOUT1 of instance: gpt.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad FEC_RX_ER. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_rx_er_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_ADDR      (REGS_IOMUXC_BASE + 0x138)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_rx_er_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_RX_ER. NOTE: Pad
 * FEC_RX_ER is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT for mode ALT1. 101 Select mux mode: ALT5 mux port:
 * GPIO[19] of instance: gpio4. 110 Reserved. 111 Reserved. 000 Select mux mode: ALT0 mux port:
 * RX_ER of instance: fec. 001 Select mux mode: ALT1 mux port: DAT0 of instance: usdhc4. 010 Select
 * mux mode: ALT2 mux port: AUD6_RXD of instance: audmux. 011 Select mux mode: ALT3 mux port: MOSI
 * of instance: ecspi4. 100 Select mux mode: ALT4 mux port: CMPOUT1 of instance: gpt.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad FEC_RX_ER. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_RXD0. NOTE: Pad FEC_RXD0 is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: RDATA[0] of instance: fec. 001 Select mux mode: ALT1 mux port: DAT5 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: USBOTG1_ID of instance: anatop. 011 Select mux mode: ALT3 mux port: VSELECT of instance: usdhc1. 100 Select mux mode: ALT4 mux port: VSELECT of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[17] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad FEC_RXD0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_rxd0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_ADDR      (REGS_IOMUXC_BASE + 0x13c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_rxd0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_RXD0. NOTE: Pad FEC_RXD0
 * is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT for mode
 * ALT2. - Config Register IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port:
 * RDATA[0] of instance: fec. 001 Select mux mode: ALT1 mux port: DAT5 of instance: usdhc4. 010
 * Select mux mode: ALT2 mux port: USBOTG1_ID of instance: anatop. 011 Select mux mode: ALT3 mux
 * port: VSELECT of instance: usdhc1. 100 Select mux mode: ALT4 mux port: VSELECT of instance:
 * usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[17] of instance: gpio4. 110 Reserved. 111
 * Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad FEC_RXD0. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_RXD1. NOTE: Pad FEC_RXD1 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_FEC_FEC_COL_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: RDATA[1] of instance: fec. 001 Select mux mode: ALT1 mux port: DAT2 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: AUD6_TXFS of instance: audmux. 011 Select mux mode: ALT3 mux port: SS1 of instance: ecspi4. 100 Select mux mode: ALT4 mux port: CMPOUT3 of instance: gpt. 101 Select mux mode: ALT5 mux port: GPIO[18] of instance: gpio4. 110 Select mux mode: ALT6 mux port: COL of instance: fec. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad FEC_RXD1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_rxd1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_ADDR      (REGS_IOMUXC_BASE + 0x140)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_rxd1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_RXD1. NOTE: Pad FEC_RXD1
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT3. - Config
 * Register IOMUXC_FEC_FEC_COL_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port:
 * RDATA[1] of instance: fec. 001 Select mux mode: ALT1 mux port: DAT2 of instance: usdhc4. 010
 * Select mux mode: ALT2 mux port: AUD6_TXFS of instance: audmux. 011 Select mux mode: ALT3 mux
 * port: SS1 of instance: ecspi4. 100 Select mux mode: ALT4 mux port: CMPOUT3 of instance: gpt. 101
 * Select mux mode: ALT5 mux port: GPIO[18] of instance: gpio4. 110 Select mux mode: ALT6 mux port:
 * COL of instance: fec. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad FEC_RXD1. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_TX_CLK. NOTE: Pad FEC_TX_CLK is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: TX_CLK of instance: fec. 001 Select mux mode: ALT1 mux port: CMD of instance: usdhc4. 010 Select mux mode: ALT2 mux port: AUD6_RXC of instance: audmux. 011 Select mux mode: ALT3 mux port: SCLK of instance: ecspi4. 100 Select mux mode: ALT4 mux port: CAPIN2 of instance: gpt. 101 Select mux mode: ALT5 mux port: GPIO[21] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad FEC_TX_CLK. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_tx_clk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_ADDR      (REGS_IOMUXC_BASE + 0x144)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_tx_clk_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_TX_CLK. NOTE: Pad
 * FEC_TX_CLK is involved in Daisy Chain. - Config Register
 * IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: TX_CLK
 * of instance: fec. 001 Select mux mode: ALT1 mux port: CMD of instance: usdhc4. 010 Select mux
 * mode: ALT2 mux port: AUD6_RXC of instance: audmux. 011 Select mux mode: ALT3 mux port: SCLK of
 * instance: ecspi4. 100 Select mux mode: ALT4 mux port: CAPIN2 of instance: gpt. 101 Select mux
 * mode: ALT5 mux port: GPIO[21] of instance: gpio4. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad FEC_TX_CLK. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_TX_EN. NOTE: Pad FEC_TX_EN is involved in Daisy Chain. - Config Register IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: TX_EN of instance: fec. 001 Select mux mode: ALT1 mux port: DAT6 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: IN1 of instance: spdif. 011 Select mux mode: ALT3 mux port: WP of instance: usdhc1. 100 Select mux mode: ALT4 mux port: WP of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[22] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad FEC_TX_EN. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_tx_en_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_ADDR      (REGS_IOMUXC_BASE + 0x148)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_tx_en_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_TX_EN. NOTE: Pad
 * FEC_TX_EN is involved in Daisy Chain. - Config Register IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT for mode ALT3. - Config
 * Register IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: TX_EN
 * of instance: fec. 001 Select mux mode: ALT1 mux port: DAT6 of instance: usdhc4. 010 Select mux
 * mode: ALT2 mux port: IN1 of instance: spdif. 011 Select mux mode: ALT3 mux port: WP of instance:
 * usdhc1. 100 Select mux mode: ALT4 mux port: WP of instance: usdhc3. 101 Select mux mode: ALT5 mux
 * port: GPIO[22] of instance: gpio4. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad FEC_TX_EN. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_TXD0. NOTE: Pad FEC_TXD0 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: TDATA[0] of instance: fec. 001 Select mux mode: ALT1 mux port: DAT3 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: AUD6_TXD of instance: audmux. 011 Select mux mode: ALT3 mux port: SS2 of instance: ecspi4. 100 Select mux mode: ALT4 mux port: CLKIN of instance: gpt. 101 Select mux mode: ALT5 mux port: GPIO[24] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad FEC_TXD0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_txd0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_ADDR      (REGS_IOMUXC_BASE + 0x14c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_txd0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_TXD0. NOTE: Pad FEC_TXD0
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT for mode
 * ALT2. - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT for mode ALT3. - Config
 * Register IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port:
 * TDATA[0] of instance: fec. 001 Select mux mode: ALT1 mux port: DAT3 of instance: usdhc4. 010
 * Select mux mode: ALT2 mux port: AUD6_TXD of instance: audmux. 011 Select mux mode: ALT3 mux port:
 * SS2 of instance: ecspi4. 100 Select mux mode: ALT4 mux port: CLKIN of instance: gpt. 101 Select
 * mux mode: ALT5 mux port: GPIO[24] of instance: gpio4. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad FEC_TXD0. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_TXD1. NOTE: Pad FEC_TXD1 is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: TDATA[1] of instance: fec. 001 Select mux mode: ALT1 mux port: DAT7 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: OUT1 of instance: spdif. 011 Select mux mode: ALT3 mux port: CD of instance: usdhc1. 100 Select mux mode: ALT4 mux port: CD of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[16] of instance: gpio4. 110 Select mux mode: ALT6 mux port: RX_CLK of instance: fec. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad FEC_TXD1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_txd1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_ADDR      (REGS_IOMUXC_BASE + 0x150)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_txd1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: FEC_TXD1. NOTE: Pad FEC_TXD1
 * is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT for mode ALT6. -
 * Config Register IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port:
 * TDATA[1] of instance: fec. 001 Select mux mode: ALT1 mux port: DAT7 of instance: usdhc4. 010
 * Select mux mode: ALT2 mux port: OUT1 of instance: spdif. 011 Select mux mode: ALT3 mux port: CD
 * of instance: usdhc1. 100 Select mux mode: ALT4 mux port: CD of instance: usdhc3. 101 Select mux
 * mode: ALT5 mux port: GPIO[16] of instance: gpio4. 110 Select mux mode: ALT6 mux port: RX_CLK of
 * instance: fec. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad FEC_TXD1. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 6 iomux modes to be used for pad: HSIC_DAT. NOTE: Pad HSIC_DAT is involved in Daisy Chain. - Config Register IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: H_DATA of instance: usb. 001 Select mux mode: ALT1 mux port: SCL of instance: i2c1. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm1. 011 Reserved. 100 Reserved. 101 Select mux mode: ALT5 mux port: GPIO[19] of instance: gpio3.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad HSIC_DAT. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_hsic_dat_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_ADDR      (REGS_IOMUXC_BASE + 0x154)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_hsic_dat_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 6 iomux modes to be used for pad: HSIC_DAT. NOTE: Pad HSIC_DAT
 * is involved in Daisy Chain. - Config Register IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT for mode ALT1.
 * 000 Select mux mode: ALT0 mux port: H_DATA of instance: usb. 001 Select mux mode: ALT1 mux port:
 * SCL of instance: i2c1. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm1. 011 Reserved.
 * 100 Reserved. 101 Select mux mode: ALT5 mux port: GPIO[19] of instance: gpio3.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad HSIC_DAT. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 5 iomux modes to be used for pad: HSIC_STROBE. NOTE: Pad HSIC_STROBE is involved in Daisy Chain. - Config Register IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: H_STROBE of instance: usb. 001 Select mux mode: ALT1 mux port: SDA of instance: i2c1. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm2. 011 Reserved. 101 Select mux mode: ALT5 mux port: GPIO[20] of instance: gpio3.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad HSIC_STROBE. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_hsic_strobe_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_ADDR      (REGS_IOMUXC_BASE + 0x158)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_hsic_strobe_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 5 iomux modes to be used for pad: HSIC_STROBE. NOTE: Pad
 * HSIC_STROBE is involved in Daisy Chain. - Config Register IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT for
 * mode ALT1. 000 Select mux mode: ALT0 mux port: H_STROBE of instance: usb. 001 Select mux mode:
 * ALT1 mux port: SDA of instance: i2c1. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm2.
 * 011 Reserved. 101 Select mux mode: ALT5 mux port: GPIO[20] of instance: gpio3.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad HSIC_STROBE. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: I2C1_SCL. NOTE: Pad I2C1_SCL is involved in Daisy Chain. - Config Register IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SCL of instance: i2c1. 001 Select mux mode: ALT1 mux port: RTS of instance: uart1. 010 Select mux mode: ALT2 mux port: SS2 of instance: ecspi3. 011 Select mux mode: ALT3 mux port: RDATA[0] of instance: fec. 100 Select mux mode: ALT4 mux port: RST of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[12] of instance: gpio3. 110 Select mux mode: ALT6 mux port: SS1 of instance: ecspi1. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad I2C1_SCL. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_i2c1_scl_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_ADDR      (REGS_IOMUXC_BASE + 0x15c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_i2c1_scl_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: I2C1_SCL. NOTE: Pad I2C1_SCL
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT for mode
 * ALT6. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT for mode ALT2. - Config
 * Register IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SCL
 * of instance: i2c1. 001 Select mux mode: ALT1 mux port: RTS of instance: uart1. 010 Select mux
 * mode: ALT2 mux port: SS2 of instance: ecspi3. 011 Select mux mode: ALT3 mux port: RDATA[0] of
 * instance: fec. 100 Select mux mode: ALT4 mux port: RST of instance: usdhc3. 101 Select mux mode:
 * ALT5 mux port: GPIO[12] of instance: gpio3. 110 Select mux mode: ALT6 mux port: SS1 of instance:
 * ecspi1. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad I2C1_SCL. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: I2C1_SDA. NOTE: Pad I2C1_SDA is involved in Daisy Chain. - Config Register IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDA of instance: i2c1. 001 Select mux mode: ALT1 mux port: CTS of instance: uart1. 010 Select mux mode: ALT2 mux port: SS3 of instance: ecspi3. 011 Select mux mode: ALT3 mux port: TX_EN of instance: fec. 100 Select mux mode: ALT4 mux port: VSELECT of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[13] of instance: gpio3. 110 Select mux mode: ALT6 mux port: SS2 of instance: ecspi1. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad I2C1_SDA. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_i2c1_sda_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_ADDR      (REGS_IOMUXC_BASE + 0x160)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_i2c1_sda_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: I2C1_SDA. NOTE: Pad I2C1_SDA
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT for mode
 * ALT6. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT for mode ALT2. - Config
 * Register IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: SDA
 * of instance: i2c1. 001 Select mux mode: ALT1 mux port: CTS of instance: uart1. 010 Select mux
 * mode: ALT2 mux port: SS3 of instance: ecspi3. 011 Select mux mode: ALT3 mux port: TX_EN of
 * instance: fec. 100 Select mux mode: ALT4 mux port: VSELECT of instance: usdhc3. 101 Select mux
 * mode: ALT5 mux port: GPIO[13] of instance: gpio3. 110 Select mux mode: ALT6 mux port: SS2 of
 * instance: ecspi1. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad I2C1_SDA. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: I2C2_SCL. NOTE: Pad I2C2_SCL is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: SCL of instance: i2c2. 001 Select mux mode: ALT1 mux port: AUD4_RXFS of instance: audmux. 010 Select mux mode: ALT2 mux port: IN1 of instance: spdif. 011 Select mux mode: ALT3 mux port: TDATA[1] of instance: fec. 100 Select mux mode: ALT4 mux port: WP of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[14] of instance: gpio3. 110 Select mux mode: ALT6 mux port: RDY of instance: ecspi1. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad I2C2_SCL. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_i2c2_scl_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_ADDR      (REGS_IOMUXC_BASE + 0x164)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_i2c2_scl_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: I2C2_SCL. NOTE: Pad I2C2_SCL
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT for mode ALT6. -
 * Config Register IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: SCL of
 * instance: i2c2. 001 Select mux mode: ALT1 mux port: AUD4_RXFS of instance: audmux. 010 Select mux
 * mode: ALT2 mux port: IN1 of instance: spdif. 011 Select mux mode: ALT3 mux port: TDATA[1] of
 * instance: fec. 100 Select mux mode: ALT4 mux port: WP of instance: usdhc3. 101 Select mux mode:
 * ALT5 mux port: GPIO[14] of instance: gpio3. 110 Select mux mode: ALT6 mux port: RDY of instance:
 * ecspi1. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad I2C2_SCL. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: I2C2_SDA. NOTE: Pad I2C2_SDA is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: SDA of instance: i2c2. 001 Select mux mode: ALT1 mux port: AUD4_RXC of instance: audmux. 010 Select mux mode: ALT2 mux port: OUT1 of instance: spdif. 011 Select mux mode: ALT3 mux port: REF_OUT of instance: fec. 100 Select mux mode: ALT4 mux port: CD of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[15] of instance: gpio3. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad I2C2_SDA. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_i2c2_sda_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_ADDR      (REGS_IOMUXC_BASE + 0x168)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_i2c2_sda_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: I2C2_SDA. NOTE: Pad I2C2_SDA
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: SDA of
 * instance: i2c2. 001 Select mux mode: ALT1 mux port: AUD4_RXC of instance: audmux. 010 Select mux
 * mode: ALT2 mux port: OUT1 of instance: spdif. 011 Select mux mode: ALT3 mux port: REF_OUT of
 * instance: fec. 100 Select mux mode: ALT4 mux port: CD of instance: usdhc3. 101 Select mux mode:
 * ALT5 mux port: GPIO[15] of instance: gpio3. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad I2C2_SDA. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL0. NOTE: Pad KEY_COL0 is involved in Daisy Chain. - Config Register IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[0] of instance: kpp. 001 Select mux mode: ALT1 mux port: SCL of instance: i2c2. 010 Select mux mode: ALT2 mux port: DAT[0] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[0] of instance: weim. 100 Select mux mode: ALT4 mux port: CD of instance: usdhc1. 101 Select mux mode: ALT5 mux port: GPIO[24] of instance: gpio3. 110 Select mux mode: ALT6 mux port: SCLK of instance: mshc. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_COL0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_ADDR      (REGS_IOMUXC_BASE + 0x16c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL0. NOTE: Pad KEY_COL0
 * is involved in Daisy Chain. - Config Register IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT for mode ALT1.
 * - Config Register IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[0]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: SCL of instance: i2c2. 010 Select mux mode:
 * ALT2 mux port: DAT[0] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[0] of
 * instance: weim. 100 Select mux mode: ALT4 mux port: CD of instance: usdhc1. 101 Select mux mode:
 * ALT5 mux port: GPIO[24] of instance: gpio3. 110 Select mux mode: ALT6 mux port: SCLK of instance:
 * mshc. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_COL0. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL1. NOTE: Pad KEY_COL1 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[1] of instance: kpp. 001 Select mux mode: ALT1 mux port: MOSI of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[2] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[2] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT4 of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[26] of instance: gpio3. 110 Select mux mode: ALT6 mux port: DATA[0] of instance: mshc. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_COL1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_ADDR      (REGS_IOMUXC_BASE + 0x170)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL1. NOTE: Pad KEY_COL1
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[1]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: MOSI of instance: ecspi4. 010 Select mux
 * mode: ALT2 mux port: DAT[2] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[2]
 * of instance: weim. 100 Select mux mode: ALT4 mux port: DAT4 of instance: usdhc3. 101 Select mux
 * mode: ALT5 mux port: GPIO[26] of instance: gpio3. 110 Select mux mode: ALT6 mux port: DATA[0] of
 * instance: mshc. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_COL1. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL2. NOTE: Pad KEY_COL2 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[2] of instance: kpp. 001 Select mux mode: ALT1 mux port: SS0 of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[4] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[4] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT6 of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[28] of instance: gpio3. 110 Select mux mode: ALT6 mux port: DATA[2] of instance: mshc. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_COL2. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_ADDR      (REGS_IOMUXC_BASE + 0x174)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col2_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL2. NOTE: Pad KEY_COL2
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[2]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: SS0 of instance: ecspi4. 010 Select mux
 * mode: ALT2 mux port: DAT[4] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[4]
 * of instance: weim. 100 Select mux mode: ALT4 mux port: DAT6 of instance: usdhc3. 101 Select mux
 * mode: ALT5 mux port: GPIO[28] of instance: gpio3. 110 Select mux mode: ALT6 mux port: DATA[2] of
 * instance: mshc. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_COL2. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL2, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL3. NOTE: Pad KEY_COL3 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[3] of instance: kpp. 001 Select mux mode: ALT1 mux port: AUD6_RXFS of instance: audmux. 010 Select mux mode: ALT2 mux port: DAT[6] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[6] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT6 of instance: usdhc4. 101 Select mux mode: ALT5 mux port: GPIO[30] of instance: gpio3. 110 Select mux mode: ALT6 mux port: RST of instance: usdhc1. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_COL3. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_ADDR      (REGS_IOMUXC_BASE + 0x178)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col3_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL3. NOTE: Pad KEY_COL3
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT for mode ALT0. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[3]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: AUD6_RXFS of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: DAT[6] of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_DA_A[6] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT6 of instance: usdhc4. 101
 * Select mux mode: ALT5 mux port: GPIO[30] of instance: gpio3. 110 Select mux mode: ALT6 mux port:
 * RST of instance: usdhc1. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_COL3. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL3, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL4. NOTE: Pad KEY_COL4 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[4] of instance: kpp. 001 Select mux mode: ALT1 mux port: AUD6_RXD of instance: audmux. 010 Select mux mode: ALT2 mux port: DAT[8] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[8] of instance: weim. 100 Select mux mode: ALT4 mux port: CLK of instance: usdhc4. 101 Select mux mode: ALT5 mux port: GPIO[0] of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG1_PWR of instance: usb. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_COL4. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_ADDR      (REGS_IOMUXC_BASE + 0x17c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col4_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL4. NOTE: Pad KEY_COL4
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port:
 * COL[4] of instance: kpp. 001 Select mux mode: ALT1 mux port: AUD6_RXD of instance: audmux. 010
 * Select mux mode: ALT2 mux port: DAT[8] of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_DA_A[8] of instance: weim. 100 Select mux mode: ALT4 mux port: CLK of instance: usdhc4. 101
 * Select mux mode: ALT5 mux port: GPIO[0] of instance: gpio4. 110 Select mux mode: ALT6 mux port:
 * USBOTG1_PWR of instance: usb. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_COL4. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL4, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL5. NOTE: Pad KEY_COL5 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[5] of instance: kpp. 001 Select mux mode: ALT1 mux port: AUD6_TXFS of instance: audmux. 010 Select mux mode: ALT2 mux port: DAT[10] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[10] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT0 of instance: usdhc4. 101 Select mux mode: ALT5 mux port: GPIO[2] of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG2_PWR of instance: usb. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_COL5. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_ADDR      (REGS_IOMUXC_BASE + 0x180)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col5_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL5. NOTE: Pad KEY_COL5
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT for mode ALT0. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[5]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: AUD6_TXFS of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: DAT[10] of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_DA_A[10] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT0 of instance: usdhc4.
 * 101 Select mux mode: ALT5 mux port: GPIO[2] of instance: gpio4. 110 Select mux mode: ALT6 mux
 * port: USBOTG2_PWR of instance: usb. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_COL5. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL5, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL6. NOTE: Pad KEY_COL6 is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[6] of instance: kpp. 001 Select mux mode: ALT1 mux port: RXD_MUX of instance: uart4. 010 Select mux mode: ALT2 mux port: DAT[12] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[12] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT2 of instance: usdhc4. 101 Select mux mode: ALT5 mux port: GPIO[4] of instance: gpio4. 110 Select mux mode: ALT6 mux port: RST of instance: usdhc3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_COL6. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_ADDR      (REGS_IOMUXC_BASE + 0x184)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col6_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL6. NOTE: Pad KEY_COL6
 * is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT for mode
 * ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT for mode ALT2. - Config
 * Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[6]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: RXD_MUX of instance: uart4. 010 Select mux
 * mode: ALT2 mux port: DAT[12] of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_DA_A[12] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT2 of instance: usdhc4.
 * 101 Select mux mode: ALT5 mux port: GPIO[4] of instance: gpio4. 110 Select mux mode: ALT6 mux
 * port: RST of instance: usdhc3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_COL6. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL6, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL7. NOTE: Pad KEY_COL7 is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[7] of instance: kpp. 001 Select mux mode: ALT1 mux port: RTS of instance: uart4. 010 Select mux mode: ALT2 mux port: DAT[14] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[14] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT4 of instance: usdhc4. 101 Select mux mode: ALT5 mux port: GPIO[6] of instance: gpio4. 110 Select mux mode: ALT6 mux port: WP of instance: usdhc1. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_COL7. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_ADDR      (REGS_IOMUXC_BASE + 0x188)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col7_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_COL7. NOTE: Pad KEY_COL7
 * is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT for mode
 * ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT for mode ALT2. - Config
 * Register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: COL[7]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: RTS of instance: uart4. 010 Select mux
 * mode: ALT2 mux port: DAT[14] of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_DA_A[14] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT4 of instance: usdhc4.
 * 101 Select mux mode: ALT5 mux port: GPIO[6] of instance: gpio4. 110 Select mux mode: ALT6 mux
 * port: WP of instance: usdhc1. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_COL7. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_COL7, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW0. NOTE: Pad KEY_ROW0 is involved in Daisy Chain. - Config Register IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[0] of instance: kpp. 001 Select mux mode: ALT1 mux port: SDA of instance: i2c2. 010 Select mux mode: ALT2 mux port: DAT[1] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[1] of instance: weim. 100 Select mux mode: ALT4 mux port: WP of instance: usdhc1. 101 Select mux mode: ALT5 mux port: GPIO[25] of instance: gpio3. 110 Select mux mode: ALT6 mux port: BS of instance: mshc. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_ROW0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_ADDR      (REGS_IOMUXC_BASE + 0x18c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW0. NOTE: Pad KEY_ROW0
 * is involved in Daisy Chain. - Config Register IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT for mode ALT1.
 * - Config Register IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[0] of
 * instance: kpp. 001 Select mux mode: ALT1 mux port: SDA of instance: i2c2. 010 Select mux mode:
 * ALT2 mux port: DAT[1] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[1] of
 * instance: weim. 100 Select mux mode: ALT4 mux port: WP of instance: usdhc1. 101 Select mux mode:
 * ALT5 mux port: GPIO[25] of instance: gpio3. 110 Select mux mode: ALT6 mux port: BS of instance:
 * mshc. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_ROW0. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW1. NOTE: Pad KEY_ROW1 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[1] of instance: kpp. 001 Select mux mode: ALT1 mux port: MISO of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[3] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[3] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT5 of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[27] of instance: gpio3. 110 Select mux mode: ALT6 mux port: DATA[1] of instance: mshc. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_ROW1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_ADDR      (REGS_IOMUXC_BASE + 0x190)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW1. NOTE: Pad KEY_ROW1
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[1]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: MISO of instance: ecspi4. 010 Select mux
 * mode: ALT2 mux port: DAT[3] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[3]
 * of instance: weim. 100 Select mux mode: ALT4 mux port: DAT5 of instance: usdhc3. 101 Select mux
 * mode: ALT5 mux port: GPIO[27] of instance: gpio3. 110 Select mux mode: ALT6 mux port: DATA[1] of
 * instance: mshc. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_ROW1. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW2. NOTE: Pad KEY_ROW2 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[2] of instance: kpp. 001 Select mux mode: ALT1 mux port: SCLK of instance: ecspi4. 010 Select mux mode: ALT2 mux port: DAT[5] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[5] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT7 of instance: usdhc3. 101 Select mux mode: ALT5 mux port: GPIO[29] of instance: gpio3. 110 Select mux mode: ALT6 mux port: DATA[3] of instance: mshc. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_ROW2. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_ADDR      (REGS_IOMUXC_BASE + 0x194)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row2_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW2. NOTE: Pad KEY_ROW2
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[2]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: SCLK of instance: ecspi4. 010 Select mux
 * mode: ALT2 mux port: DAT[5] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[5]
 * of instance: weim. 100 Select mux mode: ALT4 mux port: DAT7 of instance: usdhc3. 101 Select mux
 * mode: ALT5 mux port: GPIO[29] of instance: gpio3. 110 Select mux mode: ALT6 mux port: DATA[3] of
 * instance: mshc. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_ROW2. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW3. NOTE: Pad KEY_ROW3 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[3] of instance: kpp. 001 Select mux mode: ALT1 mux port: AUD6_RXC of instance: audmux. 010 Select mux mode: ALT2 mux port: DAT[7] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[7] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT7 of instance: usdhc4. 101 Select mux mode: ALT5 mux port: GPIO[31] of instance: gpio3. 110 Select mux mode: ALT6 mux port: VSELECT of instance: usdhc1. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_ROW3. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_ADDR      (REGS_IOMUXC_BASE + 0x198)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row3_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW3. NOTE: Pad KEY_ROW3
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT for mode ALT0. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[3]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: AUD6_RXC of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: DAT[7] of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_DA_A[7] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT7 of instance: usdhc4. 101
 * Select mux mode: ALT5 mux port: GPIO[31] of instance: gpio3. 110 Select mux mode: ALT6 mux port:
 * VSELECT of instance: usdhc1. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_ROW3. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW4. NOTE: Pad KEY_ROW4 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[4] of instance: kpp. 001 Select mux mode: ALT1 mux port: AUD6_TXC of instance: audmux. 010 Select mux mode: ALT2 mux port: DAT[9] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[9] of instance: weim. 100 Select mux mode: ALT4 mux port: CMD of instance: usdhc4. 101 Select mux mode: ALT5 mux port: GPIO[1] of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG1_OC of instance: usb. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_ROW4. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_ADDR      (REGS_IOMUXC_BASE + 0x19c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row4_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW4. NOTE: Pad KEY_ROW4
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT for mode ALT0. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[4]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: AUD6_TXC of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: DAT[9] of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_DA_A[9] of instance: weim. 100 Select mux mode: ALT4 mux port: CMD of instance: usdhc4. 101
 * Select mux mode: ALT5 mux port: GPIO[1] of instance: gpio4. 110 Select mux mode: ALT6 mux port:
 * USBOTG1_OC of instance: usb. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_ROW4. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW5. NOTE: Pad KEY_ROW5 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[5] of instance: kpp. 001 Select mux mode: ALT1 mux port: AUD6_TXD of instance: audmux. 010 Select mux mode: ALT2 mux port: DAT[11] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[11] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT1 of instance: usdhc4. 101 Select mux mode: ALT5 mux port: GPIO[3] of instance: gpio4. 110 Select mux mode: ALT6 mux port: USBOTG2_OC of instance: usb. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_ROW5. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_ADDR      (REGS_IOMUXC_BASE + 0x1a0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row5_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW5. NOTE: Pad KEY_ROW5
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[5]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: AUD6_TXD of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: DAT[11] of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_DA_A[11] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT1 of instance: usdhc4.
 * 101 Select mux mode: ALT5 mux port: GPIO[3] of instance: gpio4. 110 Select mux mode: ALT6 mux
 * port: USBOTG2_OC of instance: usb. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_ROW5. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW6. NOTE: Pad KEY_ROW6 is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[6] of instance: kpp. 001 Select mux mode: ALT1 mux port: TXD_MUX of instance: uart4. 010 Select mux mode: ALT2 mux port: DAT[13] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[13] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT3 of instance: usdhc4. 101 Select mux mode: ALT5 mux port: GPIO[5] of instance: gpio4. 110 Select mux mode: ALT6 mux port: VSELECT of instance: usdhc3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_ROW6. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_ADDR      (REGS_IOMUXC_BASE + 0x1a4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row6_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW6. NOTE: Pad KEY_ROW6
 * is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT for mode
 * ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT for mode ALT2. - Config
 * Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[6]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: TXD_MUX of instance: uart4. 010 Select mux
 * mode: ALT2 mux port: DAT[13] of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_DA_A[13] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT3 of instance: usdhc4.
 * 101 Select mux mode: ALT5 mux port: GPIO[5] of instance: gpio4. 110 Select mux mode: ALT6 mux
 * port: VSELECT of instance: usdhc3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_ROW6. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW7. NOTE: Pad KEY_ROW7 is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[7] of instance: kpp. 001 Select mux mode: ALT1 mux port: CTS of instance: uart4. 010 Select mux mode: ALT2 mux port: DAT[15] of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_DA_A[15] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT5 of instance: usdhc4. 101 Select mux mode: ALT5 mux port: GPIO[7] of instance: gpio4. 110 Select mux mode: ALT6 mux port: CD of instance: usdhc1. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad KEY_ROW7. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_ADDR      (REGS_IOMUXC_BASE + 0x1a8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row7_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: KEY_ROW7. NOTE: Pad KEY_ROW7
 * is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT for mode
 * ALT0. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT for mode ALT2. - Config
 * Register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: ROW[7]
 * of instance: kpp. 001 Select mux mode: ALT1 mux port: CTS of instance: uart4. 010 Select mux
 * mode: ALT2 mux port: DAT[15] of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_DA_A[15] of instance: weim. 100 Select mux mode: ALT4 mux port: DAT5 of instance: usdhc4.
 * 101 Select mux mode: ALT5 mux port: GPIO[7] of instance: gpio4. 110 Select mux mode: ALT6 mux
 * port: CD of instance: usdhc1. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad KEY_ROW7. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_CLK. NOTE: Pad LCD_CLK is involved in Daisy Chain. - Config Register IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: CLK of instance: lcdif. 001 Select mux mode: ALT1 mux port: DAT4 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: WR_RWN of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_RW of instance: weim. 100 Select mux mode: ALT4 mux port: PWMO of instance: pwm4. 101 Select mux mode: ALT5 mux port: GPIO[15] of instance: gpio2. 110 Select mux mode: ALT6 mux port: EARLY_RST of instance: src. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_CLK. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_clk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_ADDR      (REGS_IOMUXC_BASE + 0x1ac)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_clk_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_CLK. NOTE: Pad LCD_CLK
 * is involved in Daisy Chain. - Config Register IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT for mode
 * ALT1. 000 Select mux mode: ALT0 mux port: CLK of instance: lcdif. 001 Select mux mode: ALT1 mux
 * port: DAT4 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: WR_RWN of instance: lcdif.
 * 011 Select mux mode: ALT3 mux port: WEIM_RW of instance: weim. 100 Select mux mode: ALT4 mux
 * port: PWMO of instance: pwm4. 101 Select mux mode: ALT5 mux port: GPIO[15] of instance: gpio2.
 * 110 Select mux mode: ALT6 mux port: EARLY_RST of instance: src. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_CLK. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_CLK, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT0. NOTE: Pad LCD_DAT0 is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[0] of instance: lcdif. 001 Select mux mode: ALT1 mux port: MOSI of instance: ecspi1. 010 Select mux mode: ALT2 mux port: USBOTG2_ID of instance: anatop. 011 Select mux mode: ALT3 mux port: PWMO of instance: pwm1. 100 Select mux mode: ALT4 mux port: DTR of instance: uart5. 101 Select mux mode: ALT5 mux port: GPIO[20] of instance: gpio2. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[0] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_ADDR      (REGS_IOMUXC_BASE + 0x1b0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT0. NOTE: Pad LCD_DAT0
 * is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT for mode
 * ALT2. - Config Register IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[0] of instance: lcdif. 001 Select mux mode: ALT1 mux port: MOSI of instance: ecspi1. 010
 * Select mux mode: ALT2 mux port: USBOTG2_ID of instance: anatop. 011 Select mux mode: ALT3 mux
 * port: PWMO of instance: pwm1. 100 Select mux mode: ALT4 mux port: DTR of instance: uart5. 101
 * Select mux mode: ALT5 mux port: GPIO[20] of instance: gpio2. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[0] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT0. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT1. NOTE: Pad LCD_DAT1 is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[1] of instance: lcdif. 001 Select mux mode: ALT1 mux port: MISO of instance: ecspi1. 010 Select mux mode: ALT2 mux port: USBOTG1_ID of instance: anatop. 011 Select mux mode: ALT3 mux port: PWMO of instance: pwm2. 100 Select mux mode: ALT4 mux port: AUD4_RXFS of instance: audmux. 101 Select mux mode: ALT5 mux port: GPIO[21] of instance: gpio2. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[1] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_ADDR      (REGS_IOMUXC_BASE + 0x1b4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT1. NOTE: Pad LCD_DAT1
 * is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT for mode
 * ALT2. - Config Register IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT for mode ALT4. - Config
 * Register IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[1] of instance: lcdif. 001 Select mux mode: ALT1 mux port: MISO of instance: ecspi1. 010
 * Select mux mode: ALT2 mux port: USBOTG1_ID of instance: anatop. 011 Select mux mode: ALT3 mux
 * port: PWMO of instance: pwm2. 100 Select mux mode: ALT4 mux port: AUD4_RXFS of instance: audmux.
 * 101 Select mux mode: ALT5 mux port: GPIO[21] of instance: gpio2. 110 Reserved. 111 Select mux
 * mode: ALT7 mux port: BT_CFG[1] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT1. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT10. NOTE: Pad LCD_DAT10 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[10] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[1] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[7] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[4] of instance: weim. 100 Select mux mode: ALT4 mux port: MISO of instance: ecspi2. 101 Select mux mode: ALT5 mux port: GPIO[30] of instance: gpio2. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[10] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT10. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat10_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_ADDR      (REGS_IOMUXC_BASE + 0x1b8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat10_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT10. NOTE: Pad
 * LCD_DAT10 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT for mode ALT4. - Config
 * Register IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[10] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[1] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[7] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[4] of instance: weim. 100 Select mux mode: ALT4 mux port: MISO of instance: ecspi2. 101
 * Select mux mode: ALT5 mux port: GPIO[30] of instance: gpio2. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[10] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT10. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT11. NOTE: Pad LCD_DAT11 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[11] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[1] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[6] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[5] of instance: weim. 100 Select mux mode: ALT4 mux port: SS1 of instance: ecspi2. 101 Select mux mode: ALT5 mux port: GPIO[31] of instance: gpio2. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[11] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT11. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat11_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_ADDR      (REGS_IOMUXC_BASE + 0x1bc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat11_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT11. NOTE: Pad
 * LCD_DAT11 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT4. - Config
 * Register IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[11] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[1] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[6] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[5] of instance: weim. 100 Select mux mode: ALT4 mux port: SS1 of instance: ecspi2. 101
 * Select mux mode: ALT5 mux port: GPIO[31] of instance: gpio2. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[11] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT11. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT12. NOTE: Pad LCD_DAT12 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT[12] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[2] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[5] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[6] of instance: weim. 100 Select mux mode: ALT4 mux port: RTS of instance: uart5. 101 Select mux mode: ALT5 mux port: GPIO[0] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[12] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT12. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat12_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_ADDR      (REGS_IOMUXC_BASE + 0x1c0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat12_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT12. NOTE: Pad
 * LCD_DAT12 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port:
 * DAT[12] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[2] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[5] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[6] of instance: weim. 100 Select mux mode: ALT4 mux port: RTS of instance: uart5. 101
 * Select mux mode: ALT5 mux port: GPIO[0] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[12] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT12. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT13. NOTE: Pad LCD_DAT13 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT[13] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[2] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[4] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[7] of instance: weim. 100 Select mux mode: ALT4 mux port: CTS of instance: uart5. 101 Select mux mode: ALT5 mux port: GPIO[1] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[13] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT13. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat13_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_ADDR      (REGS_IOMUXC_BASE + 0x1c4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat13_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT13. NOTE: Pad
 * LCD_DAT13 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port:
 * DAT[13] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[2] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[4] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[7] of instance: weim. 100 Select mux mode: ALT4 mux port: CTS of instance: uart5. 101
 * Select mux mode: ALT5 mux port: GPIO[1] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[13] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT13. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT14. NOTE: Pad LCD_DAT14 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT[14] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[3] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[3] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[8] of instance: weim. 100 Select mux mode: ALT4 mux port: RXD_MUX of instance: uart5. 101 Select mux mode: ALT5 mux port: GPIO[2] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[14] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT14. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat14_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_ADDR      (REGS_IOMUXC_BASE + 0x1c8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat14_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT14. NOTE: Pad
 * LCD_DAT14 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port:
 * DAT[14] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[3] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[3] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[8] of instance: weim. 100 Select mux mode: ALT4 mux port: RXD_MUX of instance: uart5. 101
 * Select mux mode: ALT5 mux port: GPIO[2] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[14] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT14. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT15. NOTE: Pad LCD_DAT15 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT[15] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[3] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[2] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[9] of instance: weim. 100 Select mux mode: ALT4 mux port: TXD_MUX of instance: uart5. 101 Select mux mode: ALT5 mux port: GPIO[3] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[15] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT15. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat15_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_ADDR      (REGS_IOMUXC_BASE + 0x1cc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat15_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT15. NOTE: Pad
 * LCD_DAT15 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT for mode ALT0. - Config Register
 * IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port:
 * DAT[15] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[3] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[2] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[9] of instance: weim. 100 Select mux mode: ALT4 mux port: TXD_MUX of instance: uart5. 101
 * Select mux mode: ALT5 mux port: GPIO[3] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[15] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT15. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT16. NOTE: Pad LCD_DAT16 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[16] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[4] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[1] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[10] of instance: weim. 100 Select mux mode: ALT4 mux port: SCL of instance: i2c2. 101 Select mux mode: ALT5 mux port: GPIO[4] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[24] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT16. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat16_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_ADDR      (REGS_IOMUXC_BASE + 0x1d0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat16_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT16. NOTE: Pad
 * LCD_DAT16 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[16] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[4] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[1] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[10] of instance: weim. 100 Select mux mode: ALT4 mux port: SCL of instance: i2c2. 101
 * Select mux mode: ALT5 mux port: GPIO[4] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[24] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT16. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT17. NOTE: Pad LCD_DAT17 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[17] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[4] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[0] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[11] of instance: weim. 100 Select mux mode: ALT4 mux port: SDA of instance: i2c2. 101 Select mux mode: ALT5 mux port: GPIO[5] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[25] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT17. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat17_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_ADDR      (REGS_IOMUXC_BASE + 0x1d4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat17_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT17. NOTE: Pad
 * LCD_DAT17 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[17] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[4] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[0] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[11] of instance: weim. 100 Select mux mode: ALT4 mux port: SDA of instance: i2c2. 101
 * Select mux mode: ALT5 mux port: GPIO[5] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[25] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT17. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT18. NOTE: Pad LCD_DAT18 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[18] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[5] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[15] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[12] of instance: weim. 100 Select mux mode: ALT4 mux port: CAPIN1 of instance: gpt. 101 Select mux mode: ALT5 mux port: GPIO[6] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[26] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT18. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat18_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_ADDR      (REGS_IOMUXC_BASE + 0x1d8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat18_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT18. NOTE: Pad
 * LCD_DAT18 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT for mode ALT4. - Config
 * Register IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[18] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[5] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[15] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[12] of instance: weim. 100 Select mux mode: ALT4 mux port: CAPIN1 of instance: gpt. 101
 * Select mux mode: ALT5 mux port: GPIO[6] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[26] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT18. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT19. NOTE: Pad LCD_DAT19 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[19] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[5] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[14] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[13] of instance: weim. 100 Select mux mode: ALT4 mux port: CAPIN2 of instance: gpt. 101 Select mux mode: ALT5 mux port: GPIO[7] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[27] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT19. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat19_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_ADDR      (REGS_IOMUXC_BASE + 0x1dc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat19_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT19. NOTE: Pad
 * LCD_DAT19 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT for mode ALT4. - Config
 * Register IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[19] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[5] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[14] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[13] of instance: weim. 100 Select mux mode: ALT4 mux port: CAPIN2 of instance: gpt. 101
 * Select mux mode: ALT5 mux port: GPIO[7] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[27] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT19. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT2. NOTE: Pad LCD_DAT2 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[2] of instance: lcdif. 001 Select mux mode: ALT1 mux port: SS0 of instance: ecspi1. 010 Select mux mode: ALT2 mux port: EPITO of instance: epit2. 011 Select mux mode: ALT3 mux port: PWMO of instance: pwm3. 100 Select mux mode: ALT4 mux port: AUD4_RXC of instance: audmux. 101 Select mux mode: ALT5 mux port: GPIO[22] of instance: gpio2. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[2] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT2. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_ADDR      (REGS_IOMUXC_BASE + 0x1e0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat2_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT2. NOTE: Pad LCD_DAT2
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT for
 * mode ALT4. - Config Register IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux
 * port: DAT[2] of instance: lcdif. 001 Select mux mode: ALT1 mux port: SS0 of instance: ecspi1. 010
 * Select mux mode: ALT2 mux port: EPITO of instance: epit2. 011 Select mux mode: ALT3 mux port:
 * PWMO of instance: pwm3. 100 Select mux mode: ALT4 mux port: AUD4_RXC of instance: audmux. 101
 * Select mux mode: ALT5 mux port: GPIO[22] of instance: gpio2. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[2] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT2. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT20. NOTE: Pad LCD_DAT20 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[20] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[6] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[13] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[14] of instance: weim. 100 Select mux mode: ALT4 mux port: CMPOUT1 of instance: gpt. 101 Select mux mode: ALT5 mux port: GPIO[8] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[28] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT20. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat20_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_ADDR      (REGS_IOMUXC_BASE + 0x1e4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat20_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT20. NOTE: Pad
 * LCD_DAT20 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux
 * port: DAT[20] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[6] of instance: kpp.
 * 010 Select mux mode: ALT2 mux port: D[13] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[14] of instance: weim. 100 Select mux mode: ALT4 mux port: CMPOUT1 of instance: gpt. 101
 * Select mux mode: ALT5 mux port: GPIO[8] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[28] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT20. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT21. NOTE: Pad LCD_DAT21 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[21] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[6] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[12] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[15] of instance: weim. 100 Select mux mode: ALT4 mux port: CMPOUT2 of instance: gpt. 101 Select mux mode: ALT5 mux port: GPIO[9] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[29] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT21. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat21_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_ADDR      (REGS_IOMUXC_BASE + 0x1e8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat21_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT21. NOTE: Pad
 * LCD_DAT21 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux
 * port: DAT[21] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[6] of instance: kpp.
 * 010 Select mux mode: ALT2 mux port: D[12] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[15] of instance: weim. 100 Select mux mode: ALT4 mux port: CMPOUT2 of instance: gpt. 101
 * Select mux mode: ALT5 mux port: GPIO[9] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[29] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT21. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT22. NOTE: Pad LCD_DAT22 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[22] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[7] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[11] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_EB[3] of instance: weim. 100 Select mux mode: ALT4 mux port: CMPOUT3 of instance: gpt. 101 Select mux mode: ALT5 mux port: GPIO[10] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[30] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT22. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat22_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_ADDR      (REGS_IOMUXC_BASE + 0x1ec)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat22_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT22. NOTE: Pad
 * LCD_DAT22 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux
 * port: DAT[22] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[7] of instance: kpp.
 * 010 Select mux mode: ALT2 mux port: D[11] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_EB[3] of instance: weim. 100 Select mux mode: ALT4 mux port: CMPOUT3 of instance: gpt. 101
 * Select mux mode: ALT5 mux port: GPIO[10] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[30] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT22. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT23. NOTE: Pad LCD_DAT23 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[23] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[7] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[10] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_EB[2] of instance: weim. 100 Select mux mode: ALT4 mux port: CLKIN of instance: gpt. 101 Select mux mode: ALT5 mux port: GPIO[11] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[31] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT23. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat23_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_ADDR      (REGS_IOMUXC_BASE + 0x1f0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat23_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT23. NOTE: Pad
 * LCD_DAT23 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT for
 * mode ALT2. - Config Register IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT for mode ALT4. - Config
 * Register IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[23] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[7] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[10] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_EB[2] of instance: weim. 100 Select mux mode: ALT4 mux port: CLKIN of instance: gpt. 101
 * Select mux mode: ALT5 mux port: GPIO[11] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[31] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT23. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT3. NOTE: Pad LCD_DAT3 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[3] of instance: lcdif. 001 Select mux mode: ALT1 mux port: SCLK of instance: ecspi1. 010 Select mux mode: ALT2 mux port: DSR of instance: uart5. 011 Select mux mode: ALT3 mux port: PWMO of instance: pwm4. 100 Select mux mode: ALT4 mux port: AUD4_RXD of instance: audmux. 101 Select mux mode: ALT5 mux port: GPIO[23] of instance: gpio2. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[3] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT3. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_ADDR      (REGS_IOMUXC_BASE + 0x1f4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat3_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT3. NOTE: Pad LCD_DAT3
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT for mode
 * ALT4. - Config Register IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux
 * port: DAT[3] of instance: lcdif. 001 Select mux mode: ALT1 mux port: SCLK of instance: ecspi1.
 * 010 Select mux mode: ALT2 mux port: DSR of instance: uart5. 011 Select mux mode: ALT3 mux port:
 * PWMO of instance: pwm4. 100 Select mux mode: ALT4 mux port: AUD4_RXD of instance: audmux. 101
 * Select mux mode: ALT5 mux port: GPIO[23] of instance: gpio2. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[3] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT3. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT4. NOTE: Pad LCD_DAT4 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[4] of instance: lcdif. 001 Select mux mode: ALT1 mux port: SS1 of instance: ecspi1. 010 Select mux mode: ALT2 mux port: VSYNC of instance: csi. 011 Select mux mode: ALT3 mux port: WDOG_RST_B_DEB of instance: wdog2. 100 Select mux mode: ALT4 mux port: AUD4_TXC of instance: audmux. 101 Select mux mode: ALT5 mux port: GPIO[24] of instance: gpio2. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[4] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT4. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_ADDR      (REGS_IOMUXC_BASE + 0x1f8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat4_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT4. NOTE: Pad LCD_DAT4
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT for
 * mode ALT4. - Config Register IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT for mode ALT2. - Config
 * Register IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[4] of instance: lcdif. 001 Select mux mode: ALT1 mux port: SS1 of instance: ecspi1. 010
 * Select mux mode: ALT2 mux port: VSYNC of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WDOG_RST_B_DEB of instance: wdog2. 100 Select mux mode: ALT4 mux port: AUD4_TXC of instance:
 * audmux. 101 Select mux mode: ALT5 mux port: GPIO[24] of instance: gpio2. 110 Reserved. 111 Select
 * mux mode: ALT7 mux port: BT_CFG[4] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT4. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT5. NOTE: Pad LCD_DAT5 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[5] of instance: lcdif. 001 Select mux mode: ALT1 mux port: SS2 of instance: ecspi1. 010 Select mux mode: ALT2 mux port: HSYNC of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_CS[3] of instance: weim. 100 Select mux mode: ALT4 mux port: AUD4_TXFS of instance: audmux. 101 Select mux mode: ALT5 mux port: GPIO[25] of instance: gpio2. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[5] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT5. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_ADDR      (REGS_IOMUXC_BASE + 0x1fc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat5_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT5. NOTE: Pad LCD_DAT5
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT for
 * mode ALT4. - Config Register IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT for mode ALT2. - Config
 * Register IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[5] of instance: lcdif. 001 Select mux mode: ALT1 mux port: SS2 of instance: ecspi1. 010
 * Select mux mode: ALT2 mux port: HSYNC of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_CS[3] of instance: weim. 100 Select mux mode: ALT4 mux port: AUD4_TXFS of instance: audmux.
 * 101 Select mux mode: ALT5 mux port: GPIO[25] of instance: gpio2. 110 Reserved. 111 Select mux
 * mode: ALT7 mux port: BT_CFG[5] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT5. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT6. NOTE: Pad LCD_DAT6 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[6] of instance: lcdif. 001 Select mux mode: ALT1 mux port: SS3 of instance: ecspi1. 010 Select mux mode: ALT2 mux port: PIXCLK of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[0] of instance: weim. 100 Select mux mode: ALT4 mux port: AUD4_TXD of instance: audmux. 101 Select mux mode: ALT5 mux port: GPIO[26] of instance: gpio2. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[6] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT6. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_ADDR      (REGS_IOMUXC_BASE + 0x200)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat6_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT6. NOTE: Pad LCD_DAT6
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT for mode
 * ALT4. - Config Register IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[6] of instance: lcdif. 001 Select mux mode: ALT1 mux port: SS3 of instance: ecspi1. 010
 * Select mux mode: ALT2 mux port: PIXCLK of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[0] of instance: weim. 100 Select mux mode: ALT4 mux port: AUD4_TXD of instance: audmux.
 * 101 Select mux mode: ALT5 mux port: GPIO[26] of instance: gpio2. 110 Reserved. 111 Select mux
 * mode: ALT7 mux port: BT_CFG[6] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT6. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT7. NOTE: Pad LCD_DAT7 is involved in Daisy Chain. - Config Register IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[7] of instance: lcdif. 001 Select mux mode: ALT1 mux port: RDY of instance: ecspi1. 010 Select mux mode: ALT2 mux port: MCLK of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[1] of instance: weim. 100 Select mux mode: ALT4 mux port: AUDIO_CLK_OUT of instance: audmux. 101 Select mux mode: ALT5 mux port: GPIO[27] of instance: gpio2. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[7] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT7. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_ADDR      (REGS_IOMUXC_BASE + 0x204)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat7_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT7. NOTE: Pad LCD_DAT7
 * is involved in Daisy Chain. - Config Register IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT for mode ALT0. 000 Select
 * mux mode: ALT0 mux port: DAT[7] of instance: lcdif. 001 Select mux mode: ALT1 mux port: RDY of
 * instance: ecspi1. 010 Select mux mode: ALT2 mux port: MCLK of instance: csi. 011 Select mux mode:
 * ALT3 mux port: WEIM_D[1] of instance: weim. 100 Select mux mode: ALT4 mux port: AUDIO_CLK_OUT of
 * instance: audmux. 101 Select mux mode: ALT5 mux port: GPIO[27] of instance: gpio2. 110 Reserved.
 * 111 Select mux mode: ALT7 mux port: BT_CFG[7] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT7. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT8. NOTE: Pad LCD_DAT8 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[8] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[0] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[9] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[2] of instance: weim. 100 Select mux mode: ALT4 mux port: SCLK of instance: ecspi2. 101 Select mux mode: ALT5 mux port: GPIO[28] of instance: gpio2. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[8] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT8. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat8_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_ADDR      (REGS_IOMUXC_BASE + 0x208)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat8_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT8. NOTE: Pad LCD_DAT8
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT for mode ALT2.
 * - Config Register IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[8] of instance: lcdif. 001 Select mux mode: ALT1 mux port: COL[0] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[9] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[2] of instance: weim. 100 Select mux mode: ALT4 mux port: SCLK of instance: ecspi2. 101
 * Select mux mode: ALT5 mux port: GPIO[28] of instance: gpio2. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[8] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT8. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT9. NOTE: Pad LCD_DAT9 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port: DAT[9] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[0] of instance: kpp. 010 Select mux mode: ALT2 mux port: D[8] of instance: csi. 011 Select mux mode: ALT3 mux port: WEIM_D[3] of instance: weim. 100 Select mux mode: ALT4 mux port: MOSI of instance: ecspi2. 101 Select mux mode: ALT5 mux port: GPIO[29] of instance: gpio2. 110 Reserved. 111 Select mux mode: ALT7 mux port: BT_CFG[9] of instance: src.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_DAT9. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat9_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_ADDR      (REGS_IOMUXC_BASE + 0x20c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat9_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_DAT9. NOTE: Pad LCD_DAT9
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT for mode ALT2.
 * - Config Register IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT for mode ALT0. 000 Select mux mode: ALT0 mux port:
 * DAT[9] of instance: lcdif. 001 Select mux mode: ALT1 mux port: ROW[0] of instance: kpp. 010
 * Select mux mode: ALT2 mux port: D[8] of instance: csi. 011 Select mux mode: ALT3 mux port:
 * WEIM_D[3] of instance: weim. 100 Select mux mode: ALT4 mux port: MOSI of instance: ecspi2. 101
 * Select mux mode: ALT5 mux port: GPIO[29] of instance: gpio2. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: BT_CFG[9] of instance: src.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_DAT9. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_ENABLE. NOTE: Pad LCD_ENABLE is involved in Daisy Chain. - Config Register IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: ENABLE of instance: lcdif. 001 Select mux mode: ALT1 mux port: DAT5 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: RD_E of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_OE of instance: weim. 100 Select mux mode: ALT4 mux port: RXD_MUX of instance: uart2. 101 Select mux mode: ALT5 mux port: GPIO[16] of instance: gpio2. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_ENABLE. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_enable_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_ADDR      (REGS_IOMUXC_BASE + 0x210)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_enable_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_ENABLE. NOTE: Pad
 * LCD_ENABLE is involved in Daisy Chain. - Config Register
 * IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: ENABLE
 * of instance: lcdif. 001 Select mux mode: ALT1 mux port: DAT5 of instance: usdhc4. 010 Select mux
 * mode: ALT2 mux port: RD_E of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_OE of
 * instance: weim. 100 Select mux mode: ALT4 mux port: RXD_MUX of instance: uart2. 101 Select mux
 * mode: ALT5 mux port: GPIO[16] of instance: gpio2. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_ENABLE. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_HSYNC. NOTE: Pad LCD_HSYNC is involved in Daisy Chain. - Config Register IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: HSYNC of instance: lcdif. 001 Select mux mode: ALT1 mux port: DAT6 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: CS of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_CS[0] of instance: weim. 100 Select mux mode: ALT4 mux port: TXD_MUX of instance: uart2. 101 Select mux mode: ALT5 mux port: GPIO[17] of instance: gpio2. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_HSYNC. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_hsync_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_ADDR      (REGS_IOMUXC_BASE + 0x214)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_hsync_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_HSYNC. NOTE: Pad
 * LCD_HSYNC is involved in Daisy Chain. - Config Register IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT for
 * mode ALT0. - Config Register IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. - Config
 * Register IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux
 * port: HSYNC of instance: lcdif. 001 Select mux mode: ALT1 mux port: DAT6 of instance: usdhc4. 010
 * Select mux mode: ALT2 mux port: CS of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_CS[0] of instance: weim. 100 Select mux mode: ALT4 mux port: TXD_MUX of instance: uart2. 101
 * Select mux mode: ALT5 mux port: GPIO[17] of instance: gpio2. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_HSYNC. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_RESET. NOTE: Pad LCD_RESET is involved in Daisy Chain. - Config Register IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT for mode ALT6. - Config Register IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT for mode ALT3. 000 Select mux mode: ALT0 mux port: RESET of instance: lcdif. 001 Select mux mode: ALT1 mux port: WEIM_DTACK_B of instance: weim. 010 Select mux mode: ALT2 mux port: BUSY of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_WAIT of instance: weim. 100 Select mux mode: ALT4 mux port: CTS of instance: uart2. 101 Select mux mode: ALT5 mux port: GPIO[19] of instance: gpio2. 110 Select mux mode: ALT6 mux port: PMIC_RDY of instance: ccm. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_RESET. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_reset_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_ADDR      (REGS_IOMUXC_BASE + 0x218)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_reset_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_RESET. NOTE: Pad
 * LCD_RESET is involved in Daisy Chain. - Config Register
 * IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT for mode ALT6. - Config Register
 * IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT for mode ALT3. 000 Select mux mode: ALT0 mux port: RESET
 * of instance: lcdif. 001 Select mux mode: ALT1 mux port: WEIM_DTACK_B of instance: weim. 010
 * Select mux mode: ALT2 mux port: BUSY of instance: lcdif. 011 Select mux mode: ALT3 mux port:
 * WEIM_WAIT of instance: weim. 100 Select mux mode: ALT4 mux port: CTS of instance: uart2. 101
 * Select mux mode: ALT5 mux port: GPIO[19] of instance: gpio2. 110 Select mux mode: ALT6 mux port:
 * PMIC_RDY of instance: ccm. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_RESET. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_RESET, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_VSYNC. NOTE: Pad LCD_VSYNC is involved in Daisy Chain. - Config Register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: VSYNC of instance: lcdif. 001 Select mux mode: ALT1 mux port: DAT7 of instance: usdhc4. 010 Select mux mode: ALT2 mux port: RS of instance: lcdif. 011 Select mux mode: ALT3 mux port: WEIM_CS[1] of instance: weim. 100 Select mux mode: ALT4 mux port: RTS of instance: uart2. 101 Select mux mode: ALT5 mux port: GPIO[18] of instance: gpio2. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad LCD_VSYNC. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_vsync_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_ADDR      (REGS_IOMUXC_BASE + 0x21c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_vsync_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: LCD_VSYNC. NOTE: Pad
 * LCD_VSYNC is involved in Daisy Chain. - Config Register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT
 * for mode ALT4. - Config Register IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT for mode ALT1. 000 Select
 * mux mode: ALT0 mux port: VSYNC of instance: lcdif. 001 Select mux mode: ALT1 mux port: DAT7 of
 * instance: usdhc4. 010 Select mux mode: ALT2 mux port: RS of instance: lcdif. 011 Select mux mode:
 * ALT3 mux port: WEIM_CS[1] of instance: weim. 100 Select mux mode: ALT4 mux port: RTS of instance:
 * uart2. 101 Select mux mode: ALT5 mux port: GPIO[18] of instance: gpio2. 110 Reserved. 111
 * Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad LCD_VSYNC. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: PWM1. 000 Select mux mode: ALT0 mux port: PWMO of instance: pwm1. 001 Select mux mode: ALT1 mux port: CLKO of instance: ccm. 010 Select mux mode: ALT2 mux port: AUDIO_CLK_OUT of instance: audmux. 011 Select mux mode: ALT3 mux port: REF_OUT of instance: fec. 100 Select mux mode: ALT4 mux port: MCLK of instance: csi. 101 Select mux mode: ALT5 mux port: GPIO[23] of instance: gpio3. 110 Select mux mode: ALT6 mux port: EPITO of instance: epit1. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad PWM1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_pwm1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_ADDR      (REGS_IOMUXC_BASE + 0x220)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_pwm1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: PWM1. 000 Select mux mode:
 * ALT0 mux port: PWMO of instance: pwm1. 001 Select mux mode: ALT1 mux port: CLKO of instance: ccm.
 * 010 Select mux mode: ALT2 mux port: AUDIO_CLK_OUT of instance: audmux. 011 Select mux mode: ALT3
 * mux port: REF_OUT of instance: fec. 100 Select mux mode: ALT4 mux port: MCLK of instance: csi.
 * 101 Select mux mode: ALT5 mux port: GPIO[23] of instance: gpio3. 110 Select mux mode: ALT6 mux
 * port: EPITO of instance: epit1. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad PWM1. 0 Input Path is determined by functionality of the
 * selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_PWM1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: REF_CLK_24M. NOTE: Pad REF_CLK_24M is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT for mode ALT6. 000 Reserved. 001 Select mux mode: ALT1 mux port: SCL of instance: i2c3. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm3. 011 Select mux mode: ALT3 mux port: USBOTG2_ID of instance: anatop. 100 Select mux mode: ALT4 mux port: PMIC_RDY of instance: ccm. 101 Select mux mode: ALT5 mux port: GPIO[21] of instance: gpio3. 110 Select mux mode: ALT6 mux port: WP of instance: usdhc3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad REF_CLK_24M. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_ref_clk_24m_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_ADDR      (REGS_IOMUXC_BASE + 0x224)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ref_clk_24m_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: REF_CLK_24M. NOTE: Pad
 * REF_CLK_24M is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT
 * for mode ALT3. - Config Register IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT for mode ALT4. -
 * Config Register IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT for mode ALT1. - Config Register
 * IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT for mode ALT6. 000 Reserved. 001 Select mux mode: ALT1 mux
 * port: SCL of instance: i2c3. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm3. 011
 * Select mux mode: ALT3 mux port: USBOTG2_ID of instance: anatop. 100 Select mux mode: ALT4 mux
 * port: PMIC_RDY of instance: ccm. 101 Select mux mode: ALT5 mux port: GPIO[21] of instance: gpio3.
 * 110 Select mux mode: ALT6 mux port: WP of instance: usdhc3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad REF_CLK_24M. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: REF_CLK_32K. NOTE: Pad REF_CLK_32K is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT for mode ALT6. 000 Reserved. 001 Select mux mode: ALT1 mux port: SDA of instance: i2c3. 010 Select mux mode: ALT2 mux port: PWMO of instance: pwm4. 011 Select mux mode: ALT3 mux port: USBOTG1_ID of instance: anatop. 100 Select mux mode: ALT4 mux port: LCTL of instance: usdhc1. 101 Select mux mode: ALT5 mux port: GPIO[22] of instance: gpio3. 110 Select mux mode: ALT6 mux port: CD of instance: usdhc3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad REF_CLK_32K. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_ref_clk_32k_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_ADDR      (REGS_IOMUXC_BASE + 0x228)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ref_clk_32k_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: REF_CLK_32K. NOTE: Pad
 * REF_CLK_32K is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT
 * for mode ALT3. - Config Register IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT for mode ALT6. 000 Reserved. 001 Select mux
 * mode: ALT1 mux port: SDA of instance: i2c3. 010 Select mux mode: ALT2 mux port: PWMO of instance:
 * pwm4. 011 Select mux mode: ALT3 mux port: USBOTG1_ID of instance: anatop. 100 Select mux mode:
 * ALT4 mux port: LCTL of instance: usdhc1. 101 Select mux mode: ALT5 mux port: GPIO[22] of
 * instance: gpio3. 110 Select mux mode: ALT6 mux port: CD of instance: usdhc3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad REF_CLK_32K. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_CLK. NOTE: Pad SD1_CLK is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_MDI_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: CLK of instance: usdhc1. 001 Select mux mode: ALT1 mux port: MDIO of instance: fec. 010 Select mux mode: ALT2 mux port: COL[0] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDCE[4] of instance: epdc. 100 Select mux mode: ALT4 mux port: SCLK of instance: mshc. 101 Select mux mode: ALT5 mux port: GPIO[15] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD1_CLK. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_clk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_ADDR      (REGS_IOMUXC_BASE + 0x22c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_clk_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_CLK. NOTE: Pad SD1_CLK
 * is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_MDI_SELECT_INPUT for mode ALT1. -
 * Config Register IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: CLK of
 * instance: usdhc1. 001 Select mux mode: ALT1 mux port: MDIO of instance: fec. 010 Select mux mode:
 * ALT2 mux port: COL[0] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDCE[4] of instance:
 * epdc. 100 Select mux mode: ALT4 mux port: SCLK of instance: mshc. 101 Select mux mode: ALT5 mux
 * port: GPIO[15] of instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD1_CLK. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CLK, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_CMD. NOTE: Pad SD1_CMD is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: CMD of instance: usdhc1. 001 Select mux mode: ALT1 mux port: TX_CLK of instance: fec. 010 Select mux mode: ALT2 mux port: ROW[0] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDCE[5] of instance: epdc. 100 Select mux mode: ALT4 mux port: BS of instance: mshc. 101 Select mux mode: ALT5 mux port: GPIO[14] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD1_CMD. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_cmd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_ADDR      (REGS_IOMUXC_BASE + 0x230)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_cmd_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_CMD. NOTE: Pad SD1_CMD
 * is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT for mode ALT1. -
 * Config Register IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0
 * mux port: CMD of instance: usdhc1. 001 Select mux mode: ALT1 mux port: TX_CLK of instance: fec.
 * 010 Select mux mode: ALT2 mux port: ROW[0] of instance: kpp. 011 Select mux mode: ALT3 mux port:
 * SDCE[5] of instance: epdc. 100 Select mux mode: ALT4 mux port: BS of instance: mshc. 101 Select
 * mux mode: ALT5 mux port: GPIO[14] of instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD1_CMD. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_CMD, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT0. NOTE: Pad SD1_DAT0 is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT0 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: RX_ER of instance: fec. 010 Select mux mode: ALT2 mux port: COL[1] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDCE[6] of instance: epdc. 100 Select mux mode: ALT4 mux port: DATA[0] of instance: mshc. 101 Select mux mode: ALT5 mux port: GPIO[11] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD1_DAT0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_ADDR      (REGS_IOMUXC_BASE + 0x234)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT0. NOTE: Pad SD1_DAT0
 * is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT for mode ALT1. -
 * Config Register IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT0 of
 * instance: usdhc1. 001 Select mux mode: ALT1 mux port: RX_ER of instance: fec. 010 Select mux
 * mode: ALT2 mux port: COL[1] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDCE[6] of
 * instance: epdc. 100 Select mux mode: ALT4 mux port: DATA[0] of instance: mshc. 101 Select mux
 * mode: ALT5 mux port: GPIO[11] of instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD1_DAT0. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT1. NOTE: Pad SD1_DAT1 is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT1 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: RX_DV of instance: fec. 010 Select mux mode: ALT2 mux port: ROW[1] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDCE[7] of instance: epdc. 100 Select mux mode: ALT4 mux port: DATA[1] of instance: mshc. 101 Select mux mode: ALT5 mux port: GPIO[8] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD1_DAT1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_ADDR      (REGS_IOMUXC_BASE + 0x238)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT1. NOTE: Pad SD1_DAT1
 * is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT for mode ALT1. -
 * Config Register IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT1 of
 * instance: usdhc1. 001 Select mux mode: ALT1 mux port: RX_DV of instance: fec. 010 Select mux
 * mode: ALT2 mux port: ROW[1] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDCE[7] of
 * instance: epdc. 100 Select mux mode: ALT4 mux port: DATA[1] of instance: mshc. 101 Select mux
 * mode: ALT5 mux port: GPIO[8] of instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD1_DAT1. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT2. NOTE: Pad SD1_DAT2 is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT2 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: RDATA[1] of instance: fec. 010 Select mux mode: ALT2 mux port: COL[2] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDCE[8] of instance: epdc. 100 Select mux mode: ALT4 mux port: DATA[2] of instance: mshc. 101 Select mux mode: ALT5 mux port: GPIO[13] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD1_DAT2. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_ADDR      (REGS_IOMUXC_BASE + 0x23c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat2_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT2. NOTE: Pad SD1_DAT2
 * is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT for mode ALT1.
 * - Config Register IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT2 of
 * instance: usdhc1. 001 Select mux mode: ALT1 mux port: RDATA[1] of instance: fec. 010 Select mux
 * mode: ALT2 mux port: COL[2] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDCE[8] of
 * instance: epdc. 100 Select mux mode: ALT4 mux port: DATA[2] of instance: mshc. 101 Select mux
 * mode: ALT5 mux port: GPIO[13] of instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD1_DAT2. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT3. NOTE: Pad SD1_DAT3 is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT3 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: TDATA[0] of instance: fec. 010 Select mux mode: ALT2 mux port: ROW[2] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDCE[9] of instance: epdc. 100 Select mux mode: ALT4 mux port: DATA[3] of instance: mshc. 101 Select mux mode: ALT5 mux port: GPIO[6] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD1_DAT3. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_ADDR      (REGS_IOMUXC_BASE + 0x240)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat3_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT3. NOTE: Pad SD1_DAT3
 * is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT for mode
 * ALT2. - Config Register IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT for mode ALT4. 000 Select mux
 * mode: ALT0 mux port: DAT3 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: TDATA[0] of
 * instance: fec. 010 Select mux mode: ALT2 mux port: ROW[2] of instance: kpp. 011 Select mux mode:
 * ALT3 mux port: SDCE[9] of instance: epdc. 100 Select mux mode: ALT4 mux port: DATA[3] of
 * instance: mshc. 101 Select mux mode: ALT5 mux port: GPIO[6] of instance: gpio5. 110 Reserved. 111
 * Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD1_DAT3. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT4. NOTE: Pad SD1_DAT4 is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT4 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: MDC of instance: fec. 010 Select mux mode: ALT2 mux port: COL[3] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDCLKN of instance: epdc. 100 Select mux mode: ALT4 mux port: RXD_MUX of instance: uart4. 101 Select mux mode: ALT5 mux port: GPIO[12] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD1_DAT4. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_ADDR      (REGS_IOMUXC_BASE + 0x244)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat4_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT4. NOTE: Pad SD1_DAT4
 * is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT for mode
 * ALT2. - Config Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux
 * mode: ALT0 mux port: DAT4 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: MDC of
 * instance: fec. 010 Select mux mode: ALT2 mux port: COL[3] of instance: kpp. 011 Select mux mode:
 * ALT3 mux port: SDCLKN of instance: epdc. 100 Select mux mode: ALT4 mux port: RXD_MUX of instance:
 * uart4. 101 Select mux mode: ALT5 mux port: GPIO[12] of instance: gpio5. 110 Reserved. 111
 * Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD1_DAT4. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT5. NOTE: Pad SD1_DAT5 is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT5 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: RDATA[0] of instance: fec. 010 Select mux mode: ALT2 mux port: ROW[3] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDOED of instance: epdc. 100 Select mux mode: ALT4 mux port: TXD_MUX of instance: uart4. 101 Select mux mode: ALT5 mux port: GPIO[9] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD1_DAT5. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_ADDR      (REGS_IOMUXC_BASE + 0x248)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat5_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT5. NOTE: Pad SD1_DAT5
 * is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT for mode ALT1.
 * - Config Register IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port:
 * DAT5 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: RDATA[0] of instance: fec. 010
 * Select mux mode: ALT2 mux port: ROW[3] of instance: kpp. 011 Select mux mode: ALT3 mux port:
 * SDOED of instance: epdc. 100 Select mux mode: ALT4 mux port: TXD_MUX of instance: uart4. 101
 * Select mux mode: ALT5 mux port: GPIO[9] of instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD1_DAT5. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT6. NOTE: Pad SD1_DAT6 is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT6 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: TX_EN of instance: fec. 010 Select mux mode: ALT2 mux port: COL[4] of instance: kpp. 011 Select mux mode: ALT3 mux port: SDOEZ of instance: epdc. 100 Select mux mode: ALT4 mux port: RTS of instance: uart4. 101 Select mux mode: ALT5 mux port: GPIO[7] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD1_DAT6. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_ADDR      (REGS_IOMUXC_BASE + 0x24c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat6_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT6. NOTE: Pad SD1_DAT6
 * is involved in Daisy Chain. - Config Register IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT for mode
 * ALT2. - Config Register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. 000 Select mux
 * mode: ALT0 mux port: DAT6 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: TX_EN of
 * instance: fec. 010 Select mux mode: ALT2 mux port: COL[4] of instance: kpp. 011 Select mux mode:
 * ALT3 mux port: SDOEZ of instance: epdc. 100 Select mux mode: ALT4 mux port: RTS of instance:
 * uart4. 101 Select mux mode: ALT5 mux port: GPIO[7] of instance: gpio5. 110 Reserved. 111
 * Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD1_DAT6. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT7. NOTE: Pad SD1_DAT7 is involved in Daisy Chain. - Config Register IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT7 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: TDATA[1] of instance: fec. 010 Select mux mode: ALT2 mux port: ROW[4] of instance: kpp. 011 Select mux mode: ALT3 mux port: PMIC_RDY of instance: ccm. 100 Select mux mode: ALT4 mux port: CTS of instance: uart4. 101 Select mux mode: ALT5 mux port: GPIO[10] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD1_DAT7. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_ADDR      (REGS_IOMUXC_BASE + 0x250)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat7_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD1_DAT7. NOTE: Pad SD1_DAT7
 * is involved in Daisy Chain. - Config Register IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT for
 * mode ALT3. - Config Register IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT for mode ALT2. - Config
 * Register IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux
 * port: DAT7 of instance: usdhc1. 001 Select mux mode: ALT1 mux port: TDATA[1] of instance: fec.
 * 010 Select mux mode: ALT2 mux port: ROW[4] of instance: kpp. 011 Select mux mode: ALT3 mux port:
 * PMIC_RDY of instance: ccm. 100 Select mux mode: ALT4 mux port: CTS of instance: uart4. 101 Select
 * mux mode: ALT5 mux port: GPIO[10] of instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD1_DAT7. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_CLK. NOTE: Pad SD2_CLK is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT for mode ALT7. 000 Select mux mode: ALT0 mux port: CLK of instance: usdhc2. 001 Select mux mode: ALT1 mux port: AUD4_RXFS of instance: audmux. 010 Select mux mode: ALT2 mux port: SCLK of instance: ecspi3. 011 Select mux mode: ALT3 mux port: D[0] of instance: csi. 100 Reserved. 101 Select mux mode: ALT5 mux port: GPIO[5] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD2_CLK. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_clk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_ADDR      (REGS_IOMUXC_BASE + 0x254)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_clk_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_CLK. NOTE: Pad SD2_CLK
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT for mode ALT7. 000 Select mux mode: ALT0
 * mux port: CLK of instance: usdhc2. 001 Select mux mode: ALT1 mux port: AUD4_RXFS of instance:
 * audmux. 010 Select mux mode: ALT2 mux port: SCLK of instance: ecspi3. 011 Select mux mode: ALT3
 * mux port: D[0] of instance: csi. 100 Reserved. 101 Select mux mode: ALT5 mux port: GPIO[5] of
 * instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD2_CLK. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CLK, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_CMD. NOTE: Pad SD2_CMD is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: CMD of instance: usdhc2. 001 Select mux mode: ALT1 mux port: AUD4_RXC of instance: audmux. 010 Select mux mode: ALT2 mux port: SS0 of instance: ecspi3. 011 Select mux mode: ALT3 mux port: D[1] of instance: csi. 100 Select mux mode: ALT4 mux port: EPITO of instance: epit1. 101 Select mux mode: ALT5 mux port: GPIO[4] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD2_CMD. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_cmd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_ADDR      (REGS_IOMUXC_BASE + 0x258)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_cmd_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_CMD. NOTE: Pad SD2_CMD
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: CMD
 * of instance: usdhc2. 001 Select mux mode: ALT1 mux port: AUD4_RXC of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: SS0 of instance: ecspi3. 011 Select mux mode: ALT3 mux port: D[1] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: EPITO of instance: epit1. 101 Select mux mode:
 * ALT5 mux port: GPIO[4] of instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD2_CMD. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_CMD, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT0. NOTE: Pad SD2_DAT0 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT0 of instance: usdhc2. 001 Select mux mode: ALT1 mux port: AUD4_RXD of instance: audmux. 010 Select mux mode: ALT2 mux port: MOSI of instance: ecspi3. 011 Select mux mode: ALT3 mux port: D[2] of instance: csi. 100 Select mux mode: ALT4 mux port: RTS of instance: uart5. 101 Select mux mode: ALT5 mux port: GPIO[1] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD2_DAT0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_ADDR      (REGS_IOMUXC_BASE + 0x25c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT0. NOTE: Pad SD2_DAT0
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT0
 * of instance: usdhc2. 001 Select mux mode: ALT1 mux port: AUD4_RXD of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: MOSI of instance: ecspi3. 011 Select mux mode: ALT3 mux port: D[2] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: RTS of instance: uart5. 101 Select mux mode:
 * ALT5 mux port: GPIO[1] of instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD2_DAT0. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT1. NOTE: Pad SD2_DAT1 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT1 of instance: usdhc2. 001 Select mux mode: ALT1 mux port: AUD4_TXC of instance: audmux. 010 Select mux mode: ALT2 mux port: MISO of instance: ecspi3. 011 Select mux mode: ALT3 mux port: D[3] of instance: csi. 100 Select mux mode: ALT4 mux port: CTS of instance: uart5. 101 Select mux mode: ALT5 mux port: GPIO[30] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD2_DAT1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_ADDR      (REGS_IOMUXC_BASE + 0x260)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT1. NOTE: Pad SD2_DAT1
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT1
 * of instance: usdhc2. 001 Select mux mode: ALT1 mux port: AUD4_TXC of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: MISO of instance: ecspi3. 011 Select mux mode: ALT3 mux port: D[3] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: CTS of instance: uart5. 101 Select mux mode:
 * ALT5 mux port: GPIO[30] of instance: gpio4. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD2_DAT1. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT2. NOTE: Pad SD2_DAT2 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_FEC_FEC_COL_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT2 of instance: usdhc2. 001 Select mux mode: ALT1 mux port: AUD4_TXFS of instance: audmux. 010 Select mux mode: ALT2 mux port: COL of instance: fec. 011 Select mux mode: ALT3 mux port: D[4] of instance: csi. 100 Select mux mode: ALT4 mux port: RXD_MUX of instance: uart5. 101 Select mux mode: ALT5 mux port: GPIO[3] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD2_DAT2. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_ADDR      (REGS_IOMUXC_BASE + 0x264)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat2_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT2. NOTE: Pad SD2_DAT2
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_FEC_FEC_COL_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port:
 * DAT2 of instance: usdhc2. 001 Select mux mode: ALT1 mux port: AUD4_TXFS of instance: audmux. 010
 * Select mux mode: ALT2 mux port: COL of instance: fec. 011 Select mux mode: ALT3 mux port: D[4] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: RXD_MUX of instance: uart5. 101 Select mux
 * mode: ALT5 mux port: GPIO[3] of instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD2_DAT2. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT3. NOTE: Pad SD2_DAT3 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: DAT3 of instance: usdhc2. 001 Select mux mode: ALT1 mux port: AUD4_TXD of instance: audmux. 010 Select mux mode: ALT2 mux port: RX_CLK of instance: fec. 011 Select mux mode: ALT3 mux port: D[5] of instance: csi. 100 Select mux mode: ALT4 mux port: TXD_MUX of instance: uart5. 101 Select mux mode: ALT5 mux port: GPIO[28] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD2_DAT3. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_ADDR      (REGS_IOMUXC_BASE + 0x268)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat3_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT3. NOTE: Pad SD2_DAT3
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port:
 * DAT3 of instance: usdhc2. 001 Select mux mode: ALT1 mux port: AUD4_TXD of instance: audmux. 010
 * Select mux mode: ALT2 mux port: RX_CLK of instance: fec. 011 Select mux mode: ALT3 mux port: D[5]
 * of instance: csi. 100 Select mux mode: ALT4 mux port: TXD_MUX of instance: uart5. 101 Select mux
 * mode: ALT5 mux port: GPIO[28] of instance: gpio4. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD2_DAT3. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT4. NOTE: Pad SD2_DAT4 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: DAT4 of instance: usdhc2. 001 Select mux mode: ALT1 mux port: DAT4 of instance: usdhc3. 010 Select mux mode: ALT2 mux port: RXD_MUX of instance: uart2. 011 Select mux mode: ALT3 mux port: D[6] of instance: csi. 100 Select mux mode: ALT4 mux port: OUT1 of instance: spdif. 101 Select mux mode: ALT5 mux port: GPIO[2] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD2_DAT4. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_ADDR      (REGS_IOMUXC_BASE + 0x26c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat4_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT4. NOTE: Pad SD2_DAT4
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT for mode ALT3.
 * - Config Register IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: DAT4 of
 * instance: usdhc2. 001 Select mux mode: ALT1 mux port: DAT4 of instance: usdhc3. 010 Select mux
 * mode: ALT2 mux port: RXD_MUX of instance: uart2. 011 Select mux mode: ALT3 mux port: D[6] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: OUT1 of instance: spdif. 101 Select mux mode:
 * ALT5 mux port: GPIO[2] of instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD2_DAT4. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT5. NOTE: Pad SD2_DAT5 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: DAT5 of instance: usdhc2. 001 Select mux mode: ALT1 mux port: DAT5 of instance: usdhc3. 010 Select mux mode: ALT2 mux port: TXD_MUX of instance: uart2. 011 Select mux mode: ALT3 mux port: D[7] of instance: csi. 100 Select mux mode: ALT4 mux port: IN1 of instance: spdif. 101 Select mux mode: ALT5 mux port: GPIO[31] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD2_DAT5. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_ADDR      (REGS_IOMUXC_BASE + 0x270)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat5_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT5. NOTE: Pad SD2_DAT5
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT for mode ALT3.
 * - Config Register IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: DAT5 of
 * instance: usdhc2. 001 Select mux mode: ALT1 mux port: DAT5 of instance: usdhc3. 010 Select mux
 * mode: ALT2 mux port: TXD_MUX of instance: uart2. 011 Select mux mode: ALT3 mux port: D[7] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: IN1 of instance: spdif. 101 Select mux mode:
 * ALT5 mux port: GPIO[31] of instance: gpio4. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD2_DAT5. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT6. NOTE: Pad SD2_DAT6 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: DAT6 of instance: usdhc2. 001 Select mux mode: ALT1 mux port: DAT6 of instance: usdhc3. 010 Select mux mode: ALT2 mux port: RTS of instance: uart2. 011 Select mux mode: ALT3 mux port: D[8] of instance: csi. 100 Select mux mode: ALT4 mux port: WP of instance: usdhc2. 101 Select mux mode: ALT5 mux port: GPIO[29] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD2_DAT6. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_ADDR      (REGS_IOMUXC_BASE + 0x274)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat6_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT6. NOTE: Pad SD2_DAT6
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT for mode ALT3.
 * - Config Register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: DAT6 of
 * instance: usdhc2. 001 Select mux mode: ALT1 mux port: DAT6 of instance: usdhc3. 010 Select mux
 * mode: ALT2 mux port: RTS of instance: uart2. 011 Select mux mode: ALT3 mux port: D[8] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: WP of instance: usdhc2. 101 Select mux mode:
 * ALT5 mux port: GPIO[29] of instance: gpio4. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD2_DAT6. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT7. NOTE: Pad SD2_DAT7 is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: DAT7 of instance: usdhc2. 001 Select mux mode: ALT1 mux port: DAT7 of instance: usdhc3. 010 Select mux mode: ALT2 mux port: CTS of instance: uart2. 011 Select mux mode: ALT3 mux port: D[9] of instance: csi. 100 Select mux mode: ALT4 mux port: CD of instance: usdhc2. 101 Select mux mode: ALT5 mux port: GPIO[0] of instance: gpio5. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD2_DAT7. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_ADDR      (REGS_IOMUXC_BASE + 0x278)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat7_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_DAT7. NOTE: Pad SD2_DAT7
 * is involved in Daisy Chain. - Config Register IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT for mode ALT3.
 * - Config Register IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT for mode ALT4. - Config Register
 * IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT for mode ALT1. 000 Select mux mode: ALT0 mux port: DAT7 of
 * instance: usdhc2. 001 Select mux mode: ALT1 mux port: DAT7 of instance: usdhc3. 010 Select mux
 * mode: ALT2 mux port: CTS of instance: uart2. 011 Select mux mode: ALT3 mux port: D[9] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: CD of instance: usdhc2. 101 Select mux mode:
 * ALT5 mux port: GPIO[0] of instance: gpio5. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD2_DAT7. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_RST. 000 Select mux mode: ALT0 mux port: RST of instance: usdhc2. 001 Select mux mode: ALT1 mux port: REF_OUT of instance: fec. 010 Select mux mode: ALT2 mux port: WDOG_B of instance: wdog2. 011 Select mux mode: ALT3 mux port: OUT1 of instance: spdif. 100 Select mux mode: ALT4 mux port: MCLK of instance: csi. 101 Select mux mode: ALT5 mux port: GPIO[27] of instance: gpio4. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD2_RST. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_rst_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_ADDR      (REGS_IOMUXC_BASE + 0x27c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_rst_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD2_RST. 000 Select mux
 * mode: ALT0 mux port: RST of instance: usdhc2. 001 Select mux mode: ALT1 mux port: REF_OUT of
 * instance: fec. 010 Select mux mode: ALT2 mux port: WDOG_B of instance: wdog2. 011 Select mux
 * mode: ALT3 mux port: OUT1 of instance: spdif. 100 Select mux mode: ALT4 mux port: MCLK of
 * instance: csi. 101 Select mux mode: ALT5 mux port: GPIO[27] of instance: gpio4. 110 Reserved. 111
 * Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD2_RST. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD2_RST, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD3_CLK. NOTE: Pad SD3_CLK is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: CLK of instance: usdhc3. 001 Select mux mode: ALT1 mux port: AUD5_RXFS of instance: audmux. 010 Select mux mode: ALT2 mux port: COL[5] of instance: kpp. 011 Select mux mode: ALT3 mux port: D[10] of instance: csi. 100 Select mux mode: ALT4 mux port: WDOG_RST_B_DEB of instance: wdog1. 101 Select mux mode: ALT5 mux port: GPIO[18] of instance: gpio5. 110 Select mux mode: ALT6 mux port: USBOTG1_PWR of instance: usb. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD3_CLK. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_clk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_ADDR      (REGS_IOMUXC_BASE + 0x280)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_clk_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD3_CLK. NOTE: Pad SD3_CLK
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT for mode ALT3. - Config
 * Register IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * CLK of instance: usdhc3. 001 Select mux mode: ALT1 mux port: AUD5_RXFS of instance: audmux. 010
 * Select mux mode: ALT2 mux port: COL[5] of instance: kpp. 011 Select mux mode: ALT3 mux port:
 * D[10] of instance: csi. 100 Select mux mode: ALT4 mux port: WDOG_RST_B_DEB of instance: wdog1.
 * 101 Select mux mode: ALT5 mux port: GPIO[18] of instance: gpio5. 110 Select mux mode: ALT6 mux
 * port: USBOTG1_PWR of instance: usb. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD3_CLK. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CLK, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD3_CMD. NOTE: Pad SD3_CMD is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: CMD of instance: usdhc3. 001 Select mux mode: ALT1 mux port: AUD5_RXC of instance: audmux. 010 Select mux mode: ALT2 mux port: ROW[5] of instance: kpp. 011 Select mux mode: ALT3 mux port: D[11] of instance: csi. 100 Select mux mode: ALT4 mux port: USBOTG2_ID of instance: anatop. 101 Select mux mode: ALT5 mux port: GPIO[21] of instance: gpio5. 110 Select mux mode: ALT6 mux port: USBOTG2_PWR of instance: usb. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD3_CMD. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_cmd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_ADDR      (REGS_IOMUXC_BASE + 0x284)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_cmd_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD3_CMD. NOTE: Pad SD3_CMD
 * is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT for mode
 * ALT4. - Config Register IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: CMD of
 * instance: usdhc3. 001 Select mux mode: ALT1 mux port: AUD5_RXC of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: ROW[5] of instance: kpp. 011 Select mux mode: ALT3 mux port: D[11] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: USBOTG2_ID of instance: anatop. 101 Select mux
 * mode: ALT5 mux port: GPIO[21] of instance: gpio5. 110 Select mux mode: ALT6 mux port: USBOTG2_PWR
 * of instance: usb. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD3_CMD. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_CMD, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD3_DAT0. NOTE: Pad SD3_DAT0 is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT for mode ALT4. - Config Register IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: DAT0 of instance: usdhc3. 001 Select mux mode: ALT1 mux port: AUD5_RXD of instance: audmux. 010 Select mux mode: ALT2 mux port: COL[6] of instance: kpp. 011 Select mux mode: ALT3 mux port: D[12] of instance: csi. 100 Select mux mode: ALT4 mux port: USBOTG1_ID of instance: anatop. 101 Select mux mode: ALT5 mux port: GPIO[19] of instance: gpio5. 110 Select mux mode: ALT6 mux port: JTAG_ACT of instance: sjc. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD3_DAT0. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_dat0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_ADDR      (REGS_IOMUXC_BASE + 0x288)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_dat0_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD3_DAT0. NOTE: Pad SD3_DAT0
 * is involved in Daisy Chain. - Config Register IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT for mode
 * ALT4. - Config Register IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT for mode ALT1. - Config
 * Register IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: DAT0 of
 * instance: usdhc3. 001 Select mux mode: ALT1 mux port: AUD5_RXD of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: COL[6] of instance: kpp. 011 Select mux mode: ALT3 mux port: D[12] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: USBOTG1_ID of instance: anatop. 101 Select mux
 * mode: ALT5 mux port: GPIO[19] of instance: gpio5. 110 Select mux mode: ALT6 mux port: JTAG_ACT of
 * instance: sjc. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD3_DAT0. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD3_DAT1. NOTE: Pad SD3_DAT1 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port: DAT1 of instance: usdhc3. 001 Select mux mode: ALT1 mux port: AUD5_TXC of instance: audmux. 010 Select mux mode: ALT2 mux port: ROW[6] of instance: kpp. 011 Select mux mode: ALT3 mux port: D[13] of instance: csi. 100 Select mux mode: ALT4 mux port: VSELECT of instance: usdhc1. 101 Select mux mode: ALT5 mux port: GPIO[20] of instance: gpio5. 110 Select mux mode: ALT6 mux port: DE_B of instance: sjc. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD3_DAT1. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_dat1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_ADDR      (REGS_IOMUXC_BASE + 0x28c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_dat1_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD3_DAT1. NOTE: Pad SD3_DAT1
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT for mode ALT3. - Config
 * Register IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT for mode ALT2. 000 Select mux mode: ALT0 mux port:
 * DAT1 of instance: usdhc3. 001 Select mux mode: ALT1 mux port: AUD5_TXC of instance: audmux. 010
 * Select mux mode: ALT2 mux port: ROW[6] of instance: kpp. 011 Select mux mode: ALT3 mux port:
 * D[13] of instance: csi. 100 Select mux mode: ALT4 mux port: VSELECT of instance: usdhc1. 101
 * Select mux mode: ALT5 mux port: GPIO[20] of instance: gpio5. 110 Select mux mode: ALT6 mux port:
 * DE_B of instance: sjc. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD3_DAT1. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD3_DAT2. NOTE: Pad SD3_DAT2 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: DAT2 of instance: usdhc3. 001 Select mux mode: ALT1 mux port: AUD5_TXFS of instance: audmux. 010 Select mux mode: ALT2 mux port: COL[7] of instance: kpp. 011 Select mux mode: ALT3 mux port: D[14] of instance: csi. 100 Select mux mode: ALT4 mux port: EPITO of instance: epit1. 101 Select mux mode: ALT5 mux port: GPIO[16] of instance: gpio5. 110 Select mux mode: ALT6 mux port: USBOTG2_OC of instance: usb. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD3_DAT2. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_dat2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_ADDR      (REGS_IOMUXC_BASE + 0x290)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_dat2_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD3_DAT2. NOTE: Pad SD3_DAT2
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT for
 * mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT for mode ALT3. - Config
 * Register IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: DAT2
 * of instance: usdhc3. 001 Select mux mode: ALT1 mux port: AUD5_TXFS of instance: audmux. 010
 * Select mux mode: ALT2 mux port: COL[7] of instance: kpp. 011 Select mux mode: ALT3 mux port:
 * D[14] of instance: csi. 100 Select mux mode: ALT4 mux port: EPITO of instance: epit1. 101 Select
 * mux mode: ALT5 mux port: GPIO[16] of instance: gpio5. 110 Select mux mode: ALT6 mux port:
 * USBOTG2_OC of instance: usb. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD3_DAT2. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3 - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD3_DAT3. NOTE: Pad SD3_DAT3 is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT for mode ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: DAT3 of instance: usdhc3. 001 Select mux mode: ALT1 mux port: AUD5_TXD of instance: audmux. 010 Select mux mode: ALT2 mux port: ROW[7] of instance: kpp. 011 Select mux mode: ALT3 mux port: D[15] of instance: csi. 100 Select mux mode: ALT4 mux port: EPITO of instance: epit2. 101 Select mux mode: ALT5 mux port: GPIO[17] of instance: gpio5. 110 Select mux mode: ALT6 mux port: USBOTG1_OC of instance: usb. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad SD3_DAT3. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_dat3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3 register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_ADDR      (REGS_IOMUXC_BASE + 0x294)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_dat3_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: SD3_DAT3. NOTE: Pad SD3_DAT3
 * is involved in Daisy Chain. - Config Register IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT for mode
 * ALT1. - Config Register IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT for mode ALT3. - Config Register
 * IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT for mode ALT6. 000 Select mux mode: ALT0 mux port: DAT3 of
 * instance: usdhc3. 001 Select mux mode: ALT1 mux port: AUD5_TXD of instance: audmux. 010 Select
 * mux mode: ALT2 mux port: ROW[7] of instance: kpp. 011 Select mux mode: ALT3 mux port: D[15] of
 * instance: csi. 100 Select mux mode: ALT4 mux port: EPITO of instance: epit2. 101 Select mux mode:
 * ALT5 mux port: GPIO[17] of instance: gpio5. 110 Select mux mode: ALT6 mux port: USBOTG1_OC of
 * instance: usb. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad SD3_DAT3. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: UART1_RXD. NOTE: Pad UART1_RXD is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_COL_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: RXD_MUX of instance: uart1. 001 Select mux mode: ALT1 mux port: PWMO of instance: pwm1. 010 Select mux mode: ALT2 mux port: RXD_MUX of instance: uart4. 011 Select mux mode: ALT3 mux port: COL of instance: fec. 100 Select mux mode: ALT4 mux port: RXD_MUX of instance: uart5. 101 Select mux mode: ALT5 mux port: GPIO[16] of instance: gpio3. 110 Reserved. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad UART1_RXD. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_uart1_rxd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_ADDR      (REGS_IOMUXC_BASE + 0x298)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_uart1_rxd_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: UART1_RXD. NOTE: Pad
 * UART1_RXD is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_COL_SELECT_INPUT for mode
 * ALT3. - Config Register IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT0. - Config
 * Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port:
 * RXD_MUX of instance: uart1. 001 Select mux mode: ALT1 mux port: PWMO of instance: pwm1. 010
 * Select mux mode: ALT2 mux port: RXD_MUX of instance: uart4. 011 Select mux mode: ALT3 mux port:
 * COL of instance: fec. 100 Select mux mode: ALT4 mux port: RXD_MUX of instance: uart5. 101 Select
 * mux mode: ALT5 mux port: GPIO[16] of instance: gpio3. 110 Reserved. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad UART1_RXD. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_RXD, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: UART1_TXD. NOTE: Pad UART1_TXD is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT for mode ALT3. - Config Register IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT0. - Config Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. - Config Register IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port: TXD_MUX of instance: uart1. 001 Select mux mode: ALT1 mux port: PWMO of instance: pwm2. 010 Select mux mode: ALT2 mux port: TXD_MUX of instance: uart4. 011 Select mux mode: ALT3 mux port: RX_CLK of instance: fec. 100 Select mux mode: ALT4 mux port: TXD_MUX of instance: uart5. 101 Select mux mode: ALT5 mux port: GPIO[17] of instance: gpio3. 110 Reserved. 111 Select mux mode: ALT7 mux port: DCD of instance: uart5.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad UART1_TXD. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_uart1_txd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_ADDR      (REGS_IOMUXC_BASE + 0x29c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_uart1_txd_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 8 iomux modes to be used for pad: UART1_TXD. NOTE: Pad
 * UART1_TXD is involved in Daisy Chain. - Config Register IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT for
 * mode ALT3. - Config Register IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT0. - Config
 * Register IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT2. - Config Register
 * IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT for mode ALT4. 000 Select mux mode: ALT0 mux port:
 * TXD_MUX of instance: uart1. 001 Select mux mode: ALT1 mux port: PWMO of instance: pwm2. 010
 * Select mux mode: ALT2 mux port: TXD_MUX of instance: uart4. 011 Select mux mode: ALT3 mux port:
 * RX_CLK of instance: fec. 100 Select mux mode: ALT4 mux port: TXD_MUX of instance: uart5. 101
 * Select mux mode: ALT5 mux port: GPIO[17] of instance: gpio3. 110 Reserved. 111 Select mux mode:
 * ALT7 mux port: DCD of instance: uart5.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad UART1_TXD. 0 Input Path is determined by functionality
 * of the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_UART1_TXD, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B - SW_MUX_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MUX_MODE : 3; //!< MUX Mode Select Field. Select 1 of 5 iomux modes to be used for pad: WDOG_B. 000 Select mux mode: ALT0 mux port: WDOG_B of instance: wdog1. 001 Select mux mode: ALT1 mux port: WDOG_RST_B_DEB of instance: wdog1. 010 Select mux mode: ALT2 mux port: RI of instance: uart5. 101 Select mux mode: ALT5 mux port: GPIO[18] of instance: gpio3. 111 Reserved.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SION : 1; //!< Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE functionality. 1 Force input path of pad WDOG_B. 0 Input Path is determined by functionality of the selected mux mode (regular).
        unsigned RESERVED1 : 27; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_mux_ctl_pad_wdog_b_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B register
 */
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_ADDR      (REGS_IOMUXC_BASE + 0x2a0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B           (*(volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_wdog_b_t *) HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_ADDR)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_RD()      (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B.U)
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_WR(v)     (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B.U = (v))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_SET(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_CLR(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_TOG(v)    (HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_WR(HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B, field MUX_MODE[2:0] (RW)
 *
 * MUX Mode Select Field. Select 1 of 5 iomux modes to be used for pad: WDOG_B. 000 Select mux mode:
 * ALT0 mux port: WDOG_B of instance: wdog1. 001 Select mux mode: ALT1 mux port: WDOG_RST_B_DEB of
 * instance: wdog1. 010 Select mux mode: ALT2 mux port: RI of instance: uart5. 101 Select mux mode:
 * ALT5 mux port: GPIO[18] of instance: gpio3. 111 Reserved.
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_MUX_MODE      (0)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_MUX_MODE      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_MUX_MODE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_MUX_MODE)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_MUX_MODE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_MUX_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MUX_MODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_MUX_MODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B, MUX_MODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B, field SION[4:4] (RW)
 *
 * Software Input On Field. Force the selected mux mode Input path no matter of MUX_MODE
 * functionality. 1 Force input path of pad WDOG_B. 0 Input Path is determined by functionality of
 * the selected mux mode (regular).
 */

#define BP_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_SION      (4)
#define BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_SION      (0x00000010)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_SION(v)   ((((reg32_t) v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_SION)
#else
#define BF_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_SION(v)   (((v) << 4) & BM_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_SION)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SION field to a new value.
#define BW_IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B_SION(v)   BF_CS1(IOMUXC_IOMUXC_SW_MUX_CTL_PAD_WDOG_B, SION, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: AUD_MCLK. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: AUD_MCLK. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: AUD_MCLK. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: AUD_MCLK. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: AUD_MCLK. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: AUD_MCLK. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: AUD_MCLK. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: AUD_MCLK. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: AUD_MCLK. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_mclk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_ADDR      (REGS_IOMUXC_BASE + 0x2a4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_mclk_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: AUD_MCLK. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: AUD_MCLK. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: AUD_MCLK. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: AUD_MCLK. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: AUD_MCLK. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: AUD_MCLK. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: AUD_MCLK. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: AUD_MCLK. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: AUD_MCLK. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: AUD_RXC. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: AUD_RXC. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: AUD_RXC. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: AUD_RXC. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: AUD_RXC. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: AUD_RXC. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: AUD_RXC. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: AUD_RXC. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: AUD_RXC. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_rxc_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_ADDR      (REGS_IOMUXC_BASE + 0x2a8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_rxc_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: AUD_RXC. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: AUD_RXC. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: AUD_RXC. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: AUD_RXC. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: AUD_RXC. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: AUD_RXC. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: AUD_RXC. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: AUD_RXC. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: AUD_RXC. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXC, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: AUD_RXD. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: AUD_RXD. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: AUD_RXD. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: AUD_RXD. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: AUD_RXD. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: AUD_RXD. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: AUD_RXD. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: AUD_RXD. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: AUD_RXD. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_rxd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_ADDR      (REGS_IOMUXC_BASE + 0x2ac)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_rxd_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: AUD_RXD. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: AUD_RXD. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: AUD_RXD. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: AUD_RXD. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: AUD_RXD. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: AUD_RXD. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: AUD_RXD. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: AUD_RXD. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: AUD_RXD. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXD, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: AUD_RXFS. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: AUD_RXFS. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: AUD_RXFS. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: AUD_RXFS. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: AUD_RXFS. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: AUD_RXFS. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: AUD_RXFS. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: AUD_RXFS. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: AUD_RXFS. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_rxfs_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_ADDR      (REGS_IOMUXC_BASE + 0x2b0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_rxfs_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: AUD_RXFS. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: AUD_RXFS. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: AUD_RXFS. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: AUD_RXFS. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: AUD_RXFS. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: AUD_RXFS. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: AUD_RXFS. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: AUD_RXFS. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: AUD_RXFS. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: AUD_TXC. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: AUD_TXC. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: AUD_TXC. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: AUD_TXC. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: AUD_TXC. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: AUD_TXC. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: AUD_TXC. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: AUD_TXC. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: AUD_TXC. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_txc_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_ADDR      (REGS_IOMUXC_BASE + 0x2b4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_txc_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: AUD_TXC. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: AUD_TXC. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: AUD_TXC. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: AUD_TXC. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: AUD_TXC. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: AUD_TXC. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: AUD_TXC. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: AUD_TXC. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: AUD_TXC. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXC, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: AUD_TXD. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: AUD_TXD. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: AUD_TXD. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: AUD_TXD. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: AUD_TXD. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: AUD_TXD. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: AUD_TXD. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: AUD_TXD. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: AUD_TXD. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_txd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_ADDR      (REGS_IOMUXC_BASE + 0x2b8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_txd_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: AUD_TXD. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: AUD_TXD. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: AUD_TXD. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: AUD_TXD. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: AUD_TXD. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: AUD_TXD. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: AUD_TXD. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: AUD_TXD. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: AUD_TXD. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXD, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: AUD_TXFS. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: AUD_TXFS. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: AUD_TXFS. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: AUD_TXFS. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: AUD_TXFS. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: AUD_TXFS. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: AUD_TXFS. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: AUD_TXFS. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: AUD_TXFS. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_txfs_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_ADDR      (REGS_IOMUXC_BASE + 0x2bc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_txfs_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: AUD_TXFS. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: AUD_TXFS. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: AUD_TXFS. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: AUD_TXFS. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: AUD_TXFS. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: AUD_TXFS. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: AUD_TXFS. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: AUD_TXFS. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: AUD_TXFS. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A0. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A0. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_ADDR      (REGS_IOMUXC_BASE + 0x2c0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A0. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A0. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A0, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A1. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A1. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_ADDR      (REGS_IOMUXC_BASE + 0x2c4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A1. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A1. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A1, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A10. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A10. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A10. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a10_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_ADDR      (REGS_IOMUXC_BASE + 0x2c8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a10_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A10. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A10. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A10. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A10, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A11. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A11. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A11. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a11_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_ADDR      (REGS_IOMUXC_BASE + 0x2cc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a11_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A11. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A11. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A11. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A11, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A12. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A12. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A12. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a12_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_ADDR      (REGS_IOMUXC_BASE + 0x2d0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a12_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A12. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A12. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A12. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A12, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A13. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A13. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A13. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a13_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_ADDR      (REGS_IOMUXC_BASE + 0x2d4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a13_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A13. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A13. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A13. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A13, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A14. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A14. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A14. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a14_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_ADDR      (REGS_IOMUXC_BASE + 0x2d8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a14_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A14. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A14. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A14. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A14, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A15. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A15. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A15. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a15_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_ADDR      (REGS_IOMUXC_BASE + 0x2dc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a15_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A15. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A15. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A15. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A15, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A2. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A2. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A2. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_ADDR      (REGS_IOMUXC_BASE + 0x2e0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A2. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A2. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A2. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A2, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A3. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A3. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A3. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_ADDR      (REGS_IOMUXC_BASE + 0x2e4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a3_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A3. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A3. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A3. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A3, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A4. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A4. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A4. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_ADDR      (REGS_IOMUXC_BASE + 0x2e8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a4_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A4. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A4. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A4. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A4, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A5. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A5. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A5. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_ADDR      (REGS_IOMUXC_BASE + 0x2ec)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a5_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A5. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A5. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A5. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A5, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A6. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A6. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A6. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_ADDR      (REGS_IOMUXC_BASE + 0x2f0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a6_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A6. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A6. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A6. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A6, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A7. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A7. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A7. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_ADDR      (REGS_IOMUXC_BASE + 0x2f4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a7_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A7. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A7. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A7. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A7, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A8. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A8. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A8. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a8_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_ADDR      (REGS_IOMUXC_BASE + 0x2f8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a8_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A8. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A8. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A8. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A8, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_A9. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_A9. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A9. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a9_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_ADDR      (REGS_IOMUXC_BASE + 0x2fc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a9_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_A9. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_A9. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_A9. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_A9, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_CAS. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_CAS. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_CAS. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_CAS. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_cas_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_ADDR      (REGS_IOMUXC_BASE + 0x300)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_cas_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_CAS. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_CAS. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_CAS. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_CAS. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_CS0. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_CS0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_CS0. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_cs0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_ADDR      (REGS_IOMUXC_BASE + 0x304)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_cs0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_CTLDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_CS0. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_CS0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_CS0. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_CS1. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_CS1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_CS1. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_cs1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_ADDR      (REGS_IOMUXC_BASE + 0x308)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_cs1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_CTLDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_CS1. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_CS1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_CS1. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_DQM0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_DQM0. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_DQM0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_DQM0. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_dqm0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_ADDR      (REGS_IOMUXC_BASE + 0x30c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_dqm0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_DQM0. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_DQM0. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_DQM0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_DQM0. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_DQM1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_DQM1. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_DQM1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_DQM1. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_dqm1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_ADDR      (REGS_IOMUXC_BASE + 0x310)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_dqm1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_DQM1. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_DQM1. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_DQM1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_DQM1. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_DQM2. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_DQM2. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_DQM2. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_DQM2. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_dqm2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_ADDR      (REGS_IOMUXC_BASE + 0x314)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_dqm2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_DQM2. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_DQM2. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_DQM2. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_DQM2. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_DQM3. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_DQM3. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_DQM3. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_DQM3. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_dqm3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_ADDR      (REGS_IOMUXC_BASE + 0x318)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_dqm3_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_DQM3. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_DQM3. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_DQM3. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_DQM3. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_RAS. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_RAS. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_RAS. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_RAS. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_ras_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_ADDR      (REGS_IOMUXC_BASE + 0x31c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_ras_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_RAS. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_RAS. 000 off 001 120 Ohm ODT
 * 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_RAS. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_RAS. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_RESET. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_RESET. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: DRAM_RESET. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: DRAM_RESET. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: DRAM_RESET. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_RESET. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_RESET. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Select one out of next values for pad: DRAM_RESET. 00 LPDDR1 / DDR3 / (DDR2 ODT) modes 01 DDR2 driver mode 10 LPDDR2 mode 11 RESERVED
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_reset_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_ADDR      (REGS_IOMUXC_BASE + 0x320)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_reset_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_RESET. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_RESET. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: DRAM_RESET. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: DRAM_RESET. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: DRAM_RESET. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_RESET. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_RESET. 0 CMOS input type
 * 1 Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Select one out of next values for pad: DRAM_RESET. 00 LPDDR1 / DDR3 / (DDR2 ODT)
 * modes 01 DDR2 driver mode 10 LPDDR2 mode 11 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_SDBA0. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_SDBA0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDBA0. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdba0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_ADDR      (REGS_IOMUXC_BASE + 0x324)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdba0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_SDBA0. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_SDBA0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDBA0. 0 CMOS input type
 * 1 Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_SDBA1. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_SDBA1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDBA1. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdba1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_ADDR      (REGS_IOMUXC_BASE + 0x328)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdba1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_ADDDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_SDBA1. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_SDBA1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDBA1. 0 CMOS input type
 * 1 Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_SDBA2. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDBA2. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: DRAM_SDBA2. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_SDBA2. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDBA2. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdba2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_ADDR      (REGS_IOMUXC_BASE + 0x32c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdba2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_CTLDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_SDBA2. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDBA2. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: DRAM_SDBA2. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_SDBA2. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDBA2. 0 CMOS input type
 * 1 Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_SDCKE0. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDCKE0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: DRAM_SDCKE0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDCKE0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_SDCKE0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDCKE0. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdcke0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_ADDR      (REGS_IOMUXC_BASE + 0x330)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdcke0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_CTLDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_SDCKE0. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDCKE0. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: DRAM_SDCKE0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDCKE0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_SDCKE0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDCKE0. 0 CMOS input type
 * 1 Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_SDCKE1. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDCKE1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: DRAM_SDCKE1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDCKE1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_SDCKE1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDCKE1. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdcke1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_ADDR      (REGS_IOMUXC_BASE + 0x334)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdcke1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_CTLDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_SDCKE1. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDCKE1. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: DRAM_SDCKE1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDCKE1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_SDCKE1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDCKE1. 0 CMOS input type
 * 1 Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_SDCLK_0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_SDCLK_0. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_SDCLK_0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDCLK_0. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 0 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdclk_0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_ADDR      (REGS_IOMUXC_BASE + 0x338)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdclk_0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_SDCLK_0. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_SDCLK_0. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_SDCLK_0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDCLK_0. 0 CMOS input
 * type 1 Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 0 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_SDODT0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_SDODT0. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDODT0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: DRAM_SDODT0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDODT0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_SDODT0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDODT0. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdodt0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_ADDR      (REGS_IOMUXC_BASE + 0x33c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdodt0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_SDODT0. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_SDODT0. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDODT0. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: DRAM_SDODT0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDODT0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_SDODT0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDODT0. 0 CMOS input type
 * 1 Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_SDODT1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_SDODT1. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDODT1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: DRAM_SDODT1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDODT1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_SDODT1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDODT1. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdodt1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_ADDR      (REGS_IOMUXC_BASE + 0x340)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdodt1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_SDODT1. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_SDODT1. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDODT1. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: DRAM_SDODT1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDODT1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_SDODT1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDODT1. 0 CMOS input type
 * 1 Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_SDQS0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Read Only Field 0 off
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDQS0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: DRAM_SDQS0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDQS0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS 0 Hysteresis Disabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL 0 CMOS input type
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdqs0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_ADDR      (REGS_IOMUXC_BASE + 0x344)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdqs0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_SDQS0. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, field ODT[10:8] (RW)
 *
 * On Die Termination Field Read Only Field 0 off
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDQS0. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: DRAM_SDQS0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDQS0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRHYS 0 Hysteresis Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL 0 CMOS input type
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_SDQS1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Read Only Field 0 off
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDQS1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: DRAM_SDQS1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDQS1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS 0 Hysteresis Disabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL 0 CMOS input type
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdqs1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_ADDR      (REGS_IOMUXC_BASE + 0x348)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdqs1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_SDQS1. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, field ODT[10:8] (RW)
 *
 * On Die Termination Field Read Only Field 0 off
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDQS1. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: DRAM_SDQS1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDQS1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRHYS 0 Hysteresis Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL 0 CMOS input type
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_SDQS2. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Read Only Field 0 off
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDQS2. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: DRAM_SDQS2. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDQS2. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS 0 Hysteresis Disabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL 0 CMOS input type
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdqs2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_ADDR      (REGS_IOMUXC_BASE + 0x34c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdqs2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_SDQS2. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, field ODT[10:8] (RW)
 *
 * On Die Termination Field Read Only Field 0 off
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDQS2. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: DRAM_SDQS2. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDQS2. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRHYS 0 Hysteresis Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL 0 CMOS input type
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: DRAM_SDQS3. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Read Only Field 0 off
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDQS3. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: DRAM_SDQS3. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDQS3. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRHYS 0 Hysteresis Disabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL 0 CMOS input type
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdqs3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_ADDR      (REGS_IOMUXC_BASE + 0x350)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdqs3_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: DRAM_SDQS3. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, field ODT[10:8] (RW)
 *
 * On Die Termination Field Read Only Field 0 off
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: DRAM_SDQS3. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: DRAM_SDQS3. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: DRAM_SDQS3. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRHYS 0 Hysteresis Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL 0 CMOS input type
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_CTLDS 0 output driver disabled;
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Select one out of next values for pad: DRAM_SDWE. 000 off 001 120 Ohm ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: DRAM_SDWE. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDWE. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Read Only Field Can be configured using Group Control Register: IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdwe_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_ADDR      (REGS_IOMUXC_BASE + 0x354)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdwe_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_CTLDS 0 output driver disabled;
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, field ODT[10:8] (RW)
 *
 * On Die Termination Field Select one out of next values for pad: DRAM_SDWE. 000 off 001 120 Ohm
 * ODT 010 60 Ohm ODT 011 40 Ohm ODT 100 30 Ohm ODT 101 RESERVED 110 20 Ohm ODT 111 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPKE 0 Pull/Keeper Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDRPK 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: DRAM_SDWE. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: DRAM_SDWE. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Read Only Field Can be configured using Group Control Register:
 * IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE 0 LPDDR1 / DDR3 / (DDR2 ODT) modes
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: ECSPI1_MISO. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: ECSPI1_MISO. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: ECSPI1_MISO. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: ECSPI1_MISO. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: ECSPI1_MISO. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: ECSPI1_MISO. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: ECSPI1_MISO. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: ECSPI1_MISO. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: ECSPI1_MISO. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi1_miso_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_ADDR      (REGS_IOMUXC_BASE + 0x358)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi1_miso_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: ECSPI1_MISO. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: ECSPI1_MISO. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: ECSPI1_MISO. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: ECSPI1_MISO. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: ECSPI1_MISO. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: ECSPI1_MISO. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: ECSPI1_MISO. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: ECSPI1_MISO. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: ECSPI1_MISO. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: ECSPI1_MOSI. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: ECSPI1_MOSI. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: ECSPI1_MOSI. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: ECSPI1_MOSI. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: ECSPI1_MOSI. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: ECSPI1_MOSI. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: ECSPI1_MOSI. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: ECSPI1_MOSI. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: ECSPI1_MOSI. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi1_mosi_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_ADDR      (REGS_IOMUXC_BASE + 0x35c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi1_mosi_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: ECSPI1_MOSI. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: ECSPI1_MOSI. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: ECSPI1_MOSI. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: ECSPI1_MOSI. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: ECSPI1_MOSI. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: ECSPI1_MOSI. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: ECSPI1_MOSI. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: ECSPI1_MOSI. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: ECSPI1_MOSI. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: ECSPI1_SCLK. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: ECSPI1_SCLK. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: ECSPI1_SCLK. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: ECSPI1_SCLK. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: ECSPI1_SCLK. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: ECSPI1_SCLK. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: ECSPI1_SCLK. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: ECSPI1_SCLK. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: ECSPI1_SCLK. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi1_sclk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_ADDR      (REGS_IOMUXC_BASE + 0x360)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi1_sclk_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: ECSPI1_SCLK. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: ECSPI1_SCLK. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: ECSPI1_SCLK. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: ECSPI1_SCLK. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: ECSPI1_SCLK. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: ECSPI1_SCLK. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: ECSPI1_SCLK. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: ECSPI1_SCLK. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: ECSPI1_SCLK. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: ECSPI1_SS0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: ECSPI1_SS0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: ECSPI1_SS0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: ECSPI1_SS0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: ECSPI1_SS0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: ECSPI1_SS0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: ECSPI1_SS0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: ECSPI1_SS0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: ECSPI1_SS0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi1_ss0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_ADDR      (REGS_IOMUXC_BASE + 0x364)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi1_ss0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: ECSPI1_SS0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: ECSPI1_SS0. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: ECSPI1_SS0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: ECSPI1_SS0. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: ECSPI1_SS0. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: ECSPI1_SS0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: ECSPI1_SS0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: ECSPI1_SS0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: ECSPI1_SS0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: ECSPI2_MISO. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: ECSPI2_MISO. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: ECSPI2_MISO. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: ECSPI2_MISO. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: ECSPI2_MISO. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: ECSPI2_MISO. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: ECSPI2_MISO. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: ECSPI2_MISO. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: ECSPI2_MISO. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi2_miso_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_ADDR      (REGS_IOMUXC_BASE + 0x368)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi2_miso_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: ECSPI2_MISO. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: ECSPI2_MISO. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: ECSPI2_MISO. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: ECSPI2_MISO. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: ECSPI2_MISO. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: ECSPI2_MISO. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: ECSPI2_MISO. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: ECSPI2_MISO. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: ECSPI2_MISO. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: ECSPI2_MOSI. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: ECSPI2_MOSI. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: ECSPI2_MOSI. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: ECSPI2_MOSI. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: ECSPI2_MOSI. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: ECSPI2_MOSI. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: ECSPI2_MOSI. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: ECSPI2_MOSI. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: ECSPI2_MOSI. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi2_mosi_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_ADDR      (REGS_IOMUXC_BASE + 0x36c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi2_mosi_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: ECSPI2_MOSI. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: ECSPI2_MOSI. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: ECSPI2_MOSI. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: ECSPI2_MOSI. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: ECSPI2_MOSI. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: ECSPI2_MOSI. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: ECSPI2_MOSI. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: ECSPI2_MOSI. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: ECSPI2_MOSI. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: ECSPI2_SCLK. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: ECSPI2_SCLK. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: ECSPI2_SCLK. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: ECSPI2_SCLK. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: ECSPI2_SCLK. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: ECSPI2_SCLK. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: ECSPI2_SCLK. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: ECSPI2_SCLK. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: ECSPI2_SCLK. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi2_sclk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_ADDR      (REGS_IOMUXC_BASE + 0x370)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi2_sclk_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: ECSPI2_SCLK. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: ECSPI2_SCLK. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: ECSPI2_SCLK. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: ECSPI2_SCLK. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: ECSPI2_SCLK. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: ECSPI2_SCLK. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: ECSPI2_SCLK. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: ECSPI2_SCLK. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: ECSPI2_SCLK. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: ECSPI2_SS0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: ECSPI2_SS0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: ECSPI2_SS0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: ECSPI2_SS0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: ECSPI2_SS0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: ECSPI2_SS0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: ECSPI2_SS0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: ECSPI2_SS0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: ECSPI2_SS0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi2_ss0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_ADDR      (REGS_IOMUXC_BASE + 0x374)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi2_ss0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: ECSPI2_SS0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: ECSPI2_SS0. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: ECSPI2_SS0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: ECSPI2_SS0. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: ECSPI2_SS0. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: ECSPI2_SS0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: ECSPI2_SS0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: ECSPI2_SS0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: ECSPI2_SS0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_BDR0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_BDR0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_BDR0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_BDR0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_BDR0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_BDR0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_BDR0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_BDR0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_BDR0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_bdr0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_ADDR      (REGS_IOMUXC_BASE + 0x378)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_bdr0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_BDR0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_BDR0. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_BDR0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_BDR0. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_BDR0. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_BDR0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_BDR0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_BDR0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_BDR0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_BDR1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_BDR1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_BDR1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_BDR1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_BDR1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_BDR1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_BDR1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_BDR1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_BDR1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_bdr1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_ADDR      (REGS_IOMUXC_BASE + 0x37c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_bdr1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_BDR1. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_BDR1. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_BDR1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_BDR1. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_BDR1. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_BDR1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_BDR1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_BDR1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_BDR1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_ADDR      (REGS_IOMUXC_BASE + 0x380)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D0. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D0. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D0. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D0. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D0. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_ADDR      (REGS_IOMUXC_BASE + 0x384)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D1. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D1. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D1. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D1. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D1. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D10. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D10. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D10. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D10. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D10. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D10. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D10. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D10. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D10. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d10_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_ADDR      (REGS_IOMUXC_BASE + 0x388)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d10_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D10. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D10. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D10. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D10. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D10. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D10. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D10. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D10. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D10. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D10, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D11. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D11. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D11. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D11. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D11. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D11. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D11. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D11. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D11. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d11_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_ADDR      (REGS_IOMUXC_BASE + 0x38c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d11_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D11. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D11. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D11. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D11. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D11. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D11. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D11. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D11. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D11. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D11, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D12. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D12. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D12. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D12. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D12. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D12. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D12. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D12. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D12. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d12_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_ADDR      (REGS_IOMUXC_BASE + 0x390)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d12_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D12. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D12. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D12. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D12. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D12. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D12. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D12. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D12. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D12. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D12, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D13. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D13. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D13. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D13. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D13. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D13. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D13. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D13. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D13. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d13_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_ADDR      (REGS_IOMUXC_BASE + 0x394)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d13_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D13. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D13. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D13. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D13. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D13. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D13. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D13. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D13. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D13. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D13, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D14. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D14. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D14. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D14. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D14. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D14. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D14. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D14. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D14. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d14_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_ADDR      (REGS_IOMUXC_BASE + 0x398)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d14_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D14. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D14. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D14. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D14. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D14. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D14. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D14. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D14. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D14. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D14, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D15. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D15. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D15. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D15. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D15. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D15. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D15. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D15. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D15. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d15_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_ADDR      (REGS_IOMUXC_BASE + 0x39c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d15_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D15. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D15. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D15. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D15. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D15. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D15. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D15. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D15. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D15. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D15, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D2. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D2. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D2. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D2. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D2. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D2. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D2. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D2. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D2. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_ADDR      (REGS_IOMUXC_BASE + 0x3a0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D2. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D2. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D2. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D2. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D2. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D2. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D2. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D2. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D2. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D2, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D3. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D3. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D3. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D3. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D3. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D3. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D3. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D3. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D3. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_ADDR      (REGS_IOMUXC_BASE + 0x3a4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d3_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D3. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D3. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D3. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D3. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D3. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D3. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D3. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D3. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D3. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D3, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D4. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D4. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D4. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D4. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D4. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D4. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D4. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D4. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D4. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_ADDR      (REGS_IOMUXC_BASE + 0x3a8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d4_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D4. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D4. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D4. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D4. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D4. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D4. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D4. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D4. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D4. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D4, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D5. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D5. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D5. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D5. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D5. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D5. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D5. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D5. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D5. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_ADDR      (REGS_IOMUXC_BASE + 0x3ac)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d5_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D5. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D5. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D5. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D5. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D5. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D5. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D5. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D5. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D5. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D5, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D6. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D6. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D6. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D6. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D6. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D6. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D6. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D6. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D6. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_ADDR      (REGS_IOMUXC_BASE + 0x3b0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d6_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D6. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D6. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D6. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D6. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D6. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D6. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D6. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D6. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D6. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D6, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D7. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D7. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D7. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D7. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D7. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D7. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D7. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D7. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D7. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_ADDR      (REGS_IOMUXC_BASE + 0x3b4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d7_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D7. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D7. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D7. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D7. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D7. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D7. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D7. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D7. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D7. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D7, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D8. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D8. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D8. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D8. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D8. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D8. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D8. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D8. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D8. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d8_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_ADDR      (REGS_IOMUXC_BASE + 0x3b8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d8_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D8. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D8. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D8. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D8. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D8. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D8. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D8. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D8. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D8. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D8, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_D9. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_D9. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_D9. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_D9. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_D9. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_D9. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D9. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_D9. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_D9. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d9_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_ADDR      (REGS_IOMUXC_BASE + 0x3bc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d9_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_D9. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_D9. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_D9. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_D9. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_D9. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_D9. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_D9. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_D9. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_D9. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_D9, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_GDCLK. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_GDCLK. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_GDCLK. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_GDCLK. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_GDCLK. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_GDCLK. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_GDCLK. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_GDCLK. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_GDCLK. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_gdclk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_ADDR      (REGS_IOMUXC_BASE + 0x3c0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_gdclk_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_GDCLK. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_GDCLK. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_GDCLK. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_GDCLK. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_GDCLK. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_GDCLK. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_GDCLK. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_GDCLK. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_GDCLK. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_GDOE. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_GDOE. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_GDOE. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_GDOE. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_GDOE. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_GDOE. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_GDOE. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_GDOE. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_GDOE. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_gdoe_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_ADDR      (REGS_IOMUXC_BASE + 0x3c4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_gdoe_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_GDOE. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_GDOE. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_GDOE. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_GDOE. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_GDOE. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_GDOE. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_GDOE. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_GDOE. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_GDOE. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_GDRL. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_GDRL. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_GDRL. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_GDRL. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_GDRL. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_GDRL. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_GDRL. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_GDRL. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_GDRL. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_gdrl_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_ADDR      (REGS_IOMUXC_BASE + 0x3c8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_gdrl_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_GDRL. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_GDRL. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_GDRL. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_GDRL. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_GDRL. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_GDRL. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_GDRL. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_GDRL. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_GDRL. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_GDSP. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_GDSP. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_GDSP. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_GDSP. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_GDSP. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_GDSP. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_GDSP. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_GDSP. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_GDSP. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_gdsp_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_ADDR      (REGS_IOMUXC_BASE + 0x3cc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_gdsp_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_GDSP. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_GDSP. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_GDSP. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_GDSP. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_GDSP. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_GDSP. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_GDSP. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_GDSP. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_GDSP. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_PWRCOM. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_PWRCOM. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_PWRCOM. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_PWRCOM. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRCOM. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRCOM. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRCOM. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_PWRCOM. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_PWRCOM. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrcom_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_ADDR      (REGS_IOMUXC_BASE + 0x3d0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrcom_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_PWRCOM. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_PWRCOM. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_PWRCOM. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_PWRCOM. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRCOM. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRCOM. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRCOM. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_PWRCOM. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_PWRCOM. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_PWRCTRL0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_PWRCTRL0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_PWRCTRL0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_PWRCTRL0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRCTRL0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRCTRL0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRCTRL0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_PWRCTRL0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_PWRCTRL0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_ADDR      (REGS_IOMUXC_BASE + 0x3d4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_PWRCTRL0. 0 Slow Slew Rate 1 Fast
 * Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_PWRCTRL0. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_PWRCTRL0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_PWRCTRL0. 0 Open Drain
 * Disabled 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRCTRL0. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRCTRL0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRCTRL0. 00 100KOhm
 * Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_PWRCTRL0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_PWRCTRL0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_PWRCTRL1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_PWRCTRL1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_PWRCTRL1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_PWRCTRL1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRCTRL1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRCTRL1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRCTRL1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_PWRCTRL1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_PWRCTRL1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_ADDR      (REGS_IOMUXC_BASE + 0x3d8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_PWRCTRL1. 0 Slow Slew Rate 1 Fast
 * Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_PWRCTRL1. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_PWRCTRL1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_PWRCTRL1. 0 Open Drain
 * Disabled 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRCTRL1. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRCTRL1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRCTRL1. 00 100KOhm
 * Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_PWRCTRL1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_PWRCTRL1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_PWRCTRL2. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_PWRCTRL2. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_PWRCTRL2. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_PWRCTRL2. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRCTRL2. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRCTRL2. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRCTRL2. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_PWRCTRL2. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_PWRCTRL2. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_ADDR      (REGS_IOMUXC_BASE + 0x3dc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_PWRCTRL2. 0 Slow Slew Rate 1 Fast
 * Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_PWRCTRL2. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_PWRCTRL2. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_PWRCTRL2. 0 Open Drain
 * Disabled 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRCTRL2. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRCTRL2. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRCTRL2. 00 100KOhm
 * Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_PWRCTRL2. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_PWRCTRL2. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_PWRCTRL3. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_PWRCTRL3. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_PWRCTRL3. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_PWRCTRL3. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRCTRL3. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRCTRL3. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRCTRL3. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_PWRCTRL3. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_PWRCTRL3. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_ADDR      (REGS_IOMUXC_BASE + 0x3e0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl3_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_PWRCTRL3. 0 Slow Slew Rate 1 Fast
 * Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_PWRCTRL3. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_PWRCTRL3. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_PWRCTRL3. 0 Open Drain
 * Disabled 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRCTRL3. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRCTRL3. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRCTRL3. 00 100KOhm
 * Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_PWRCTRL3. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_PWRCTRL3. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_PWRINT. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_PWRINT. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_PWRINT. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_PWRINT. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRINT. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRINT. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRINT. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_PWRINT. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_PWRINT. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrint_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_ADDR      (REGS_IOMUXC_BASE + 0x3e4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrint_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_PWRINT. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_PWRINT. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_PWRINT. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_PWRINT. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRINT. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRINT. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRINT. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_PWRINT. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_PWRINT. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_PWRSTAT. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_PWRSTAT. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_PWRSTAT. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_PWRSTAT. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRSTAT. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRSTAT. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRSTAT. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_PWRSTAT. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_PWRSTAT. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrstat_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_ADDR      (REGS_IOMUXC_BASE + 0x3e8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrstat_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_PWRSTAT. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_PWRSTAT. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_PWRSTAT. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_PWRSTAT. 0 Open Drain
 * Disabled 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRSTAT. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRSTAT. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRSTAT. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_PWRSTAT. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_PWRSTAT. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_PWRWAKEUP. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_PWRWAKEUP. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_PWRWAKEUP. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_PWRWAKEUP. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRWAKEUP. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRWAKEUP. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRWAKEUP. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_PWRWAKEUP. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_PWRWAKEUP. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrwakeup_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_ADDR      (REGS_IOMUXC_BASE + 0x3ec)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrwakeup_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_PWRWAKEUP. 0 Slow Slew Rate 1 Fast
 * Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_PWRWAKEUP. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_PWRWAKEUP. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_PWRWAKEUP. 0 Open Drain
 * Disabled 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_PWRWAKEUP. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_PWRWAKEUP. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_PWRWAKEUP. 00 100KOhm
 * Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_PWRWAKEUP. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_PWRWAKEUP. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_SDCE0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_SDCE0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_SDCE0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_SDCE0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDCE0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_SDCE0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDCE0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_SDCE0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_SDCE0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdce0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_ADDR      (REGS_IOMUXC_BASE + 0x3f0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdce0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_SDCE0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_SDCE0. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_SDCE0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_SDCE0. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDCE0. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_SDCE0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDCE0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_SDCE0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_SDCE0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_SDCE1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_SDCE1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_SDCE1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_SDCE1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDCE1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_SDCE1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDCE1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_SDCE1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_SDCE1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdce1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_ADDR      (REGS_IOMUXC_BASE + 0x3f4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdce1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_SDCE1. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_SDCE1. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_SDCE1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_SDCE1. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDCE1. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_SDCE1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDCE1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_SDCE1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_SDCE1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_SDCE2. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_SDCE2. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_SDCE2. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_SDCE2. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDCE2. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_SDCE2. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDCE2. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_SDCE2. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_SDCE2. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdce2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_ADDR      (REGS_IOMUXC_BASE + 0x3f8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdce2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_SDCE2. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_SDCE2. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_SDCE2. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_SDCE2. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDCE2. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_SDCE2. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDCE2. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_SDCE2. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_SDCE2. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_SDCE3. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_SDCE3. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_SDCE3. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_SDCE3. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDCE3. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_SDCE3. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDCE3. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_SDCE3. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_SDCE3. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdce3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_ADDR      (REGS_IOMUXC_BASE + 0x3fc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdce3_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_SDCE3. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_SDCE3. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_SDCE3. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_SDCE3. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDCE3. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_SDCE3. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDCE3. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_SDCE3. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_SDCE3. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_SDCLK. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_SDCLK. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_SDCLK. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_SDCLK. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDCLK. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_SDCLK. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDCLK. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_SDCLK. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_SDCLK. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdclk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_ADDR      (REGS_IOMUXC_BASE + 0x400)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdclk_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_SDCLK. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_SDCLK. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_SDCLK. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_SDCLK. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDCLK. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_SDCLK. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDCLK. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_SDCLK. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_SDCLK. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_SDLE. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_SDLE. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_SDLE. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_SDLE. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDLE. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_SDLE. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDLE. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_SDLE. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_SDLE. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdle_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_ADDR      (REGS_IOMUXC_BASE + 0x404)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdle_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_SDLE. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_SDLE. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_SDLE. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_SDLE. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDLE. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_SDLE. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDLE. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_SDLE. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_SDLE. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_SDOE. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_SDOE. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_SDOE. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_SDOE. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDOE. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_SDOE. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDOE. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_SDOE. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_SDOE. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdoe_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_ADDR      (REGS_IOMUXC_BASE + 0x408)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdoe_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_SDOE. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_SDOE. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_SDOE. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_SDOE. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDOE. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_SDOE. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDOE. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_SDOE. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_SDOE. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_SDSHR. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_SDSHR. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_SDSHR. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_SDSHR. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDSHR. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_SDSHR. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDSHR. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_SDSHR. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_SDSHR. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdshr_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_ADDR      (REGS_IOMUXC_BASE + 0x40c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdshr_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_SDSHR. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_SDSHR. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_SDSHR. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_SDSHR. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_SDSHR. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_SDSHR. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_SDSHR. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_SDSHR. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_SDSHR. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_VCOM0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_VCOM0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_VCOM0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_VCOM0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_VCOM0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_VCOM0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_VCOM0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_VCOM0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_VCOM0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_vcom0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_ADDR      (REGS_IOMUXC_BASE + 0x410)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_vcom0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_VCOM0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_VCOM0. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_VCOM0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_VCOM0. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_VCOM0. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_VCOM0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_VCOM0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_VCOM0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_VCOM0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: EPDC_VCOM1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: EPDC_VCOM1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: EPDC_VCOM1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: EPDC_VCOM1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: EPDC_VCOM1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: EPDC_VCOM1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: EPDC_VCOM1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: EPDC_VCOM1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: EPDC_VCOM1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_vcom1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_ADDR      (REGS_IOMUXC_BASE + 0x414)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_vcom1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: EPDC_VCOM1. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: EPDC_VCOM1. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: EPDC_VCOM1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: EPDC_VCOM1. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: EPDC_VCOM1. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: EPDC_VCOM1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: EPDC_VCOM1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: EPDC_VCOM1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: EPDC_VCOM1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: FEC_CRS_DV. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: FEC_CRS_DV. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: FEC_CRS_DV. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: FEC_CRS_DV. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: FEC_CRS_DV. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: FEC_CRS_DV. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: FEC_CRS_DV. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: FEC_CRS_DV. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: FEC_CRS_DV. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_crs_dv_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_ADDR      (REGS_IOMUXC_BASE + 0x418)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_crs_dv_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: FEC_CRS_DV. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: FEC_CRS_DV. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: FEC_CRS_DV. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: FEC_CRS_DV. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: FEC_CRS_DV. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: FEC_CRS_DV. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: FEC_CRS_DV. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: FEC_CRS_DV. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: FEC_CRS_DV. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: FEC_MDC. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: FEC_MDC. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: FEC_MDC. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: FEC_MDC. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: FEC_MDC. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: FEC_MDC. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: FEC_MDC. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: FEC_MDC. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: FEC_MDC. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_mdc_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_ADDR      (REGS_IOMUXC_BASE + 0x41c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_mdc_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: FEC_MDC. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: FEC_MDC. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: FEC_MDC. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: FEC_MDC. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: FEC_MDC. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: FEC_MDC. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: FEC_MDC. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: FEC_MDC. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: FEC_MDC. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDC, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: FEC_MDIO. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: FEC_MDIO. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: FEC_MDIO. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: FEC_MDIO. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: FEC_MDIO. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: FEC_MDIO. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: FEC_MDIO. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: FEC_MDIO. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: FEC_MDIO. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_mdio_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_ADDR      (REGS_IOMUXC_BASE + 0x420)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_mdio_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: FEC_MDIO. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: FEC_MDIO. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: FEC_MDIO. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: FEC_MDIO. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: FEC_MDIO. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: FEC_MDIO. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: FEC_MDIO. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: FEC_MDIO. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: FEC_MDIO. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: FEC_REF_CLK. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: FEC_REF_CLK. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: FEC_REF_CLK. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: FEC_REF_CLK. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: FEC_REF_CLK. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: FEC_REF_CLK. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: FEC_REF_CLK. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: FEC_REF_CLK. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: FEC_REF_CLK. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_ref_clk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_ADDR      (REGS_IOMUXC_BASE + 0x424)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_ref_clk_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: FEC_REF_CLK. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: FEC_REF_CLK. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: FEC_REF_CLK. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: FEC_REF_CLK. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: FEC_REF_CLK. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: FEC_REF_CLK. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: FEC_REF_CLK. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: FEC_REF_CLK. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: FEC_REF_CLK. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: FEC_RX_ER. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: FEC_RX_ER. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: FEC_RX_ER. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: FEC_RX_ER. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: FEC_RX_ER. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: FEC_RX_ER. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: FEC_RX_ER. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: FEC_RX_ER. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: FEC_RX_ER. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_rx_er_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_ADDR      (REGS_IOMUXC_BASE + 0x428)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_rx_er_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: FEC_RX_ER. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: FEC_RX_ER. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: FEC_RX_ER. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: FEC_RX_ER. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: FEC_RX_ER. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: FEC_RX_ER. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: FEC_RX_ER. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: FEC_RX_ER. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: FEC_RX_ER. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: FEC_RXD0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: FEC_RXD0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: FEC_RXD0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: FEC_RXD0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: FEC_RXD0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: FEC_RXD0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: FEC_RXD0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: FEC_RXD0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: FEC_RXD0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_rxd0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_ADDR      (REGS_IOMUXC_BASE + 0x42c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_rxd0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: FEC_RXD0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: FEC_RXD0. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: FEC_RXD0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: FEC_RXD0. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: FEC_RXD0. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: FEC_RXD0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: FEC_RXD0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: FEC_RXD0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: FEC_RXD0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: FEC_RXD1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: FEC_RXD1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: FEC_RXD1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: FEC_RXD1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: FEC_RXD1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: FEC_RXD1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: FEC_RXD1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: FEC_RXD1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: FEC_RXD1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_rxd1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_ADDR      (REGS_IOMUXC_BASE + 0x430)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_rxd1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: FEC_RXD1. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: FEC_RXD1. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: FEC_RXD1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: FEC_RXD1. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: FEC_RXD1. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: FEC_RXD1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: FEC_RXD1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: FEC_RXD1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: FEC_RXD1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: FEC_TX_CLK. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: FEC_TX_CLK. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: FEC_TX_CLK. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: FEC_TX_CLK. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: FEC_TX_CLK. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: FEC_TX_CLK. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: FEC_TX_CLK. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: FEC_TX_CLK. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: FEC_TX_CLK. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_tx_clk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_ADDR      (REGS_IOMUXC_BASE + 0x434)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_tx_clk_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: FEC_TX_CLK. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: FEC_TX_CLK. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: FEC_TX_CLK. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: FEC_TX_CLK. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: FEC_TX_CLK. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: FEC_TX_CLK. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: FEC_TX_CLK. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: FEC_TX_CLK. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: FEC_TX_CLK. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: FEC_TX_EN. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: FEC_TX_EN. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: FEC_TX_EN. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: FEC_TX_EN. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: FEC_TX_EN. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: FEC_TX_EN. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: FEC_TX_EN. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: FEC_TX_EN. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: FEC_TX_EN. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_tx_en_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_ADDR      (REGS_IOMUXC_BASE + 0x438)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_tx_en_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: FEC_TX_EN. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: FEC_TX_EN. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: FEC_TX_EN. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: FEC_TX_EN. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: FEC_TX_EN. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: FEC_TX_EN. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: FEC_TX_EN. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: FEC_TX_EN. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: FEC_TX_EN. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: FEC_TXD0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: FEC_TXD0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: FEC_TXD0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: FEC_TXD0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: FEC_TXD0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: FEC_TXD0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: FEC_TXD0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: FEC_TXD0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: FEC_TXD0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_txd0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_ADDR      (REGS_IOMUXC_BASE + 0x43c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_txd0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: FEC_TXD0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: FEC_TXD0. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: FEC_TXD0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: FEC_TXD0. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: FEC_TXD0. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: FEC_TXD0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: FEC_TXD0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: FEC_TXD0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: FEC_TXD0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: FEC_TXD1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: FEC_TXD1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: FEC_TXD1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: FEC_TXD1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: FEC_TXD1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: FEC_TXD1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: FEC_TXD1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: FEC_TXD1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: FEC_TXD1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_txd1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_ADDR      (REGS_IOMUXC_BASE + 0x440)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_txd1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: FEC_TXD1. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: FEC_TXD1. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: FEC_TXD1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: FEC_TXD1. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: FEC_TXD1. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: FEC_TXD1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: FEC_TXD1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: FEC_TXD1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: FEC_TXD1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: HSIC_DAT. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Read Only Field 000 off
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: HSIC_DAT. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: HSIC_DAT. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: HSIC_DAT. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: HSIC_DAT. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: HSIC_DAT. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Select one out of next values for pad: HSIC_DAT. 00 LPDDR1 / DDR3 / (DDR2 ODT) modes 01 DDR2 driver mode 10 LPDDR2 mode 11 RESERVED
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_hsic_dat_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_ADDR      (REGS_IOMUXC_BASE + 0x444)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_hsic_dat_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: HSIC_DAT. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, field ODT[10:8] (RW)
 *
 * On Die Termination Field Read Only Field 000 off
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: HSIC_DAT. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: HSIC_DAT. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: HSIC_DAT. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: HSIC_DAT. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: HSIC_DAT. 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Select one out of next values for pad: HSIC_DAT. 00 LPDDR1 / DDR3 / (DDR2 ODT)
 * modes 01 DDR2 driver mode 10 LPDDR2 mode 11 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: HSIC_STROBE. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned ODT : 3; //!< On Die Termination Field Read Only Field 000 off
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: HSIC_STROBE. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: HSIC_STROBE. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: HSIC_STROBE. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: HSIC_STROBE. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for pad: HSIC_STROBE. 0 CMOS input type 1 Differential input mode
        unsigned DDR_SEL : 2; //!< ddr_sel Field Select one out of next values for pad: HSIC_STROBE. 00 LPDDR1 / DDR3 / (DDR2 ODT) modes 01 DDR2 driver mode 10 LPDDR2 mode 11 RESERVED
        unsigned DO_TRIM : 2; //!< do_trim Field Read Only Field 00 0
        unsigned RESERVED3 : 10; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_hsic_strobe_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_ADDR      (REGS_IOMUXC_BASE + 0x448)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_hsic_strobe_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: HSIC_STROBE. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, field ODT[10:8] (RW)
 *
 * On Die Termination Field Read Only Field 000 off
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_ODT      (8)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_ODT      (0x00000700)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_ODT(v)   ((((reg32_t) v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_ODT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_ODT(v)   (((v) << 8) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_ODT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_ODT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, ODT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: HSIC_STROBE. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: HSIC_STROBE. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: HSIC_STROBE. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: HSIC_STROBE. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for pad: HSIC_STROBE. 0 CMOS input type
 * 1 Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, DDR_INPUT, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Select one out of next values for pad: HSIC_STROBE. 00 LPDDR1 / DDR3 / (DDR2 ODT)
 * modes 01 DDR2 driver mode 10 LPDDR2 mode 11 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, DDR_SEL, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, field DO_TRIM[21:20] (RW)
 *
 * do_trim Field Read Only Field 00 0
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DO_TRIM      (20)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DO_TRIM      (0x00300000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DO_TRIM(v)   ((((reg32_t) v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DO_TRIM)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DO_TRIM(v)   (((v) << 20) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DO_TRIM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DO_TRIM field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE_DO_TRIM(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE, DO_TRIM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: I2C1_SCL. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: I2C1_SCL. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: I2C1_SCL. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: I2C1_SCL. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: I2C1_SCL. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: I2C1_SCL. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: I2C1_SCL. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: I2C1_SCL. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: I2C1_SCL. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_i2c1_scl_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_ADDR      (REGS_IOMUXC_BASE + 0x44c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_i2c1_scl_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: I2C1_SCL. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: I2C1_SCL. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: I2C1_SCL. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: I2C1_SCL. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: I2C1_SCL. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: I2C1_SCL. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: I2C1_SCL. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: I2C1_SCL. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: I2C1_SCL. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: I2C1_SDA. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: I2C1_SDA. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: I2C1_SDA. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: I2C1_SDA. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: I2C1_SDA. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: I2C1_SDA. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: I2C1_SDA. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: I2C1_SDA. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: I2C1_SDA. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_i2c1_sda_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_ADDR      (REGS_IOMUXC_BASE + 0x450)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_i2c1_sda_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: I2C1_SDA. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: I2C1_SDA. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: I2C1_SDA. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: I2C1_SDA. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: I2C1_SDA. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: I2C1_SDA. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: I2C1_SDA. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: I2C1_SDA. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: I2C1_SDA. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: I2C2_SCL. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: I2C2_SCL. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: I2C2_SCL. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: I2C2_SCL. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: I2C2_SCL. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: I2C2_SCL. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: I2C2_SCL. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: I2C2_SCL. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: I2C2_SCL. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_i2c2_scl_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_ADDR      (REGS_IOMUXC_BASE + 0x454)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_i2c2_scl_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: I2C2_SCL. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: I2C2_SCL. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: I2C2_SCL. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: I2C2_SCL. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: I2C2_SCL. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: I2C2_SCL. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: I2C2_SCL. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: I2C2_SCL. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: I2C2_SCL. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: I2C2_SDA. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: I2C2_SDA. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: I2C2_SDA. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: I2C2_SDA. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: I2C2_SDA. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: I2C2_SDA. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: I2C2_SDA. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: I2C2_SDA. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: I2C2_SDA. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_i2c2_sda_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_ADDR      (REGS_IOMUXC_BASE + 0x458)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_i2c2_sda_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: I2C2_SDA. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: I2C2_SDA. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: I2C2_SDA. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: I2C2_SDA. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: I2C2_SDA. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: I2C2_SDA. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: I2C2_SDA. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: I2C2_SDA. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: I2C2_SDA. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Read Only Field 0 Slow Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field 100 60 Ohm
        unsigned SPEED : 2; //!< Speed Field Read Only Field 01 low(50MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Read Only Field 0 Open Drain Disabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: JTAG_MOD. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: JTAG_MOD. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: JTAG_MOD. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Read Only Field 0 High Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_mod_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_ADDR      (REGS_IOMUXC_BASE + 0x45c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_mod_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, field SRE[0:0] (RW)
 *
 * Slew Rate Field Read Only Field 0 Slow Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field 100 60 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, field SPEED[7:6] (RW)
 *
 * Speed Field Read Only Field 01 low(50MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Read Only Field 0 Open Drain Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: JTAG_MOD. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: JTAG_MOD. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: JTAG_MOD. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, field LVE[22:22] (RW)
 *
 * ipp_lve Field Read Only Field 0 High Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Read Only Field 0 Slow Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field 100 60 Ohm
        unsigned SPEED : 2; //!< Speed Field Read Only Field 01 low(50MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Read Only Field 0 Open Drain Disabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: JTAG_TCK. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: JTAG_TCK. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: JTAG_TCK. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Read Only Field 0 High Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_tck_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_ADDR      (REGS_IOMUXC_BASE + 0x460)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_tck_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, field SRE[0:0] (RW)
 *
 * Slew Rate Field Read Only Field 0 Slow Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field 100 60 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, field SPEED[7:6] (RW)
 *
 * Speed Field Read Only Field 01 low(50MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Read Only Field 0 Open Drain Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: JTAG_TCK. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: JTAG_TCK. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: JTAG_TCK. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, field LVE[22:22] (RW)
 *
 * ipp_lve Field Read Only Field 0 High Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Read Only Field 0 Slow Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field 100 60 Ohm
        unsigned SPEED : 2; //!< Speed Field Read Only Field 01 low(50MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Read Only Field 0 Open Drain Disabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: JTAG_TDI. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: JTAG_TDI. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: JTAG_TDI. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Read Only Field 0 High Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_tdi_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_ADDR      (REGS_IOMUXC_BASE + 0x464)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_tdi_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, field SRE[0:0] (RW)
 *
 * Slew Rate Field Read Only Field 0 Slow Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field 100 60 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, field SPEED[7:6] (RW)
 *
 * Speed Field Read Only Field 01 low(50MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Read Only Field 0 Open Drain Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: JTAG_TDI. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: JTAG_TDI. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: JTAG_TDI. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, field LVE[22:22] (RW)
 *
 * ipp_lve Field Read Only Field 0 High Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Read Only Field 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field 110 40 Ohm
        unsigned SPEED : 2; //!< Speed Field Read Only Field 10 medium(100MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Read Only Field 0 Open Drain Disabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: JTAG_TDO. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field 0 Keeper
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Read Only Field 0 Hysteresis Disabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Read Only Field 0 High Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_tdo_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_ADDR      (REGS_IOMUXC_BASE + 0x468)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_tdo_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, field SRE[0:0] (RW)
 *
 * Slew Rate Field Read Only Field 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field 110 40 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, field SPEED[7:6] (RW)
 *
 * Speed Field Read Only Field 10 medium(100MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Read Only Field 0 Open Drain Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: JTAG_TDO. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field 0 Keeper
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Read Only Field 10 100KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Read Only Field 0 Hysteresis Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, field LVE[22:22] (RW)
 *
 * ipp_lve Field Read Only Field 0 High Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Read Only Field 0 Slow Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field 100 60 Ohm
        unsigned SPEED : 2; //!< Speed Field Read Only Field 01 low(50MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Read Only Field 0 Open Drain Disabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: JTAG_TMS. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: JTAG_TMS. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: JTAG_TMS. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Read Only Field 0 High Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_tms_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_ADDR      (REGS_IOMUXC_BASE + 0x46c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_tms_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, field SRE[0:0] (RW)
 *
 * Slew Rate Field Read Only Field 0 Slow Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field 100 60 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, field SPEED[7:6] (RW)
 *
 * Speed Field Read Only Field 01 low(50MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Read Only Field 0 Open Drain Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: JTAG_TMS. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: JTAG_TMS. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: JTAG_TMS. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, field LVE[22:22] (RW)
 *
 * ipp_lve Field Read Only Field 0 High Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Read Only Field 0 Slow Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Read Only Field 100 60 Ohm
        unsigned SPEED : 2; //!< Speed Field Read Only Field 01 low(50MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Read Only Field 0 Open Drain Disabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: JTAG_TRSTB. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Read Only Field 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: JTAG_TRSTB. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: JTAG_TRSTB. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Read Only Field 0 High Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_trstb_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_ADDR      (REGS_IOMUXC_BASE + 0x470)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_trstb_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, field SRE[0:0] (RW)
 *
 * Slew Rate Field Read Only Field 0 Slow Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, field DSE[5:3] (RW)
 *
 * Drive Strength Field Read Only Field 100 60 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, field SPEED[7:6] (RW)
 *
 * Speed Field Read Only Field 01 low(50MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Read Only Field 0 Open Drain Disabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: JTAG_TRSTB. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Read Only Field 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: JTAG_TRSTB. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: JTAG_TRSTB. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, field LVE[22:22] (RW)
 *
 * ipp_lve Field Read Only Field 0 High Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_COL0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_COL0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_COL0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_COL0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_COL0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_COL0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_COL0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_COL0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_ADDR      (REGS_IOMUXC_BASE + 0x474)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_COL0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_COL0. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_COL0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_COL0. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_COL0. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_COL0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_COL0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_COL0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_COL1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_COL1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_COL1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_COL1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_COL1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_COL1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_COL1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_COL1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_ADDR      (REGS_IOMUXC_BASE + 0x478)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_COL1. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_COL1. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_COL1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_COL1. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_COL1. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_COL1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_COL1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_COL1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_COL2. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_COL2. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_COL2. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_COL2. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_COL2. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_COL2. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL2. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_COL2. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_COL2. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_ADDR      (REGS_IOMUXC_BASE + 0x47c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_COL2. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_COL2. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_COL2. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_COL2. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_COL2. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_COL2. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL2. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_COL2. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_COL2. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL2, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_COL3. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_COL3. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_COL3. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_COL3. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_COL3. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_COL3. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL3. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_COL3. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_COL3. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_ADDR      (REGS_IOMUXC_BASE + 0x480)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col3_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_COL3. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_COL3. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_COL3. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_COL3. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_COL3. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_COL3. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL3. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_COL3. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_COL3. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL3, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_COL4. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_COL4. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_COL4. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_COL4. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_COL4. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_COL4. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL4. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_COL4. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_COL4. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_ADDR      (REGS_IOMUXC_BASE + 0x484)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col4_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_COL4. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_COL4. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_COL4. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_COL4. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_COL4. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_COL4. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL4. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_COL4. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_COL4. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL4, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_COL5. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_COL5. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_COL5. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_COL5. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_COL5. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_COL5. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL5. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_COL5. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_COL5. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_ADDR      (REGS_IOMUXC_BASE + 0x488)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col5_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_COL5. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_COL5. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_COL5. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_COL5. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_COL5. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_COL5. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL5. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_COL5. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_COL5. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL5, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_COL6. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_COL6. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_COL6. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_COL6. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_COL6. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_COL6. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL6. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_COL6. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_COL6. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_ADDR      (REGS_IOMUXC_BASE + 0x48c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col6_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_COL6. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_COL6. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_COL6. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_COL6. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_COL6. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_COL6. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL6. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_COL6. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_COL6. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL6, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_COL7. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_COL7. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_COL7. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_COL7. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_COL7. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_COL7. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL7. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_COL7. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_COL7. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_ADDR      (REGS_IOMUXC_BASE + 0x490)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col7_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_COL7. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_COL7. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_COL7. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_COL7. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_COL7. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_COL7. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_COL7. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_COL7. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_COL7. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_COL7, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_ROW0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_ROW0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_ROW0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_ROW0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_ROW0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_ROW0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_ROW0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_ADDR      (REGS_IOMUXC_BASE + 0x494)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_ROW0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_ROW0. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_ROW0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_ROW0. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW0. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_ROW0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_ROW0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_ROW0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_ROW1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_ROW1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_ROW1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_ROW1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_ROW1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_ROW1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_ROW1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_ADDR      (REGS_IOMUXC_BASE + 0x498)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_ROW1. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_ROW1. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_ROW1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_ROW1. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW1. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_ROW1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_ROW1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_ROW1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_ROW2. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_ROW2. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_ROW2. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_ROW2. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW2. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_ROW2. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW2. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_ROW2. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_ROW2. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_ADDR      (REGS_IOMUXC_BASE + 0x49c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_ROW2. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_ROW2. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_ROW2. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_ROW2. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW2. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_ROW2. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW2. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_ROW2. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_ROW2. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_ROW3. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_ROW3. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_ROW3. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_ROW3. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW3. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_ROW3. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW3. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_ROW3. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_ROW3. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_ADDR      (REGS_IOMUXC_BASE + 0x4a0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row3_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_ROW3. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_ROW3. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_ROW3. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_ROW3. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW3. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_ROW3. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW3. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_ROW3. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_ROW3. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_ROW4. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_ROW4. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_ROW4. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_ROW4. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW4. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_ROW4. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW4. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_ROW4. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_ROW4. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_ADDR      (REGS_IOMUXC_BASE + 0x4a4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row4_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_ROW4. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_ROW4. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_ROW4. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_ROW4. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW4. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_ROW4. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW4. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_ROW4. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_ROW4. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_ROW5. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_ROW5. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_ROW5. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_ROW5. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW5. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_ROW5. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW5. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_ROW5. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_ROW5. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_ADDR      (REGS_IOMUXC_BASE + 0x4a8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row5_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_ROW5. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_ROW5. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_ROW5. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_ROW5. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW5. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_ROW5. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW5. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_ROW5. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_ROW5. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_ROW6. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_ROW6. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_ROW6. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_ROW6. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW6. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_ROW6. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW6. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_ROW6. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_ROW6. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_ADDR      (REGS_IOMUXC_BASE + 0x4ac)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row6_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_ROW6. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_ROW6. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_ROW6. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_ROW6. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW6. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_ROW6. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW6. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_ROW6. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_ROW6. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: KEY_ROW7. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: KEY_ROW7. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: KEY_ROW7. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: KEY_ROW7. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW7. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: KEY_ROW7. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW7. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: KEY_ROW7. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: KEY_ROW7. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_ADDR      (REGS_IOMUXC_BASE + 0x4b0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row7_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: KEY_ROW7. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: KEY_ROW7. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: KEY_ROW7. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: KEY_ROW7. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: KEY_ROW7. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: KEY_ROW7. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: KEY_ROW7. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: KEY_ROW7. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: KEY_ROW7. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_CLK. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_CLK. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_CLK. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_CLK. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_CLK. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_CLK. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_CLK. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_CLK. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_CLK. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_clk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_ADDR      (REGS_IOMUXC_BASE + 0x4b4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_clk_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_CLK. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_CLK. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_CLK. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_CLK. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_CLK. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_CLK. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_CLK. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_CLK. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_CLK. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_CLK, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_ADDR      (REGS_IOMUXC_BASE + 0x4b8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT0. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT0. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT0. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_ADDR      (REGS_IOMUXC_BASE + 0x4bc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT1. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT1. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT1. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT1. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT10. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT10. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT10. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT10. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT10. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT10. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT10. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT10. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT10. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat10_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_ADDR      (REGS_IOMUXC_BASE + 0x4c0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat10_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT10. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT10. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT10. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT10. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT10. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT10. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT10. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT10. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT10. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT11. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT11. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT11. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT11. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT11. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT11. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT11. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT11. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT11. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat11_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_ADDR      (REGS_IOMUXC_BASE + 0x4c4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat11_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT11. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT11. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT11. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT11. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT11. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT11. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT11. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT11. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT11. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT12. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT12. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT12. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT12. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT12. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT12. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT12. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT12. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT12. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat12_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_ADDR      (REGS_IOMUXC_BASE + 0x4c8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat12_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT12. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT12. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT12. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT12. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT12. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT12. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT12. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT12. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT12. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT13. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT13. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT13. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT13. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT13. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT13. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT13. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT13. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT13. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat13_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_ADDR      (REGS_IOMUXC_BASE + 0x4cc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat13_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT13. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT13. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT13. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT13. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT13. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT13. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT13. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT13. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT13. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT14. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT14. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT14. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT14. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT14. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT14. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT14. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT14. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT14. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat14_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_ADDR      (REGS_IOMUXC_BASE + 0x4d0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat14_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT14. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT14. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT14. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT14. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT14. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT14. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT14. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT14. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT14. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT15. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT15. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT15. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT15. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT15. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT15. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT15. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT15. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT15. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat15_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_ADDR      (REGS_IOMUXC_BASE + 0x4d4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat15_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT15. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT15. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT15. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT15. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT15. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT15. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT15. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT15. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT15. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT16. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT16. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT16. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT16. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT16. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT16. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT16. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT16. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT16. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat16_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_ADDR      (REGS_IOMUXC_BASE + 0x4d8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat16_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT16. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT16. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT16. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT16. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT16. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT16. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT16. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT16. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT16. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT17. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT17. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT17. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT17. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT17. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT17. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT17. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT17. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT17. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat17_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_ADDR      (REGS_IOMUXC_BASE + 0x4dc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat17_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT17. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT17. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT17. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT17. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT17. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT17. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT17. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT17. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT17. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT18. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT18. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT18. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT18. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT18. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT18. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT18. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT18. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT18. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat18_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_ADDR      (REGS_IOMUXC_BASE + 0x4e0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat18_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT18. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT18. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT18. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT18. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT18. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT18. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT18. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT18. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT18. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT19. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT19. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT19. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT19. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT19. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT19. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT19. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT19. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT19. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat19_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_ADDR      (REGS_IOMUXC_BASE + 0x4e4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat19_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT19. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT19. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT19. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT19. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT19. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT19. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT19. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT19. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT19. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT2. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT2. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT2. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT2. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT2. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT2. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT2. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT2. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT2. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_ADDR      (REGS_IOMUXC_BASE + 0x4e8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT2. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT2. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT2. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT2. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT2. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT2. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT2. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT2. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT2. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT20. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT20. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT20. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT20. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT20. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT20. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT20. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT20. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT20. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat20_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_ADDR      (REGS_IOMUXC_BASE + 0x4ec)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat20_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT20. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT20. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT20. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT20. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT20. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT20. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT20. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT20. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT20. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT21. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT21. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT21. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT21. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT21. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT21. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT21. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT21. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT21. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat21_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_ADDR      (REGS_IOMUXC_BASE + 0x4f0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat21_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT21. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT21. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT21. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT21. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT21. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT21. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT21. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT21. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT21. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT22. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT22. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT22. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT22. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT22. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT22. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT22. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT22. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT22. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat22_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_ADDR      (REGS_IOMUXC_BASE + 0x4f4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat22_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT22. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT22. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT22. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT22. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT22. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT22. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT22. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT22. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT22. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT23. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT23. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT23. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT23. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT23. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT23. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT23. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT23. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT23. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat23_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_ADDR      (REGS_IOMUXC_BASE + 0x4f8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat23_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT23. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT23. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT23. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT23. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT23. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT23. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT23. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT23. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT23. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT3. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT3. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT3. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT3. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT3. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT3. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT3. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT3. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT3. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_ADDR      (REGS_IOMUXC_BASE + 0x4fc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat3_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT3. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT3. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT3. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT3. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT3. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT3. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT3. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT3. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT3. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT4. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT4. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT4. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT4. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT4. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT4. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT4. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT4. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT4. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_ADDR      (REGS_IOMUXC_BASE + 0x500)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat4_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT4. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT4. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT4. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT4. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT4. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT4. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT4. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT4. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT4. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT5. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT5. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT5. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT5. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT5. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT5. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT5. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT5. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT5. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_ADDR      (REGS_IOMUXC_BASE + 0x504)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat5_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT5. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT5. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT5. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT5. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT5. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT5. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT5. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT5. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT5. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT6. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT6. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT6. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT6. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT6. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT6. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT6. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT6. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT6. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_ADDR      (REGS_IOMUXC_BASE + 0x508)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat6_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT6. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT6. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT6. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT6. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT6. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT6. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT6. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT6. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT6. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT7. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT7. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT7. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT7. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT7. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT7. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT7. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT7. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT7. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_ADDR      (REGS_IOMUXC_BASE + 0x50c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat7_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT7. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT7. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT7. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT7. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT7. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT7. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT7. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT7. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT7. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT8. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT8. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT8. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT8. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT8. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT8. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT8. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT8. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT8. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat8_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_ADDR      (REGS_IOMUXC_BASE + 0x510)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat8_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT8. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT8. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT8. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT8. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT8. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT8. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT8. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT8. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT8. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_DAT9. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_DAT9. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_DAT9. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_DAT9. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT9. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_DAT9. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT9. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_DAT9. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_DAT9. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat9_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_ADDR      (REGS_IOMUXC_BASE + 0x514)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat9_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_DAT9. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_DAT9. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_DAT9. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_DAT9. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_DAT9. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_DAT9. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_DAT9. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_DAT9. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_DAT9. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_ENABLE. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_ENABLE. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_ENABLE. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_ENABLE. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_ENABLE. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_ENABLE. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_ENABLE. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_ENABLE. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_ENABLE. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_enable_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_ADDR      (REGS_IOMUXC_BASE + 0x518)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_enable_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_ENABLE. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_ENABLE. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_ENABLE. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_ENABLE. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_ENABLE. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_ENABLE. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_ENABLE. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_ENABLE. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_ENABLE. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_HSYNC. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_HSYNC. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_HSYNC. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_HSYNC. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_HSYNC. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_HSYNC. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_HSYNC. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_HSYNC. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_HSYNC. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_hsync_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_ADDR      (REGS_IOMUXC_BASE + 0x51c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_hsync_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_HSYNC. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_HSYNC. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_HSYNC. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_HSYNC. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_HSYNC. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_HSYNC. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_HSYNC. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_HSYNC. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_HSYNC. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_RESET. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_RESET. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_RESET. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_RESET. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_RESET. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_RESET. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_RESET. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_RESET. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_RESET. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_reset_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_ADDR      (REGS_IOMUXC_BASE + 0x520)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_reset_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_RESET. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_RESET. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_RESET. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_RESET. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_RESET. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_RESET. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_RESET. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_RESET. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_RESET. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_RESET, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: LCD_VSYNC. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: LCD_VSYNC. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: LCD_VSYNC. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: LCD_VSYNC. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: LCD_VSYNC. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: LCD_VSYNC. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: LCD_VSYNC. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: LCD_VSYNC. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: LCD_VSYNC. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_vsync_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_ADDR      (REGS_IOMUXC_BASE + 0x524)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_vsync_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: LCD_VSYNC. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: LCD_VSYNC. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: LCD_VSYNC. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: LCD_VSYNC. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: LCD_VSYNC. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: LCD_VSYNC. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: LCD_VSYNC. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: LCD_VSYNC. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: LCD_VSYNC. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: PWM1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: PWM1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: PWM1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: PWM1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: PWM1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: PWM1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: PWM1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: PWM1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: PWM1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_pwm1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_ADDR      (REGS_IOMUXC_BASE + 0x528)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_pwm1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: PWM1. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: PWM1. 000 output driver disabled; 001
 * 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: PWM1. 00 TBD 01 low(50MHz) 10 medium(100MHz)
 * 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: PWM1. 0 Open Drain Disabled 1 Open
 * Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: PWM1. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: PWM1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: PWM1. 00 100KOhm Pull Down 01
 * 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: PWM1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: PWM1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_PWM1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: REF_CLK_24M. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: REF_CLK_24M. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: REF_CLK_24M. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: REF_CLK_24M. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: REF_CLK_24M. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: REF_CLK_24M. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: REF_CLK_24M. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: REF_CLK_24M. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: REF_CLK_24M. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_ref_clk_24m_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_ADDR      (REGS_IOMUXC_BASE + 0x52c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ref_clk_24m_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: REF_CLK_24M. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: REF_CLK_24M. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: REF_CLK_24M. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: REF_CLK_24M. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: REF_CLK_24M. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: REF_CLK_24M. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: REF_CLK_24M. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: REF_CLK_24M. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: REF_CLK_24M. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: REF_CLK_32K. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: REF_CLK_32K. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: REF_CLK_32K. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: REF_CLK_32K. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: REF_CLK_32K. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: REF_CLK_32K. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: REF_CLK_32K. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: REF_CLK_32K. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: REF_CLK_32K. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_ref_clk_32k_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_ADDR      (REGS_IOMUXC_BASE + 0x530)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ref_clk_32k_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: REF_CLK_32K. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: REF_CLK_32K. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: REF_CLK_32K. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: REF_CLK_32K. 0 Open Drain Disabled
 * 1 Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: REF_CLK_32K. 0 Pull/Keeper
 * Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: REF_CLK_32K. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: REF_CLK_32K. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: REF_CLK_32K. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: REF_CLK_32K. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD1_CLK. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD1_CLK. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD1_CLK. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD1_CLK. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD1_CLK. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD1_CLK. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD1_CLK. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD1_CLK. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD1_CLK. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_clk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_ADDR      (REGS_IOMUXC_BASE + 0x534)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_clk_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD1_CLK. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD1_CLK. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD1_CLK. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD1_CLK. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD1_CLK. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD1_CLK. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD1_CLK. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD1_CLK. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD1_CLK. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CLK, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD1_CMD. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD1_CMD. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD1_CMD. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD1_CMD. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD1_CMD. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD1_CMD. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD1_CMD. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD1_CMD. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD1_CMD. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_cmd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_ADDR      (REGS_IOMUXC_BASE + 0x538)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_cmd_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD1_CMD. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD1_CMD. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD1_CMD. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD1_CMD. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD1_CMD. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD1_CMD. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD1_CMD. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD1_CMD. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD1_CMD. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_CMD, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD1_DAT0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD1_DAT0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD1_DAT0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD1_DAT0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD1_DAT0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD1_DAT0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD1_DAT0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_ADDR      (REGS_IOMUXC_BASE + 0x53c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD1_DAT0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD1_DAT0. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD1_DAT0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD1_DAT0. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT0. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD1_DAT0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD1_DAT0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD1_DAT0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD1_DAT1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD1_DAT1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD1_DAT1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD1_DAT1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD1_DAT1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD1_DAT1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD1_DAT1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_ADDR      (REGS_IOMUXC_BASE + 0x540)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD1_DAT1. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD1_DAT1. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD1_DAT1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD1_DAT1. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT1. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD1_DAT1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD1_DAT1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD1_DAT1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD1_DAT2. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD1_DAT2. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD1_DAT2. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD1_DAT2. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT2. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD1_DAT2. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT2. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD1_DAT2. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD1_DAT2. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_ADDR      (REGS_IOMUXC_BASE + 0x544)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD1_DAT2. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD1_DAT2. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD1_DAT2. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD1_DAT2. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT2. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD1_DAT2. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT2. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD1_DAT2. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD1_DAT2. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD1_DAT3. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD1_DAT3. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD1_DAT3. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD1_DAT3. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT3. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD1_DAT3. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT3. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD1_DAT3. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD1_DAT3. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_ADDR      (REGS_IOMUXC_BASE + 0x548)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat3_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD1_DAT3. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD1_DAT3. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD1_DAT3. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD1_DAT3. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT3. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD1_DAT3. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT3. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD1_DAT3. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD1_DAT3. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD1_DAT4. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD1_DAT4. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD1_DAT4. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD1_DAT4. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT4. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD1_DAT4. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT4. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD1_DAT4. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD1_DAT4. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_ADDR      (REGS_IOMUXC_BASE + 0x54c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat4_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD1_DAT4. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD1_DAT4. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD1_DAT4. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD1_DAT4. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT4. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD1_DAT4. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT4. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD1_DAT4. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD1_DAT4. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD1_DAT5. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD1_DAT5. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD1_DAT5. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD1_DAT5. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT5. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD1_DAT5. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT5. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD1_DAT5. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD1_DAT5. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_ADDR      (REGS_IOMUXC_BASE + 0x550)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat5_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD1_DAT5. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD1_DAT5. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD1_DAT5. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD1_DAT5. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT5. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD1_DAT5. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT5. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD1_DAT5. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD1_DAT5. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD1_DAT6. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD1_DAT6. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD1_DAT6. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD1_DAT6. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT6. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD1_DAT6. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT6. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD1_DAT6. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD1_DAT6. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_ADDR      (REGS_IOMUXC_BASE + 0x554)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat6_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD1_DAT6. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD1_DAT6. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD1_DAT6. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD1_DAT6. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT6. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD1_DAT6. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT6. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD1_DAT6. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD1_DAT6. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD1_DAT7. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD1_DAT7. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD1_DAT7. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD1_DAT7. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT7. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD1_DAT7. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT7. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD1_DAT7. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD1_DAT7. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_ADDR      (REGS_IOMUXC_BASE + 0x558)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat7_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD1_DAT7. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD1_DAT7. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD1_DAT7. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD1_DAT7. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD1_DAT7. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD1_DAT7. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD1_DAT7. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD1_DAT7. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD1_DAT7. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD2_CLK. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD2_CLK. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD2_CLK. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD2_CLK. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD2_CLK. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD2_CLK. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD2_CLK. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD2_CLK. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD2_CLK. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_clk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_ADDR      (REGS_IOMUXC_BASE + 0x55c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_clk_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD2_CLK. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD2_CLK. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD2_CLK. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD2_CLK. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD2_CLK. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD2_CLK. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD2_CLK. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD2_CLK. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD2_CLK. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CLK, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD2_CMD. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD2_CMD. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD2_CMD. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD2_CMD. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD2_CMD. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD2_CMD. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD2_CMD. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD2_CMD. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD2_CMD. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_cmd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_ADDR      (REGS_IOMUXC_BASE + 0x560)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_cmd_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD2_CMD. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD2_CMD. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD2_CMD. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD2_CMD. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD2_CMD. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD2_CMD. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD2_CMD. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD2_CMD. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD2_CMD. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_CMD, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD2_DAT0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD2_DAT0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD2_DAT0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD2_DAT0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD2_DAT0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD2_DAT0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD2_DAT0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_ADDR      (REGS_IOMUXC_BASE + 0x564)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD2_DAT0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD2_DAT0. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD2_DAT0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD2_DAT0. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT0. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD2_DAT0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD2_DAT0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD2_DAT0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD2_DAT1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD2_DAT1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD2_DAT1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD2_DAT1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD2_DAT1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD2_DAT1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD2_DAT1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_ADDR      (REGS_IOMUXC_BASE + 0x568)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD2_DAT1. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD2_DAT1. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD2_DAT1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD2_DAT1. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT1. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD2_DAT1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD2_DAT1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD2_DAT1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD2_DAT2. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD2_DAT2. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD2_DAT2. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD2_DAT2. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT2. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD2_DAT2. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT2. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD2_DAT2. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD2_DAT2. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_ADDR      (REGS_IOMUXC_BASE + 0x56c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD2_DAT2. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD2_DAT2. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD2_DAT2. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD2_DAT2. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT2. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD2_DAT2. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT2. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD2_DAT2. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD2_DAT2. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD2_DAT3. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD2_DAT3. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD2_DAT3. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD2_DAT3. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT3. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD2_DAT3. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT3. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD2_DAT3. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD2_DAT3. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_ADDR      (REGS_IOMUXC_BASE + 0x570)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat3_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD2_DAT3. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD2_DAT3. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD2_DAT3. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD2_DAT3. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT3. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD2_DAT3. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT3. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD2_DAT3. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD2_DAT3. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD2_DAT4. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD2_DAT4. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD2_DAT4. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD2_DAT4. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT4. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD2_DAT4. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT4. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD2_DAT4. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD2_DAT4. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat4_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_ADDR      (REGS_IOMUXC_BASE + 0x574)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat4_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD2_DAT4. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD2_DAT4. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD2_DAT4. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD2_DAT4. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT4. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD2_DAT4. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT4. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD2_DAT4. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD2_DAT4. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD2_DAT5. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD2_DAT5. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD2_DAT5. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD2_DAT5. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT5. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD2_DAT5. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT5. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD2_DAT5. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD2_DAT5. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat5_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_ADDR      (REGS_IOMUXC_BASE + 0x578)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat5_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD2_DAT5. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD2_DAT5. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD2_DAT5. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD2_DAT5. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT5. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD2_DAT5. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT5. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD2_DAT5. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD2_DAT5. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD2_DAT6. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD2_DAT6. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD2_DAT6. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD2_DAT6. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT6. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD2_DAT6. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT6. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD2_DAT6. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD2_DAT6. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat6_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_ADDR      (REGS_IOMUXC_BASE + 0x57c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat6_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD2_DAT6. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD2_DAT6. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD2_DAT6. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD2_DAT6. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT6. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD2_DAT6. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT6. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD2_DAT6. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD2_DAT6. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD2_DAT7. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD2_DAT7. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD2_DAT7. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD2_DAT7. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT7. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD2_DAT7. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT7. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD2_DAT7. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD2_DAT7. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat7_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_ADDR      (REGS_IOMUXC_BASE + 0x580)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat7_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD2_DAT7. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD2_DAT7. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD2_DAT7. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD2_DAT7. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD2_DAT7. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD2_DAT7. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD2_DAT7. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD2_DAT7. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD2_DAT7. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD2_RST. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD2_RST. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD2_RST. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD2_RST. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD2_RST. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD2_RST. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD2_RST. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD2_RST. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD2_RST. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_rst_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_ADDR      (REGS_IOMUXC_BASE + 0x584)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_rst_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD2_RST. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD2_RST. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD2_RST. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD2_RST. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD2_RST. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD2_RST. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD2_RST. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD2_RST. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD2_RST. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD2_RST, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD3_CLK. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD3_CLK. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD3_CLK. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD3_CLK. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD3_CLK. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD3_CLK. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD3_CLK. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD3_CLK. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD3_CLK. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_clk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_ADDR      (REGS_IOMUXC_BASE + 0x588)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_clk_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD3_CLK. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD3_CLK. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD3_CLK. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD3_CLK. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD3_CLK. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD3_CLK. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD3_CLK. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD3_CLK. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD3_CLK. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CLK, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD3_CMD. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD3_CMD. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD3_CMD. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD3_CMD. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD3_CMD. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD3_CMD. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD3_CMD. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD3_CMD. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD3_CMD. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_cmd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_ADDR      (REGS_IOMUXC_BASE + 0x58c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_cmd_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD3_CMD. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD3_CMD. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD3_CMD. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD3_CMD. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD3_CMD. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD3_CMD. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD3_CMD. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD3_CMD. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD3_CMD. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_CMD, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD3_DAT0. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD3_DAT0. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD3_DAT0. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD3_DAT0. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD3_DAT0. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD3_DAT0. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD3_DAT0. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD3_DAT0. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD3_DAT0. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_dat0_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_ADDR      (REGS_IOMUXC_BASE + 0x590)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_dat0_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD3_DAT0. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD3_DAT0. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD3_DAT0. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD3_DAT0. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD3_DAT0. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD3_DAT0. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD3_DAT0. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD3_DAT0. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD3_DAT0. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD3_DAT1. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD3_DAT1. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD3_DAT1. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD3_DAT1. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD3_DAT1. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD3_DAT1. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD3_DAT1. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD3_DAT1. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD3_DAT1. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_dat1_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_ADDR      (REGS_IOMUXC_BASE + 0x594)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_dat1_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD3_DAT1. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD3_DAT1. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD3_DAT1. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD3_DAT1. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD3_DAT1. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD3_DAT1. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD3_DAT1. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD3_DAT1. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD3_DAT1. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD3_DAT2. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD3_DAT2. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD3_DAT2. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD3_DAT2. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD3_DAT2. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD3_DAT2. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD3_DAT2. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD3_DAT2. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD3_DAT2. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_dat2_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_ADDR      (REGS_IOMUXC_BASE + 0x598)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_dat2_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD3_DAT2. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD3_DAT2. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD3_DAT2. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD3_DAT2. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD3_DAT2. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD3_DAT2. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD3_DAT2. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD3_DAT2. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD3_DAT2. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3 - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: SD3_DAT3. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: SD3_DAT3. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: SD3_DAT3. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: SD3_DAT3. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: SD3_DAT3. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: SD3_DAT3. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: SD3_DAT3. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: SD3_DAT3. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: SD3_DAT3. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_dat3_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3 register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_ADDR      (REGS_IOMUXC_BASE + 0x59c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_dat3_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3 bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: SD3_DAT3. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: SD3_DAT3. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: SD3_DAT3. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: SD3_DAT3. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: SD3_DAT3. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: SD3_DAT3. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: SD3_DAT3. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: SD3_DAT3. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: SD3_DAT3. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: UART1_RXD. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: UART1_RXD. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: UART1_RXD. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: UART1_RXD. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: UART1_RXD. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: UART1_RXD. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: UART1_RXD. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: UART1_RXD. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: UART1_RXD. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_uart1_rxd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_ADDR      (REGS_IOMUXC_BASE + 0x5a0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_uart1_rxd_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: UART1_RXD. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: UART1_RXD. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: UART1_RXD. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: UART1_RXD. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: UART1_RXD. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: UART1_RXD. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: UART1_RXD. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: UART1_RXD. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: UART1_RXD. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_RXD, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: UART1_TXD. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: UART1_TXD. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: UART1_TXD. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: UART1_TXD. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: UART1_TXD. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: UART1_TXD. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: UART1_TXD. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: UART1_TXD. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: UART1_TXD. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_uart1_txd_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_ADDR      (REGS_IOMUXC_BASE + 0x5a4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_uart1_txd_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: UART1_TXD. 0 Slow Slew Rate 1 Fast Slew
 * Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: UART1_TXD. 000 output driver
 * disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: UART1_TXD. 00 TBD 01 low(50MHz) 10
 * medium(100MHz) 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: UART1_TXD. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: UART1_TXD. 0 Pull/Keeper Disabled
 * 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: UART1_TXD. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: UART1_TXD. 00 100KOhm Pull
 * Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: UART1_TXD. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: UART1_TXD. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_UART1_TXD, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B - SW_PAD_CTL (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SRE : 1; //!< Slew Rate Field Select one out of next values for pad: WDOG_B. 0 Slow Slew Rate 1 Fast Slew Rate
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for pad: WDOG_B. 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned SPEED : 2; //!< Speed Field Select one out of next values for pad: WDOG_B. 00 TBD 01 low(50MHz) 10 medium(100MHz) 11 max(200MHz)
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned ODE : 1; //!< Open Drain Enable Field Select one out of next values for pad: WDOG_B. 0 Open Drain Disabled 1 Open Drain Enabled
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for pad: WDOG_B. 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for pad: WDOG_B. 0 Keeper 1 Pull
        unsigned PUS : 2; //!< Pull Up / Down Config. Field Select one out of next values for pad: WDOG_B. 00 100KOhm Pull Down 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for pad: WDOG_B. 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED2 : 5; //!< Reserved
        unsigned LVE : 1; //!< ipp_lve Field Select one out of next values for pad: WDOG_B. 0 High Voltage 1 Low Voltage
        unsigned RESERVED3 : 9; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_pad_wdog_b_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_ADDR      (REGS_IOMUXC_BASE + 0x5a8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_wdog_b_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, field SRE[0:0] (RW)
 *
 * Slew Rate Field Select one out of next values for pad: WDOG_B. 0 Slow Slew Rate 1 Fast Slew Rate
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SRE      (0)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SRE      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SRE(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SRE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SRE(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SRE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SRE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SRE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, SRE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for pad: WDOG_B. 000 output driver disabled;
 * 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, DSE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, field SPEED[7:6] (RW)
 *
 * Speed Field Select one out of next values for pad: WDOG_B. 00 TBD 01 low(50MHz) 10 medium(100MHz)
 * 11 max(200MHz)
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SPEED      (6)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SPEED      (0x000000c0)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SPEED(v)   ((((reg32_t) v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SPEED)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SPEED(v)   (((v) << 6) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SPEED)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SPEED field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_SPEED(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, SPEED, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, field ODE[11:11] (RW)
 *
 * Open Drain Enable Field Select one out of next values for pad: WDOG_B. 0 Open Drain Disabled 1
 * Open Drain Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_ODE      (11)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_ODE      (0x00000800)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_ODE(v)   ((((reg32_t) v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_ODE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_ODE(v)   (((v) << 11) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_ODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_ODE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, ODE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for pad: WDOG_B. 0 Pull/Keeper Disabled 1
 * Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, PKE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for pad: WDOG_B. 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, PUE, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, field PUS[15:14] (RW)
 *
 * Pull Up / Down Config. Field Select one out of next values for pad: WDOG_B. 00 100KOhm Pull Down
 * 01 47KOhm Pull Up 10 100KOhm Pull Up 11 22KOhm Pull Up
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUS      (14)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUS      (0x0000c000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUS(v)   ((((reg32_t) v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUS(v)   (((v) << 14) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_PUS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, PUS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for pad: WDOG_B. 0 Hysteresis Disabled 1
 * Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, HYS, v)
#endif

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, field LVE[22:22] (RW)
 *
 * ipp_lve Field Select one out of next values for pad: WDOG_B. 0 High Voltage 1 Low Voltage
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_LVE      (22)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_LVE      (0x00400000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_LVE(v)   ((((reg32_t) v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_LVE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_LVE(v)   (((v) << 22) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_LVE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LVE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B_LVE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_PAD_WDOG_B, LVE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS - SW_GRP (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for group: ADDDS (Pads: DRAM_A0 DRAM_A1 DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14 DRAM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7 DRAM_A8 DRAM_A9 DRAM_SDBA0 DRAM_SDBA1). 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 26; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_grp_addds_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_ADDR      (REGS_IOMUXC_BASE + 0x5ac)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_addds_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for group: ADDDS (Pads: DRAM_A0 DRAM_A1
 * DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14 DRAM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6
 * DRAM_A7 DRAM_A8 DRAM_A9 DRAM_SDBA0 DRAM_SDBA1). 000 output driver disabled; 001 240 Ohm 010 120
 * Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_GRP_ADDDS, DSE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL - SW_GRP (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 17; //!< Reserved
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for group: DDRMODE_CTL (Pads: DRAM_SDQS0 DRAM_SDQS1 DRAM_SDQS2 DRAM_SDQS3). 0 CMOS input type 1 Differential input mode
        unsigned RESERVED1 : 14; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrmode_ctl_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_ADDR      (REGS_IOMUXC_BASE + 0x5b0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrmode_ctl_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for group: DDRMODE_CTL (Pads:
 * DRAM_SDQS0 DRAM_SDQS1 DRAM_SDQS2 DRAM_SDQS3). 0 CMOS input type 1 Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL, DDR_INPUT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE - SW_GRP (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 12; //!< Reserved
        unsigned PKE : 1; //!< Pull / Keep Enable Field Select one out of next values for group: DDRPKE (Pads: DRAM_A0 DRAM_A1 DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14 DRAM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7 DRAM_A8 DRAM_A9 DRAM_CAS DRAM_CS0 DRAM_CS1 DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_DQM0 DRAM_DQM1 DRAM_DQM2 DRAM_DQM3 DRAM_RAS DRAM_SDBA0 DRAM_SDBA1 DRAM_SDCLK_0 DRAM_SDWE). 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
        unsigned RESERVED1 : 19; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrpke_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_ADDR      (REGS_IOMUXC_BASE + 0x5b4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrpke_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE, field PKE[12:12] (RW)
 *
 * Pull / Keep Enable Field Select one out of next values for group: DDRPKE (Pads: DRAM_A0 DRAM_A1
 * DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14 DRAM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6
 * DRAM_A7 DRAM_A8 DRAM_A9 DRAM_CAS DRAM_CS0 DRAM_CS1 DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12
 * DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 DRAM_D20 DRAM_D21 DRAM_D22
 * DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4
 * DRAM_D5 DRAM_D6 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_DQM0 DRAM_DQM1 DRAM_DQM2 DRAM_DQM3 DRAM_RAS
 * DRAM_SDBA0 DRAM_SDBA1 DRAM_SDCLK_0 DRAM_SDWE). 0 Pull/Keeper Disabled 1 Pull/Keeper Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_PKE      (12)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_PKE      (0x00001000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_PKE(v)   ((((reg32_t) v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_PKE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_PKE(v)   (((v) << 12) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_PKE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PKE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE_PKE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPKE, PKE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK - SW_GRP (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 13; //!< Reserved
        unsigned PUE : 1; //!< Pull / Keep Select Field Select one out of next values for group: DDRPK (Pads: DRAM_A0 DRAM_A1 DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14 DRAM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7 DRAM_A8 DRAM_A9 DRAM_CAS DRAM_CS0 DRAM_CS1 DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_DQM0 DRAM_DQM1 DRAM_DQM2 DRAM_DQM3 DRAM_RAS DRAM_SDBA0 DRAM_SDBA1 DRAM_SDCLK_0 DRAM_SDWE). 0 Keeper 1 Pull
        unsigned RESERVED1 : 18; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrpk_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_ADDR      (REGS_IOMUXC_BASE + 0x5b8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrpk_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK, field PUE[13:13] (RW)
 *
 * Pull / Keep Select Field Select one out of next values for group: DDRPK (Pads: DRAM_A0 DRAM_A1
 * DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14 DRAM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6
 * DRAM_A7 DRAM_A8 DRAM_A9 DRAM_CAS DRAM_CS0 DRAM_CS1 DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12
 * DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 DRAM_D20 DRAM_D21 DRAM_D22
 * DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4
 * DRAM_D5 DRAM_D6 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_DQM0 DRAM_DQM1 DRAM_DQM2 DRAM_DQM3 DRAM_RAS
 * DRAM_SDBA0 DRAM_SDBA1 DRAM_SDCLK_0 DRAM_SDWE). 0 Keeper 1 Pull
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_PUE      (13)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_PUE      (0x00002000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_PUE(v)   ((((reg32_t) v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_PUE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_PUE(v)   (((v) << 13) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_PUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PUE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK_PUE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRPK, PUE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS - SW_GRP (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 16; //!< Reserved
        unsigned HYS : 1; //!< Hyst. Enable Field Select one out of next values for group: DDRHYS (Pads: DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_SDQS0 DRAM_SDQS1 DRAM_SDQS2 DRAM_SDQS3). 0 Hysteresis Disabled 1 Hysteresis Enabled
        unsigned RESERVED1 : 15; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrhys_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_ADDR      (REGS_IOMUXC_BASE + 0x5bc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrhys_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS, field HYS[16:16] (RW)
 *
 * Hyst. Enable Field Select one out of next values for group: DDRHYS (Pads: DRAM_D0 DRAM_D1
 * DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2
 * DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D3
 * DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_SDQS0 DRAM_SDQS1
 * DRAM_SDQS2 DRAM_SDQS3). 0 Hysteresis Disabled 1 Hysteresis Enabled
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_HYS      (16)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_HYS      (0x00010000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_HYS(v)   ((((reg32_t) v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_HYS)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_HYS(v)   (((v) << 16) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_HYS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the HYS field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS_HYS(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRHYS, HYS, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE - SW_GRP (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 17; //!< Reserved
        unsigned DDR_INPUT : 1; //!< DDR / CMOS Input Mode Field Select one out of next values for group: DDRMODE (Pads: DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7 DRAM_D8 DRAM_D9). 0 CMOS input type 1 Differential input mode
        unsigned RESERVED1 : 14; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrmode_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_ADDR      (REGS_IOMUXC_BASE + 0x5c0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrmode_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE, field DDR_INPUT[17:17] (RW)
 *
 * DDR / CMOS Input Mode Field Select one out of next values for group: DDRMODE (Pads: DRAM_D0
 * DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19
 * DRAM_D2 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29
 * DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7 DRAM_D8 DRAM_D9). 0 CMOS input type 1
 * Differential input mode
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_DDR_INPUT      (17)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_DDR_INPUT      (0x00020000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_DDR_INPUT(v)   ((((reg32_t) v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_DDR_INPUT)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_DDR_INPUT(v)   (((v) << 17) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_DDR_INPUT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_INPUT field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE_DDR_INPUT(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDRMODE, DDR_INPUT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS - SW_GRP (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for group: B0DS (Pads: DRAM_D0 DRAM_D1 DRAM_D2 DRAM_D3 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7). 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 26; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_grp_b0ds_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_ADDR      (REGS_IOMUXC_BASE + 0x5c4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_b0ds_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for group: B0DS (Pads: DRAM_D0 DRAM_D1 DRAM_D2
 * DRAM_D3 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7). 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011
 * 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B0DS, DSE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS - SW_GRP (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for group: CTLDS (Pads: DRAM_CS0 DRAM_CS1 DRAM_SDBA2 DRAM_SDCKE0 DRAM_SDCKE1 DRAM_SDWE). 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 26; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_grp_ctlds_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_ADDR      (REGS_IOMUXC_BASE + 0x5c8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ctlds_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for group: CTLDS (Pads: DRAM_CS0 DRAM_CS1
 * DRAM_SDBA2 DRAM_SDCKE0 DRAM_SDCKE1 DRAM_SDWE). 000 output driver disabled; 001 240 Ohm 010 120
 * Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_GRP_CTLDS, DSE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS - SW_GRP (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for group: B1DS (Pads: DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D8 DRAM_D9). 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 26; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_grp_b1ds_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_ADDR      (REGS_IOMUXC_BASE + 0x5cc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_b1ds_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for group: B1DS (Pads: DRAM_D10 DRAM_D11
 * DRAM_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D8 DRAM_D9). 000 output driver disabled; 001 240 Ohm 010
 * 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B1DS, DSE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE - SW_GRP (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 18; //!< Reserved
        unsigned DDR_SEL : 2; //!< ddr_sel Field Select one out of next values for group: DDR_TYPE (Pads: DRAM_A0 DRAM_A1 DRAM_A10 DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14 DRAM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7 DRAM_A8 DRAM_A9 DRAM_CAS DRAM_CS0 DRAM_CS1 DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13 DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23 DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5 DRAM_D6 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_DQM0 DRAM_DQM1 DRAM_DQM2 DRAM_DQM3 DRAM_RAS DRAM_SDBA0 DRAM_SDBA1 DRAM_SDBA2 DRAM_SDCKE0 DRAM_SDCKE1 DRAM_SDCLK_0 DRAM_SDODT0 DRAM_SDODT1 DRAM_SDQS0 DRAM_SDQS1 DRAM_SDQS2 DRAM_SDQS3 DRAM_SDWE). 00 LPDDR1 / DDR3 / (DDR2 ODT) modes 01 DDR2 driver mode 10 LPDDR2 mode 11 RESERVED
        unsigned RESERVED1 : 12; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddr_type_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_ADDR      (REGS_IOMUXC_BASE + 0x5d0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddr_type_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE, field DDR_SEL[19:18] (RW)
 *
 * ddr_sel Field Select one out of next values for group: DDR_TYPE (Pads: DRAM_A0 DRAM_A1 DRAM_A10
 * DRAM_A11 DRAM_A12 DRAM_A13 DRAM_A14 DRAM_A15 DRAM_A2 DRAM_A3 DRAM_A4 DRAM_A5 DRAM_A6 DRAM_A7
 * DRAM_A8 DRAM_A9 DRAM_CAS DRAM_CS0 DRAM_CS1 DRAM_D0 DRAM_D1 DRAM_D10 DRAM_D11 DRAM_D12 DRAM_D13
 * DRAM_D14 DRAM_D15 DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D2 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23
 * DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D3 DRAM_D30 DRAM_D31 DRAM_D4 DRAM_D5
 * DRAM_D6 DRAM_D7 DRAM_D8 DRAM_D9 DRAM_DQM0 DRAM_DQM1 DRAM_DQM2 DRAM_DQM3 DRAM_RAS DRAM_SDBA0
 * DRAM_SDBA1 DRAM_SDBA2 DRAM_SDCKE0 DRAM_SDCKE1 DRAM_SDCLK_0 DRAM_SDODT0 DRAM_SDODT1 DRAM_SDQS0
 * DRAM_SDQS1 DRAM_SDQS2 DRAM_SDQS3 DRAM_SDWE). 00 LPDDR1 / DDR3 / (DDR2 ODT) modes 01 DDR2 driver
 * mode 10 LPDDR2 mode 11 RESERVED
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_DDR_SEL      (18)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_DDR_SEL      (0x000c0000)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_DDR_SEL(v)   ((((reg32_t) v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_DDR_SEL)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_DDR_SEL(v)   (((v) << 18) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_DDR_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DDR_SEL field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE_DDR_SEL(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE, DDR_SEL, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS - SW_GRP (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for group: B2DS (Pads: DRAM_D16 DRAM_D17 DRAM_D18 DRAM_D19 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23). 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 26; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_grp_b2ds_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_ADDR      (REGS_IOMUXC_BASE + 0x5d4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_b2ds_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for group: B2DS (Pads: DRAM_D16 DRAM_D17
 * DRAM_D18 DRAM_D19 DRAM_D20 DRAM_D21 DRAM_D22 DRAM_D23). 000 output driver disabled; 001 240 Ohm
 * 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B2DS, DSE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS - SW_GRP (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DSE : 3; //!< Drive Strength Field Select one out of next values for group: B3DS (Pads: DRAM_D24 DRAM_D25 DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D30 DRAM_D31). 000 output driver disabled; 001 240 Ohm 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
        unsigned RESERVED1 : 26; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_sw_pad_ctl_grp_b3ds_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS register
 */
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_ADDR      (REGS_IOMUXC_BASE + 0x5d8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS           (*(volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_b3ds_t *) HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_ADDR)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_RD()      (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS.U)
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_WR(v)     (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS.U = (v))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_SET(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_CLR(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_TOG(v)    (HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_WR(HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS, field DSE[5:3] (RW)
 *
 * Drive Strength Field Select one out of next values for group: B3DS (Pads: DRAM_D24 DRAM_D25
 * DRAM_D26 DRAM_D27 DRAM_D28 DRAM_D29 DRAM_D30 DRAM_D31). 000 output driver disabled; 001 240 Ohm
 * 010 120 Ohm 011 80 Ohm 100 60 Ohm 101 48 Ohm 110 40 Ohm 111 34 Ohm
 */

#define BP_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_DSE      (3)
#define BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_DSE      (0x00000038)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_DSE(v)   ((((reg32_t) v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_DSE)
#else
#define BF_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_DSE(v)   (((v) << 3) & BM_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_DSE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DSE field to a new value.
#define BW_IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS_DSE(v)   BF_CS1(IOMUXC_IOMUXC_SW_PAD_CTL_GRP_B3DS, DSE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 3; //!< Selecting Pads Involved in Daisy Chain. Instance: anatop, In Pin: usb_otg_id 000 Selecting Pad: EPDC_PWRCOM for Mode: ALT4. 001 Selecting Pad: FEC_RXD0 for Mode: ALT2. 010 Selecting Pad: LCD_DAT1 for Mode: ALT2. 011 Selecting Pad: REF_CLK_32K for Mode: ALT3. 100 Selecting Pad: SD3_DAT0 for Mode: ALT4.
        unsigned RESERVED0 : 29; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_anatop_usb_otg_id_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x5dc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_anatop_usb_otg_id_select_input_t *) HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT, field DAISY[2:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: anatop, In Pin: usb_otg_id 000 Selecting Pad:
 * EPDC_PWRCOM for Mode: ALT4. 001 Selecting Pad: FEC_RXD0 for Mode: ALT2. 010 Selecting Pad:
 * LCD_DAT1 for Mode: ALT2. 011 Selecting Pad: REF_CLK_32K for Mode: ALT3. 100 Selecting Pad:
 * SD3_DAT0 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_DAISY      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: anatop, In Pin: usb_uh1_id 00 Selecting Pad: EPDC_PWRINT for Mode: ALT4. 01 Selecting Pad: LCD_DAT0 for Mode: ALT2. 10 Selecting Pad: REF_CLK_24M for Mode: ALT3. 11 Selecting Pad: SD3_CMD for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_anatop_usb_uh1_id_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x5e0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_anatop_usb_uh1_id_select_input_t *) HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: anatop, In Pin: usb_uh1_id 00 Selecting Pad:
 * EPDC_PWRINT for Mode: ALT4. 01 Selecting Pad: LCD_DAT0 for Mode: ALT2. 10 Selecting Pad:
 * REF_CLK_24M for Mode: ALT3. 11 Selecting Pad: SD3_CMD for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p4_input_da_amx 00 Selecting Pad: ECSPI1_SS0 for Mode: ALT1. 01 Selecting Pad: LCD_DAT3 for Mode: ALT4. 10 Selecting Pad: SD2_DAT0 for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p4_input_da_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x5e4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p4_input_da_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p4_input_da_amx 00 Selecting
 * Pad: ECSPI1_SS0 for Mode: ALT1. 01 Selecting Pad: LCD_DAT3 for Mode: ALT4. 10 Selecting Pad:
 * SD2_DAT0 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p4_input_db_amx 00 Selecting Pad: ECSPI1_SCLK for Mode: ALT1. 01 Selecting Pad: LCD_DAT6 for Mode: ALT4. 10 Selecting Pad: SD2_DAT3 for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p4_input_db_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x5e8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p4_input_db_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p4_input_db_amx 00 Selecting
 * Pad: ECSPI1_SCLK for Mode: ALT1. 01 Selecting Pad: LCD_DAT6 for Mode: ALT4. 10 Selecting Pad:
 * SD2_DAT3 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p4_input_rxclk_amx 00 Selecting Pad: I2C2_SDA for Mode: ALT1. 01 Selecting Pad: LCD_DAT2 for Mode: ALT4. 10 Selecting Pad: SD2_CMD for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p4_input_rxclk_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x5ec)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p4_input_rxclk_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p4_input_rxclk_amx 00 Selecting
 * Pad: I2C2_SDA for Mode: ALT1. 01 Selecting Pad: LCD_DAT2 for Mode: ALT4. 10 Selecting Pad:
 * SD2_CMD for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p4_input_rxfs_amx 00 Selecting Pad: I2C2_SCL for Mode: ALT1. 01 Selecting Pad: LCD_DAT1 for Mode: ALT4. 10 Selecting Pad: SD2_CLK for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p4_input_rxfs_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x5f0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p4_input_rxfs_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p4_input_rxfs_amx 00 Selecting
 * Pad: I2C2_SCL for Mode: ALT1. 01 Selecting Pad: LCD_DAT1 for Mode: ALT4. 10 Selecting Pad:
 * SD2_CLK for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p4_input_txclk_amx 00 Selecting Pad: ECSPI1_MOSI for Mode: ALT1. 01 Selecting Pad: LCD_DAT4 for Mode: ALT4. 10 Selecting Pad: SD2_DAT1 for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p4_input_txclk_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x5f4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p4_input_txclk_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p4_input_txclk_amx 00 Selecting
 * Pad: ECSPI1_MOSI for Mode: ALT1. 01 Selecting Pad: LCD_DAT4 for Mode: ALT4. 10 Selecting Pad:
 * SD2_DAT1 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p4_input_txfs_amx 00 Selecting Pad: ECSPI1_MISO for Mode: ALT1. 01 Selecting Pad: LCD_DAT5 for Mode: ALT4. 10 Selecting Pad: SD2_DAT2 for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p4_input_txfs_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x5f8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p4_input_txfs_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p4_input_txfs_amx 00 Selecting
 * Pad: ECSPI1_MISO for Mode: ALT1. 01 Selecting Pad: LCD_DAT5 for Mode: ALT4. 10 Selecting Pad:
 * SD2_DAT2 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p5_input_da_amx 0 Selecting Pad: EPDC_VCOM1 for Mode: ALT1. 1 Selecting Pad: SD3_DAT0 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p5_input_da_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x5fc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p5_input_da_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p5_input_da_amx 0 Selecting
 * Pad: EPDC_VCOM1 for Mode: ALT1. 1 Selecting Pad: SD3_DAT0 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p5_input_db_amx 0 Selecting Pad: EPDC_PWRCTRL2 for Mode: ALT1. 1 Selecting Pad: SD3_DAT3 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p5_input_db_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x600)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p5_input_db_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p5_input_db_amx 0 Selecting
 * Pad: EPDC_PWRCTRL2 for Mode: ALT1. 1 Selecting Pad: SD3_DAT3 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p5_input_rxclk_amx 0 Selecting Pad: EPDC_PWRCTRL0 for Mode: ALT1. 1 Selecting Pad: SD3_CMD for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p5_input_rxclk_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x604)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p5_input_rxclk_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p5_input_rxclk_amx 0 Selecting
 * Pad: EPDC_PWRCTRL0 for Mode: ALT1. 1 Selecting Pad: SD3_CMD for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p5_input_rxfs_amx 0 Selecting Pad: EPDC_VCOM0 for Mode: ALT1. 1 Selecting Pad: SD3_CLK for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p5_input_rxfs_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x608)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p5_input_rxfs_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p5_input_rxfs_amx 0 Selecting
 * Pad: EPDC_VCOM0 for Mode: ALT1. 1 Selecting Pad: SD3_CLK for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p5_input_txclk_amx 0 Selecting Pad: EPDC_PWRCTRL3 for Mode: ALT1. 1 Selecting Pad: SD3_DAT1 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p5_input_txclk_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x60c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p5_input_txclk_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p5_input_txclk_amx 0 Selecting
 * Pad: EPDC_PWRCTRL3 for Mode: ALT1. 1 Selecting Pad: SD3_DAT1 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p5_input_txfs_amx 0 Selecting Pad: EPDC_PWRCTRL1 for Mode: ALT1. 1 Selecting Pad: SD3_DAT2 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p5_input_txfs_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x610)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p5_input_txfs_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p5_input_txfs_amx 0 Selecting
 * Pad: EPDC_PWRCTRL1 for Mode: ALT1. 1 Selecting Pad: SD3_DAT2 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p6_input_da_amx 0 Selecting Pad: FEC_RX_ER for Mode: ALT2. 1 Selecting Pad: KEY_COL4 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p6_input_da_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x614)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p6_input_da_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p6_input_da_amx 0 Selecting
 * Pad: FEC_RX_ER for Mode: ALT2. 1 Selecting Pad: KEY_COL4 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p6_input_db_amx 0 Selecting Pad: FEC_TXD0 for Mode: ALT2. 1 Selecting Pad: KEY_ROW5 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p6_input_db_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x618)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p6_input_db_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p6_input_db_amx 0 Selecting
 * Pad: FEC_TXD0 for Mode: ALT2. 1 Selecting Pad: KEY_ROW5 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p6_input_rxclk_amx 0 Selecting Pad: FEC_TX_CLK for Mode: ALT2. 1 Selecting Pad: KEY_ROW3 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p6_input_rxclk_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x61c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p6_input_rxclk_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p6_input_rxclk_amx 0 Selecting
 * Pad: FEC_TX_CLK for Mode: ALT2. 1 Selecting Pad: KEY_ROW3 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p6_input_rxfs_amx 0 Selecting Pad: FEC_MDIO for Mode: ALT2. 1 Selecting Pad: KEY_COL3 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p6_input_rxfs_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x620)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p6_input_rxfs_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p6_input_rxfs_amx 0 Selecting
 * Pad: FEC_MDIO for Mode: ALT2. 1 Selecting Pad: KEY_COL3 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p6_input_txclk_amx 0 Selecting Pad: FEC_CRS_DV for Mode: ALT2. 1 Selecting Pad: KEY_ROW4 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p6_input_txclk_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x624)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p6_input_txclk_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p6_input_txclk_amx 0 Selecting
 * Pad: FEC_CRS_DV for Mode: ALT2. 1 Selecting Pad: KEY_ROW4 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p6_input_txfs_amx 0 Selecting Pad: FEC_RXD1 for Mode: ALT2. 1 Selecting Pad: KEY_COL5 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_audmux_p6_input_txfs_amx_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x628)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_audmux_p6_input_txfs_amx_select_input_t *) HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: audmux, In Pin: p6_input_txfs_amx 0 Selecting
 * Pad: FEC_RXD1 for Mode: ALT2. 1 Selecting Pad: KEY_COL5 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: ccm, In Pin: pmic_vfuncional_ready 00 Selecting Pad: FEC_REF_CLK for Mode: ALT4. 01 Selecting Pad: LCD_RESET for Mode: ALT6. 10 Selecting Pad: REF_CLK_24M for Mode: ALT4. 11 Selecting Pad: SD1_DAT7 for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ccm_pmic_vfuncional_ready_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x62c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ccm_pmic_vfuncional_ready_select_input_t *) HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ccm, In Pin: pmic_vfuncional_ready 00 Selecting
 * Pad: FEC_REF_CLK for Mode: ALT4. 01 Selecting Pad: LCD_RESET for Mode: ALT6. 10 Selecting Pad:
 * REF_CLK_24M for Mode: ALT4. 11 Selecting Pad: SD1_DAT7 for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[0] 00 Selecting Pad: EPDC_D0 for Mode: ALT3. 01 Selecting Pad: LCD_DAT17 for Mode: ALT2. 10 Selecting Pad: SD2_CLK for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_0_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x630)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_0_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[0] 00 Selecting Pad:
 * EPDC_D0 for Mode: ALT3. 01 Selecting Pad: LCD_DAT17 for Mode: ALT2. 10 Selecting Pad: SD2_CLK for
 * Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[1] 00 Selecting Pad: EPDC_D1 for Mode: ALT3. 01 Selecting Pad: LCD_DAT16 for Mode: ALT2. 10 Selecting Pad: SD2_CMD for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x634)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_1_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[1] 00 Selecting Pad:
 * EPDC_D1 for Mode: ALT3. 01 Selecting Pad: LCD_DAT16 for Mode: ALT2. 10 Selecting Pad: SD2_CMD for
 * Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[2] 00 Selecting Pad: EPDC_D2 for Mode: ALT3. 01 Selecting Pad: LCD_DAT15 for Mode: ALT2. 10 Selecting Pad: SD2_DAT0 for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_2_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x638)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_2_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[2] 00 Selecting Pad:
 * EPDC_D2 for Mode: ALT3. 01 Selecting Pad: LCD_DAT15 for Mode: ALT2. 10 Selecting Pad: SD2_DAT0
 * for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[3] 00 Selecting Pad: EPDC_D3 for Mode: ALT3. 01 Selecting Pad: LCD_DAT14 for Mode: ALT2. 10 Selecting Pad: SD2_DAT1 for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_3_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x63c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_3_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[3] 00 Selecting Pad:
 * EPDC_D3 for Mode: ALT3. 01 Selecting Pad: LCD_DAT14 for Mode: ALT2. 10 Selecting Pad: SD2_DAT1
 * for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[4] 00 Selecting Pad: EPDC_D4 for Mode: ALT3. 01 Selecting Pad: LCD_DAT13 for Mode: ALT2. 10 Selecting Pad: SD2_DAT2 for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_4_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x640)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_4_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[4] 00 Selecting Pad:
 * EPDC_D4 for Mode: ALT3. 01 Selecting Pad: LCD_DAT13 for Mode: ALT2. 10 Selecting Pad: SD2_DAT2
 * for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[5] 00 Selecting Pad: EPDC_D5 for Mode: ALT3. 01 Selecting Pad: LCD_DAT12 for Mode: ALT2. 10 Selecting Pad: SD2_DAT3 for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_5_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x644)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_5_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[5] 00 Selecting Pad:
 * EPDC_D5 for Mode: ALT3. 01 Selecting Pad: LCD_DAT12 for Mode: ALT2. 10 Selecting Pad: SD2_DAT3
 * for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[6] 00 Selecting Pad: EPDC_D6 for Mode: ALT3. 01 Selecting Pad: LCD_DAT11 for Mode: ALT2. 10 Selecting Pad: SD2_DAT4 for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_6_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x648)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_6_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[6] 00 Selecting Pad:
 * EPDC_D6 for Mode: ALT3. 01 Selecting Pad: LCD_DAT11 for Mode: ALT2. 10 Selecting Pad: SD2_DAT4
 * for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[7] 00 Selecting Pad: EPDC_D7 for Mode: ALT3. 01 Selecting Pad: LCD_DAT10 for Mode: ALT2. 10 Selecting Pad: SD2_DAT5 for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_7_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x64c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_7_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[7] 00 Selecting Pad:
 * EPDC_D7 for Mode: ALT3. 01 Selecting Pad: LCD_DAT10 for Mode: ALT2. 10 Selecting Pad: SD2_DAT5
 * for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[8] 00 Selecting Pad: EPDC_SDCLK for Mode: ALT3. 01 Selecting Pad: LCD_DAT9 for Mode: ALT2. 10 Selecting Pad: SD2_DAT6 for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_8_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x650)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_8_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[8] 00 Selecting Pad:
 * EPDC_SDCLK for Mode: ALT3. 01 Selecting Pad: LCD_DAT9 for Mode: ALT2. 10 Selecting Pad: SD2_DAT6
 * for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[9] 00 Selecting Pad: EPDC_SDLE for Mode: ALT3. 01 Selecting Pad: LCD_DAT8 for Mode: ALT2. 10 Selecting Pad: SD2_DAT7 for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_9_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x654)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_9_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[9] 00 Selecting Pad:
 * EPDC_SDLE for Mode: ALT3. 01 Selecting Pad: LCD_DAT8 for Mode: ALT2. 10 Selecting Pad: SD2_DAT7
 * for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[10] 00 Selecting Pad: EPDC_SDOE for Mode: ALT3. 01 Selecting Pad: LCD_DAT23 for Mode: ALT2. 10 Selecting Pad: SD3_CLK for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_10_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x658)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_10_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[10] 00 Selecting Pad:
 * EPDC_SDOE for Mode: ALT3. 01 Selecting Pad: LCD_DAT23 for Mode: ALT2. 10 Selecting Pad: SD3_CLK
 * for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[11] 00 Selecting Pad: EPDC_SDSHR for Mode: ALT3. 01 Selecting Pad: LCD_DAT22 for Mode: ALT2. 10 Selecting Pad: SD3_CMD for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_11_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x65c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_11_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[11] 00 Selecting Pad:
 * EPDC_SDSHR for Mode: ALT3. 01 Selecting Pad: LCD_DAT22 for Mode: ALT2. 10 Selecting Pad: SD3_CMD
 * for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[12] 0 Selecting Pad: LCD_DAT21 for Mode: ALT2. 1 Selecting Pad: SD3_DAT0 for Mode: ALT3.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_12_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x660)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_12_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[12] 0 Selecting Pad:
 * LCD_DAT21 for Mode: ALT2. 1 Selecting Pad: SD3_DAT0 for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[13] 0 Selecting Pad: LCD_DAT20 for Mode: ALT2. 1 Selecting Pad: SD3_DAT1 for Mode: ALT3.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_13_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x664)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_13_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[13] 0 Selecting Pad:
 * LCD_DAT20 for Mode: ALT2. 1 Selecting Pad: SD3_DAT1 for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[14] 0 Selecting Pad: LCD_DAT19 for Mode: ALT2. 1 Selecting Pad: SD3_DAT2 for Mode: ALT3.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_14_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x668)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_14_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[14] 0 Selecting Pad:
 * LCD_DAT19 for Mode: ALT2. 1 Selecting Pad: SD3_DAT2 for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[15] 0 Selecting Pad: LCD_DAT18 for Mode: ALT2. 1 Selecting Pad: SD3_DAT3 for Mode: ALT3.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_d_15_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x66c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_15_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_d[15] 0 Selecting Pad:
 * LCD_DAT18 for Mode: ALT2. 1 Selecting Pad: SD3_DAT3 for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_hsync 00 Selecting Pad: ECSPI2_MOSI for Mode: ALT3. 01 Selecting Pad: EPDC_GDOE for Mode: ALT3. 10 Selecting Pad: LCD_DAT5 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_hsync_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x670)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_hsync_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_hsync 00 Selecting Pad:
 * ECSPI2_MOSI for Mode: ALT3. 01 Selecting Pad: EPDC_GDOE for Mode: ALT3. 10 Selecting Pad:
 * LCD_DAT5 for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_pixclk 00 Selecting Pad: ECSPI2_SCLK for Mode: ALT3. 01 Selecting Pad: EPDC_GDCLK for Mode: ALT3. 10 Selecting Pad: LCD_DAT6 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_pixclk_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x674)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_pixclk_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_pixclk 00 Selecting Pad:
 * ECSPI2_SCLK for Mode: ALT3. 01 Selecting Pad: EPDC_GDCLK for Mode: ALT3. 10 Selecting Pad:
 * LCD_DAT6 for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_vsync 00 Selecting Pad: ECSPI2_SS0 for Mode: ALT3. 01 Selecting Pad: EPDC_GDSP for Mode: ALT3. 10 Selecting Pad: LCD_DAT4 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_csi_ipp_csi_vsync_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x678)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_csi_ipp_csi_vsync_select_input_t *) HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: csi, In Pin: ipp_csi_vsync 00 Selecting Pad:
 * ECSPI2_SS0 for Mode: ALT3. 01 Selecting Pad: EPDC_GDSP for Mode: ALT3. 10 Selecting Pad: LCD_DAT4
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_cspi_clk_in 0 Selecting Pad: ECSPI1_SCLK for Mode: ALT0. 1 Selecting Pad: LCD_DAT3 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi1_ipp_cspi_clk_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x67c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi1_ipp_cspi_clk_in_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_cspi_clk_in 0 Selecting
 * Pad: ECSPI1_SCLK for Mode: ALT0. 1 Selecting Pad: LCD_DAT3 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_dataready_b 0 Selecting Pad: I2C2_SCL for Mode: ALT6. 1 Selecting Pad: LCD_DAT7 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi1_ipp_ind_dataready_b_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x680)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_dataready_b_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_dataready_b 0 Selecting
 * Pad: I2C2_SCL for Mode: ALT6. 1 Selecting Pad: LCD_DAT7 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_miso 0 Selecting Pad: ECSPI1_MISO for Mode: ALT0. 1 Selecting Pad: LCD_DAT1 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi1_ipp_ind_miso_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x684)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_miso_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_miso 0 Selecting Pad:
 * ECSPI1_MISO for Mode: ALT0. 1 Selecting Pad: LCD_DAT1 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_mosi 0 Selecting Pad: ECSPI1_MOSI for Mode: ALT0. 1 Selecting Pad: LCD_DAT0 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi1_ipp_ind_mosi_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x688)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_mosi_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_mosi 0 Selecting Pad:
 * ECSPI1_MOSI for Mode: ALT0. 1 Selecting Pad: LCD_DAT0 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_ss_b[0] 0 Selecting Pad: ECSPI1_SS0 for Mode: ALT0. 1 Selecting Pad: LCD_DAT2 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi1_ipp_ind_ss_b_0_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x68c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_ss_b_0_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_ss_b[0] 0 Selecting
 * Pad: ECSPI1_SS0 for Mode: ALT0. 1 Selecting Pad: LCD_DAT2 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_ss_b[1] 0 Selecting Pad: I2C1_SCL for Mode: ALT6. 1 Selecting Pad: LCD_DAT4 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi1_ipp_ind_ss_b_1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x690)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_ss_b_1_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_ss_b[1] 0 Selecting
 * Pad: I2C1_SCL for Mode: ALT6. 1 Selecting Pad: LCD_DAT4 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_ss_b[2] 0 Selecting Pad: I2C1_SDA for Mode: ALT6. 1 Selecting Pad: LCD_DAT5 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi1_ipp_ind_ss_b_2_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x694)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_ss_b_2_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_ss_b[2] 0 Selecting
 * Pad: I2C1_SDA for Mode: ALT6. 1 Selecting Pad: LCD_DAT5 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_ss_b[3] 0 Selecting Pad: ECSPI2_SS0 for Mode: ALT1. 1 Selecting Pad: LCD_DAT6 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi1_ipp_ind_ss_b_3_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x698)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_ss_b_3_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi1, In Pin: ipp_ind_ss_b[3] 0 Selecting
 * Pad: ECSPI2_SS0 for Mode: ALT1. 1 Selecting Pad: LCD_DAT6 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi2, In Pin: ipp_cspi_clk_in 00 Selecting Pad: ECSPI2_SCLK for Mode: ALT0. 01 Selecting Pad: EPDC_SDSHR for Mode: ALT1. 10 Selecting Pad: LCD_DAT8 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi2_ipp_cspi_clk_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x69c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi2_ipp_cspi_clk_in_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi2, In Pin: ipp_cspi_clk_in 00 Selecting
 * Pad: ECSPI2_SCLK for Mode: ALT0. 01 Selecting Pad: EPDC_SDSHR for Mode: ALT1. 10 Selecting Pad:
 * LCD_DAT8 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi2, In Pin: ipp_ind_miso 00 Selecting Pad: ECSPI2_MISO for Mode: ALT0. 01 Selecting Pad: EPDC_SDLE for Mode: ALT1. 10 Selecting Pad: LCD_DAT10 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi2_ipp_ind_miso_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6a0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi2_ipp_ind_miso_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi2, In Pin: ipp_ind_miso 00 Selecting Pad:
 * ECSPI2_MISO for Mode: ALT0. 01 Selecting Pad: EPDC_SDLE for Mode: ALT1. 10 Selecting Pad:
 * LCD_DAT10 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi2, In Pin: ipp_ind_mosi 00 Selecting Pad: ECSPI2_MOSI for Mode: ALT0. 01 Selecting Pad: EPDC_SDCLK for Mode: ALT1. 10 Selecting Pad: LCD_DAT9 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi2_ipp_ind_mosi_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6a4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi2_ipp_ind_mosi_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi2, In Pin: ipp_ind_mosi 00 Selecting Pad:
 * ECSPI2_MOSI for Mode: ALT0. 01 Selecting Pad: EPDC_SDCLK for Mode: ALT1. 10 Selecting Pad:
 * LCD_DAT9 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi2, In Pin: ipp_ind_ss_b[0] 0 Selecting Pad: ECSPI2_SS0 for Mode: ALT0. 1 Selecting Pad: EPDC_SDOE for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi2_ipp_ind_ss_b_0_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6a8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi2_ipp_ind_ss_b_0_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi2, In Pin: ipp_ind_ss_b[0] 0 Selecting
 * Pad: ECSPI2_SS0 for Mode: ALT0. 1 Selecting Pad: EPDC_SDOE for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi2, In Pin: ipp_ind_ss_b[1] 0 Selecting Pad: EPDC_SDCE0 for Mode: ALT1. 1 Selecting Pad: LCD_DAT11 for Mode: ALT4.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi2_ipp_ind_ss_b_1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6ac)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi2_ipp_ind_ss_b_1_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi2, In Pin: ipp_ind_ss_b[1] 0 Selecting
 * Pad: EPDC_SDCE0 for Mode: ALT1. 1 Selecting Pad: LCD_DAT11 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_cspi_clk_in 00 Selecting Pad: AUD_TXD for Mode: ALT1. 01 Selecting Pad: EPDC_D11 for Mode: ALT1. 10 Selecting Pad: SD2_CLK for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi3_ipp_cspi_clk_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6b0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi3_ipp_cspi_clk_in_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_cspi_clk_in 00 Selecting
 * Pad: AUD_TXD for Mode: ALT1. 01 Selecting Pad: EPDC_D11 for Mode: ALT1. 10 Selecting Pad: SD2_CLK
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_dataready_b 0 Selecting Pad: AUD_MCLK for Mode: ALT2. 1 Selecting Pad: EPDC_D15 for Mode: ALT6.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi3_ipp_ind_dataready_b_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6b4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_dataready_b_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_dataready_b 0 Selecting
 * Pad: AUD_MCLK for Mode: ALT2. 1 Selecting Pad: EPDC_D15 for Mode: ALT6.
 */

#define BP_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_miso 00 Selecting Pad: AUD_TXC for Mode: ALT1. 01 Selecting Pad: EPDC_D9 for Mode: ALT1. 10 Selecting Pad: SD2_DAT1 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi3_ipp_ind_miso_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6b8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_miso_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_miso 00 Selecting Pad:
 * AUD_TXC for Mode: ALT1. 01 Selecting Pad: EPDC_D9 for Mode: ALT1. 10 Selecting Pad: SD2_DAT1 for
 * Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_mosi 00 Selecting Pad: AUD_RXD for Mode: ALT1. 01 Selecting Pad: EPDC_D8 for Mode: ALT1. 10 Selecting Pad: SD2_DAT0 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi3_ipp_ind_mosi_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6bc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_mosi_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_mosi 00 Selecting Pad:
 * AUD_RXD for Mode: ALT1. 01 Selecting Pad: EPDC_D8 for Mode: ALT1. 10 Selecting Pad: SD2_DAT0 for
 * Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_ss_b[0] 00 Selecting Pad: AUD_RXFS for Mode: ALT6. 01 Selecting Pad: EPDC_D10 for Mode: ALT1. 10 Selecting Pad: SD2_CMD for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi3_ipp_ind_ss_b_0_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6c0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_ss_b_0_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_ss_b[0] 00 Selecting
 * Pad: AUD_RXFS for Mode: ALT6. 01 Selecting Pad: EPDC_D10 for Mode: ALT1. 10 Selecting Pad:
 * SD2_CMD for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_ss_b[1] 0 Selecting Pad: AUD_RXC for Mode: ALT6. 1 Selecting Pad: EPDC_D12 for Mode: ALT6.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi3_ipp_ind_ss_b_1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6c4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_ss_b_1_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_ss_b[1] 0 Selecting
 * Pad: AUD_RXC for Mode: ALT6. 1 Selecting Pad: EPDC_D12 for Mode: ALT6.
 */

#define BP_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_ss_b[2] 0 Selecting Pad: EPDC_D13 for Mode: ALT6. 1 Selecting Pad: I2C1_SCL for Mode: ALT2.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi3_ipp_ind_ss_b_2_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6c8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_ss_b_2_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_ss_b[2] 0 Selecting
 * Pad: EPDC_D13 for Mode: ALT6. 1 Selecting Pad: I2C1_SCL for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_ss_b[3] 0 Selecting Pad: EPDC_D14 for Mode: ALT6. 1 Selecting Pad: I2C1_SDA for Mode: ALT2.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi3_ipp_ind_ss_b_3_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6cc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_ss_b_3_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi3, In Pin: ipp_ind_ss_b[3] 0 Selecting
 * Pad: EPDC_D14 for Mode: ALT6. 1 Selecting Pad: I2C1_SDA for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi4, In Pin: ipp_cspi_clk_in 00 Selecting Pad: EPDC_D3 for Mode: ALT1. 01 Selecting Pad: FEC_TX_CLK for Mode: ALT3. 10 Selecting Pad: KEY_ROW2 for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi4_ipp_cspi_clk_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6d0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi4_ipp_cspi_clk_in_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi4, In Pin: ipp_cspi_clk_in 00 Selecting
 * Pad: EPDC_D3 for Mode: ALT1. 01 Selecting Pad: FEC_TX_CLK for Mode: ALT3. 10 Selecting Pad:
 * KEY_ROW2 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi4, In Pin: ipp_ind_miso 00 Selecting Pad: EPDC_D1 for Mode: ALT1. 01 Selecting Pad: FEC_CRS_DV for Mode: ALT3. 10 Selecting Pad: KEY_ROW1 for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi4_ipp_ind_miso_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6d4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi4_ipp_ind_miso_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi4, In Pin: ipp_ind_miso 00 Selecting Pad:
 * EPDC_D1 for Mode: ALT1. 01 Selecting Pad: FEC_CRS_DV for Mode: ALT3. 10 Selecting Pad: KEY_ROW1
 * for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi4, In Pin: ipp_ind_mosi 00 Selecting Pad: EPDC_D0 for Mode: ALT1. 01 Selecting Pad: FEC_RX_ER for Mode: ALT3. 10 Selecting Pad: KEY_COL1 for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi4_ipp_ind_mosi_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6d8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi4_ipp_ind_mosi_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi4, In Pin: ipp_ind_mosi 00 Selecting Pad:
 * EPDC_D0 for Mode: ALT1. 01 Selecting Pad: FEC_RX_ER for Mode: ALT3. 10 Selecting Pad: KEY_COL1
 * for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi4, In Pin: ipp_ind_ss_b[0] 00 Selecting Pad: EPDC_D2 for Mode: ALT1. 01 Selecting Pad: FEC_MDIO for Mode: ALT3. 10 Selecting Pad: KEY_COL2 for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi4_ipp_ind_ss_b_0_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6dc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi4_ipp_ind_ss_b_0_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi4, In Pin: ipp_ind_ss_b[0] 00 Selecting
 * Pad: EPDC_D2 for Mode: ALT1. 01 Selecting Pad: FEC_MDIO for Mode: ALT3. 10 Selecting Pad:
 * KEY_COL2 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi4, In Pin: ipp_ind_ss_b[1] 0 Selecting Pad: EPDC_D4 for Mode: ALT1. 1 Selecting Pad: FEC_RXD1 for Mode: ALT3.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi4_ipp_ind_ss_b_1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6e0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi4_ipp_ind_ss_b_1_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi4, In Pin: ipp_ind_ss_b[1] 0 Selecting
 * Pad: EPDC_D4 for Mode: ALT1. 1 Selecting Pad: FEC_RXD1 for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: ecspi4, In Pin: ipp_ind_ss_b[2] 0 Selecting Pad: EPDC_D5 for Mode: ALT1. 1 Selecting Pad: FEC_TXD0 for Mode: ALT3.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_ecspi4_ipp_ind_ss_b_2_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6e4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_ecspi4_ipp_ind_ss_b_2_select_input_t *) HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: ecspi4, In Pin: ipp_ind_ss_b[2] 0 Selecting
 * Pad: EPDC_D5 for Mode: ALT1. 1 Selecting Pad: FEC_TXD0 for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: epdc, In Pin: ipp_epdc_pwrirq 0 Selecting Pad: EPDC_D13 for Mode: ALT2. 1 Selecting Pad: EPDC_PWRINT for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_epdc_ipp_epdc_pwrirq_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6e8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_epdc_ipp_epdc_pwrirq_select_input_t *) HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: epdc, In Pin: ipp_epdc_pwrirq 0 Selecting Pad:
 * EPDC_D13 for Mode: ALT2. 1 Selecting Pad: EPDC_PWRINT for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: epdc, In Pin: ipp_epdc_pwrstat 0 Selecting Pad: EPDC_D14 for Mode: ALT2. 1 Selecting Pad: EPDC_PWRSTAT for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_epdc_ipp_epdc_pwrstat_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6ec)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_epdc_ipp_epdc_pwrstat_select_input_t *) HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: epdc, In Pin: ipp_epdc_pwrstat 0 Selecting Pad:
 * EPDC_D14 for Mode: ALT2. 1 Selecting Pad: EPDC_PWRSTAT for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_col 00 Selecting Pad: FEC_RXD1 for Mode: ALT6. 01 Selecting Pad: SD2_DAT2 for Mode: ALT2. 10 Selecting Pad: UART1_RXD for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_fec_fec_col_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6f0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_fec_fec_col_select_input_t *) HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_col 00 Selecting Pad: FEC_RXD1
 * for Mode: ALT6. 01 Selecting Pad: SD2_DAT2 for Mode: ALT2. 10 Selecting Pad: UART1_RXD for Mode:
 * ALT3.
 */

#define BP_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_FEC_FEC_COL_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_mdi 00 Selecting Pad: AUD_RXFS for Mode: ALT3. 01 Selecting Pad: FEC_MDIO for Mode: ALT0. 10 Selecting Pad: SD1_CLK for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_fec_fec_mdi_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6f4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_fec_fec_mdi_select_input_t *) HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_mdi 00 Selecting Pad: AUD_RXFS
 * for Mode: ALT3. 01 Selecting Pad: FEC_MDIO for Mode: ALT0. 10 Selecting Pad: SD1_CLK for Mode:
 * ALT1.
 */

#define BP_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_FEC_FEC_MDI_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_rdata[0] 00 Selecting Pad: FEC_RXD0 for Mode: ALT0. 01 Selecting Pad: I2C1_SCL for Mode: ALT3. 10 Selecting Pad: SD1_DAT5 for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_fec_fec_rdata_0_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6f8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_fec_fec_rdata_0_select_input_t *) HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_rdata[0] 00 Selecting Pad:
 * FEC_RXD0 for Mode: ALT0. 01 Selecting Pad: I2C1_SCL for Mode: ALT3. 10 Selecting Pad: SD1_DAT5
 * for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_rdata[1] 00 Selecting Pad: AUD_TXFS for Mode: ALT3. 01 Selecting Pad: FEC_RXD1 for Mode: ALT0. 10 Selecting Pad: SD1_DAT2 for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_fec_fec_rdata_1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x6fc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_fec_fec_rdata_1_select_input_t *) HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_rdata[1] 00 Selecting Pad:
 * AUD_TXFS for Mode: ALT3. 01 Selecting Pad: FEC_RXD1 for Mode: ALT0. 10 Selecting Pad: SD1_DAT2
 * for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_rx_clk 00 Selecting Pad: FEC_TXD1 for Mode: ALT6. 01 Selecting Pad: SD2_DAT3 for Mode: ALT2. 10 Selecting Pad: UART1_TXD for Mode: ALT3.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_fec_fec_rx_clk_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x700)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_fec_fec_rx_clk_select_input_t *) HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_rx_clk 00 Selecting Pad:
 * FEC_TXD1 for Mode: ALT6. 01 Selecting Pad: SD2_DAT3 for Mode: ALT2. 10 Selecting Pad: UART1_TXD
 * for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_rx_dv 00 Selecting Pad: AUD_TXC for Mode: ALT3. 01 Selecting Pad: FEC_CRS_DV for Mode: ALT0. 10 Selecting Pad: SD1_DAT1 for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_fec_fec_rx_dv_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x704)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_fec_fec_rx_dv_select_input_t *) HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_rx_dv 00 Selecting Pad:
 * AUD_TXC for Mode: ALT3. 01 Selecting Pad: FEC_CRS_DV for Mode: ALT0. 10 Selecting Pad: SD1_DAT1
 * for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_rx_er 00 Selecting Pad: AUD_RXD for Mode: ALT3. 01 Selecting Pad: FEC_RX_ER for Mode: ALT0. 10 Selecting Pad: SD1_DAT0 for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_fec_fec_rx_er_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x708)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_fec_fec_rx_er_select_input_t *) HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_rx_er 00 Selecting Pad:
 * AUD_RXD for Mode: ALT3. 01 Selecting Pad: FEC_RX_ER for Mode: ALT0. 10 Selecting Pad: SD1_DAT0
 * for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_tx_clk 00 Selecting Pad: AUD_RXC for Mode: ALT3. 01 Selecting Pad: FEC_TX_CLK for Mode: ALT0. 10 Selecting Pad: SD1_CMD for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_fec_fec_tx_clk_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x70c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_fec_fec_tx_clk_select_input_t *) HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: fec, In Pin: fec_tx_clk 00 Selecting Pad:
 * AUD_RXC for Mode: ALT3. 01 Selecting Pad: FEC_TX_CLK for Mode: ALT0. 10 Selecting Pad: SD1_CMD
 * for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: gpt, In Pin: ipp_ind_capin1 0 Selecting Pad: FEC_MDIO for Mode: ALT4. 1 Selecting Pad: LCD_DAT18 for Mode: ALT4.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_gpt_ipp_ind_capin1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x710)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_gpt_ipp_ind_capin1_select_input_t *) HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: gpt, In Pin: ipp_ind_capin1 0 Selecting Pad:
 * FEC_MDIO for Mode: ALT4. 1 Selecting Pad: LCD_DAT18 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: gpt, In Pin: ipp_ind_capin2 0 Selecting Pad: FEC_TX_CLK for Mode: ALT4. 1 Selecting Pad: LCD_DAT19 for Mode: ALT4.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_gpt_ipp_ind_capin2_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x714)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_gpt_ipp_ind_capin2_select_input_t *) HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: gpt, In Pin: ipp_ind_capin2 0 Selecting Pad:
 * FEC_TX_CLK for Mode: ALT4. 1 Selecting Pad: LCD_DAT19 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: gpt, In Pin: ipp_ind_clkin 0 Selecting Pad: FEC_TXD0 for Mode: ALT4. 1 Selecting Pad: LCD_DAT23 for Mode: ALT4.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_gpt_ipp_ind_clkin_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x718)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_gpt_ipp_ind_clkin_select_input_t *) HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: gpt, In Pin: ipp_ind_clkin 0 Selecting Pad:
 * FEC_TXD0 for Mode: ALT4. 1 Selecting Pad: LCD_DAT23 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: i2c1, In Pin: ipp_scl_in 00 Selecting Pad: AUD_RXFS for Mode: ALT1. 01 Selecting Pad: HSIC_DAT for Mode: ALT1. 10 Selecting Pad: I2C1_SCL for Mode: ALT0.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_i2c1_ipp_scl_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x71c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_i2c1_ipp_scl_in_select_input_t *) HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: i2c1, In Pin: ipp_scl_in 00 Selecting Pad:
 * AUD_RXFS for Mode: ALT1. 01 Selecting Pad: HSIC_DAT for Mode: ALT1. 10 Selecting Pad: I2C1_SCL
 * for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: i2c1, In Pin: ipp_sda_in 00 Selecting Pad: AUD_RXC for Mode: ALT1. 01 Selecting Pad: HSIC_STROBE for Mode: ALT1. 10 Selecting Pad: I2C1_SDA for Mode: ALT0.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_i2c1_ipp_sda_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x720)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_i2c1_ipp_sda_in_select_input_t *) HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: i2c1, In Pin: ipp_sda_in 00 Selecting Pad:
 * AUD_RXC for Mode: ALT1. 01 Selecting Pad: HSIC_STROBE for Mode: ALT1. 10 Selecting Pad: I2C1_SDA
 * for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: i2c2, In Pin: ipp_scl_in 00 Selecting Pad: EPDC_SDCLK for Mode: ALT2. 01 Selecting Pad: I2C2_SCL for Mode: ALT0. 10 Selecting Pad: KEY_COL0 for Mode: ALT1. 11 Selecting Pad: LCD_DAT16 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_i2c2_ipp_scl_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x724)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_i2c2_ipp_scl_in_select_input_t *) HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: i2c2, In Pin: ipp_scl_in 00 Selecting Pad:
 * EPDC_SDCLK for Mode: ALT2. 01 Selecting Pad: I2C2_SCL for Mode: ALT0. 10 Selecting Pad: KEY_COL0
 * for Mode: ALT1. 11 Selecting Pad: LCD_DAT16 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: i2c2, In Pin: ipp_sda_in 00 Selecting Pad: EPDC_SDLE for Mode: ALT2. 01 Selecting Pad: I2C2_SDA for Mode: ALT0. 10 Selecting Pad: KEY_ROW0 for Mode: ALT1. 11 Selecting Pad: LCD_DAT17 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_i2c2_ipp_sda_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x728)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_i2c2_ipp_sda_in_select_input_t *) HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: i2c2, In Pin: ipp_sda_in 00 Selecting Pad:
 * EPDC_SDLE for Mode: ALT2. 01 Selecting Pad: I2C2_SDA for Mode: ALT0. 10 Selecting Pad: KEY_ROW0
 * for Mode: ALT1. 11 Selecting Pad: LCD_DAT17 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: i2c3, In Pin: ipp_scl_in 00 Selecting Pad: AUD_RXFS for Mode: ALT4. 01 Selecting Pad: EPDC_SDCE2 for Mode: ALT1. 10 Selecting Pad: REF_CLK_24M for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_i2c3_ipp_scl_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x72c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_i2c3_ipp_scl_in_select_input_t *) HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: i2c3, In Pin: ipp_scl_in 00 Selecting Pad:
 * AUD_RXFS for Mode: ALT4. 01 Selecting Pad: EPDC_SDCE2 for Mode: ALT1. 10 Selecting Pad:
 * REF_CLK_24M for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: i2c3, In Pin: ipp_sda_in 00 Selecting Pad: AUD_RXC for Mode: ALT4. 01 Selecting Pad: EPDC_SDCE3 for Mode: ALT1. 10 Selecting Pad: REF_CLK_32K for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_i2c3_ipp_sda_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x730)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_i2c3_ipp_sda_in_select_input_t *) HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: i2c3, In Pin: ipp_sda_in 00 Selecting Pad:
 * AUD_RXC for Mode: ALT4. 01 Selecting Pad: EPDC_SDCE3 for Mode: ALT1. 10 Selecting Pad:
 * REF_CLK_32K for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[0] 00 Selecting Pad: KEY_COL0 for Mode: ALT0. 01 Selecting Pad: LCD_DAT8 for Mode: ALT1. 10 Selecting Pad: SD1_CLK for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_col_0_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x734)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_0_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[0] 00 Selecting Pad:
 * KEY_COL0 for Mode: ALT0. 01 Selecting Pad: LCD_DAT8 for Mode: ALT1. 10 Selecting Pad: SD1_CLK for
 * Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[1] 00 Selecting Pad: KEY_COL1 for Mode: ALT0. 01 Selecting Pad: LCD_DAT10 for Mode: ALT1. 10 Selecting Pad: SD1_DAT0 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_col_1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x738)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_1_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[1] 00 Selecting Pad:
 * KEY_COL1 for Mode: ALT0. 01 Selecting Pad: LCD_DAT10 for Mode: ALT1. 10 Selecting Pad: SD1_DAT0
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[2] 00 Selecting Pad: KEY_COL2 for Mode: ALT0. 01 Selecting Pad: LCD_DAT12 for Mode: ALT1. 10 Selecting Pad: SD1_DAT2 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_col_2_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x73c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_2_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[2] 00 Selecting Pad:
 * KEY_COL2 for Mode: ALT0. 01 Selecting Pad: LCD_DAT12 for Mode: ALT1. 10 Selecting Pad: SD1_DAT2
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[3] 00 Selecting Pad: KEY_COL3 for Mode: ALT0. 01 Selecting Pad: LCD_DAT14 for Mode: ALT1. 10 Selecting Pad: SD1_DAT4 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_col_3_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x740)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_3_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[3] 00 Selecting Pad:
 * KEY_COL3 for Mode: ALT0. 01 Selecting Pad: LCD_DAT14 for Mode: ALT1. 10 Selecting Pad: SD1_DAT4
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[4] 00 Selecting Pad: KEY_COL4 for Mode: ALT0. 01 Selecting Pad: LCD_DAT16 for Mode: ALT1. 10 Selecting Pad: SD1_DAT6 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_col_4_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x744)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_4_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[4] 00 Selecting Pad:
 * KEY_COL4 for Mode: ALT0. 01 Selecting Pad: LCD_DAT16 for Mode: ALT1. 10 Selecting Pad: SD1_DAT6
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[5] 00 Selecting Pad: KEY_COL5 for Mode: ALT0. 01 Selecting Pad: LCD_DAT18 for Mode: ALT1. 10 Selecting Pad: SD3_CLK for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_col_5_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x748)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_5_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[5] 00 Selecting Pad:
 * KEY_COL5 for Mode: ALT0. 01 Selecting Pad: LCD_DAT18 for Mode: ALT1. 10 Selecting Pad: SD3_CLK
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[6] 00 Selecting Pad: KEY_COL6 for Mode: ALT0. 01 Selecting Pad: LCD_DAT20 for Mode: ALT1. 10 Selecting Pad: SD3_DAT0 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_col_6_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x74c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_6_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[6] 00 Selecting Pad:
 * KEY_COL6 for Mode: ALT0. 01 Selecting Pad: LCD_DAT20 for Mode: ALT1. 10 Selecting Pad: SD3_DAT0
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[7] 00 Selecting Pad: KEY_COL7 for Mode: ALT0. 01 Selecting Pad: LCD_DAT22 for Mode: ALT1. 10 Selecting Pad: SD3_DAT2 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_col_7_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x750)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_7_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_col[7] 00 Selecting Pad:
 * KEY_COL7 for Mode: ALT0. 01 Selecting Pad: LCD_DAT22 for Mode: ALT1. 10 Selecting Pad: SD3_DAT2
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[0] 00 Selecting Pad: KEY_ROW0 for Mode: ALT0. 01 Selecting Pad: LCD_DAT9 for Mode: ALT1. 10 Selecting Pad: SD1_CMD for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_row_0_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x754)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_0_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[0] 00 Selecting Pad:
 * KEY_ROW0 for Mode: ALT0. 01 Selecting Pad: LCD_DAT9 for Mode: ALT1. 10 Selecting Pad: SD1_CMD for
 * Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[1] 00 Selecting Pad: KEY_ROW1 for Mode: ALT0. 01 Selecting Pad: LCD_DAT11 for Mode: ALT1. 10 Selecting Pad: SD1_DAT1 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_row_1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x758)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_1_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[1] 00 Selecting Pad:
 * KEY_ROW1 for Mode: ALT0. 01 Selecting Pad: LCD_DAT11 for Mode: ALT1. 10 Selecting Pad: SD1_DAT1
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[2] 00 Selecting Pad: KEY_ROW2 for Mode: ALT0. 01 Selecting Pad: LCD_DAT13 for Mode: ALT1. 10 Selecting Pad: SD1_DAT3 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_row_2_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x75c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_2_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[2] 00 Selecting Pad:
 * KEY_ROW2 for Mode: ALT0. 01 Selecting Pad: LCD_DAT13 for Mode: ALT1. 10 Selecting Pad: SD1_DAT3
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[3] 00 Selecting Pad: KEY_ROW3 for Mode: ALT0. 01 Selecting Pad: LCD_DAT15 for Mode: ALT1. 10 Selecting Pad: SD1_DAT5 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_row_3_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x760)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_3_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[3] 00 Selecting Pad:
 * KEY_ROW3 for Mode: ALT0. 01 Selecting Pad: LCD_DAT15 for Mode: ALT1. 10 Selecting Pad: SD1_DAT5
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[4] 00 Selecting Pad: KEY_ROW4 for Mode: ALT0. 01 Selecting Pad: LCD_DAT17 for Mode: ALT1. 10 Selecting Pad: SD1_DAT7 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_row_4_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x764)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_4_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[4] 00 Selecting Pad:
 * KEY_ROW4 for Mode: ALT0. 01 Selecting Pad: LCD_DAT17 for Mode: ALT1. 10 Selecting Pad: SD1_DAT7
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[5] 00 Selecting Pad: KEY_ROW5 for Mode: ALT0. 01 Selecting Pad: LCD_DAT19 for Mode: ALT1. 10 Selecting Pad: SD3_CMD for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_row_5_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x768)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_5_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[5] 00 Selecting Pad:
 * KEY_ROW5 for Mode: ALT0. 01 Selecting Pad: LCD_DAT19 for Mode: ALT1. 10 Selecting Pad: SD3_CMD
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[6] 00 Selecting Pad: KEY_ROW6 for Mode: ALT0. 01 Selecting Pad: LCD_DAT21 for Mode: ALT1. 10 Selecting Pad: SD3_DAT1 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_row_6_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x76c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_6_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[6] 00 Selecting Pad:
 * KEY_ROW6 for Mode: ALT0. 01 Selecting Pad: LCD_DAT21 for Mode: ALT1. 10 Selecting Pad: SD3_DAT1
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[7] 00 Selecting Pad: KEY_ROW7 for Mode: ALT0. 01 Selecting Pad: LCD_DAT23 for Mode: ALT1. 10 Selecting Pad: SD3_DAT3 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_kpp_ipp_ind_row_7_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x770)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_7_select_input_t *) HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: kpp, In Pin: ipp_ind_row[7] 00 Selecting Pad:
 * KEY_ROW7 for Mode: ALT0. 01 Selecting Pad: LCD_DAT23 for Mode: ALT1. 10 Selecting Pad: SD3_DAT3
 * for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_busy 0 Selecting Pad: LCD_HSYNC for Mode: ALT0. 1 Selecting Pad: LCD_RESET for Mode: ALT2.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_busy_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x774)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_busy_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_busy 0 Selecting Pad:
 * LCD_HSYNC for Mode: ALT0. 1 Selecting Pad: LCD_RESET for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[0] 0 Selecting Pad: KEY_COL0 for Mode: ALT2. 1 Selecting Pad: LCD_DAT0 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_0_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x778)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_0_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[0] 0 Selecting Pad:
 * KEY_COL0 for Mode: ALT2. 1 Selecting Pad: LCD_DAT0 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[1] 0 Selecting Pad: KEY_ROW0 for Mode: ALT2. 1 Selecting Pad: LCD_DAT1 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x77c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_1_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[1] 0 Selecting Pad:
 * KEY_ROW0 for Mode: ALT2. 1 Selecting Pad: LCD_DAT1 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[2] 0 Selecting Pad: KEY_COL1 for Mode: ALT2. 1 Selecting Pad: LCD_DAT2 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_2_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x780)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_2_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[2] 0 Selecting Pad:
 * KEY_COL1 for Mode: ALT2. 1 Selecting Pad: LCD_DAT2 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[3] 0 Selecting Pad: KEY_ROW1 for Mode: ALT2. 1 Selecting Pad: LCD_DAT3 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_3_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x784)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_3_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[3] 0 Selecting Pad:
 * KEY_ROW1 for Mode: ALT2. 1 Selecting Pad: LCD_DAT3 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[4] 0 Selecting Pad: KEY_COL2 for Mode: ALT2. 1 Selecting Pad: LCD_DAT4 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_4_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x788)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_4_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[4] 0 Selecting Pad:
 * KEY_COL2 for Mode: ALT2. 1 Selecting Pad: LCD_DAT4 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[5] 0 Selecting Pad: KEY_ROW2 for Mode: ALT2. 1 Selecting Pad: LCD_DAT5 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_5_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x78c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_5_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[5] 0 Selecting Pad:
 * KEY_ROW2 for Mode: ALT2. 1 Selecting Pad: LCD_DAT5 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[6] 0 Selecting Pad: KEY_COL3 for Mode: ALT2. 1 Selecting Pad: LCD_DAT6 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_6_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x790)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_6_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[6] 0 Selecting Pad:
 * KEY_COL3 for Mode: ALT2. 1 Selecting Pad: LCD_DAT6 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[7] 0 Selecting Pad: KEY_ROW3 for Mode: ALT2. 1 Selecting Pad: LCD_DAT7 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_7_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x794)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_7_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[7] 0 Selecting Pad:
 * KEY_ROW3 for Mode: ALT2. 1 Selecting Pad: LCD_DAT7 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[8] 0 Selecting Pad: KEY_COL4 for Mode: ALT2. 1 Selecting Pad: LCD_DAT8 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_8_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x798)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_8_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[8] 0 Selecting Pad:
 * KEY_COL4 for Mode: ALT2. 1 Selecting Pad: LCD_DAT8 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[9] 0 Selecting Pad: KEY_ROW4 for Mode: ALT2. 1 Selecting Pad: LCD_DAT9 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_9_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x79c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_9_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[9] 0 Selecting Pad:
 * KEY_ROW4 for Mode: ALT2. 1 Selecting Pad: LCD_DAT9 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[10] 0 Selecting Pad: KEY_COL5 for Mode: ALT2. 1 Selecting Pad: LCD_DAT10 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_10_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7a0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_10_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[10] 0 Selecting
 * Pad: KEY_COL5 for Mode: ALT2. 1 Selecting Pad: LCD_DAT10 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[11] 0 Selecting Pad: KEY_ROW5 for Mode: ALT2. 1 Selecting Pad: LCD_DAT11 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_11_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7a4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_11_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[11] 0 Selecting
 * Pad: KEY_ROW5 for Mode: ALT2. 1 Selecting Pad: LCD_DAT11 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[12] 0 Selecting Pad: KEY_COL6 for Mode: ALT2. 1 Selecting Pad: LCD_DAT12 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_12_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7a8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_12_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[12] 0 Selecting
 * Pad: KEY_COL6 for Mode: ALT2. 1 Selecting Pad: LCD_DAT12 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[13] 0 Selecting Pad: KEY_ROW6 for Mode: ALT2. 1 Selecting Pad: LCD_DAT13 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_13_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7ac)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_13_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[13] 0 Selecting
 * Pad: KEY_ROW6 for Mode: ALT2. 1 Selecting Pad: LCD_DAT13 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[14] 0 Selecting Pad: KEY_COL7 for Mode: ALT2. 1 Selecting Pad: LCD_DAT14 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_14_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7b0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_14_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[14] 0 Selecting
 * Pad: KEY_COL7 for Mode: ALT2. 1 Selecting Pad: LCD_DAT14 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[15] 0 Selecting Pad: KEY_ROW7 for Mode: ALT2. 1 Selecting Pad: LCD_DAT15 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_15_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7b4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_15_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[15] 0 Selecting
 * Pad: KEY_ROW7 for Mode: ALT2. 1 Selecting Pad: LCD_DAT15 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[16] 0 Selecting Pad: EPDC_PWRCTRL0 for Mode: ALT2. 1 Selecting Pad: LCD_DAT16 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_16_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7b8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_16_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[16] 0 Selecting
 * Pad: EPDC_PWRCTRL0 for Mode: ALT2. 1 Selecting Pad: LCD_DAT16 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[17] 0 Selecting Pad: EPDC_PWRCTRL1 for Mode: ALT2. 1 Selecting Pad: LCD_DAT17 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_17_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7bc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_17_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[17] 0 Selecting
 * Pad: EPDC_PWRCTRL1 for Mode: ALT2. 1 Selecting Pad: LCD_DAT17 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[18] 0 Selecting Pad: EPDC_PWRCTRL2 for Mode: ALT2. 1 Selecting Pad: LCD_DAT18 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_18_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7c0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_18_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[18] 0 Selecting
 * Pad: EPDC_PWRCTRL2 for Mode: ALT2. 1 Selecting Pad: LCD_DAT18 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[19] 0 Selecting Pad: EPDC_PWRCTRL3 for Mode: ALT2. 1 Selecting Pad: LCD_DAT19 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_19_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7c4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_19_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[19] 0 Selecting
 * Pad: EPDC_PWRCTRL3 for Mode: ALT2. 1 Selecting Pad: LCD_DAT19 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[20] 0 Selecting Pad: EPDC_PWRCOM for Mode: ALT2. 1 Selecting Pad: LCD_DAT20 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_20_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7c8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_20_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[20] 0 Selecting
 * Pad: EPDC_PWRCOM for Mode: ALT2. 1 Selecting Pad: LCD_DAT20 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[21] 0 Selecting Pad: EPDC_PWRINT for Mode: ALT2. 1 Selecting Pad: LCD_DAT21 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_21_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7cc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_21_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[21] 0 Selecting
 * Pad: EPDC_PWRINT for Mode: ALT2. 1 Selecting Pad: LCD_DAT21 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[22] 0 Selecting Pad: EPDC_PWRSTAT for Mode: ALT2. 1 Selecting Pad: LCD_DAT22 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_22_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7d0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_22_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[22] 0 Selecting
 * Pad: EPDC_PWRSTAT for Mode: ALT2. 1 Selecting Pad: LCD_DAT22 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[23] 0 Selecting Pad: EPDC_PWRWAKEUP for Mode: ALT2. 1 Selecting Pad: LCD_DAT23 for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_23_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7d4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_23_select_input_t *) HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: lcdif, In Pin: lcdif_rxdata[23] 0 Selecting
 * Pad: EPDC_PWRWAKEUP for Mode: ALT2. 1 Selecting Pad: LCD_DAT23 for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: mshc, In Pin: ipp_di_data[0] 0 Selecting Pad: KEY_COL1 for Mode: ALT6. 1 Selecting Pad: SD1_DAT0 for Mode: ALT4.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_mshc_ipp_di_data_0_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7d8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_mshc_ipp_di_data_0_select_input_t *) HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: mshc, In Pin: ipp_di_data[0] 0 Selecting Pad:
 * KEY_COL1 for Mode: ALT6. 1 Selecting Pad: SD1_DAT0 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: mshc, In Pin: ipp_di_data[1] 0 Selecting Pad: KEY_ROW1 for Mode: ALT6. 1 Selecting Pad: SD1_DAT1 for Mode: ALT4.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_mshc_ipp_di_data_1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7dc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_mshc_ipp_di_data_1_select_input_t *) HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: mshc, In Pin: ipp_di_data[1] 0 Selecting Pad:
 * KEY_ROW1 for Mode: ALT6. 1 Selecting Pad: SD1_DAT1 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: mshc, In Pin: ipp_di_data[2] 0 Selecting Pad: KEY_COL2 for Mode: ALT6. 1 Selecting Pad: SD1_DAT2 for Mode: ALT4.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_mshc_ipp_di_data_2_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7e0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_mshc_ipp_di_data_2_select_input_t *) HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: mshc, In Pin: ipp_di_data[2] 0 Selecting Pad:
 * KEY_COL2 for Mode: ALT6. 1 Selecting Pad: SD1_DAT2 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: mshc, In Pin: ipp_di_data[3] 0 Selecting Pad: KEY_ROW2 for Mode: ALT6. 1 Selecting Pad: SD1_DAT3 for Mode: ALT4.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_mshc_ipp_di_data_3_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7e4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_mshc_ipp_di_data_3_select_input_t *) HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: mshc, In Pin: ipp_di_data[3] 0 Selecting Pad:
 * KEY_ROW2 for Mode: ALT6. 1 Selecting Pad: SD1_DAT3 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: mshc, In Pin: ipp_di_scki 0 Selecting Pad: KEY_COL0 for Mode: ALT6. 1 Selecting Pad: SD1_CLK for Mode: ALT4.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_mshc_ipp_di_scki_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7e8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_mshc_ipp_di_scki_select_input_t *) HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: mshc, In Pin: ipp_di_scki 0 Selecting Pad:
 * KEY_COL0 for Mode: ALT6. 1 Selecting Pad: SD1_CLK for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: pl301_sim_mx6sl_per1, In Pin: hprot_m_d_6[1] 0 Selecting Pad: AUD_RXFS for Mode: ALT7. 1 Selecting Pad: SD2_CLK for Mode: ALT7.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_pl301_sim_mx6sl_per1_hprot_m_d_6_1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7ec)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_pl301_sim_mx6sl_per1_hprot_m_d_6_1_select_input_t *) HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: pl301_sim_mx6sl_per1, In Pin: hprot_m_d_6[1] 0
 * Selecting Pad: AUD_RXFS for Mode: ALT7. 1 Selecting Pad: SD2_CLK for Mode: ALT7.
 */

#define BP_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: spdif, In Pin: spdif_in1 00 Selecting Pad: FEC_TX_EN for Mode: ALT2. 01 Selecting Pad: I2C2_SCL for Mode: ALT2. 10 Selecting Pad: SD2_DAT5 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_spdif_spdif_in1_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7f0)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_spdif_spdif_in1_select_input_t *) HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: spdif, In Pin: spdif_in1 00 Selecting Pad:
 * FEC_TX_EN for Mode: ALT2. 01 Selecting Pad: I2C2_SCL for Mode: ALT2. 10 Selecting Pad: SD2_DAT5
 * for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: spdif, In Pin: tx_clk2 00 Selecting Pad: AUD_MCLK for Mode: ALT6. 01 Selecting Pad: ECSPI2_SCLK for Mode: ALT1. 10 Selecting Pad: FEC_REF_CLK for Mode: ALT6.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_spdif_tx_clk2_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7f4)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_spdif_tx_clk2_select_input_t *) HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: spdif, In Pin: tx_clk2 00 Selecting Pad:
 * AUD_MCLK for Mode: ALT6. 01 Selecting Pad: ECSPI2_SCLK for Mode: ALT1. 10 Selecting Pad:
 * FEC_REF_CLK for Mode: ALT6.
 */

#define BP_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: uart1, In Pin: ipp_uart_rts_b 0 Selecting Pad: I2C1_SCL for Mode: ALT1. 1 Selecting Pad: I2C1_SDA for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_uart1_ipp_uart_rts_b_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7f8)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_uart1_ipp_uart_rts_b_select_input_t *) HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: uart1, In Pin: ipp_uart_rts_b 0 Selecting Pad:
 * I2C1_SCL for Mode: ALT1. 1 Selecting Pad: I2C1_SDA for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: uart1, In Pin: ipp_uart_rxd_mux 0 Selecting Pad: UART1_RXD for Mode: ALT0. 1 Selecting Pad: UART1_TXD for Mode: ALT0.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_uart1_ipp_uart_rxd_mux_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x7fc)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_uart1_ipp_uart_rxd_mux_select_input_t *) HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: uart1, In Pin: ipp_uart_rxd_mux 0 Selecting
 * Pad: UART1_RXD for Mode: ALT0. 1 Selecting Pad: UART1_TXD for Mode: ALT0.
 */

#define BP_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 3; //!< Selecting Pads Involved in Daisy Chain. Instance: uart2, In Pin: ipp_uart_rts_b 000 Selecting Pad: EPDC_D14 for Mode: ALT1. 001 Selecting Pad: EPDC_D15 for Mode: ALT1. 010 Selecting Pad: LCD_RESET for Mode: ALT4. 011 Selecting Pad: LCD_VSYNC for Mode: ALT4. 100 Selecting Pad: SD2_DAT6 for Mode: ALT2. 101 Selecting Pad: SD2_DAT7 for Mode: ALT2.
        unsigned RESERVED0 : 29; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_uart2_ipp_uart_rts_b_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x800)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_uart2_ipp_uart_rts_b_select_input_t *) HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT, field DAISY[2:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: uart2, In Pin: ipp_uart_rts_b 000 Selecting
 * Pad: EPDC_D14 for Mode: ALT1. 001 Selecting Pad: EPDC_D15 for Mode: ALT1. 010 Selecting Pad:
 * LCD_RESET for Mode: ALT4. 011 Selecting Pad: LCD_VSYNC for Mode: ALT4. 100 Selecting Pad:
 * SD2_DAT6 for Mode: ALT2. 101 Selecting Pad: SD2_DAT7 for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_DAISY      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 3; //!< Selecting Pads Involved in Daisy Chain. Instance: uart2, In Pin: ipp_uart_rxd_mux 000 Selecting Pad: EPDC_D12 for Mode: ALT1. 001 Selecting Pad: EPDC_D13 for Mode: ALT1. 010 Selecting Pad: LCD_ENABLE for Mode: ALT4. 011 Selecting Pad: LCD_HSYNC for Mode: ALT4. 100 Selecting Pad: SD2_DAT4 for Mode: ALT2. 101 Selecting Pad: SD2_DAT5 for Mode: ALT2.
        unsigned RESERVED0 : 29; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_uart2_ipp_uart_rxd_mux_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x804)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_uart2_ipp_uart_rxd_mux_select_input_t *) HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT, field DAISY[2:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: uart2, In Pin: ipp_uart_rxd_mux 000 Selecting
 * Pad: EPDC_D12 for Mode: ALT1. 001 Selecting Pad: EPDC_D13 for Mode: ALT1. 010 Selecting Pad:
 * LCD_ENABLE for Mode: ALT4. 011 Selecting Pad: LCD_HSYNC for Mode: ALT4. 100 Selecting Pad:
 * SD2_DAT4 for Mode: ALT2. 101 Selecting Pad: SD2_DAT5 for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: uart3, In Pin: ipp_uart_rts_b 00 Selecting Pad: ECSPI2_MISO for Mode: ALT2. 01 Selecting Pad: ECSPI2_SS0 for Mode: ALT2. 10 Selecting Pad: EPDC_BDR0 for Mode: ALT2. 11 Selecting Pad: EPDC_BDR1 for Mode: ALT2.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_uart3_ipp_uart_rts_b_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x808)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_uart3_ipp_uart_rts_b_select_input_t *) HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: uart3, In Pin: ipp_uart_rts_b 00 Selecting Pad:
 * ECSPI2_MISO for Mode: ALT2. 01 Selecting Pad: ECSPI2_SS0 for Mode: ALT2. 10 Selecting Pad:
 * EPDC_BDR0 for Mode: ALT2. 11 Selecting Pad: EPDC_BDR1 for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 3; //!< Selecting Pads Involved in Daisy Chain. Instance: uart3, In Pin: ipp_uart_rxd_mux 000 Selecting Pad: AUD_RXC for Mode: ALT2. 001 Selecting Pad: AUD_RXFS for Mode: ALT2. 010 Selecting Pad: ECSPI2_MOSI for Mode: ALT2. 011 Selecting Pad: ECSPI2_SCLK for Mode: ALT2. 100 Selecting Pad: EPDC_VCOM0 for Mode: ALT2. 101 Selecting Pad: EPDC_VCOM1 for Mode: ALT2.
        unsigned RESERVED0 : 29; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_uart3_ipp_uart_rxd_mux_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x80c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_uart3_ipp_uart_rxd_mux_select_input_t *) HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT, field DAISY[2:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: uart3, In Pin: ipp_uart_rxd_mux 000 Selecting
 * Pad: AUD_RXC for Mode: ALT2. 001 Selecting Pad: AUD_RXFS for Mode: ALT2. 010 Selecting Pad:
 * ECSPI2_MOSI for Mode: ALT2. 011 Selecting Pad: ECSPI2_SCLK for Mode: ALT2. 100 Selecting Pad:
 * EPDC_VCOM0 for Mode: ALT2. 101 Selecting Pad: EPDC_VCOM1 for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 3; //!< Selecting Pads Involved in Daisy Chain. Instance: uart4, In Pin: ipp_uart_rts_b 000 Selecting Pad: AUD_TXD for Mode: ALT2. 001 Selecting Pad: AUD_TXFS for Mode: ALT2. 010 Selecting Pad: KEY_COL7 for Mode: ALT1. 011 Selecting Pad: KEY_ROW7 for Mode: ALT1. 100 Selecting Pad: SD1_DAT6 for Mode: ALT4. 101 Selecting Pad: SD1_DAT7 for Mode: ALT4.
        unsigned RESERVED0 : 29; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_uart4_ipp_uart_rts_b_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x810)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_uart4_ipp_uart_rts_b_select_input_t *) HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT, field DAISY[2:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: uart4, In Pin: ipp_uart_rts_b 000 Selecting
 * Pad: AUD_TXD for Mode: ALT2. 001 Selecting Pad: AUD_TXFS for Mode: ALT2. 010 Selecting Pad:
 * KEY_COL7 for Mode: ALT1. 011 Selecting Pad: KEY_ROW7 for Mode: ALT1. 100 Selecting Pad: SD1_DAT6
 * for Mode: ALT4. 101 Selecting Pad: SD1_DAT7 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_DAISY      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 3; //!< Selecting Pads Involved in Daisy Chain. Instance: uart4, In Pin: ipp_uart_rxd_mux 000 Selecting Pad: AUD_RXD for Mode: ALT2. 001 Selecting Pad: AUD_TXC for Mode: ALT2. 010 Selecting Pad: KEY_COL6 for Mode: ALT1. 011 Selecting Pad: KEY_ROW6 for Mode: ALT1. 100 Selecting Pad: SD1_DAT4 for Mode: ALT4. 101 Selecting Pad: SD1_DAT5 for Mode: ALT4. 110 Selecting Pad: UART1_RXD for Mode: ALT2. 111 Selecting Pad: UART1_TXD for Mode: ALT2.
        unsigned RESERVED0 : 29; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_uart4_ipp_uart_rxd_mux_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x814)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_uart4_ipp_uart_rxd_mux_select_input_t *) HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT, field DAISY[2:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: uart4, In Pin: ipp_uart_rxd_mux 000 Selecting
 * Pad: AUD_RXD for Mode: ALT2. 001 Selecting Pad: AUD_TXC for Mode: ALT2. 010 Selecting Pad:
 * KEY_COL6 for Mode: ALT1. 011 Selecting Pad: KEY_ROW6 for Mode: ALT1. 100 Selecting Pad: SD1_DAT4
 * for Mode: ALT4. 101 Selecting Pad: SD1_DAT5 for Mode: ALT4. 110 Selecting Pad: UART1_RXD for
 * Mode: ALT2. 111 Selecting Pad: UART1_TXD for Mode: ALT2.
 */

#define BP_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 3; //!< Selecting Pads Involved in Daisy Chain. Instance: uart5, In Pin: ipp_uart_rts_b 000 Selecting Pad: ECSPI1_MISO for Mode: ALT2. 001 Selecting Pad: ECSPI1_SS0 for Mode: ALT2. 010 Selecting Pad: LCD_DAT12 for Mode: ALT4. 011 Selecting Pad: LCD_DAT13 for Mode: ALT4. 100 Selecting Pad: SD2_DAT0 for Mode: ALT4. 101 Selecting Pad: SD2_DAT1 for Mode: ALT4.
        unsigned RESERVED0 : 29; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_uart5_ipp_uart_rts_b_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x818)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_uart5_ipp_uart_rts_b_select_input_t *) HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT, field DAISY[2:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: uart5, In Pin: ipp_uart_rts_b 000 Selecting
 * Pad: ECSPI1_MISO for Mode: ALT2. 001 Selecting Pad: ECSPI1_SS0 for Mode: ALT2. 010 Selecting Pad:
 * LCD_DAT12 for Mode: ALT4. 011 Selecting Pad: LCD_DAT13 for Mode: ALT4. 100 Selecting Pad:
 * SD2_DAT0 for Mode: ALT4. 101 Selecting Pad: SD2_DAT1 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_DAISY      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 3; //!< Selecting Pads Involved in Daisy Chain. Instance: uart5, In Pin: ipp_uart_rxd_mux 000 Selecting Pad: ECSPI1_MOSI for Mode: ALT2. 001 Selecting Pad: ECSPI1_SCLK for Mode: ALT2. 010 Selecting Pad: LCD_DAT14 for Mode: ALT4. 011 Selecting Pad: LCD_DAT15 for Mode: ALT4. 100 Selecting Pad: SD2_DAT2 for Mode: ALT4. 101 Selecting Pad: SD2_DAT3 for Mode: ALT4. 110 Selecting Pad: UART1_RXD for Mode: ALT4. 111 Selecting Pad: UART1_TXD for Mode: ALT4.
        unsigned RESERVED0 : 29; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_uart5_ipp_uart_rxd_mux_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x81c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_uart5_ipp_uart_rxd_mux_select_input_t *) HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT, field DAISY[2:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: uart5, In Pin: ipp_uart_rxd_mux 000 Selecting
 * Pad: ECSPI1_MOSI for Mode: ALT2. 001 Selecting Pad: ECSPI1_SCLK for Mode: ALT2. 010 Selecting
 * Pad: LCD_DAT14 for Mode: ALT4. 011 Selecting Pad: LCD_DAT15 for Mode: ALT4. 100 Selecting Pad:
 * SD2_DAT2 for Mode: ALT4. 101 Selecting Pad: SD2_DAT3 for Mode: ALT4. 110 Selecting Pad: UART1_RXD
 * for Mode: ALT4. 111 Selecting Pad: UART1_TXD for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY      (0x00000007)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usb, In Pin: ipp_ind_otg2_oc 00 Selecting Pad: ECSPI1_SCLK for Mode: ALT6. 01 Selecting Pad: ECSPI2_SCLK for Mode: ALT6. 10 Selecting Pad: KEY_ROW5 for Mode: ALT6. 11 Selecting Pad: SD3_DAT2 for Mode: ALT6.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usb_ipp_ind_otg2_oc_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x820)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usb_ipp_ind_otg2_oc_select_input_t *) HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usb, In Pin: ipp_ind_otg2_oc 00 Selecting Pad:
 * ECSPI1_SCLK for Mode: ALT6. 01 Selecting Pad: ECSPI2_SCLK for Mode: ALT6. 10 Selecting Pad:
 * KEY_ROW5 for Mode: ALT6. 11 Selecting Pad: SD3_DAT2 for Mode: ALT6.
 */

#define BP_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usb, In Pin: ipp_ind_otg_oc 00 Selecting Pad: ECSPI2_MISO for Mode: ALT6. 01 Selecting Pad: KEY_ROW4 for Mode: ALT6. 10 Selecting Pad: SD3_DAT3 for Mode: ALT6.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usb_ipp_ind_otg_oc_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x824)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usb_ipp_ind_otg_oc_select_input_t *) HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usb, In Pin: ipp_ind_otg_oc 00 Selecting Pad:
 * ECSPI2_MISO for Mode: ALT6. 01 Selecting Pad: KEY_ROW4 for Mode: ALT6. 10 Selecting Pad: SD3_DAT3
 * for Mode: ALT6.
 */

#define BP_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc1, In Pin: ipp_card_det 00 Selecting Pad: ECSPI2_SS0 for Mode: ALT4. 01 Selecting Pad: FEC_TXD1 for Mode: ALT3. 10 Selecting Pad: KEY_COL0 for Mode: ALT4. 11 Selecting Pad: KEY_ROW7 for Mode: ALT6.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc1_ipp_card_det_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x828)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc1_ipp_card_det_select_input_t *) HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc1, In Pin: ipp_card_det 00 Selecting Pad:
 * ECSPI2_SS0 for Mode: ALT4. 01 Selecting Pad: FEC_TXD1 for Mode: ALT3. 10 Selecting Pad: KEY_COL0
 * for Mode: ALT4. 11 Selecting Pad: KEY_ROW7 for Mode: ALT6.
 */

#define BP_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc1, In Pin: ipp_wp_on 00 Selecting Pad: ECSPI2_MISO for Mode: ALT4. 01 Selecting Pad: FEC_TX_EN for Mode: ALT3. 10 Selecting Pad: KEY_COL7 for Mode: ALT6. 11 Selecting Pad: KEY_ROW0 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc1_ipp_wp_on_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x82c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc1_ipp_wp_on_select_input_t *) HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc1, In Pin: ipp_wp_on 00 Selecting Pad:
 * ECSPI2_MISO for Mode: ALT4. 01 Selecting Pad: FEC_TX_EN for Mode: ALT3. 10 Selecting Pad:
 * KEY_COL7 for Mode: ALT6. 11 Selecting Pad: KEY_ROW0 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc2, In Pin: ipp_card_det 00 Selecting Pad: ECSPI1_SS0 for Mode: ALT4. 01 Selecting Pad: EPDC_GDSP for Mode: ALT6. 10 Selecting Pad: SD2_DAT7 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc2_ipp_card_det_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x830)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc2_ipp_card_det_select_input_t *) HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc2, In Pin: ipp_card_det 00 Selecting Pad:
 * ECSPI1_SS0 for Mode: ALT4. 01 Selecting Pad: EPDC_GDSP for Mode: ALT6. 10 Selecting Pad: SD2_DAT7
 * for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc2, In Pin: ipp_wp_on 00 Selecting Pad: ECSPI1_MISO for Mode: ALT4. 01 Selecting Pad: EPDC_GDRL for Mode: ALT6. 10 Selecting Pad: SD2_DAT6 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc2_ipp_wp_on_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x834)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc2_ipp_wp_on_select_input_t *) HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc2, In Pin: ipp_wp_on 00 Selecting Pad:
 * ECSPI1_MISO for Mode: ALT4. 01 Selecting Pad: EPDC_GDRL for Mode: ALT6. 10 Selecting Pad:
 * SD2_DAT6 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc3, In Pin: ipp_card_det 00 Selecting Pad: EPDC_PWRWAKEUP for Mode: ALT6. 01 Selecting Pad: FEC_TXD1 for Mode: ALT4. 10 Selecting Pad: I2C2_SDA for Mode: ALT4. 11 Selecting Pad: REF_CLK_32K for Mode: ALT6.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc3_ipp_card_det_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x838)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc3_ipp_card_det_select_input_t *) HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc3, In Pin: ipp_card_det 00 Selecting Pad:
 * EPDC_PWRWAKEUP for Mode: ALT6. 01 Selecting Pad: FEC_TXD1 for Mode: ALT4. 10 Selecting Pad:
 * I2C2_SDA for Mode: ALT4. 11 Selecting Pad: REF_CLK_32K for Mode: ALT6.
 */

#define BP_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc3, In Pin: ipp_dat4_in 0 Selecting Pad: KEY_COL1 for Mode: ALT4. 1 Selecting Pad: SD2_DAT4 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc3_ipp_dat4_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x83c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc3_ipp_dat4_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc3, In Pin: ipp_dat4_in 0 Selecting Pad:
 * KEY_COL1 for Mode: ALT4. 1 Selecting Pad: SD2_DAT4 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc3, In Pin: ipp_dat5_in 0 Selecting Pad: KEY_ROW1 for Mode: ALT4. 1 Selecting Pad: SD2_DAT5 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc3_ipp_dat5_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x840)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc3_ipp_dat5_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc3, In Pin: ipp_dat5_in 0 Selecting Pad:
 * KEY_ROW1 for Mode: ALT4. 1 Selecting Pad: SD2_DAT5 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc3, In Pin: ipp_dat6_in 0 Selecting Pad: KEY_COL2 for Mode: ALT4. 1 Selecting Pad: SD2_DAT6 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc3_ipp_dat6_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x844)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc3_ipp_dat6_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc3, In Pin: ipp_dat6_in 0 Selecting Pad:
 * KEY_COL2 for Mode: ALT4. 1 Selecting Pad: SD2_DAT6 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc3, In Pin: ipp_dat7_in 0 Selecting Pad: KEY_ROW2 for Mode: ALT4. 1 Selecting Pad: SD2_DAT7 for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc3_ipp_dat7_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x848)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc3_ipp_dat7_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc3, In Pin: ipp_dat7_in 0 Selecting Pad:
 * KEY_ROW2 for Mode: ALT4. 1 Selecting Pad: SD2_DAT7 for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc3, In Pin: ipp_wp_on 00 Selecting Pad: EPDC_PWRSTAT for Mode: ALT6. 01 Selecting Pad: FEC_TX_EN for Mode: ALT4. 10 Selecting Pad: I2C2_SCL for Mode: ALT4. 11 Selecting Pad: REF_CLK_24M for Mode: ALT6.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc3_ipp_wp_on_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x84c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc3_ipp_wp_on_select_input_t *) HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc3, In Pin: ipp_wp_on 00 Selecting Pad:
 * EPDC_PWRSTAT for Mode: ALT6. 01 Selecting Pad: FEC_TX_EN for Mode: ALT4. 10 Selecting Pad:
 * I2C2_SCL for Mode: ALT4. 11 Selecting Pad: REF_CLK_24M for Mode: ALT6.
 */

#define BP_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_card_clk_in 00 Selecting Pad: EPDC_BDR0 for Mode: ALT1. 01 Selecting Pad: FEC_MDIO for Mode: ALT1. 10 Selecting Pad: KEY_COL4 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc4_ipp_card_clk_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x850)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc4_ipp_card_clk_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_card_clk_in 00 Selecting
 * Pad: EPDC_BDR0 for Mode: ALT1. 01 Selecting Pad: FEC_MDIO for Mode: ALT1. 10 Selecting Pad:
 * KEY_COL4 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_card_det 0 Selecting Pad: EPDC_D11 for Mode: ALT6. 1 Selecting Pad: EPDC_PWRCTRL3 for Mode: ALT6.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc4_ipp_card_det_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x854)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc4_ipp_card_det_select_input_t *) HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_card_det 0 Selecting Pad:
 * EPDC_D11 for Mode: ALT6. 1 Selecting Pad: EPDC_PWRCTRL3 for Mode: ALT6.
 */

#define BP_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_cmd_in 00 Selecting Pad: EPDC_BDR1 for Mode: ALT1. 01 Selecting Pad: FEC_TX_CLK for Mode: ALT1. 10 Selecting Pad: KEY_ROW4 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc4_ipp_cmd_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x858)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc4_ipp_cmd_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_cmd_in 00 Selecting Pad:
 * EPDC_BDR1 for Mode: ALT1. 01 Selecting Pad: FEC_TX_CLK for Mode: ALT1. 10 Selecting Pad: KEY_ROW4
 * for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat0_in 00 Selecting Pad: EPDC_PWRCOM for Mode: ALT1. 01 Selecting Pad: FEC_RX_ER for Mode: ALT1. 10 Selecting Pad: KEY_COL5 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc4_ipp_dat0_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x85c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat0_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat0_in 00 Selecting Pad:
 * EPDC_PWRCOM for Mode: ALT1. 01 Selecting Pad: FEC_RX_ER for Mode: ALT1. 10 Selecting Pad:
 * KEY_COL5 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat1_in 00 Selecting Pad: EPDC_PWRINT for Mode: ALT1. 01 Selecting Pad: FEC_CRS_DV for Mode: ALT1. 10 Selecting Pad: KEY_ROW5 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc4_ipp_dat1_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x860)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat1_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat1_in 00 Selecting Pad:
 * EPDC_PWRINT for Mode: ALT1. 01 Selecting Pad: FEC_CRS_DV for Mode: ALT1. 10 Selecting Pad:
 * KEY_ROW5 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat2_in 00 Selecting Pad: EPDC_PWRSTAT for Mode: ALT1. 01 Selecting Pad: FEC_RXD1 for Mode: ALT1. 10 Selecting Pad: KEY_COL6 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc4_ipp_dat2_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x864)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat2_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat2_in 00 Selecting Pad:
 * EPDC_PWRSTAT for Mode: ALT1. 01 Selecting Pad: FEC_RXD1 for Mode: ALT1. 10 Selecting Pad:
 * KEY_COL6 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat3_in 00 Selecting Pad: EPDC_PWRWAKEUP for Mode: ALT1. 01 Selecting Pad: FEC_TXD0 for Mode: ALT1. 10 Selecting Pad: KEY_ROW6 for Mode: ALT4.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc4_ipp_dat3_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x868)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat3_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat3_in 00 Selecting Pad:
 * EPDC_PWRWAKEUP for Mode: ALT1. 01 Selecting Pad: FEC_TXD0 for Mode: ALT1. 10 Selecting Pad:
 * KEY_ROW6 for Mode: ALT4.
 */

#define BP_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat4_in 00 Selecting Pad: FEC_MDC for Mode: ALT1. 01 Selecting Pad: KEY_COL7 for Mode: ALT4. 10 Selecting Pad: LCD_CLK for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc4_ipp_dat4_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x86c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat4_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat4_in 00 Selecting Pad:
 * FEC_MDC for Mode: ALT1. 01 Selecting Pad: KEY_COL7 for Mode: ALT4. 10 Selecting Pad: LCD_CLK for
 * Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat5_in 00 Selecting Pad: FEC_RXD0 for Mode: ALT1. 01 Selecting Pad: KEY_ROW7 for Mode: ALT4. 10 Selecting Pad: LCD_ENABLE for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc4_ipp_dat5_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x870)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat5_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat5_in 00 Selecting Pad:
 * FEC_RXD0 for Mode: ALT1. 01 Selecting Pad: KEY_ROW7 for Mode: ALT4. 10 Selecting Pad: LCD_ENABLE
 * for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat6_in 00 Selecting Pad: FEC_TX_EN for Mode: ALT1. 01 Selecting Pad: KEY_COL3 for Mode: ALT4. 10 Selecting Pad: LCD_HSYNC for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc4_ipp_dat6_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x874)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat6_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat6_in 00 Selecting Pad:
 * FEC_TX_EN for Mode: ALT1. 01 Selecting Pad: KEY_COL3 for Mode: ALT4. 10 Selecting Pad: LCD_HSYNC
 * for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 2; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat7_in 00 Selecting Pad: FEC_TXD1 for Mode: ALT1. 01 Selecting Pad: KEY_ROW3 for Mode: ALT4. 10 Selecting Pad: LCD_VSYNC for Mode: ALT1.
        unsigned RESERVED0 : 30; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc4_ipp_dat7_in_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x878)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat7_in_select_input_t *) HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT, field DAISY[1:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_dat7_in 00 Selecting Pad:
 * FEC_TXD1 for Mode: ALT1. 01 Selecting Pad: KEY_ROW3 for Mode: ALT4. 10 Selecting Pad: LCD_VSYNC
 * for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_DAISY      (0x00000003)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_wp_on 0 Selecting Pad: EPDC_D10 for Mode: ALT6. 1 Selecting Pad: EPDC_PWRCTRL2 for Mode: ALT6.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_usdhc4_ipp_wp_on_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x87c)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_usdhc4_ipp_wp_on_select_input_t *) HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: usdhc4, In Pin: ipp_wp_on 0 Selecting Pad:
 * EPDC_D10 for Mode: ALT6. 1 Selecting Pad: EPDC_PWRCTRL2 for Mode: ALT6.
 */

#define BP_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: weim, In Pin: ipp_ind_dtack_b 0 Selecting Pad: EPDC_PWRWAKEUP for Mode: ALT3. 1 Selecting Pad: LCD_RESET for Mode: ALT1.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_weim_ipp_ind_dtack_b_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x880)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_weim_ipp_ind_dtack_b_select_input_t *) HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: weim, In Pin: ipp_ind_dtack_b 0 Selecting Pad:
 * EPDC_PWRWAKEUP for Mode: ALT3. 1 Selecting Pad: LCD_RESET for Mode: ALT1.
 */

#define BP_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT, DAISY, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT - DAISY (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DAISY : 1; //!< Selecting Pads Involved in Daisy Chain. Instance: weim, In Pin: ipp_ind_wait_b 0 Selecting Pad: EPDC_PWRSTAT for Mode: ALT3. 1 Selecting Pad: LCD_RESET for Mode: ALT3.
        unsigned RESERVED0 : 31; //!< Reserved
    } B;
} hw_iomuxc_iomuxc_weim_ipp_ind_wait_b_select_input_t;
#endif

/*
 * constants & macros for entire IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT register
 */
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_ADDR      (REGS_IOMUXC_BASE + 0x884)

#ifndef __LANGUAGE_ASM__
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT           (*(volatile hw_iomuxc_iomuxc_weim_ipp_ind_wait_b_select_input_t *) HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_ADDR)
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_RD()      (HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT.U)
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_WR(v)     (HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT.U = (v))
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_SET(v)    (HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_RD() |  (v)))
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_CLR(v)    (HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_RD() & ~(v)))
#define HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_TOG(v)    (HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_WR(HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_RD() ^  (v)))
#endif

/*
 * constants & macros for individual IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT bitfields
 */

/* --- Register HW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT, field DAISY[0:0] (RW)
 *
 * Selecting Pads Involved in Daisy Chain. Instance: weim, In Pin: ipp_ind_wait_b 0 Selecting Pad:
 * EPDC_PWRSTAT for Mode: ALT3. 1 Selecting Pad: LCD_RESET for Mode: ALT3.
 */

#define BP_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_DAISY      (0)
#define BM_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_DAISY      (0x00000001)

#ifndef __LANGUAGE_ASM__
#define BF_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_DAISY(v)   ((((reg32_t) v) << 0) & BM_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_DAISY)
#else
#define BF_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_DAISY(v)   (((v) << 0) & BM_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_DAISY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DAISY field to a new value.
#define BW_IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT_DAISY(v)   BF_CS1(IOMUXC_IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT, DAISY, v)
#endif


/*!
 * @brief All IOMUXC module registers.
 */
#ifndef __LANGUAGE_ASM__
typedef struct
{
    volatile hw_iomuxc_iomuxc_gpr0_t IOMUXC_GPR0; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr1_t IOMUXC_GPR1; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr2_t IOMUXC_GPR2; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr3_t IOMUXC_GPR3; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr4_t IOMUXC_GPR4; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr5_t IOMUXC_GPR5; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr6_t IOMUXC_GPR6; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr7_t IOMUXC_GPR7; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr8_t IOMUXC_GPR8; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr9_t IOMUXC_GPR9; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr10_t IOMUXC_GPR10; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr11_t IOMUXC_GPR11; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr12_t IOMUXC_GPR12; //!< GPR
    volatile hw_iomuxc_iomuxc_gpr13_t IOMUXC_GPR13; //!< GPR
    volatile hw_iomuxc_iomuxc_observe_mux_0_t IOMUXC_OBSERVE_MUX_0; //!< OBSRV
    volatile hw_iomuxc_iomuxc_observe_mux_1_t IOMUXC_OBSERVE_MUX_1; //!< OBSRV
    volatile hw_iomuxc_iomuxc_observe_mux_2_t IOMUXC_OBSERVE_MUX_2; //!< OBSRV
    volatile hw_iomuxc_iomuxc_observe_mux_3_t IOMUXC_OBSERVE_MUX_3; //!< OBSRV
    volatile hw_iomuxc_iomuxc_observe_mux_4_t IOMUXC_OBSERVE_MUX_4; //!< OBSRV
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_mclk_t IOMUXC_SW_MUX_CTL_PAD_AUD_MCLK; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_rxc_t IOMUXC_SW_MUX_CTL_PAD_AUD_RXC; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_rxd_t IOMUXC_SW_MUX_CTL_PAD_AUD_RXD; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_rxfs_t IOMUXC_SW_MUX_CTL_PAD_AUD_RXFS; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_txc_t IOMUXC_SW_MUX_CTL_PAD_AUD_TXC; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_txd_t IOMUXC_SW_MUX_CTL_PAD_AUD_TXD; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_aud_txfs_t IOMUXC_SW_MUX_CTL_PAD_AUD_TXFS; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi1_miso_t IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MISO; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi1_mosi_t IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi1_sclk_t IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi1_ss0_t IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SS0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi2_miso_t IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MISO; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi2_mosi_t IOMUXC_SW_MUX_CTL_PAD_ECSPI2_MOSI; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi2_sclk_t IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SCLK; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ecspi2_ss0_t IOMUXC_SW_MUX_CTL_PAD_ECSPI2_SS0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_bdr0_t IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_bdr1_t IOMUXC_SW_MUX_CTL_PAD_EPDC_BDR1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d0_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d1_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d10_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D10; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d11_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D11; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d12_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D12; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d13_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D13; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d14_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D14; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d15_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D15; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d2_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D2; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d3_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D3; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d4_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D4; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d5_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D5; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d6_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D6; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d7_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D7; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d8_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D8; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_d9_t IOMUXC_SW_MUX_CTL_PAD_EPDC_D9; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_gdclk_t IOMUXC_SW_MUX_CTL_PAD_EPDC_GDCLK; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_gdoe_t IOMUXC_SW_MUX_CTL_PAD_EPDC_GDOE; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_gdrl_t IOMUXC_SW_MUX_CTL_PAD_EPDC_GDRL; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_gdsp_t IOMUXC_SW_MUX_CTL_PAD_EPDC_GDSP; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrcom_t IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCOM; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl0_t IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl1_t IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl2_t IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL2; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrctrl3_t IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRCTRL3; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrint_t IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRINT; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrstat_t IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRSTAT; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_pwrwakeup_t IOMUXC_SW_MUX_CTL_PAD_EPDC_PWRWAKEUP; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdce0_t IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdce1_t IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdce2_t IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE2; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdce3_t IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCE3; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdclk_t IOMUXC_SW_MUX_CTL_PAD_EPDC_SDCLK; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdle_t IOMUXC_SW_MUX_CTL_PAD_EPDC_SDLE; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdoe_t IOMUXC_SW_MUX_CTL_PAD_EPDC_SDOE; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_sdshr_t IOMUXC_SW_MUX_CTL_PAD_EPDC_SDSHR; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_vcom0_t IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_epdc_vcom1_t IOMUXC_SW_MUX_CTL_PAD_EPDC_VCOM1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_crs_dv_t IOMUXC_SW_MUX_CTL_PAD_FEC_CRS_DV; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_mdc_t IOMUXC_SW_MUX_CTL_PAD_FEC_MDC; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_mdio_t IOMUXC_SW_MUX_CTL_PAD_FEC_MDIO; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_ref_clk_t IOMUXC_SW_MUX_CTL_PAD_FEC_REF_CLK; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_rx_er_t IOMUXC_SW_MUX_CTL_PAD_FEC_RX_ER; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_rxd0_t IOMUXC_SW_MUX_CTL_PAD_FEC_RXD0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_rxd1_t IOMUXC_SW_MUX_CTL_PAD_FEC_RXD1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_tx_clk_t IOMUXC_SW_MUX_CTL_PAD_FEC_TX_CLK; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_tx_en_t IOMUXC_SW_MUX_CTL_PAD_FEC_TX_EN; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_txd0_t IOMUXC_SW_MUX_CTL_PAD_FEC_TXD0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_fec_txd1_t IOMUXC_SW_MUX_CTL_PAD_FEC_TXD1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_hsic_dat_t IOMUXC_SW_MUX_CTL_PAD_HSIC_DAT; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_hsic_strobe_t IOMUXC_SW_MUX_CTL_PAD_HSIC_STROBE; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_i2c1_scl_t IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_i2c1_sda_t IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_i2c2_scl_t IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_i2c2_sda_t IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col0_t IOMUXC_SW_MUX_CTL_PAD_KEY_COL0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col1_t IOMUXC_SW_MUX_CTL_PAD_KEY_COL1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col2_t IOMUXC_SW_MUX_CTL_PAD_KEY_COL2; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col3_t IOMUXC_SW_MUX_CTL_PAD_KEY_COL3; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col4_t IOMUXC_SW_MUX_CTL_PAD_KEY_COL4; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col5_t IOMUXC_SW_MUX_CTL_PAD_KEY_COL5; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col6_t IOMUXC_SW_MUX_CTL_PAD_KEY_COL6; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_col7_t IOMUXC_SW_MUX_CTL_PAD_KEY_COL7; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row0_t IOMUXC_SW_MUX_CTL_PAD_KEY_ROW0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row1_t IOMUXC_SW_MUX_CTL_PAD_KEY_ROW1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row2_t IOMUXC_SW_MUX_CTL_PAD_KEY_ROW2; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row3_t IOMUXC_SW_MUX_CTL_PAD_KEY_ROW3; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row4_t IOMUXC_SW_MUX_CTL_PAD_KEY_ROW4; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row5_t IOMUXC_SW_MUX_CTL_PAD_KEY_ROW5; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row6_t IOMUXC_SW_MUX_CTL_PAD_KEY_ROW6; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_key_row7_t IOMUXC_SW_MUX_CTL_PAD_KEY_ROW7; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_clk_t IOMUXC_SW_MUX_CTL_PAD_LCD_CLK; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat0_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat1_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat10_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT10; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat11_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT11; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat12_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT12; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat13_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT13; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat14_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT14; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat15_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT15; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat16_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT16; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat17_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT17; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat18_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT18; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat19_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT19; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat2_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT2; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat20_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT20; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat21_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT21; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat22_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT22; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat23_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT23; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat3_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT3; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat4_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT4; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat5_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT5; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat6_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT6; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat7_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT7; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat8_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT8; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_dat9_t IOMUXC_SW_MUX_CTL_PAD_LCD_DAT9; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_enable_t IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_hsync_t IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_reset_t IOMUXC_SW_MUX_CTL_PAD_LCD_RESET; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_lcd_vsync_t IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_pwm1_t IOMUXC_SW_MUX_CTL_PAD_PWM1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ref_clk_24m_t IOMUXC_SW_MUX_CTL_PAD_REF_CLK_24M; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_ref_clk_32k_t IOMUXC_SW_MUX_CTL_PAD_REF_CLK_32K; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_clk_t IOMUXC_SW_MUX_CTL_PAD_SD1_CLK; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_cmd_t IOMUXC_SW_MUX_CTL_PAD_SD1_CMD; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat0_t IOMUXC_SW_MUX_CTL_PAD_SD1_DAT0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat1_t IOMUXC_SW_MUX_CTL_PAD_SD1_DAT1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat2_t IOMUXC_SW_MUX_CTL_PAD_SD1_DAT2; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat3_t IOMUXC_SW_MUX_CTL_PAD_SD1_DAT3; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat4_t IOMUXC_SW_MUX_CTL_PAD_SD1_DAT4; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat5_t IOMUXC_SW_MUX_CTL_PAD_SD1_DAT5; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat6_t IOMUXC_SW_MUX_CTL_PAD_SD1_DAT6; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd1_dat7_t IOMUXC_SW_MUX_CTL_PAD_SD1_DAT7; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_clk_t IOMUXC_SW_MUX_CTL_PAD_SD2_CLK; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_cmd_t IOMUXC_SW_MUX_CTL_PAD_SD2_CMD; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat0_t IOMUXC_SW_MUX_CTL_PAD_SD2_DAT0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat1_t IOMUXC_SW_MUX_CTL_PAD_SD2_DAT1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat2_t IOMUXC_SW_MUX_CTL_PAD_SD2_DAT2; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat3_t IOMUXC_SW_MUX_CTL_PAD_SD2_DAT3; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat4_t IOMUXC_SW_MUX_CTL_PAD_SD2_DAT4; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat5_t IOMUXC_SW_MUX_CTL_PAD_SD2_DAT5; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat6_t IOMUXC_SW_MUX_CTL_PAD_SD2_DAT6; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_dat7_t IOMUXC_SW_MUX_CTL_PAD_SD2_DAT7; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd2_rst_t IOMUXC_SW_MUX_CTL_PAD_SD2_RST; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_clk_t IOMUXC_SW_MUX_CTL_PAD_SD3_CLK; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_cmd_t IOMUXC_SW_MUX_CTL_PAD_SD3_CMD; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_dat0_t IOMUXC_SW_MUX_CTL_PAD_SD3_DAT0; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_dat1_t IOMUXC_SW_MUX_CTL_PAD_SD3_DAT1; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_dat2_t IOMUXC_SW_MUX_CTL_PAD_SD3_DAT2; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_sd3_dat3_t IOMUXC_SW_MUX_CTL_PAD_SD3_DAT3; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_uart1_rxd_t IOMUXC_SW_MUX_CTL_PAD_UART1_RXD; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_uart1_txd_t IOMUXC_SW_MUX_CTL_PAD_UART1_TXD; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_mux_ctl_pad_wdog_b_t IOMUXC_SW_MUX_CTL_PAD_WDOG_B; //!< SW_MUX_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_mclk_t IOMUXC_SW_PAD_CTL_PAD_AUD_MCLK; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_rxc_t IOMUXC_SW_PAD_CTL_PAD_AUD_RXC; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_rxd_t IOMUXC_SW_PAD_CTL_PAD_AUD_RXD; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_rxfs_t IOMUXC_SW_PAD_CTL_PAD_AUD_RXFS; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_txc_t IOMUXC_SW_PAD_CTL_PAD_AUD_TXC; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_txd_t IOMUXC_SW_PAD_CTL_PAD_AUD_TXD; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_aud_txfs_t IOMUXC_SW_PAD_CTL_PAD_AUD_TXFS; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a0_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a1_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a10_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A10; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a11_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A11; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a12_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A12; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a13_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A13; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a14_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A14; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a15_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A15; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a2_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a3_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A3; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a4_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A4; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a5_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A5; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a6_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A6; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a7_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A7; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a8_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A8; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_a9_t IOMUXC_SW_PAD_CTL_PAD_DRAM_A9; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_cas_t IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_cs0_t IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_cs1_t IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_dqm0_t IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_dqm1_t IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_dqm2_t IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_dqm3_t IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_ras_t IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_reset_t IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdba0_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdba1_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdba2_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdcke0_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdcke1_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdclk_0_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdodt0_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdodt1_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdqs0_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdqs1_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdqs2_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdqs3_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_dram_sdwe_t IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi1_miso_t IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MISO; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi1_mosi_t IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi1_sclk_t IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi1_ss0_t IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SS0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi2_miso_t IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MISO; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi2_mosi_t IOMUXC_SW_PAD_CTL_PAD_ECSPI2_MOSI; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi2_sclk_t IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SCLK; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ecspi2_ss0_t IOMUXC_SW_PAD_CTL_PAD_ECSPI2_SS0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_bdr0_t IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_bdr1_t IOMUXC_SW_PAD_CTL_PAD_EPDC_BDR1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d0_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d1_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d10_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D10; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d11_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D11; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d12_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D12; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d13_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D13; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d14_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D14; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d15_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D15; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d2_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d3_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D3; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d4_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D4; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d5_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D5; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d6_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D6; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d7_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D7; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d8_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D8; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_d9_t IOMUXC_SW_PAD_CTL_PAD_EPDC_D9; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_gdclk_t IOMUXC_SW_PAD_CTL_PAD_EPDC_GDCLK; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_gdoe_t IOMUXC_SW_PAD_CTL_PAD_EPDC_GDOE; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_gdrl_t IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_gdsp_t IOMUXC_SW_PAD_CTL_PAD_EPDC_GDSP; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrcom_t IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCOM; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl0_t IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl1_t IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl2_t IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrctrl3_t IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRCTRL3; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrint_t IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRINT; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrstat_t IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRSTAT; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_pwrwakeup_t IOMUXC_SW_PAD_CTL_PAD_EPDC_PWRWAKEUP; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdce0_t IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdce1_t IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdce2_t IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdce3_t IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCE3; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdclk_t IOMUXC_SW_PAD_CTL_PAD_EPDC_SDCLK; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdle_t IOMUXC_SW_PAD_CTL_PAD_EPDC_SDLE; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdoe_t IOMUXC_SW_PAD_CTL_PAD_EPDC_SDOE; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_sdshr_t IOMUXC_SW_PAD_CTL_PAD_EPDC_SDSHR; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_vcom0_t IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_epdc_vcom1_t IOMUXC_SW_PAD_CTL_PAD_EPDC_VCOM1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_crs_dv_t IOMUXC_SW_PAD_CTL_PAD_FEC_CRS_DV; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_mdc_t IOMUXC_SW_PAD_CTL_PAD_FEC_MDC; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_mdio_t IOMUXC_SW_PAD_CTL_PAD_FEC_MDIO; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_ref_clk_t IOMUXC_SW_PAD_CTL_PAD_FEC_REF_CLK; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_rx_er_t IOMUXC_SW_PAD_CTL_PAD_FEC_RX_ER; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_rxd0_t IOMUXC_SW_PAD_CTL_PAD_FEC_RXD0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_rxd1_t IOMUXC_SW_PAD_CTL_PAD_FEC_RXD1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_tx_clk_t IOMUXC_SW_PAD_CTL_PAD_FEC_TX_CLK; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_tx_en_t IOMUXC_SW_PAD_CTL_PAD_FEC_TX_EN; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_txd0_t IOMUXC_SW_PAD_CTL_PAD_FEC_TXD0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_fec_txd1_t IOMUXC_SW_PAD_CTL_PAD_FEC_TXD1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_hsic_dat_t IOMUXC_SW_PAD_CTL_PAD_HSIC_DAT; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_hsic_strobe_t IOMUXC_SW_PAD_CTL_PAD_HSIC_STROBE; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_i2c1_scl_t IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_i2c1_sda_t IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_i2c2_scl_t IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_i2c2_sda_t IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_mod_t IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_tck_t IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_tdi_t IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_tdo_t IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_tms_t IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_jtag_trstb_t IOMUXC_SW_PAD_CTL_PAD_JTAG_TRSTB; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col0_t IOMUXC_SW_PAD_CTL_PAD_KEY_COL0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col1_t IOMUXC_SW_PAD_CTL_PAD_KEY_COL1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col2_t IOMUXC_SW_PAD_CTL_PAD_KEY_COL2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col3_t IOMUXC_SW_PAD_CTL_PAD_KEY_COL3; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col4_t IOMUXC_SW_PAD_CTL_PAD_KEY_COL4; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col5_t IOMUXC_SW_PAD_CTL_PAD_KEY_COL5; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col6_t IOMUXC_SW_PAD_CTL_PAD_KEY_COL6; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_col7_t IOMUXC_SW_PAD_CTL_PAD_KEY_COL7; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row0_t IOMUXC_SW_PAD_CTL_PAD_KEY_ROW0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row1_t IOMUXC_SW_PAD_CTL_PAD_KEY_ROW1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row2_t IOMUXC_SW_PAD_CTL_PAD_KEY_ROW2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row3_t IOMUXC_SW_PAD_CTL_PAD_KEY_ROW3; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row4_t IOMUXC_SW_PAD_CTL_PAD_KEY_ROW4; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row5_t IOMUXC_SW_PAD_CTL_PAD_KEY_ROW5; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row6_t IOMUXC_SW_PAD_CTL_PAD_KEY_ROW6; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_key_row7_t IOMUXC_SW_PAD_CTL_PAD_KEY_ROW7; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_clk_t IOMUXC_SW_PAD_CTL_PAD_LCD_CLK; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat0_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat1_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat10_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT10; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat11_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT11; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat12_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT12; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat13_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT13; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat14_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT14; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat15_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT15; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat16_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT16; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat17_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT17; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat18_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT18; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat19_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT19; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat2_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat20_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT20; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat21_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT21; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat22_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT22; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat23_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT23; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat3_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT3; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat4_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT4; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat5_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT5; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat6_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT6; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat7_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT7; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat8_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT8; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_dat9_t IOMUXC_SW_PAD_CTL_PAD_LCD_DAT9; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_enable_t IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_hsync_t IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_reset_t IOMUXC_SW_PAD_CTL_PAD_LCD_RESET; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_lcd_vsync_t IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_pwm1_t IOMUXC_SW_PAD_CTL_PAD_PWM1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ref_clk_24m_t IOMUXC_SW_PAD_CTL_PAD_REF_CLK_24M; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_ref_clk_32k_t IOMUXC_SW_PAD_CTL_PAD_REF_CLK_32K; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_clk_t IOMUXC_SW_PAD_CTL_PAD_SD1_CLK; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_cmd_t IOMUXC_SW_PAD_CTL_PAD_SD1_CMD; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat0_t IOMUXC_SW_PAD_CTL_PAD_SD1_DAT0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat1_t IOMUXC_SW_PAD_CTL_PAD_SD1_DAT1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat2_t IOMUXC_SW_PAD_CTL_PAD_SD1_DAT2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat3_t IOMUXC_SW_PAD_CTL_PAD_SD1_DAT3; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat4_t IOMUXC_SW_PAD_CTL_PAD_SD1_DAT4; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat5_t IOMUXC_SW_PAD_CTL_PAD_SD1_DAT5; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat6_t IOMUXC_SW_PAD_CTL_PAD_SD1_DAT6; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd1_dat7_t IOMUXC_SW_PAD_CTL_PAD_SD1_DAT7; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_clk_t IOMUXC_SW_PAD_CTL_PAD_SD2_CLK; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_cmd_t IOMUXC_SW_PAD_CTL_PAD_SD2_CMD; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat0_t IOMUXC_SW_PAD_CTL_PAD_SD2_DAT0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat1_t IOMUXC_SW_PAD_CTL_PAD_SD2_DAT1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat2_t IOMUXC_SW_PAD_CTL_PAD_SD2_DAT2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat3_t IOMUXC_SW_PAD_CTL_PAD_SD2_DAT3; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat4_t IOMUXC_SW_PAD_CTL_PAD_SD2_DAT4; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat5_t IOMUXC_SW_PAD_CTL_PAD_SD2_DAT5; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat6_t IOMUXC_SW_PAD_CTL_PAD_SD2_DAT6; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_dat7_t IOMUXC_SW_PAD_CTL_PAD_SD2_DAT7; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd2_rst_t IOMUXC_SW_PAD_CTL_PAD_SD2_RST; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_clk_t IOMUXC_SW_PAD_CTL_PAD_SD3_CLK; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_cmd_t IOMUXC_SW_PAD_CTL_PAD_SD3_CMD; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_dat0_t IOMUXC_SW_PAD_CTL_PAD_SD3_DAT0; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_dat1_t IOMUXC_SW_PAD_CTL_PAD_SD3_DAT1; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_dat2_t IOMUXC_SW_PAD_CTL_PAD_SD3_DAT2; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_sd3_dat3_t IOMUXC_SW_PAD_CTL_PAD_SD3_DAT3; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_uart1_rxd_t IOMUXC_SW_PAD_CTL_PAD_UART1_RXD; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_uart1_txd_t IOMUXC_SW_PAD_CTL_PAD_UART1_TXD; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_pad_wdog_b_t IOMUXC_SW_PAD_CTL_PAD_WDOG_B; //!< SW_PAD_CTL
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_addds_t IOMUXC_SW_PAD_CTL_GRP_ADDDS; //!< SW_GRP
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrmode_ctl_t IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL; //!< SW_GRP
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrpke_t IOMUXC_SW_PAD_CTL_GRP_DDRPKE; //!< SW_GRP
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrpk_t IOMUXC_SW_PAD_CTL_GRP_DDRPK; //!< SW_GRP
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrhys_t IOMUXC_SW_PAD_CTL_GRP_DDRHYS; //!< SW_GRP
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddrmode_t IOMUXC_SW_PAD_CTL_GRP_DDRMODE; //!< SW_GRP
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_b0ds_t IOMUXC_SW_PAD_CTL_GRP_B0DS; //!< SW_GRP
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ctlds_t IOMUXC_SW_PAD_CTL_GRP_CTLDS; //!< SW_GRP
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_b1ds_t IOMUXC_SW_PAD_CTL_GRP_B1DS; //!< SW_GRP
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_ddr_type_t IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE; //!< SW_GRP
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_b2ds_t IOMUXC_SW_PAD_CTL_GRP_B2DS; //!< SW_GRP
    volatile hw_iomuxc_iomuxc_sw_pad_ctl_grp_b3ds_t IOMUXC_SW_PAD_CTL_GRP_B3DS; //!< SW_GRP
    volatile hw_iomuxc_iomuxc_anatop_usb_otg_id_select_input_t IOMUXC_ANATOP_USB_OTG_ID_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_anatop_usb_uh1_id_select_input_t IOMUXC_ANATOP_USB_UH1_ID_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p4_input_da_amx_select_input_t IOMUXC_AUDMUX_P4_INPUT_DA_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p4_input_db_amx_select_input_t IOMUXC_AUDMUX_P4_INPUT_DB_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p4_input_rxclk_amx_select_input_t IOMUXC_AUDMUX_P4_INPUT_RXCLK_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p4_input_rxfs_amx_select_input_t IOMUXC_AUDMUX_P4_INPUT_RXFS_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p4_input_txclk_amx_select_input_t IOMUXC_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p4_input_txfs_amx_select_input_t IOMUXC_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p5_input_da_amx_select_input_t IOMUXC_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p5_input_db_amx_select_input_t IOMUXC_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p5_input_rxclk_amx_select_input_t IOMUXC_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p5_input_rxfs_amx_select_input_t IOMUXC_AUDMUX_P5_INPUT_RXFS_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p5_input_txclk_amx_select_input_t IOMUXC_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p5_input_txfs_amx_select_input_t IOMUXC_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p6_input_da_amx_select_input_t IOMUXC_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p6_input_db_amx_select_input_t IOMUXC_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p6_input_rxclk_amx_select_input_t IOMUXC_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p6_input_rxfs_amx_select_input_t IOMUXC_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p6_input_txclk_amx_select_input_t IOMUXC_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_audmux_p6_input_txfs_amx_select_input_t IOMUXC_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ccm_pmic_vfuncional_ready_select_input_t IOMUXC_CCM_PMIC_VFUNCIONAL_READY_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_0_select_input_t IOMUXC_CSI_IPP_CSI_D_0_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_1_select_input_t IOMUXC_CSI_IPP_CSI_D_1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_2_select_input_t IOMUXC_CSI_IPP_CSI_D_2_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_3_select_input_t IOMUXC_CSI_IPP_CSI_D_3_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_4_select_input_t IOMUXC_CSI_IPP_CSI_D_4_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_5_select_input_t IOMUXC_CSI_IPP_CSI_D_5_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_6_select_input_t IOMUXC_CSI_IPP_CSI_D_6_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_7_select_input_t IOMUXC_CSI_IPP_CSI_D_7_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_8_select_input_t IOMUXC_CSI_IPP_CSI_D_8_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_9_select_input_t IOMUXC_CSI_IPP_CSI_D_9_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_10_select_input_t IOMUXC_CSI_IPP_CSI_D_10_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_11_select_input_t IOMUXC_CSI_IPP_CSI_D_11_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_12_select_input_t IOMUXC_CSI_IPP_CSI_D_12_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_13_select_input_t IOMUXC_CSI_IPP_CSI_D_13_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_14_select_input_t IOMUXC_CSI_IPP_CSI_D_14_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_d_15_select_input_t IOMUXC_CSI_IPP_CSI_D_15_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_hsync_select_input_t IOMUXC_CSI_IPP_CSI_HSYNC_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_pixclk_select_input_t IOMUXC_CSI_IPP_CSI_PIXCLK_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_csi_ipp_csi_vsync_select_input_t IOMUXC_CSI_IPP_CSI_VSYNC_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi1_ipp_cspi_clk_in_select_input_t IOMUXC_ECSPI1_IPP_CSPI_CLK_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_dataready_b_select_input_t IOMUXC_ECSPI1_IPP_IND_DATAREADY_B_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_miso_select_input_t IOMUXC_ECSPI1_IPP_IND_MISO_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_mosi_select_input_t IOMUXC_ECSPI1_IPP_IND_MOSI_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_ss_b_0_select_input_t IOMUXC_ECSPI1_IPP_IND_SS_B_0_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_ss_b_1_select_input_t IOMUXC_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_ss_b_2_select_input_t IOMUXC_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi1_ipp_ind_ss_b_3_select_input_t IOMUXC_ECSPI1_IPP_IND_SS_B_3_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi2_ipp_cspi_clk_in_select_input_t IOMUXC_ECSPI2_IPP_CSPI_CLK_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi2_ipp_ind_miso_select_input_t IOMUXC_ECSPI2_IPP_IND_MISO_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi2_ipp_ind_mosi_select_input_t IOMUXC_ECSPI2_IPP_IND_MOSI_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi2_ipp_ind_ss_b_0_select_input_t IOMUXC_ECSPI2_IPP_IND_SS_B_0_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi2_ipp_ind_ss_b_1_select_input_t IOMUXC_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi3_ipp_cspi_clk_in_select_input_t IOMUXC_ECSPI3_IPP_CSPI_CLK_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_dataready_b_select_input_t IOMUXC_ECSPI3_IPP_IND_DATAREADY_B_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_miso_select_input_t IOMUXC_ECSPI3_IPP_IND_MISO_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_mosi_select_input_t IOMUXC_ECSPI3_IPP_IND_MOSI_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_ss_b_0_select_input_t IOMUXC_ECSPI3_IPP_IND_SS_B_0_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_ss_b_1_select_input_t IOMUXC_ECSPI3_IPP_IND_SS_B_1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_ss_b_2_select_input_t IOMUXC_ECSPI3_IPP_IND_SS_B_2_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi3_ipp_ind_ss_b_3_select_input_t IOMUXC_ECSPI3_IPP_IND_SS_B_3_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi4_ipp_cspi_clk_in_select_input_t IOMUXC_ECSPI4_IPP_CSPI_CLK_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi4_ipp_ind_miso_select_input_t IOMUXC_ECSPI4_IPP_IND_MISO_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi4_ipp_ind_mosi_select_input_t IOMUXC_ECSPI4_IPP_IND_MOSI_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi4_ipp_ind_ss_b_0_select_input_t IOMUXC_ECSPI4_IPP_IND_SS_B_0_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi4_ipp_ind_ss_b_1_select_input_t IOMUXC_ECSPI4_IPP_IND_SS_B_1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_ecspi4_ipp_ind_ss_b_2_select_input_t IOMUXC_ECSPI4_IPP_IND_SS_B_2_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_epdc_ipp_epdc_pwrirq_select_input_t IOMUXC_EPDC_IPP_EPDC_PWRIRQ_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_epdc_ipp_epdc_pwrstat_select_input_t IOMUXC_EPDC_IPP_EPDC_PWRSTAT_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_fec_fec_col_select_input_t IOMUXC_FEC_FEC_COL_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_fec_fec_mdi_select_input_t IOMUXC_FEC_FEC_MDI_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_fec_fec_rdata_0_select_input_t IOMUXC_FEC_FEC_RDATA_0_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_fec_fec_rdata_1_select_input_t IOMUXC_FEC_FEC_RDATA_1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_fec_fec_rx_clk_select_input_t IOMUXC_FEC_FEC_RX_CLK_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_fec_fec_rx_dv_select_input_t IOMUXC_FEC_FEC_RX_DV_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_fec_fec_rx_er_select_input_t IOMUXC_FEC_FEC_RX_ER_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_fec_fec_tx_clk_select_input_t IOMUXC_FEC_FEC_TX_CLK_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_gpt_ipp_ind_capin1_select_input_t IOMUXC_GPT_IPP_IND_CAPIN1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_gpt_ipp_ind_capin2_select_input_t IOMUXC_GPT_IPP_IND_CAPIN2_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_gpt_ipp_ind_clkin_select_input_t IOMUXC_GPT_IPP_IND_CLKIN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_i2c1_ipp_scl_in_select_input_t IOMUXC_I2C1_IPP_SCL_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_i2c1_ipp_sda_in_select_input_t IOMUXC_I2C1_IPP_SDA_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_i2c2_ipp_scl_in_select_input_t IOMUXC_I2C2_IPP_SCL_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_i2c2_ipp_sda_in_select_input_t IOMUXC_I2C2_IPP_SDA_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_i2c3_ipp_scl_in_select_input_t IOMUXC_I2C3_IPP_SCL_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_i2c3_ipp_sda_in_select_input_t IOMUXC_I2C3_IPP_SDA_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_0_select_input_t IOMUXC_KPP_IPP_IND_COL_0_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_1_select_input_t IOMUXC_KPP_IPP_IND_COL_1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_2_select_input_t IOMUXC_KPP_IPP_IND_COL_2_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_3_select_input_t IOMUXC_KPP_IPP_IND_COL_3_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_4_select_input_t IOMUXC_KPP_IPP_IND_COL_4_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_5_select_input_t IOMUXC_KPP_IPP_IND_COL_5_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_6_select_input_t IOMUXC_KPP_IPP_IND_COL_6_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_col_7_select_input_t IOMUXC_KPP_IPP_IND_COL_7_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_0_select_input_t IOMUXC_KPP_IPP_IND_ROW_0_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_1_select_input_t IOMUXC_KPP_IPP_IND_ROW_1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_2_select_input_t IOMUXC_KPP_IPP_IND_ROW_2_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_3_select_input_t IOMUXC_KPP_IPP_IND_ROW_3_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_4_select_input_t IOMUXC_KPP_IPP_IND_ROW_4_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_5_select_input_t IOMUXC_KPP_IPP_IND_ROW_5_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_6_select_input_t IOMUXC_KPP_IPP_IND_ROW_6_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_kpp_ipp_ind_row_7_select_input_t IOMUXC_KPP_IPP_IND_ROW_7_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_busy_select_input_t IOMUXC_LCDIF_LCDIF_BUSY_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_0_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_0_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_1_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_2_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_2_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_3_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_3_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_4_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_4_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_5_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_5_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_6_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_6_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_7_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_7_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_8_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_8_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_9_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_9_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_10_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_10_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_11_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_11_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_12_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_12_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_13_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_13_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_14_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_14_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_15_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_15_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_16_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_16_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_17_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_17_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_18_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_18_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_19_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_19_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_20_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_20_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_21_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_21_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_22_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_22_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_lcdif_lcdif_rxdata_23_select_input_t IOMUXC_LCDIF_LCDIF_RXDATA_23_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_mshc_ipp_di_data_0_select_input_t IOMUXC_MSHC_IPP_DI_DATA_0_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_mshc_ipp_di_data_1_select_input_t IOMUXC_MSHC_IPP_DI_DATA_1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_mshc_ipp_di_data_2_select_input_t IOMUXC_MSHC_IPP_DI_DATA_2_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_mshc_ipp_di_data_3_select_input_t IOMUXC_MSHC_IPP_DI_DATA_3_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_mshc_ipp_di_scki_select_input_t IOMUXC_MSHC_IPP_DI_SCKI_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_pl301_sim_mx6sl_per1_hprot_m_d_6_1_select_input_t IOMUXC_PL301_SIM_MX6SL_PER1_HPROT_M_D_6_1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_spdif_spdif_in1_select_input_t IOMUXC_SPDIF_SPDIF_IN1_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_spdif_tx_clk2_select_input_t IOMUXC_SPDIF_TX_CLK2_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_uart1_ipp_uart_rts_b_select_input_t IOMUXC_UART1_IPP_UART_RTS_B_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_uart1_ipp_uart_rxd_mux_select_input_t IOMUXC_UART1_IPP_UART_RXD_MUX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_uart2_ipp_uart_rts_b_select_input_t IOMUXC_UART2_IPP_UART_RTS_B_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_uart2_ipp_uart_rxd_mux_select_input_t IOMUXC_UART2_IPP_UART_RXD_MUX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_uart3_ipp_uart_rts_b_select_input_t IOMUXC_UART3_IPP_UART_RTS_B_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_uart3_ipp_uart_rxd_mux_select_input_t IOMUXC_UART3_IPP_UART_RXD_MUX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_uart4_ipp_uart_rts_b_select_input_t IOMUXC_UART4_IPP_UART_RTS_B_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_uart4_ipp_uart_rxd_mux_select_input_t IOMUXC_UART4_IPP_UART_RXD_MUX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_uart5_ipp_uart_rts_b_select_input_t IOMUXC_UART5_IPP_UART_RTS_B_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_uart5_ipp_uart_rxd_mux_select_input_t IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usb_ipp_ind_otg2_oc_select_input_t IOMUXC_USB_IPP_IND_OTG2_OC_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usb_ipp_ind_otg_oc_select_input_t IOMUXC_USB_IPP_IND_OTG_OC_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc1_ipp_card_det_select_input_t IOMUXC_USDHC1_IPP_CARD_DET_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc1_ipp_wp_on_select_input_t IOMUXC_USDHC1_IPP_WP_ON_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc2_ipp_card_det_select_input_t IOMUXC_USDHC2_IPP_CARD_DET_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc2_ipp_wp_on_select_input_t IOMUXC_USDHC2_IPP_WP_ON_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc3_ipp_card_det_select_input_t IOMUXC_USDHC3_IPP_CARD_DET_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc3_ipp_dat4_in_select_input_t IOMUXC_USDHC3_IPP_DAT4_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc3_ipp_dat5_in_select_input_t IOMUXC_USDHC3_IPP_DAT5_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc3_ipp_dat6_in_select_input_t IOMUXC_USDHC3_IPP_DAT6_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc3_ipp_dat7_in_select_input_t IOMUXC_USDHC3_IPP_DAT7_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc3_ipp_wp_on_select_input_t IOMUXC_USDHC3_IPP_WP_ON_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc4_ipp_card_clk_in_select_input_t IOMUXC_USDHC4_IPP_CARD_CLK_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc4_ipp_card_det_select_input_t IOMUXC_USDHC4_IPP_CARD_DET_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc4_ipp_cmd_in_select_input_t IOMUXC_USDHC4_IPP_CMD_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat0_in_select_input_t IOMUXC_USDHC4_IPP_DAT0_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat1_in_select_input_t IOMUXC_USDHC4_IPP_DAT1_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat2_in_select_input_t IOMUXC_USDHC4_IPP_DAT2_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat3_in_select_input_t IOMUXC_USDHC4_IPP_DAT3_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat4_in_select_input_t IOMUXC_USDHC4_IPP_DAT4_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat5_in_select_input_t IOMUXC_USDHC4_IPP_DAT5_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat6_in_select_input_t IOMUXC_USDHC4_IPP_DAT6_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc4_ipp_dat7_in_select_input_t IOMUXC_USDHC4_IPP_DAT7_IN_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_usdhc4_ipp_wp_on_select_input_t IOMUXC_USDHC4_IPP_WP_ON_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_weim_ipp_ind_dtack_b_select_input_t IOMUXC_WEIM_IPP_IND_DTACK_B_SELECT_INPUT; //!< DAISY
    volatile hw_iomuxc_iomuxc_weim_ipp_ind_wait_b_select_input_t IOMUXC_WEIM_IPP_IND_WAIT_B_SELECT_INPUT; //!< DAISY
} hw_iomuxc_t;
#endif

//! @brief Macro to access all IOMUXC registers.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_IOMUXC(0)</code>.
#define HW_IOMUXC     (*(volatile hw_iomuxc_t *) REGS_IOMUXC_BASE)


#endif // _IOMUXC_H
