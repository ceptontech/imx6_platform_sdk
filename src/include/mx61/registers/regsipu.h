/*
 * Copyright (C) 2012, Freescale Semiconductor, Inc. All Rights Reserved
 * THIS SOURCE CODE IS CONFIDENTIAL AND PROPRIETARY AND MAY NOT
 * BE USED OR DISTRIBUTED WITHOUT THE WRITTEN PERMISSION OF
 * Freescale Semiconductor, Inc.
 */

#ifndef _IPU_H
#define _IPU_H

#include "regs.h"

/*
 * Registers defined in this header file.
 *
 * - HW_IPU_CONF - Configuration Register
 * - HW_IPU_SISG_CTRL0 - SISG Control 0 Register
 * - HW_IPU_SISG_CTRL1 - SISG Control 1 Register
 * - HW_IPU_SISG_SET_I - SISG Set<i> Register
 * - HW_IPU_SISG_CLR_I - SISG Clear <i> Register
 * - HW_IPU_INT_CTRL_1 - Interrupt Control Register 1
 * - HW_IPU_INT_CTRL_2 - Interrupt Control Register 2
 * - HW_IPU_INT_CTRL_3 - Interrupt Control Register 3
 * - HW_IPU_INT_CTRL_4 - Interrupt Control Register 4
 * - HW_IPU_INT_CTRL_5 - Interrupt Control Register 5
 * - HW_IPU_INT_CTRL_6 - Interrupt Control Register 6
 * - HW_IPU_INT_CTRL_7 - Interrupt Control Register 7
 * - HW_IPU_INT_CTRL_8 - Interrupt Control Register 8
 * - HW_IPU_INT_CTRL_9 - Interrupt Control Register 9
 * - HW_IPU_INT_CTRL_10 - Interrupt Control Register 10
 * - HW_IPU_INT_CTRL_11 - Interrupt Control Register 11
 * - HW_IPU_INT_CTRL_12 - Interrupt Control Register 12
 * - HW_IPU_INT_CTRL_13 - Interrupt Control Register 13
 * - HW_IPU_INT_CTRL_14 - Interrupt Control Register 14
 * - HW_IPU_INT_CTRL_15 - Interrupt Control Register15
 * - HW_IPU_SDMA_EVENT_1 - SDMA Event Control Register 1
 * - HW_IPU_SDMA_EVENT_2 - SDMA Event Control Register 2
 * - HW_IPU_SDMA_EVENT_3 - SDMA Event Control Register 3
 * - HW_IPU_SDMA_EVENT_4 - SDMA Event Control Register 4
 * - HW_IPU_SDMA_EVENT_7 - SDMA Event Control Register 7
 * - HW_IPU_SDMA_EVENT_8 - SDMA Event Control Register 8
 * - HW_IPU_SDMA_EVENT_11 - SDMA Event Control Register 11
 * - HW_IPU_SDMA_EVENT_12 - SDMA Event Control Register 12
 * - HW_IPU_SDMA_EVENT_13 - SDMA Event Control Register 13
 * - HW_IPU_SDMA_EVENT_14 - SDMA Event Control Register 14
 * - HW_IPU_SRM_PRI1 - Shadow Registers Memory Priority 1 Register
 * - HW_IPU_SRM_PRI2 - Shadow Registers Memory Priority 2 Register
 * - HW_IPU_FS_PROC_FLOW1 - FSU Processing Flow 1 Register
 * - HW_IPU_FS_PROC_FLOW2 - FSU Processing Flow 2 Register
 * - HW_IPU_FS_DISP_FLOW1 - FSU Displaying Flow 1 Register
 * - HW_IPU_FS_DISP_FLOW2 - FSU Displaying Flow 2 Register
 * - HW_IPU_SKIP - SKIP Register
 * - HW_IPU_DISP_ALT_CONF - Display Alternate Configuration Register
 * - HW_IPU_DISP_GEN - Display General Control Register
 * - HW_IPU_DISP_ALT1 - Display Alternate Flow Control Register 1
 * - HW_IPU_DISP_ALT2 - Display Alternate Flow Control Register 2
 * - HW_IPU_DISP_ALT3 - Display Alternate Flow Control Register 3
 * - HW_IPU_DISP_ALT4 - Display Alternate Flow Control Register 4
 * - HW_IPU_SNOOP - Autorefresh and Snooping Control Register
 * - HW_IPU_MEM_RST - Memory Reset Control Register
 * - HW_IPU_PM - Power Modes Control Register
 * - HW_IPU_GPR - General Purpose Register
 * - HW_IPU_CH_DB_MODE_SEL0 - Channel Double Buffer Mode Select 0 Register
 * - HW_IPU_CH_DB_MODE_SEL1 - Channel Double Buffer Mode Select 1 Register
 * - HW_IPU_ALT_CH_DB_MODE_SEL0 - Alternate Channel Double Buffer Mode Select 0 Register
 * - HW_IPU_ALT_CH_DB_MODE_SEL1 - Alternate Channel Double Buffer Mode Select1 Register
 * - HW_IPU_ALT_CH_TRB_MODE_SEL0 - Alternate Channel Triple Buffer Mode Select 0 Register
 * - HW_IPU_ALT_CH_TRB_MODE_SEL1 - Alternate Channel Triple Buffer Mode Select 1 Register
 * - HW_IPU_INT_STAT_1 - Interrupt Status Register 1
 * - HW_IPU_INT_STAT_2 - Interrupt Status Register2
 * - HW_IPU_INT_STAT_3 - Interrupt Status Register 3
 * - HW_IPU_INT_STAT_5 - Interrupt Status Register 5
 * - HW_IPU_INT_STAT_6 - Interrupt Status Register 6
 * - HW_IPU_INT_STAT_7 - Interrupt Status Register7 1
 * - HW_IPU_INT_STAT_8 - Interrupt Status Register 8
 * - HW_IPU_INT_STAT_9 - Interrupt Status Register 9
 * - HW_IPU_INT_STAT_10 - Interrupt Status Register 10
 * - HW_IPU_INT_STAT_11 - Interrupt Status Register 11
 * - HW_IPU_INT_STAT_12 - Interrupt Status Register 12
 * - HW_IPU_INT_STAT_13 - Interrupt Status Register 13
 * - HW_IPU_INT_STAT_14 - Interrupt Status Register 14
 * - HW_IPU_INT_STAT_15 - Interrupt Status Register 15
 * - HW_IPU_CUR_BUF_0 - Current Buffer Register 0
 * - HW_IPU_CUR_BUF_1 - Current Buffer Register 1
 * - HW_IPU_ALT_CUR_0 - Alternate Current Buffer Register 0
 * - HW_IPU_ALT_CUR_1 - Alternate Current Buffer Register 1
 * - HW_IPU_SRM_STAT - Shadow Registers Memory Status Register
 * - HW_IPU_PROC_TASKS_STAT - Processing Status Tasks Register
 * - HW_IPU_DISP_TASKS_STAT - Display Tasks Status Register
 * - HW_IPU_TRIPLE_CUR_BUF_0 - Triple Current Buffer Register 0
 * - HW_IPU_TRIPLE_CUR_BUF_1 - Triple Current Buffer Register 1
 * - HW_IPU_TRIPLE_CUR_BUF_2 - Triple Current Buffer Register 2
 * - HW_IPU_TRIPLE_CUR_BUF_3 - Triple Current Buffer Register 3
 * - HW_IPU_CH_BUF0_RDY0 - IPU Channels Buffer 0 Ready 0 Register
 * - HW_IPU_CH_BUF0_RDY1 - IPU Channels Buffer 0 Ready 1 Register
 * - HW_IPU_CH_BUF1_RDY0 - IPU Channels Buffer 1 Ready 0 Register
 * - HW_IPU_CH_BUF1_RDY1 - IPU Channels Buffer 1 Ready 1Register
 * - HW_IPU_ALT_CH_BUF0_RDY0 - IPU Alternate Channels Buffer 0 Ready 0 Register
 * - HW_IPU_ALT_CH_BUF0_RDY1 - IPU Alternate Channels Buffer 0 Ready 1 Register
 * - HW_IPU_ALT_CH_BUF1_RDY0 - IPU Alternate Channels Buffer1 Ready 0 Register
 * - HW_IPU_ALT_CH_BUF1_RDY1 - IPU Alternate Channels Buffer 1 Ready 1 Register
 * - HW_IPU_CH_BUF2_RDY0 - IPU Channels Buffer 2 Ready 0 Register
 * - HW_IPU_CH_BUF2_RDY1 - IPU Channels Buffer 2 Ready 1 Register
 * - HW_IPU_INT_STAT_4 - Interrupt Status Register 4
 * - HW_IPU_IDMAC_CONF - IDMAC Configuration Register
 * - HW_IPU_IDMAC_CH_EN_1 - IDMAC Channel Enable 1 Register
 * - HW_IPU_IDMAC_ALT_SEP_ALPHA - IDMAC Alternate Separate Alpha Indication Register
 * - HW_IPU_IDMAC_CH_PRI_1 - IDMAC Channel Priority 1 Register
 * - HW_IPU_IDMAC_CH_PRI_2 - IDMAC Channel Priority 2 Register
 * - HW_IPU_IDMAC_WM_EN_2 - IDMAC Channel Watermark Enable 2 Register
 * - HW_IPU_IDMAC_LOCK_EN_1 - IDMAC Channel Lock Enable 1Register
 * - HW_IPU_IDMAC_CH_BUSY_1 - IDMAC Channel Busy 1 Register
 * - HW_IPU_IDMAC_CH_BUSY_2 - IDMAC Channel Busy 2 Register
 * - HW_IPU_IDMAC_SEP_ALPHA - IDMAC Separate Alpha Indication Register
 * - HW_IPU_IDMAC_WM_EN_1 - IDMAC Channel Watermark Enable 1 Register
 * - HW_IPU_IDMAC_SC_CORD_1 - IDMAC Scroll Coordinations Register 1
 * - HW_IPU_IDMAC_CH_EN_2 - IDMAC Channel Enable 2 Register
 * - HW_IPU_IDMAC_LOCK_EN_2 - IDMAC Channel Lock Enable 2Register
 * - HW_IPU_IDMAC_SUB_ADDR_2 - IDMAC Channel Alternate Address 2 Register
 * - HW_IPU_IDMAC_SUB_ADDR_3 - IDMAC Channel Alternate Address 3 Register
 * - HW_IPU_IDMAC_BNDM_EN_1 - IDMAC Band Mode Enable 1 Register
 * - HW_IPU_DP_DEBUG_CNT - DP Debug Control Register
 * - HW_IPU_DP_DEBUG_STAT - DP Debug Status Register
 * - HW_IPU_IC_CONF - IC Configuration Register
 * - HW_IPU_IC_PRP_ENC_RSC - IC Preprocessing Encoder Resizing Coefficients Register
 * - HW_IPU_IC_PRP_VF_RSC - IC Preprocessing View-Finder Resizing Coefficients Register
 * - HW_IPU_IC_PP_RSC - IC Postprocessing Encoder Resizing Coefficients Register
 * - HW_IPU_IC_CMBP_1 - IC Combining Parameters Register 1
 * - HW_IPU_IC_CMBP_2 - IC Combining Parameters Register 2
 * - HW_IPU_IC_IDMAC_1 - IC IDMAC Parameters 1 Register
 * - HW_IPU_IC_IDMAC_2 - IC IDMAC Parameters 2 Register
 * - HW_IPU_IC_IDMAC_3 - IC IDMAC Parameters 3Register
 * - HW_IPU_IC_IDMAC_4 - IC IDMAC Parameters 4 Register
 * - HW_IPU_CSI0_SENS_CONF - CSI0 Sensor Configuration Register
 * - HW_IPU_CSI0_SENS_FRM_SIZE - CSI0 Sense Frame Size Register
 * - HW_IPU_CSI0_ACT_FRM_SIZE - CSI0 Actual Frame Size Register
 * - HW_IPU_CSI0_OUT_FRM_CTRL - CSI0 Output Control Register
 * - HW_IPU_CSI0_TST_CTRL - CSIO Test Control Register
 * - HW_IPU_CSI0_CCIR_CODE_1 - CSIO CCIR Code Register 1
 * - HW_IPU_CSI0_CCIR_CODE_2 - CSIO CCIR Code Register 2
 * - HW_IPU_CSI0_CCIR_CODE_3 - CSIO CCIR Code Register 3
 * - HW_IPU_CSI0_DI - CSI0 Data Identifier Register
 * - HW_IPU_CSI0_SKIP - CSI0 SKIP Register
 * - HW_IPU_CSIO_CPD_CTRL - CSI0 Compander Control Register
 * - HW_IPU_CSIO_CPD_RC_I - CSI0 Red Component Compander Constants Register <i>
 * - HW_IPU_CSIO_CPD_RS_I - CSI0 Red Component Compander SLOPE Register <i>
 * - HW_IPU_CSIO_CPD_GRC_I - CSI0 GR Component Compander Constants Register <i>
 * - HW_IPU_CSIO_CPD_GRS_I - CSI0 GR Component Compander SLOPE Register <i>
 * - HW_IPU_CSIO_CPD_GBC_I - CSI0 GB Component Compander Constants Register <i>
 * - HW_IPU_CSIO_CPD_GBS_I - CSI0 GB Component Compander SLOPE Register <i>
 * - HW_IPU_CSIO_CPD_BC_I - CSI0 Blue Component Compander Constants Register <i>
 * - HW_IPU_CSIO_CPD_BS_I - CSI0 Blue Component Compander SLOPE Register <i>
 * - HW_IPU_CSI0_CPD_OFFSET1 - CSI0 Compander Offset Register 1
 * - HW_IPU_CSI0_CPD_OFFSET2 - CSI0 Compander Offset Register 2
 * - HW_IPU_CSI1_SENS_CONF - CSI1 Sensor Configuration Register
 * - HW_IPU_CSI1_SENS_FRM_SIZE - CSI1 Sense Frame Size Register
 * - HW_IPU_CSI1_ACT_FRM_SIZE - CSI1 Actual Frame Size Register
 * - HW_IPU_CSI1_OUT_FRM_CTRL - CSI1 Output Control Register
 * - HW_IPU_CSI1_TST_CTRL - CSI1 Test Control Register
 * - HW_IPU_CSI1_CCIR_CODE_1 - CSI1 CCIR Code Register 1
 * - HW_IPU_CSI1_CCIR_CODE_2 - CSI1 CCIR Code Register 2
 * - HW_IPU_CSI1_CCIR_CODE_3 - CSI1 CCIR Code Register 3
 * - HW_IPU_CSI1_DI - CSI1 Data Identifier Register
 * - HW_IPU_CSI1_SKIP - CSI1 SKIP Register
 * - HW_IPU_CSI1_CPD_CTRL - CSI1 Compander Control Register
 * - HW_IPU_CSI1_CPD_RC_I - CSI1 Red Component Compander Constants Register <i>
 * - HW_IPU_CSI1_CPD_RS_I - CSI1 Red Component Compander SLOPE Register <i>
 * - HW_IPU_CSI1_CPD_GRC_I - CSI1 GR Component Compander Constants Register <i>
 * - HW_IPU_CSI1_CPD_GRS_I - CSI1 GR Component Compander SLOPE Register <i>
 * - HW_IPU_CSI1_CPD_GBC_I - CSI1 GB Component Compander Constants Register <i>
 * - HW_IPU_CSI1_CPD_GBS_I - CSI1 GB Component Compander SLOPE Register <i>
 * - HW_IPU_CSI1_CPD_BC_I - CSI1 Blue Component Compander Constants Register <i>
 * - HW_IPU_CSI1_CPD_BS_I - CSI1 Blue Component Compander SLOPE Register <i>
 * - HW_IPU_CSI1_CPD_OFFSET1 - CSI1 Compander Offset Register 1
 * - HW_IPU_CSI1_CPD_OFFSET2 - CSI1 Compander Offset Register 2
 * - HW_IPU_DI0_GENERAL - DI0 General Register
 * - HW_IPU_DI0_BS_CLKGEN0 - DI0 Base Sync Clock Gen 0 Register
 * - HW_IPU_DI0_BS_CLKGEN1 - DI0 Base Sync Clock Gen 1 Register
 * - HW_IPU_DI0_SW_GEN0_1 - DI0 Sync Wave Gen 1 Register 0
 * - HW_IPU_DI0_SW_GEN0_2 - DI0 Sync Wave Gen 2 Register 0
 * - HW_IPU_DI0_SW_GEN0_3 - DI0 Sync Wave Gen 3 Register 0
 * - HW_IPU_DI0_SW_GEN0_4 - DI0 Sync Wave Gen 4 Register 0
 * - HW_IPU_DI0_SW_GEN0_5 - DI0 Sync Wave Gen 5 Register 0
 * - HW_IPU_DI0_SW_GEN0_6 - DI0 Sync Wave Gen 6 Register 0
 * - HW_IPU_DI0_SW_GEN0_7 - DI0 Sync Wave Gen 7 Register 0
 * - HW_IPU_DI0_SW_GEN0_8 - DI0 Sync Wave Gen 8 Register 0
 * - HW_IPU_DI0_SW_GEN0_9 - DI0 Sync Wave Gen 9 Register 0
 * - HW_IPU_DI0_SW_GEN1_1 - DI0 Sync Wave Gen 1 Register 1
 * - HW_IPU_DI0_SW_GEN1_2 - DI0 Sync Wave Gen 2 Register 1
 * - HW_IPU_DI0_SW_GEN1_3 - DI0 Sync Wave Gen 3 Register 1
 * - HW_IPU_DI0_SW_GEN1_4 - DI0 Sync Wave Gen 4 Register 1
 * - HW_IPU_DI0_SW_GEN1_5 - DI0 Sync Wave Gen 5 Register 1
 * - HW_IPU_DI0_SW_GEN1_6 - DI0 Sync Wave Gen 6 Register 1
 * - HW_IPU_DI0_SW_GEN1_7 - DI0 Sync Wave Gen 7 Register 1
 * - HW_IPU_DI0_SW_GEN1_8 - DI0 Sync Wave Gen 8 Register 1
 * - HW_IPU_DI0_SW_GEN1_9 - DI0 Sync Wave Gen 9 Register 1
 * - HW_IPU_DI0_SYNC_AS_GEN - DI0 Sync Assistance Gen Register
 * - HW_IPU_DI0_DW_GEN_I - DI0 Data Wave Gen <i> Register
 * - HW_IPU_DI0_DW_SET0_I - DI0 Data Wave Set 0 <i> Register
 * - HW_IPU_DI0_DW_SET1_I - DI0 Data Wave Set 1 <i> Register
 * - HW_IPU_DI0_DW_SET2_I - DI0 Data Wave Set 2 <i> Register
 * - HW_IPU_DI0_DW_SET3_I - DI0 Data Wave Set 3 <i> Register
 * - HW_IPU_DI0_STP_REP_I - DI0 Step Repeat <i> Registers
 * - HW_IPU_DI0_STP_REP_9 - DI0 Step Repeat 9 Registers
 * - HW_IPU_DI0_SER_CONF - DI0 Serial Display Control Register
 * - HW_IPU_DI0_SSC - DI0 Special Signals Control Register
 * - HW_IPU_DI0_POL - DI0 Polarity Register
 * - HW_IPU_DI0_AW0 - DI0 Active Window 0 Register
 * - HW_IPU_DI0_AW1 - DI0 Active Window 1 Register
 * - HW_IPU_DI0_SCR_CONF - DI0 Screen Configuration Register
 * - HW_IPU_DI0_STAT - DI0 Status Register
 * - HW_IPU_DI1_GENERAL - DI1General Register
 * - HW_IPU_DI1_BS_CLKGEN0 - DI1 Base Sync Clock Gen 0 Register
 * - HW_IPU_DI1_BS_CLKGEN1 - DI1 Base Sync Clock Gen 1 Register
 * - HW_IPU_DI1_SW_GEN0_1 - DI1 Sync Wave Gen 1 Register 0
 * - HW_IPU_DI1_SW_GEN0_2 - DI1 Sync Wave Gen 2 Register 0
 * - HW_IPU_DI1_SW_GEN0_3 - DI1 Sync Wave Gen 3 Register 0
 * - HW_IPU_DI1_SW_GEN0_4 - DI1 Sync Wave Gen 4 Register 0
 * - HW_IPU_DI1_SW_GEN0_5 - DI1 Sync Wave Gen 5 Register 0
 * - HW_IPU_DI1_SW_GEN0_6 - DI1 Sync Wave Gen 6 Register 0
 * - HW_IPU_DI1_SW_GEN0_7 - DI1 Sync Wave Gen 7 Register 0
 * - HW_IPU_DI1_SW_GEN0_8 - DI1 Sync Wave Gen 8 Register 0
 * - HW_IPU_DI1_SW_GEN0_9 - DI1Sync Wave Gen 9 Register 0
 * - HW_IPU_DI1_SW_GEN1_1 - DI1 Sync Wave Gen 1 Register 1
 * - HW_IPU_DI1_SW_GEN1_2 - DI1 Sync Wave Gen 2 Register 1
 * - HW_IPU_DI1_SW_GEN1_3 - DI1 Sync Wave Gen 3 Register 1
 * - HW_IPU_DI1_SW_GEN1_4 - DI1 Sync Wave Gen 4 Register 1
 * - HW_IPU_DI1_SW_GEN1_5 - DI1 Sync Wave Gen 5 Register 1
 * - HW_IPU_DI1_SW_GEN1_6 - DI1 Sync Wave Gen 6 Register 1
 * - HW_IPU_DI1_SW_GEN1_7 - DI1Sync Wave Gen 7 Register 1
 * - HW_IPU_DI1_SW_GEN1_8 - DI1 Sync Wave Gen 8 Register 1
 * - HW_IPU_DI1_SW_GEN1_9 - DI1 Sync Wave Gen 9 Register 1
 * - HW_IPU_DI1_SYNC_AS_GEN - DI1 Sync Assistance Gen Register
 * - HW_IPU_DI1_DW_GEN_I - DI1 Data Wave Gen <i> Register
 * - HW_IPU_DI1_DW_SET0_I - DI1 Data Wave Set 0 <i> Register
 * - HW_IPU_DI1_DW_SET1_I - DI1 Data Wave Set 1 <i> Register
 * - HW_IPU_DI1_DW_SET2_I - DI1 Data Wave Set 2 <i> Register
 * - HW_IPU_DI1_DW_SET3_I - DI1 Data Wave Set 3 <i> Register
 * - HW_IPU_D1_STP_REP_I - DI1 Step Repeat <i> Registers
 * - HW_IPU_DI1_STP_REP_9 - DI1Step Repeat 9 Registers
 * - HW_IPU_DI1_SER_CONF - DI1 Serial Display Control Register
 * - HW_IPU_DI1_SSC - DI1 Special Signals Control Register
 * - HW_IPU_DI1_POL - DI1 Polarity Register
 * - HW_IPU_DI1_AW0 - DI1Active Window 0 Register
 * - HW_IPU_DI1_AW1 - DI1 Active Window 1 Register
 * - HW_IPU_DI1_SCR_CONF - DI1 Screen Configuration Register
 * - HW_IPU_DI1_STAT - DI1 Status Register
 * - HW_IPU_SMFC_MAP - SMFC Mapping Register
 * - HW_IPU_SMFC_WMC - SMFC Watermark Control Register
 * - HW_IPU_SMFC_BS - SMFC Burst Size Register
 * - HW_IPU_DC_READ_CH_CONF - DC Read Channel Configuration Register
 * - HW_IPU_DC_READ_SH_ADDR - DC Read Channel Start Address Register
 * - HW_IPU_DC_RL0_CH_0 - DC Routine Link Register 0 Channel 0
 * - HW_IPU_DC_RL1_CH_0 - DC Routine Link Register 1 Channel 0
 * - HW_IPU_DC_RL3_CH_0 - DC Routine Link Registe3 Channel 0
 * - HW_IPU_DC_RL4_CH_0 - DC Routine Link Register 4 Channel 0
 * - HW_IPU_DC_WR_CH_CONF_1 - DC Write Channel 1 Configuration Register
 * - HW_IPU_DC_RL2_CH_0 - DC Routine Link Register2 Channel 0
 * - HW_IPU_DC_RL0_CH_1 - DC Routine Link Register 0 Channel 1
 * - HW_IPU_DC_RL1_CH_1 - DC Routine Link Register 1 Channel 1
 * - HW_IPU_DC_RL2_CH_1 - DC Routine Link Register 2 Channel 1
 * - HW_IPU_DC_RL3_CH_1 - DC Routine Link Register 3 Channel 1
 * - HW_IPU_DC_RL4_CH_1 - DC Routine Link Register 4 Channel 1
 * - HW_IPU_DC_WR_CH_CONF_2 - DC Write Channel 2 Configuration Register
 * - HW_IPU_DC_WR_CH_ADDR_2 - DC Write Channel 2 Address Configuration Register
 * - HW_IPU_DC_RL0_CH_2 - DC Routine Link Register 0 Channel 2
 * - HW_IPU_DC_RL1_CH_2 - DC Routine Link Register 1 Channel 2
 * - HW_IPU_DC_RL3_CH_2 - DC Routine Link Register 3 Channel 2
 * - HW_IPU_DC_RL4_CH_2 - DC Routine Link Register 4 Channel 2
 * - HW_IPU_DC_CMD_CH_CONF_3 - DC Command Channel 3 Configuration Register
 * - HW_IPU_DC_CMD_CH_CONF_4 - DC Command Channel 4 Configuration Register
 * - HW_IPU_DC_WR_CH_CONF_5 - DC Write Channel 5Configuration Register
 * - HW_IPU_DC_WR_CH_ADDR_5 - DC Write Channel 5Address Configuration Register
 * - HW_IPU_DC_RL0_CH_5 - DC Routine Link Register 0 Channel 5
 * - HW_IPU_DC_RL1_CH_5 - DC Routine Link Register 1 Channel 5
 * - HW_IPU_DC_RL2_CH_5 - DC Routine Link Register 2 Channel 5
 * - HW_IPU_DC_RL3_CH_5 - DC Routine Link Register3 Channel 5
 * - HW_IPU_DC_RL4_CH_5 - DC Routine Link Register 4 Channel 5
 * - HW_IPU_DC_WR_CH_CONF_6 - DC Write Channel 6 Configuration Register
 * - HW_IPU_DC_WR_CH_ADDR_6 - DC Write Channel 6 Address Configuration Register
 * - HW_IPU_DC_RL0_CH_6 - DC Routine Link Register 0Channel 6
 * - HW_IPU_DC_RL1_CH_6 - DC Routine Link Register 1 Channel 6
 * - HW_IPU_DC_RL2_CH_6 - DC Routine Link Register 2 Channel 6
 * - HW_IPU_DC_RL3_CH_6 - DC Routine Link Register 3 Channel 6
 * - HW_IPU_DC_RL4_CH_6 - DC Routine Link Register 4 Channel 6
 * - HW_IPU_DC_WR_CH_CONF1_8 - DC Write Channel 8 Configuration 1Register
 * - HW_IPU_DC_WR_CH_CONF2_8 - DC Write Channel 8 Configuration 2 Register
 * - HW_IPU_DC_RL1_CH_8 - DC Routine Link Register 1 Channel 8
 * - HW_IPU_DC_RL2_CH_8 - DC Routine Link Register 2 Channel 8
 * - HW_IPU_DC_RL3_CH_8 - DC Routine Link Register 3 Channel 8
 * - HW_IPU_DC_RL4_CH_8 - DC Routine Link Register 4 Channel 8
 * - HW_IPU_DC_RL5_CH_8 - DC Routine Link Register 5 Channel 8
 * - HW_IPU_DC_RL6_CH_8 - DC Routine Link Register 6 Channel 8
 * - HW_IPU_DC_WR_CH_CONF1_9 - DC Write Channel 9 Configuration 1Register
 * - HW_IPU_DC_WR_CH_CONF2_9 - DC Write Channel 9Configuration 2Register
 * - HW_IPU_DC_RL1_CH_9 - DC Routine Link Register 1 Channel 9
 * - HW_IPU_DC_RL2_CH_9 - DC Routine Link Register 2 Channel 9
 * - HW_IPU_DC_RL3_CH_9 - DC Routine Link Register 3Channel 9
 * - HW_IPU_DC_RL4_CH_9 - DC Routine Link Register 4 Channel 9
 * - HW_IPU_DC_RL5_CH_9 - DC Routine Link Register 5 Channel 9
 * - HW_IPU_DC_RL6_CH_9 - DC Routine Link Register 6 Channel 9
 * - HW_IPU_DC_GEN - DC General Register
 * - HW_IPU_DC_DISP_CONF1_0 - DC Display Configuration 1 Register 0
 * - HW_IPU_DC_DISP_CONF1_1 - DC Display Configuration 1 Register 1
 * - HW_IPU_DC_DISP_CONF1_2 - DC Display Configuration 1 Register 2
 * - HW_IPU_DC_DISP_CONF1_3 - DC Display Configuration 1 Register 3
 * - HW_IPU_DC_DISP_CONF2_0 - DC Display Configuration 2 Register 0
 * - HW_IPU_DC_DISP_CONF2_2 - DC Display Configuration 2 Register 2
 * - HW_IPU_DC_DISP_CONF2_3 - DC Display Configuration 2 Register 3
 * - HW_IPU_DC_DI0_CONF_1 - DC DI0Configuration Register 1
 * - HW_IPU_DC_DI0_CONF_2 - DC DI0Configuration Register 2
 * - HW_IPU_DC_DI1_CONF_1 - DC DI1Configuration Register 1
 * - HW_IPU_DC_DI1_CONF_2 - DC DI1Configuration Register 2
 * - HW_IPU_DC_MAP_CONF_0 - DC Mapping Configuration Register 0
 * - HW_IPU_DC_MAP_CONF_1 - DC Mapping Configuration Register 1
 * - HW_IPU_DC_MAP_CONF_2 - DC Mapping Configuration Register 2
 * - HW_IPU_DC_MAP_CONF_3 - DC Mapping Configuration Register 3
 * - HW_IPU_DC_MAP_CONF_4 - DC Mapping Configuration Register 4
 * - HW_IPU_DC_MAP_CONF_5 - DC Mapping Configuration Register 5
 * - HW_IPU_DC_MAP_CONF_6 - DC Mapping Configuration Register 6
 * - HW_IPU_DC_MAP_CONF_7 - DC Mapping Configuration Register 7
 * - HW_IPU_DC_MAP_CONF_8 - DC Mapping Configuration Register 8
 * - HW_IPU_DC_MAP_CONF_9 - DC Mapping Configuration Register 9
 * - HW_IPU_DC_MAP_CONF_10 - DC Mapping Configuration Register 10
 * - HW_IPU_DC_MAP_CONF_11 - DC Mapping Configuration Register 11
 * - HW_IPU_DC_MAP_CONF_12 - DC Mapping Configuration Register 12
 * - HW_IPU_DC_MAP_CONF_13 - DC Mapping Configuration Register 13
 * - HW_IPU_DC_MAP_CONF_14 - DC Mapping Configuration Register 14
 * - HW_IPU_DC_MAP_CONF_15 - DC Mapping Configuration Register 15
 * - HW_IPU_DC_MAP_CONF_16 - DC Mapping Configuration Register 16
 * - HW_IPU_DC_MAP_CONF_17 - DC Mapping Configuration Register 17
 * - HW_IPU_DC_MAP_CONF_18 - DC Mapping Configuration Register 18
 * - HW_IPU_DC_MAP_CONF_19 - DC Mapping Configuration Register 19
 * - HW_IPU_DC_MAP_CONF_20 - DC Mapping Configuration Register 20
 * - HW_IPU_DC_MAP_CONF_21 - DC Mapping Configuration Register 21
 * - HW_IPU_DC_MAP_CONF_22 - DC Mapping Configuration Register 22
 * - HW_IPU_DC_MAP_CONF_23 - DC Mapping Configuration Register 23
 * - HW_IPU_DC_MAP_CONF_24 - DC Mapping Configuration Register 24
 * - HW_IPU_DC_MAP_CONF_25 - DC Mapping Configuration Register 25
 * - HW_IPU_DC_MAP_CONF_26 - DC Mapping Configuration Register 26
 * - HW_IPU_DC_UGDE0_0 - DC User General Data Event 0 Register 0
 * - HW_IPU_DC_UGDE0_1 - DC User General Data Event 0 Register 1
 * - HW_IPU_DC_UGDE0_2 - DC User General Data Event 0 Register2
 * - HW_IPU_DC_UGDE0_3 - DC User General Data Event 0 Register 3
 * - HW_IPU_DC_UGDE1_0 - DC User General Data Event 1Register0
 * - HW_IPU_DC_UGDE1_1 - DC User General Data Event 1 Register 1
 * - HW_IPU_DC_UGDE1_2 - DC User General Data Event 1Register 2
 * - HW_IPU_DC_UGDE1_3 - DC User General Data Event 1Register 3
 * - HW_IPU_DC_UGDE2_0 - DC User General Data Event 2 Register 0
 * - HW_IPU_DC_UGDE2_1 - DC User General Data Event 2 Register 1
 * - HW_IPU_DC_UGDE2_2 - DC User General Data Event 2Register 2
 * - HW_IPU_DC_UGDE2_3 - DC User General Data Event 2Register 3
 * - HW_IPU_DC_UGDE3_0 - DC User General Data Event 3Register 0
 * - HW_IPU_DC_UGDE3_1 - DC User General Data Event 3Register 1
 * - HW_IPU_DC_UGDE3_2 - DC User General Data Event 3Register 2
 * - HW_IPU_DC_UGDE3_3 - DC User General Data Event 3Register 2
 * - HW_IPU_DC_LLA0 - DC Low Level Access Control Register 0
 * - HW_IPU_DC_LLA1 - DC Low Level Access Control Register 1
 * - HW_IPU_DC_R_LLA0 - DC Read Low Level Read Access Control Register 0
 * - HW_IPU_DC_R_LLA1 - DC Read Low Level Read Access Control Register1
 * - HW_IPU_DC_WR_CH_ADDR_5_ALT - DC Write Channel 5 Configuration Register
 * - HW_IPU_DC_STAT - DC Status Register
 * - HW_IPU_DC_DISP_CONF2_1 - DC Display Configuration 2 Register 1
 * - HW_IPU_DMFC_RD_CHAN - DMFC Read Channel Register
 * - HW_IPU_DMFC_WR_CHAN - DMFC Write Channel Register
 * - HW_IPU_DMFC_WR_CHAN_DEF - DMFC Write Channel Definition Register
 * - HW_IPU_DMFC_DP_CHAN - DMFC Display Processor Channel Register
 * - HW_IPU_DMFC_DP_CHAN_DEF - DMFC Display Processor Channel Definition Register
 * - HW_IPU_DMFC_GENERAL_1 - DMFC General 1 Register
 * - HW_IPU_DMFC_GENERAL_2 - DMFC General 2 Register
 * - HW_IPU_DMFC_IC_CTRL - DMFC IC Interface Control Register
 * - HW_IPU_DMFC_WR_CHAN_ALT - DMFC Write Channel Alternate Register
 * - HW_IPU_DMFC_WR_CHAN_DEF_ALT - DMFC Write Channel Definition Alternate Register
 * - HW_IPU_DMFC_DP_CHAN_ALT - DMFC MFC Display Processor Channel Alternate Register
 * - HW_IPU_DMFC_DP_CHAN_DEF_ALT - DMFC Display Channel Definition Alternate Register
 * - HW_IPU_DMFC_GENERAL1_ALT - DMFC General 1 Alternate Register
 * - HW_IPU_DMFC_STAT - DMFC Status Register
 * - HW_IPU_VDI_FSIZE - VDI Field Size Register
 * - HW_IPU_VDI_C - VDI Control Register
 * - HW_IPU_VDI_C2_ - VDI Control Register 2
 * - HW_IPU_VDI_CMDP_1 - VDI Combining Parameters Register 1
 * - HW_IPU_VDI_CMDP_2 - VDI Combining Parameters Register 2
 * - HW_IPU_VDI_PS_1 - VDI Plane Size Register 1
 * - HW_IPU_VDI_PS_2 - VDI Plane Size Register 2
 * - HW_IPU_VDI_PS_3 - VDI Plane Size Register 3
 * - HW_IPU_VDI_PS_4 - VDI Plane Size Register 4
 * - HW_IPU_IDMAC_SUB_ADDR_0 - IDMAC Channel Alternate Address 0 Register
 * - HW_IPU_IDMAC_SUB_ADDR_4 - IDMAC Channel Alternate Address 4 Register
 * - HW_IPU_IDMAC_SUB_ADDR_1 - IDMAC Channel Alternate Address 1 Register
 * - HW_IPU_DP_COM_CONF_SYNC - DP Common Configuration Sync Flow Register
 * - HW_IPU_DP_GRAPH_WIND_CTRL_SYNC - DP Graphic Window Control Sync Flow Register
 * - HW_IPU_DP_FG_POS_SYNC - DP Partial Plane Window Position Sync Flow Register
 * - HW_IPU_DP_CUR_POS_SYNC - DP Cursor Position and Size Sync Flow Register
 * - HW_IPU_DP_CUR_MAP_SYNC - DP Color Cursor Mapping Sync Flow Register
 * - HW_IPU_DP_GAMMA_C_SYNC_I - DP Gamma Constants Sync Flow Register i
 * - HW_IPU_DP_GAMMA_S_SYNC_I - DP Gamma Correction Slope Sync Flow Register i
 * - HW_IPU_DP_CSCA_SYNC_I - DP Color Space Conversion Control Sync Flow Registers
 * - HW_IPU_DP_SCS_SYNC_0 - DP Color Conversion Control Sync Flow Register 0
 * - HW_IPU_DP_SCS_SYNC_1 - DP Color Conversion Control Sync Flow Register 1
 * - HW_IPU_DP_CUR_POS_ALT - DP Cursor Position and Size Alternate Register
 * - HW_IPU_DP_COM_CONF_ASYNC0 - DP Common Configuration Async 0 Flow Register
 * - HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0 - DP Graphic Window Control Async 0 Flow Register
 * - HW_IPU_DP_FG_POS_ASYNC0 - DP Partial Plane Window Position Async 0 Flow Register
 * - HW_IPU_DP_CUR_POS_ASYNC0 - DP Cursor Position and Size Async 0 Flow Register
 * - HW_IPU_DP_CUR_MAP_ASYNC0 - DP Color Cursor Mapping Async 0 Flow Register
 * - HW_IPU_DP_GAMMA_C_ASYNC0_I - DP Gamma Constant Async 0 Flow Register i
 * - HW_IPU_DP_GAMMA_S_ASYNC0_I - DP Gamma Correction Slope Async 0 Flow Register i
 * - HW_IPU_DP_CSCA_ASYNC0_I - DP Color Space Conversion Control Async 0 Flow Register i
 * - HW_IPU_DP_CSC_ASYNC0_0 - DP Color Conversion Control Async 0 Flow Register 0
 * - HW_IPU_DP_CSC_ASYNC_1 - DP Color Conversion Control Async 1 Flow Register
 * - HW_IPU_DP_COM_CONF_ASYNC1 - DP Common Configuration Async 1 Flow Register
 * - HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1 - DP Graphic Window Control Async 1 Flow Register
 * - HW_IPU_DP_FG_POS_ASYNC1 - DP Partial Plane Window Position Async 1 Flow Register
 * - HW_IPU_DP_CUR_POS_ASYNC1 - DP Cursor Postion and Size Async 1 Flow Register
 * - HW_IPU_DP_CUR_MAP_ASYNC1 - DP Color Cursor Mapping Async 1 Flow Register
 * - HW_IPU_DP_GAMMA_C_ASYNC1_I - DP Gamma Constants Async 1 Flow Register i
 * - HW_IPU_DP_GAMMA_S_ASYN1_I - DP Gamma Correction Slope Async 1 Flow Register i
 * - HW_IPU_DP_CSCA_ASYNC1_I - DP Color Space Converstion Control Async 1 Flow Register i
 * - HW_IPU_DP_CSC_ASYNC1_0 - DP Color Conversion Control Async 1 Flow Register 0
 * - HW_IPU_DP_CSC_ASYNC1_1 - DP Color Conversion Control Async 1 Flow Register 1
 * - HW_IPU_IDMAC_BNDM_EN_2 - IDMAC Band Mode Enable 2 Register
 * - HW_IPU_IDMAC_SC_CORD - IDMAC Scroll Coordinations Register
 *
 * hw_ipu_t - Struct containing all module registers.
 */

//! @name Module base addresses
//@{
#ifndef REGS_IPU_BASE
#define REGS_IPU0_BASE (0x02400000) //!< Base address for IPU instance number 0.
#define REGS_IPU1_BASE (0x02800000) //!< Base address for IPU instance number 1.

//! @brief Get the base address of IPU by instance number.
//! @param x IPU instance number, from 0 through 2.
#define REGS_IPU_BASE(x) ( x == 0 ? REGS_IPU0_BASE : x == 1 ? REGS_IPU1_BASE : 0xffff0000)
#endif
//@}

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CONF - Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_EN : 1; //!< Camera Sensor Interface 0 Enable bit
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned IC_EN : 1; //!< Image Conversion Sub-Block Enable bit
        unsigned IRT_EN : 1; //!< Image Rotation Sub-Block Enable bit
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned DP_EN : 1; //!< Display processor Sub-block Enable bit
        unsigned DI0_EN : 1; //!< Display interface Sub-block 0 Enable bit
        unsigned DI1_EN : 1; //!< Display Interface Sub-block 1 Enable bit
        unsigned SMFC_EN : 1; //!< Sensor's Multi FIFO Controller Sub-block (SMFC) Enable bit
        unsigned DC_EN : 1; //!< Display Controller sub-block (DC) Enable bit
        unsigned DMFC_EN : 1; //!< Display's Multi FIFO Controller sub-block (DMFC) Enable bit
        unsigned SISG_EN : 1; //!< Still Image Synchronization Generator (SISG) Enable bit
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned RESERVED3 : 3; //!< Reserved, should be cleared.
        unsigned IPU_DIAGBUS_MODE : 5; //!< IPU diagnostic bus mode. This 5 bits select one of 16 groups of signals to be routed to the IPU's diagnostics bus 00000 Route group 0 to the IPU's diagnostics bus 00001 Route group 1 to the IPU's diagnostics bus 01111 Route group 15 to the IPU's diagnostics bus 10000 Route group 16 to the IPU's diagnostics bus 10001 Route group 17 to the IPU's diagnostics bus 10010-11111 Reserved
        unsigned IPU_DIAGBUS_ON : 1; //!< IPU Diagnostics bus on This bit is connected to the IPU's output. it can be used by the SoC in order to control the IOMUX and bring the IPU's diagnostics bus to the SoC's pins.
        unsigned IDMAC_DISABLE : 1; //!< Image DMA controller (IDMAC) disable bit. This bit allows the user to turn off the clock of the IDMAC if the use case permits it. By default the IDMAC is enabled.
        unsigned RESERVED4 : 1; //!< Reserved, should be cleared.
        unsigned RESERVED5 : 1; //!< Reserved
        unsigned IC_DMFC_SEL : 1; //!< IC to DMFC select Selects the DMAIC_1 (channel 21) channel's connectivity between the IC and the DMFC
        unsigned IC_DMFC_SYNC : 1; //!< IC to DMFC Sync flow This bit defines if the direct flow between IC to DMFC is synchronous or asynchronous
        unsigned RESERVED6 : 1; //!< Reserved, should be cleared.
        unsigned CSI0_DATA_SOURCE : 1; //!< CSI0 data Source This bit selects what is the data source for the CSI0. This is a static mux that should not be changed while CSI0 is working. Data is handles differently if the source is MCT (MIPI) or parallel interface.
        unsigned CSI1_DATA_SOURCE : 1; //!< CSI1 data Source This bit selects what is the data source for the CSI1. This is a static mux that should not be changed while CSI1 is working. Data is handles differently if the source is MCT (MIPI) or parallel interface.
        unsigned RESERVED7 : 2; //!< Reserved
    } B;
} hw_ipu_conf_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CONF register
 */
#define HW_IPU_CONF_ADDR(x)      (REGS_IPU_BASE(x) + 0x0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CONF(x)           (*(volatile hw_ipu_conf_t *) HW_IPU_CONF_ADDR(x))
#define HW_IPU_CONF_RD(x)        (HW_IPU_CONF(x).U)
#define HW_IPU_CONF_WR(x, v)     (HW_IPU_CONF(x).U = (v))
#define HW_IPU_CONF_SET(x, v)    (HW_IPU_CONF_WR(x, HW_IPU_CONF_RD(x) |  (v)))
#define HW_IPU_CONF_CLR(x, v)    (HW_IPU_CONF_WR(x, HW_IPU_CONF_RD(x) & ~(v)))
#define HW_IPU_CONF_TOG(x, v)    (HW_IPU_CONF_WR(x, HW_IPU_CONF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CONF bitfields
 */

/* --- Register HW_IPU_CONF, field CSI0_EN (RW)
 *
 * Camera Sensor Interface 0 Enable bit
 *
 * Values:
 * 0 - CSI0 is disabled
 * 1 - CSI0 is enabled
 */

#define BP_IPU_CONF_CSI0_EN      0
#define BM_IPU_CONF_CSI0_EN      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_CSI0_EN(v)   ((((reg32_t) v) << 0) & BM_IPU_CONF_CSI0_EN)
#else
#define BF_IPU_CONF_CSI0_EN(v)   (((v) << 0) & BM_IPU_CONF_CSI0_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_EN field to a new value.
#define BW_IPU_CONF_CSI0_EN(v)   BF_CS1(IPU_CONF, CSI0_EN, v)
#endif


/* --- Register HW_IPU_CONF, field IC_EN (RW)
 *
 * Image Conversion Sub-Block Enable bit
 *
 * Values:
 * 0 - IC is disabled
 * 1 - IC is enabled
 */

#define BP_IPU_CONF_IC_EN      2
#define BM_IPU_CONF_IC_EN      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_IC_EN(v)   ((((reg32_t) v) << 2) & BM_IPU_CONF_IC_EN)
#else
#define BF_IPU_CONF_IC_EN(v)   (((v) << 2) & BM_IPU_CONF_IC_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_EN field to a new value.
#define BW_IPU_CONF_IC_EN(v)   BF_CS1(IPU_CONF, IC_EN, v)
#endif


/* --- Register HW_IPU_CONF, field IRT_EN (RW)
 *
 * Image Rotation Sub-Block Enable bit
 *
 * Values:
 * 0 - IRT is disabled
 * 1 - IRT is enabled
 */

#define BP_IPU_CONF_IRT_EN      3
#define BM_IPU_CONF_IRT_EN      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_IRT_EN(v)   ((((reg32_t) v) << 3) & BM_IPU_CONF_IRT_EN)
#else
#define BF_IPU_CONF_IRT_EN(v)   (((v) << 3) & BM_IPU_CONF_IRT_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IRT_EN field to a new value.
#define BW_IPU_CONF_IRT_EN(v)   BF_CS1(IPU_CONF, IRT_EN, v)
#endif


/* --- Register HW_IPU_CONF, field DP_EN (RW)
 *
 * Display processor Sub-block Enable bit
 *
 * Values:
 * 0 - DP is disabled
 * 1 - DP is enabled
 */

#define BP_IPU_CONF_DP_EN      5
#define BM_IPU_CONF_DP_EN      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_DP_EN(v)   ((((reg32_t) v) << 5) & BM_IPU_CONF_DP_EN)
#else
#define BF_IPU_CONF_DP_EN(v)   (((v) << 5) & BM_IPU_CONF_DP_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_EN field to a new value.
#define BW_IPU_CONF_DP_EN(v)   BF_CS1(IPU_CONF, DP_EN, v)
#endif


/* --- Register HW_IPU_CONF, field DI0_EN (RW)
 *
 * Display interface Sub-block 0 Enable bit
 *
 * Values:
 * 0 - DI0 is disabled
 * 1 - DI0 is enabled
 */

#define BP_IPU_CONF_DI0_EN      6
#define BM_IPU_CONF_DI0_EN      0x00000040

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_DI0_EN(v)   ((((reg32_t) v) << 6) & BM_IPU_CONF_DI0_EN)
#else
#define BF_IPU_CONF_DI0_EN(v)   (((v) << 6) & BM_IPU_CONF_DI0_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_EN field to a new value.
#define BW_IPU_CONF_DI0_EN(v)   BF_CS1(IPU_CONF, DI0_EN, v)
#endif


/* --- Register HW_IPU_CONF, field DI1_EN (RW)
 *
 * Display Interface Sub-block 1 Enable bit
 *
 * Values:
 * 0 - DI1 is disabled
 * 1 - DI1 is enabled
 */

#define BP_IPU_CONF_DI1_EN      7
#define BM_IPU_CONF_DI1_EN      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_DI1_EN(v)   ((((reg32_t) v) << 7) & BM_IPU_CONF_DI1_EN)
#else
#define BF_IPU_CONF_DI1_EN(v)   (((v) << 7) & BM_IPU_CONF_DI1_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_EN field to a new value.
#define BW_IPU_CONF_DI1_EN(v)   BF_CS1(IPU_CONF, DI1_EN, v)
#endif


/* --- Register HW_IPU_CONF, field SMFC_EN (RW)
 *
 * Sensor's Multi FIFO Controller Sub-block (SMFC) Enable bit
 *
 * Values:
 * 0 - SMFC is disabled
 * 1 - SMFC is enabled
 */

#define BP_IPU_CONF_SMFC_EN      8
#define BM_IPU_CONF_SMFC_EN      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_SMFC_EN(v)   ((((reg32_t) v) << 8) & BM_IPU_CONF_SMFC_EN)
#else
#define BF_IPU_CONF_SMFC_EN(v)   (((v) << 8) & BM_IPU_CONF_SMFC_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SMFC_EN field to a new value.
#define BW_IPU_CONF_SMFC_EN(v)   BF_CS1(IPU_CONF, SMFC_EN, v)
#endif


/* --- Register HW_IPU_CONF, field DC_EN (RW)
 *
 * Display Controller sub-block (DC) Enable bit
 *
 * Values:
 * 0 - DC is disabled
 * 1 - DC is enabled
 */

#define BP_IPU_CONF_DC_EN      9
#define BM_IPU_CONF_DC_EN      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_DC_EN(v)   ((((reg32_t) v) << 9) & BM_IPU_CONF_DC_EN)
#else
#define BF_IPU_CONF_DC_EN(v)   (((v) << 9) & BM_IPU_CONF_DC_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_EN field to a new value.
#define BW_IPU_CONF_DC_EN(v)   BF_CS1(IPU_CONF, DC_EN, v)
#endif


/* --- Register HW_IPU_CONF, field DMFC_EN (RW)
 *
 * Display's Multi FIFO Controller sub-block (DMFC) Enable bit
 *
 * Values:
 * 0 - DMFC is disabled
 * 1 - DMFC is enabled
 */

#define BP_IPU_CONF_DMFC_EN      10
#define BM_IPU_CONF_DMFC_EN      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_DMFC_EN(v)   ((((reg32_t) v) << 10) & BM_IPU_CONF_DMFC_EN)
#else
#define BF_IPU_CONF_DMFC_EN(v)   (((v) << 10) & BM_IPU_CONF_DMFC_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_EN field to a new value.
#define BW_IPU_CONF_DMFC_EN(v)   BF_CS1(IPU_CONF, DMFC_EN, v)
#endif


/* --- Register HW_IPU_CONF, field SISG_EN (RW)
 *
 * Still Image Synchronization Generator (SISG) Enable bit
 *
 * Values:
 * 0 - SISG is disabled
 * 1 - SISG is enabled
 */

#define BP_IPU_CONF_SISG_EN      11
#define BM_IPU_CONF_SISG_EN      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_SISG_EN(v)   ((((reg32_t) v) << 11) & BM_IPU_CONF_SISG_EN)
#else
#define BF_IPU_CONF_SISG_EN(v)   (((v) << 11) & BM_IPU_CONF_SISG_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SISG_EN field to a new value.
#define BW_IPU_CONF_SISG_EN(v)   BF_CS1(IPU_CONF, SISG_EN, v)
#endif


/* --- Register HW_IPU_CONF, field IPU_DIAGBUS_MODE (RW)
 *
 * IPU diagnostic bus mode. This 5 bits select one of 16 groups of signals to be routed to the IPU's
 * diagnostics bus 00000 Route group 0 to the IPU's diagnostics bus 00001 Route group 1 to the IPU's
 * diagnostics bus 01111 Route group 15 to the IPU's diagnostics bus 10000 Route group 16 to the
 * IPU's diagnostics bus 10001 Route group 17 to the IPU's diagnostics bus 10010-11111 Reserved
 */

#define BP_IPU_CONF_IPU_DIAGBUS_MODE      16
#define BM_IPU_CONF_IPU_DIAGBUS_MODE      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_IPU_DIAGBUS_MODE(v)   ((((reg32_t) v) << 16) & BM_IPU_CONF_IPU_DIAGBUS_MODE)
#else
#define BF_IPU_CONF_IPU_DIAGBUS_MODE(v)   (((v) << 16) & BM_IPU_CONF_IPU_DIAGBUS_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_DIAGBUS_MODE field to a new value.
#define BW_IPU_CONF_IPU_DIAGBUS_MODE(v)   BF_CS1(IPU_CONF, IPU_DIAGBUS_MODE, v)
#endif

/* --- Register HW_IPU_CONF, field IPU_DIAGBUS_ON (RW)
 *
 * IPU Diagnostics bus on This bit is connected to the IPU's output. it can be used by the SoC in
 * order to control the IOMUX and bring the IPU's diagnostics bus to the SoC's pins.
 *
 * Values:
 * 1 - diagnostics bus is on
 * 0 - diagnostics bus is off
 */

#define BP_IPU_CONF_IPU_DIAGBUS_ON      21
#define BM_IPU_CONF_IPU_DIAGBUS_ON      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_IPU_DIAGBUS_ON(v)   ((((reg32_t) v) << 21) & BM_IPU_CONF_IPU_DIAGBUS_ON)
#else
#define BF_IPU_CONF_IPU_DIAGBUS_ON(v)   (((v) << 21) & BM_IPU_CONF_IPU_DIAGBUS_ON)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_DIAGBUS_ON field to a new value.
#define BW_IPU_CONF_IPU_DIAGBUS_ON(v)   BF_CS1(IPU_CONF, IPU_DIAGBUS_ON, v)
#endif


/* --- Register HW_IPU_CONF, field IDMAC_DISABLE (RW)
 *
 * Image DMA controller (IDMAC) disable bit. This bit allows the user to turn off the clock of the
 * IDMAC if the use case permits it. By default the IDMAC is enabled.
 *
 * Values:
 * 0 - IDMAC is enabled
 * 1 - IDMAC is disabled
 */

#define BP_IPU_CONF_IDMAC_DISABLE      22
#define BM_IPU_CONF_IDMAC_DISABLE      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_IDMAC_DISABLE(v)   ((((reg32_t) v) << 22) & BM_IPU_CONF_IDMAC_DISABLE)
#else
#define BF_IPU_CONF_IDMAC_DISABLE(v)   (((v) << 22) & BM_IPU_CONF_IDMAC_DISABLE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_DISABLE field to a new value.
#define BW_IPU_CONF_IDMAC_DISABLE(v)   BF_CS1(IPU_CONF, IDMAC_DISABLE, v)
#endif


/* --- Register HW_IPU_CONF, field IC_DMFC_SEL (RW)
 *
 * IC to DMFC select Selects the DMAIC_1 (channel 21) channel's connectivity between the IC and the
 * DMFC
 *
 * Values:
 * 0 - DMAIC_1 (channel 21) is routed to the IDMAC
 * 1 - DMAIC_1 (channel 21) is routed to DMFC In case DMFC was selected the IDMAC_CH_EN[21] must be clear.
 */

#define BP_IPU_CONF_IC_DMFC_SEL      25
#define BM_IPU_CONF_IC_DMFC_SEL      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_IC_DMFC_SEL(v)   ((((reg32_t) v) << 25) & BM_IPU_CONF_IC_DMFC_SEL)
#else
#define BF_IPU_CONF_IC_DMFC_SEL(v)   (((v) << 25) & BM_IPU_CONF_IC_DMFC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_DMFC_SEL field to a new value.
#define BW_IPU_CONF_IC_DMFC_SEL(v)   BF_CS1(IPU_CONF, IC_DMFC_SEL, v)
#endif


/* --- Register HW_IPU_CONF, field IC_DMFC_SYNC (RW)
 *
 * IC to DMFC Sync flow This bit defines if the direct flow between IC to DMFC is synchronous or
 * asynchronous
 *
 * Values:
 * 0 - async flow
 * 1 - Sync flow
 */

#define BP_IPU_CONF_IC_DMFC_SYNC      26
#define BM_IPU_CONF_IC_DMFC_SYNC      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_IC_DMFC_SYNC(v)   ((((reg32_t) v) << 26) & BM_IPU_CONF_IC_DMFC_SYNC)
#else
#define BF_IPU_CONF_IC_DMFC_SYNC(v)   (((v) << 26) & BM_IPU_CONF_IC_DMFC_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_DMFC_SYNC field to a new value.
#define BW_IPU_CONF_IC_DMFC_SYNC(v)   BF_CS1(IPU_CONF, IC_DMFC_SYNC, v)
#endif


/* --- Register HW_IPU_CONF, field CSI0_DATA_SOURCE (RW)
 *
 * CSI0 data Source This bit selects what is the data source for the CSI0. This is a static mux that
 * should not be changed while CSI0 is working. Data is handles differently if the source is MCT
 * (MIPI) or parallel interface.
 *
 * Values:
 * 0 - Parallel interface is connected to CSI0
 * 1 - MCT (MIPI) is connected to CSI0
 */

#define BP_IPU_CONF_CSI0_DATA_SOURCE      28
#define BM_IPU_CONF_CSI0_DATA_SOURCE      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_CSI0_DATA_SOURCE(v)   ((((reg32_t) v) << 28) & BM_IPU_CONF_CSI0_DATA_SOURCE)
#else
#define BF_IPU_CONF_CSI0_DATA_SOURCE(v)   (((v) << 28) & BM_IPU_CONF_CSI0_DATA_SOURCE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_DATA_SOURCE field to a new value.
#define BW_IPU_CONF_CSI0_DATA_SOURCE(v)   BF_CS1(IPU_CONF, CSI0_DATA_SOURCE, v)
#endif


/* --- Register HW_IPU_CONF, field CSI1_DATA_SOURCE (RW)
 *
 * CSI1 data Source This bit selects what is the data source for the CSI1. This is a static mux that
 * should not be changed while CSI1 is working. Data is handles differently if the source is MCT
 * (MIPI) or parallel interface.
 *
 * Values:
 * 0 - Parallel interface is connected to CSI1
 * 1 - MCT (MIPI) is connected to CSI1
 */

#define BP_IPU_CONF_CSI1_DATA_SOURCE      29
#define BM_IPU_CONF_CSI1_DATA_SOURCE      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CONF_CSI1_DATA_SOURCE(v)   ((((reg32_t) v) << 29) & BM_IPU_CONF_CSI1_DATA_SOURCE)
#else
#define BF_IPU_CONF_CSI1_DATA_SOURCE(v)   (((v) << 29) & BM_IPU_CONF_CSI1_DATA_SOURCE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_DATA_SOURCE field to a new value.
#define BW_IPU_CONF_CSI1_DATA_SOURCE(v)   BF_CS1(IPU_CONF, CSI1_DATA_SOURCE, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SISG_CTRL0 - SISG Control 0 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned VSYNC_RST_CNT : 1; //!< VSYNC Resets counters Defines if the counters are stooped following VSYNC or when the counters reach a pre defined value (VAL_STOP_SISG_COUNTER)
        unsigned NO_VSYNC_2_STRT_CNT : 3; //!< VSYCs to Start Counter This bits define how many VSYNCs signals will be counter before activating the SISG counters. If set to 0 starts immediately. If set to N (1..7) starts after N VSYNCs.
        unsigned VAL_STOP_SISG_COUNTER : 25; //!< SISG Stop Counters value. This is a predefined value that stops the SISG counters. The user should write to this field the N-1 value of the desired value.
        unsigned MCU_ACTV_TRIG : 1; //!< Reserved, should be cleared.
        unsigned EXT_ACTV : 1; //!< External Active Define if an external active trigger will start the counters. The external active trigger is an input signal to the IPU called ext_actv_trig
        unsigned RESERVED0 : 1; //!< Reserved
    } B;
} hw_ipu_sisg_ctrl0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SISG_CTRL0 register
 */
#define HW_IPU_SISG_CTRL0_ADDR(x)      (REGS_IPU_BASE(x) + 0x4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SISG_CTRL0(x)           (*(volatile hw_ipu_sisg_ctrl0_t *) HW_IPU_SISG_CTRL0_ADDR(x))
#define HW_IPU_SISG_CTRL0_RD(x)        (HW_IPU_SISG_CTRL0(x).U)
#define HW_IPU_SISG_CTRL0_WR(x, v)     (HW_IPU_SISG_CTRL0(x).U = (v))
#define HW_IPU_SISG_CTRL0_SET(x, v)    (HW_IPU_SISG_CTRL0_WR(x, HW_IPU_SISG_CTRL0_RD(x) |  (v)))
#define HW_IPU_SISG_CTRL0_CLR(x, v)    (HW_IPU_SISG_CTRL0_WR(x, HW_IPU_SISG_CTRL0_RD(x) & ~(v)))
#define HW_IPU_SISG_CTRL0_TOG(x, v)    (HW_IPU_SISG_CTRL0_WR(x, HW_IPU_SISG_CTRL0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SISG_CTRL0 bitfields
 */

/* --- Register HW_IPU_SISG_CTRL0, field VSYNC_RST_CNT (RW)
 *
 * VSYNC Resets counters Defines if the counters are stooped following VSYNC or when the counters
 * reach a pre defined value (VAL_STOP_SISG_COUNTER)
 *
 * Values:
 * 1 - The counters are stopped at VSYNC
 * 0 - The counters are stooped when the counters reach the VAL_STOP_SISG_COUNTER value.
 */

#define BP_IPU_SISG_CTRL0_VSYNC_RST_CNT      0
#define BM_IPU_SISG_CTRL0_VSYNC_RST_CNT      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SISG_CTRL0_VSYNC_RST_CNT(v)   ((((reg32_t) v) << 0) & BM_IPU_SISG_CTRL0_VSYNC_RST_CNT)
#else
#define BF_IPU_SISG_CTRL0_VSYNC_RST_CNT(v)   (((v) << 0) & BM_IPU_SISG_CTRL0_VSYNC_RST_CNT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VSYNC_RST_CNT field to a new value.
#define BW_IPU_SISG_CTRL0_VSYNC_RST_CNT(v)   BF_CS1(IPU_SISG_CTRL0, VSYNC_RST_CNT, v)
#endif


/* --- Register HW_IPU_SISG_CTRL0, field NO_VSYNC_2_STRT_CNT (RW)
 *
 * VSYCs to Start Counter This bits define how many VSYNCs signals will be counter before activating
 * the SISG counters. If set to 0 starts immediately. If set to N (1..7) starts after N VSYNCs.
 */

#define BP_IPU_SISG_CTRL0_NO_VSYNC_2_STRT_CNT      1
#define BM_IPU_SISG_CTRL0_NO_VSYNC_2_STRT_CNT      0x0000000e

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SISG_CTRL0_NO_VSYNC_2_STRT_CNT(v)   ((((reg32_t) v) << 1) & BM_IPU_SISG_CTRL0_NO_VSYNC_2_STRT_CNT)
#else
#define BF_IPU_SISG_CTRL0_NO_VSYNC_2_STRT_CNT(v)   (((v) << 1) & BM_IPU_SISG_CTRL0_NO_VSYNC_2_STRT_CNT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the NO_VSYNC_2_STRT_CNT field to a new value.
#define BW_IPU_SISG_CTRL0_NO_VSYNC_2_STRT_CNT(v)   BF_CS1(IPU_SISG_CTRL0, NO_VSYNC_2_STRT_CNT, v)
#endif

/* --- Register HW_IPU_SISG_CTRL0, field VAL_STOP_SISG_COUNTER (RW)
 *
 * SISG Stop Counters value. This is a predefined value that stops the SISG counters. The user
 * should write to this field the N-1 value of the desired value.
 */

#define BP_IPU_SISG_CTRL0_VAL_STOP_SISG_COUNTER      4
#define BM_IPU_SISG_CTRL0_VAL_STOP_SISG_COUNTER      0x1ffffff0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SISG_CTRL0_VAL_STOP_SISG_COUNTER(v)   ((((reg32_t) v) << 4) & BM_IPU_SISG_CTRL0_VAL_STOP_SISG_COUNTER)
#else
#define BF_IPU_SISG_CTRL0_VAL_STOP_SISG_COUNTER(v)   (((v) << 4) & BM_IPU_SISG_CTRL0_VAL_STOP_SISG_COUNTER)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VAL_STOP_SISG_COUNTER field to a new value.
#define BW_IPU_SISG_CTRL0_VAL_STOP_SISG_COUNTER(v)   BF_CS1(IPU_SISG_CTRL0, VAL_STOP_SISG_COUNTER, v)
#endif

/* --- Register HW_IPU_SISG_CTRL0, field MCU_ACTV_TRIG (RW)
 *
 * Reserved, should be cleared.
 */

#define BP_IPU_SISG_CTRL0_MCU_ACTV_TRIG      29
#define BM_IPU_SISG_CTRL0_MCU_ACTV_TRIG      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SISG_CTRL0_MCU_ACTV_TRIG(v)   ((((reg32_t) v) << 29) & BM_IPU_SISG_CTRL0_MCU_ACTV_TRIG)
#else
#define BF_IPU_SISG_CTRL0_MCU_ACTV_TRIG(v)   (((v) << 29) & BM_IPU_SISG_CTRL0_MCU_ACTV_TRIG)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_ACTV_TRIG field to a new value.
#define BW_IPU_SISG_CTRL0_MCU_ACTV_TRIG(v)   BF_CS1(IPU_SISG_CTRL0, MCU_ACTV_TRIG, v)
#endif

/* --- Register HW_IPU_SISG_CTRL0, field EXT_ACTV (RW)
 *
 * External Active Define if an external active trigger will start the counters. The external active
 * trigger is an input signal to the IPU called ext_actv_trig
 */

#define BP_IPU_SISG_CTRL0_EXT_ACTV      30
#define BM_IPU_SISG_CTRL0_EXT_ACTV      0x40000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SISG_CTRL0_EXT_ACTV(v)   ((((reg32_t) v) << 30) & BM_IPU_SISG_CTRL0_EXT_ACTV)
#else
#define BF_IPU_SISG_CTRL0_EXT_ACTV(v)   (((v) << 30) & BM_IPU_SISG_CTRL0_EXT_ACTV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the EXT_ACTV field to a new value.
#define BW_IPU_SISG_CTRL0_EXT_ACTV(v)   BF_CS1(IPU_SISG_CTRL0, EXT_ACTV, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SISG_CTRL1 - SISG Control 1 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SISG_STROBE_CNT : 5; //!< SISG Strobe Count The SISG can repeat the sequence for up to 32 cycles; this is used for generating a train of pulses.
        unsigned RESERVED0 : 3; //!< Reserved, should be cleared.
        unsigned SISG_OUT_POL : 6; //!< SISG_OUT_POL This bits defines the polarity of the SISG output signals
        unsigned RESERVED1 : 18; //!< Reserved, should be cleared.
    } B;
} hw_ipu_sisg_ctrl1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SISG_CTRL1 register
 */
#define HW_IPU_SISG_CTRL1_ADDR(x)      (REGS_IPU_BASE(x) + 0x8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SISG_CTRL1(x)           (*(volatile hw_ipu_sisg_ctrl1_t *) HW_IPU_SISG_CTRL1_ADDR(x))
#define HW_IPU_SISG_CTRL1_RD(x)        (HW_IPU_SISG_CTRL1(x).U)
#define HW_IPU_SISG_CTRL1_WR(x, v)     (HW_IPU_SISG_CTRL1(x).U = (v))
#define HW_IPU_SISG_CTRL1_SET(x, v)    (HW_IPU_SISG_CTRL1_WR(x, HW_IPU_SISG_CTRL1_RD(x) |  (v)))
#define HW_IPU_SISG_CTRL1_CLR(x, v)    (HW_IPU_SISG_CTRL1_WR(x, HW_IPU_SISG_CTRL1_RD(x) & ~(v)))
#define HW_IPU_SISG_CTRL1_TOG(x, v)    (HW_IPU_SISG_CTRL1_WR(x, HW_IPU_SISG_CTRL1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SISG_CTRL1 bitfields
 */

/* --- Register HW_IPU_SISG_CTRL1, field SISG_STROBE_CNT (RW)
 *
 * SISG Strobe Count The SISG can repeat the sequence for up to 32 cycles; this is used for
 * generating a train of pulses.
 */

#define BP_IPU_SISG_CTRL1_SISG_STROBE_CNT      0
#define BM_IPU_SISG_CTRL1_SISG_STROBE_CNT      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SISG_CTRL1_SISG_STROBE_CNT(v)   ((((reg32_t) v) << 0) & BM_IPU_SISG_CTRL1_SISG_STROBE_CNT)
#else
#define BF_IPU_SISG_CTRL1_SISG_STROBE_CNT(v)   (((v) << 0) & BM_IPU_SISG_CTRL1_SISG_STROBE_CNT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SISG_STROBE_CNT field to a new value.
#define BW_IPU_SISG_CTRL1_SISG_STROBE_CNT(v)   BF_CS1(IPU_SISG_CTRL1, SISG_STROBE_CNT, v)
#endif

/* --- Register HW_IPU_SISG_CTRL1, field SISG_OUT_POL (RW)
 *
 * SISG_OUT_POL This bits defines the polarity of the SISG output signals
 *
 * Values:
 * 0 - active low
 * 1 - active high
 */

#define BP_IPU_SISG_CTRL1_SISG_OUT_POL      8
#define BM_IPU_SISG_CTRL1_SISG_OUT_POL      0x00003f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SISG_CTRL1_SISG_OUT_POL(v)   ((((reg32_t) v) << 8) & BM_IPU_SISG_CTRL1_SISG_OUT_POL)
#else
#define BF_IPU_SISG_CTRL1_SISG_OUT_POL(v)   (((v) << 8) & BM_IPU_SISG_CTRL1_SISG_OUT_POL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SISG_OUT_POL field to a new value.
#define BW_IPU_SISG_CTRL1_SISG_OUT_POL(v)   BF_CS1(IPU_SISG_CTRL1, SISG_OUT_POL, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SISG_SET_I - SISG Set<i> Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SISG_SET : 25; //!< SISG SET <i> value These bits define the set value of the SISG counter #<i>
        unsigned RESERVED0 : 7; //!< Reserved, should be cleared.
    } B;
} hw_ipu_sisg_set_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SISG_SET_I register
 */
#define HW_IPU_SISG_SET_I_ADDR(x)      (REGS_IPU_BASE(x) + 0xc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SISG_SET_I(x)           (*(volatile hw_ipu_sisg_set_i_t *) HW_IPU_SISG_SET_I_ADDR(x))
#define HW_IPU_SISG_SET_I_RD(x)        (HW_IPU_SISG_SET_I(x).U)
#define HW_IPU_SISG_SET_I_WR(x, v)     (HW_IPU_SISG_SET_I(x).U = (v))
#define HW_IPU_SISG_SET_I_SET(x, v)    (HW_IPU_SISG_SET_I_WR(x, HW_IPU_SISG_SET_I_RD(x) |  (v)))
#define HW_IPU_SISG_SET_I_CLR(x, v)    (HW_IPU_SISG_SET_I_WR(x, HW_IPU_SISG_SET_I_RD(x) & ~(v)))
#define HW_IPU_SISG_SET_I_TOG(x, v)    (HW_IPU_SISG_SET_I_WR(x, HW_IPU_SISG_SET_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SISG_SET_I bitfields
 */

/* --- Register HW_IPU_SISG_SET_I, field SISG_SET (RW)
 *
 * SISG SET <i> value These bits define the set value of the SISG counter #<i>
 */

#define BP_IPU_SISG_SET_I_SISG_SET      0
#define BM_IPU_SISG_SET_I_SISG_SET      0x01ffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SISG_SET_I_SISG_SET(v)   ((((reg32_t) v) << 0) & BM_IPU_SISG_SET_I_SISG_SET)
#else
#define BF_IPU_SISG_SET_I_SISG_SET(v)   (((v) << 0) & BM_IPU_SISG_SET_I_SISG_SET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SISG_SET field to a new value.
#define BW_IPU_SISG_SET_I_SISG_SET(v)   BF_CS1(IPU_SISG_SET_I, SISG_SET, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SISG_CLR_I - SISG Clear <i> Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SISG_CLEAR : 25; //!< SISG CLR <i> value These bits define the clear value of the SISG counter #<i>
        unsigned RESERVED0 : 7; //!< Reserved, should be cleared.
    } B;
} hw_ipu_sisg_clr_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SISG_CLR_I register
 */
#define HW_IPU_SISG_CLR_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x24)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SISG_CLR_I(x)           (*(volatile hw_ipu_sisg_clr_i_t *) HW_IPU_SISG_CLR_I_ADDR(x))
#define HW_IPU_SISG_CLR_I_RD(x)        (HW_IPU_SISG_CLR_I(x).U)
#define HW_IPU_SISG_CLR_I_WR(x, v)     (HW_IPU_SISG_CLR_I(x).U = (v))
#define HW_IPU_SISG_CLR_I_SET(x, v)    (HW_IPU_SISG_CLR_I_WR(x, HW_IPU_SISG_CLR_I_RD(x) |  (v)))
#define HW_IPU_SISG_CLR_I_CLR(x, v)    (HW_IPU_SISG_CLR_I_WR(x, HW_IPU_SISG_CLR_I_RD(x) & ~(v)))
#define HW_IPU_SISG_CLR_I_TOG(x, v)    (HW_IPU_SISG_CLR_I_WR(x, HW_IPU_SISG_CLR_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SISG_CLR_I bitfields
 */

/* --- Register HW_IPU_SISG_CLR_I, field SISG_CLEAR (RW)
 *
 * SISG CLR <i> value These bits define the clear value of the SISG counter #<i>
 */

#define BP_IPU_SISG_CLR_I_SISG_CLEAR      0
#define BM_IPU_SISG_CLR_I_SISG_CLEAR      0x01ffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SISG_CLR_I_SISG_CLEAR(v)   ((((reg32_t) v) << 0) & BM_IPU_SISG_CLR_I_SISG_CLEAR)
#else
#define BF_IPU_SISG_CLR_I_SISG_CLEAR(v)   (((v) << 0) & BM_IPU_SISG_CLR_I_SISG_CLEAR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SISG_CLEAR field to a new value.
#define BW_IPU_SISG_CLR_I_SISG_CLEAR(v)   BF_CS1(IPU_SISG_CLR_I, SISG_CLEAR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_1 - Interrupt Control Register 1 (RW)
 *
 * This register contains part of IPU interrupts controls. The controls of EOF (end of frame) of DMA
 * Channels interrupts [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_EOF_EN_0 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_1 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_2 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_3 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_EOF_EN_5 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_EOF_EN_8 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_9 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_10 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_11 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_12 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_13 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_14 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_15 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_EOF_EN_17 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_18 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_19 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_20 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_21 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_22 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_23 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_24 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_25 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_26 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_27 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_28 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_29 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_EOF_EN_31 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_int_ctrl_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_1 register
 */
#define HW_IPU_INT_CTRL_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x3c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_1(x)           (*(volatile hw_ipu_int_ctrl_1_t *) HW_IPU_INT_CTRL_1_ADDR(x))
#define HW_IPU_INT_CTRL_1_RD(x)        (HW_IPU_INT_CTRL_1(x).U)
#define HW_IPU_INT_CTRL_1_WR(x, v)     (HW_IPU_INT_CTRL_1(x).U = (v))
#define HW_IPU_INT_CTRL_1_SET(x, v)    (HW_IPU_INT_CTRL_1_WR(x, HW_IPU_INT_CTRL_1_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_1_CLR(x, v)    (HW_IPU_INT_CTRL_1_WR(x, HW_IPU_INT_CTRL_1_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_1_TOG(x, v)    (HW_IPU_INT_CTRL_1_WR(x, HW_IPU_INT_CTRL_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_1 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_0 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_0      0
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_0)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_0(v)   (((v) << 0) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_0 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_0(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_0, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_1 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_1      1
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_1(v)   ((((reg32_t) v) << 1) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_1)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_1(v)   (((v) << 1) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_1 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_1(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_1, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_2 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_2      2
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_2(v)   ((((reg32_t) v) << 2) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_2)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_2(v)   (((v) << 2) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_2 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_2(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_2, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_3 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_3      3
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_3(v)   ((((reg32_t) v) << 3) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_3)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_3(v)   (((v) << 3) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_3 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_3(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_3, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_5 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_5      5
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_5(v)   ((((reg32_t) v) << 5) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_5)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_5(v)   (((v) << 5) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_5 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_5(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_5, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_8 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_8      8
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_8(v)   ((((reg32_t) v) << 8) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_8)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_8(v)   (((v) << 8) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_8 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_8(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_8, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_9 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_9      9
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_9(v)   ((((reg32_t) v) << 9) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_9)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_9(v)   (((v) << 9) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_9 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_9(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_9, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_10 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_10      10
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_10(v)   ((((reg32_t) v) << 10) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_10)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_10(v)   (((v) << 10) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_10 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_10(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_10, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_11 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_11      11
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_11(v)   ((((reg32_t) v) << 11) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_11)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_11(v)   (((v) << 11) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_11 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_11(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_11, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_12 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_12      12
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_12(v)   ((((reg32_t) v) << 12) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_12)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_12(v)   (((v) << 12) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_12 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_12(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_12, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_13 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_13      13
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_13(v)   ((((reg32_t) v) << 13) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_13)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_13(v)   (((v) << 13) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_13 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_13(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_13, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_14 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_14      14
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_14(v)   ((((reg32_t) v) << 14) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_14)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_14(v)   (((v) << 14) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_14 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_14(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_14, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_15 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_15      15
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_15(v)   ((((reg32_t) v) << 15) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_15)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_15(v)   (((v) << 15) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_15 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_15(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_15, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_17 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_17      17
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_17      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_17(v)   ((((reg32_t) v) << 17) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_17)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_17(v)   (((v) << 17) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_17 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_17(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_17, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_18 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_18      18
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_18      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_18(v)   ((((reg32_t) v) << 18) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_18)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_18(v)   (((v) << 18) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_18 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_18(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_18, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_19 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_19      19
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_19      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_19(v)   ((((reg32_t) v) << 19) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_19)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_19(v)   (((v) << 19) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_19 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_19(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_19, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_20 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_20      20
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_20(v)   ((((reg32_t) v) << 20) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_20)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_20(v)   (((v) << 20) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_20 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_20(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_20, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_21 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_21      21
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_21(v)   ((((reg32_t) v) << 21) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_21)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_21(v)   (((v) << 21) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_21 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_21(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_21, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_22 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_22      22
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_22(v)   ((((reg32_t) v) << 22) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_22)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_22(v)   (((v) << 22) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_22 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_22(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_22, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_23 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_23      23
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_23(v)   ((((reg32_t) v) << 23) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_23)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_23(v)   (((v) << 23) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_23 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_23(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_23, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_24 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_24      24
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_24(v)   ((((reg32_t) v) << 24) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_24)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_24(v)   (((v) << 24) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_24 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_24(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_24, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_25 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_25      25
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_25)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_25(v)   (((v) << 25) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_25 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_25(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_25, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_26 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_26      26
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_26)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_26(v)   (((v) << 26) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_26 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_26(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_26, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_27 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_27      27
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_27(v)   ((((reg32_t) v) << 27) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_27)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_27(v)   (((v) << 27) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_27 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_27(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_27, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_28 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_28      28
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_28(v)   ((((reg32_t) v) << 28) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_28)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_28(v)   (((v) << 28) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_28 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_28(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_28, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_29 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_29      29
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_29(v)   ((((reg32_t) v) << 29) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_29)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_29(v)   (((v) << 29) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_29 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_29(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_29, v)
#endif


/* --- Register HW_IPU_INT_CTRL_1, field IDMAC_EOF_EN_31 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_1_IDMAC_EOF_EN_31      31
#define BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_31(v)   ((((reg32_t) v) << 31) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_31)
#else
#define BF_IPU_INT_CTRL_1_IDMAC_EOF_EN_31(v)   (((v) << 31) & BM_IPU_INT_CTRL_1_IDMAC_EOF_EN_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_31 field to a new value.
#define BW_IPU_INT_CTRL_1_IDMAC_EOF_EN_31(v)   BF_CS1(IPU_INT_CTRL_1, IDMAC_EOF_EN_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_2 - Interrupt Control Register 2 (RW)
 *
 * This register contains part of IPU interrupts controls. The controls of EOF (end of frame) of DMA
 * Channels interrupts [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_EOF_EN_33 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_EOF_EN_40 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_41 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_42 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_43 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_44 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_45 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_46 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_47 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_48 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_49 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_50 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_51 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_EN_52 : 1; //!< Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_int_ctrl_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_2 register
 */
#define HW_IPU_INT_CTRL_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x40)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_2(x)           (*(volatile hw_ipu_int_ctrl_2_t *) HW_IPU_INT_CTRL_2_ADDR(x))
#define HW_IPU_INT_CTRL_2_RD(x)        (HW_IPU_INT_CTRL_2(x).U)
#define HW_IPU_INT_CTRL_2_WR(x, v)     (HW_IPU_INT_CTRL_2(x).U = (v))
#define HW_IPU_INT_CTRL_2_SET(x, v)    (HW_IPU_INT_CTRL_2_WR(x, HW_IPU_INT_CTRL_2_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_2_CLR(x, v)    (HW_IPU_INT_CTRL_2_WR(x, HW_IPU_INT_CTRL_2_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_2_TOG(x, v)    (HW_IPU_INT_CTRL_2_WR(x, HW_IPU_INT_CTRL_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_2 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_33 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_33      1
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_33(v)   ((((reg32_t) v) << 1) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_33)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_33(v)   (((v) << 1) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_33 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_33(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_33, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_40 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_40      8
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_40      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_40(v)   ((((reg32_t) v) << 8) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_40)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_40(v)   (((v) << 8) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_40)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_40 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_40(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_40, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_41 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_41      9
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_41(v)   ((((reg32_t) v) << 9) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_41)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_41(v)   (((v) << 9) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_41 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_41(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_41, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_42 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_42      10
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_42(v)   ((((reg32_t) v) << 10) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_42)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_42(v)   (((v) << 10) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_42 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_42(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_42, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_43 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_43      11
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_43(v)   ((((reg32_t) v) << 11) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_43)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_43(v)   (((v) << 11) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_43 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_43(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_43, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_44 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_44      12
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_44(v)   ((((reg32_t) v) << 12) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_44)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_44(v)   (((v) << 12) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_44 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_44(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_44, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_45 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_45      13
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_45(v)   ((((reg32_t) v) << 13) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_45)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_45(v)   (((v) << 13) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_45 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_45(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_45, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_46 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_46      14
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_46(v)   ((((reg32_t) v) << 14) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_46)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_46(v)   (((v) << 14) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_46 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_46(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_46, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_47 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_47      15
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_47(v)   ((((reg32_t) v) << 15) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_47)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_47(v)   (((v) << 15) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_47 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_47(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_47, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_48 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_48      16
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_48(v)   ((((reg32_t) v) << 16) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_48)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_48(v)   (((v) << 16) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_48 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_48(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_48, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_49 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_49      17
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_49(v)   ((((reg32_t) v) << 17) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_49)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_49(v)   (((v) << 17) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_49 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_49(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_49, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_50 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_50      18
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_50(v)   ((((reg32_t) v) << 18) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_50)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_50(v)   (((v) << 18) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_50 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_50(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_50, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_51 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_51      19
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_51(v)   ((((reg32_t) v) << 19) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_51)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_51(v)   (((v) << 19) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_51 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_51(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_51, v)
#endif


/* --- Register HW_IPU_INT_CTRL_2, field IDMAC_EOF_EN_52 (RW)
 *
 * Enable End of Frame of Channel interrupt. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_2_IDMAC_EOF_EN_52      20
#define BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_52(v)   ((((reg32_t) v) << 20) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_52)
#else
#define BF_IPU_INT_CTRL_2_IDMAC_EOF_EN_52(v)   (((v) << 20) & BM_IPU_INT_CTRL_2_IDMAC_EOF_EN_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_EN_52 field to a new value.
#define BW_IPU_INT_CTRL_2_IDMAC_EOF_EN_52(v)   BF_CS1(IPU_INT_CTRL_2, IDMAC_EOF_EN_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_3 - Interrupt Control Register 3 (RW)
 *
 * This register contains part of IPU interrupts controls. The controls of NFACK (New Frame Ack) of
 * DMA Channels interrupts [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_NFACK_EN_0 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_1 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_2 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_3 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_NFACK_EN_5 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_NFACK_EN_8 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_9 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_10 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_11 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_12 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_13 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_14 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_15 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_NFACK_EN_17 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_18 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_19 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_20 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_21 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_22 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_23 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_24 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_25 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_26 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_27 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_28 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_29 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_NFACK_EN_31 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_int_ctrl_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_3 register
 */
#define HW_IPU_INT_CTRL_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x44)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_3(x)           (*(volatile hw_ipu_int_ctrl_3_t *) HW_IPU_INT_CTRL_3_ADDR(x))
#define HW_IPU_INT_CTRL_3_RD(x)        (HW_IPU_INT_CTRL_3(x).U)
#define HW_IPU_INT_CTRL_3_WR(x, v)     (HW_IPU_INT_CTRL_3(x).U = (v))
#define HW_IPU_INT_CTRL_3_SET(x, v)    (HW_IPU_INT_CTRL_3_WR(x, HW_IPU_INT_CTRL_3_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_3_CLR(x, v)    (HW_IPU_INT_CTRL_3_WR(x, HW_IPU_INT_CTRL_3_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_3_TOG(x, v)    (HW_IPU_INT_CTRL_3_WR(x, HW_IPU_INT_CTRL_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_3 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_0 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_0      0
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_0)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_0(v)   (((v) << 0) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_0 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_0(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_0, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_1 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_1      1
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_1(v)   ((((reg32_t) v) << 1) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_1)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_1(v)   (((v) << 1) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_1 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_1(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_1, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_2 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_2      2
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_2(v)   ((((reg32_t) v) << 2) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_2)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_2(v)   (((v) << 2) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_2 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_2(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_2, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_3 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_3      3
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_3(v)   ((((reg32_t) v) << 3) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_3)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_3(v)   (((v) << 3) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_3 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_3(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_3, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_5 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_5      5
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_5(v)   ((((reg32_t) v) << 5) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_5)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_5(v)   (((v) << 5) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_5 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_5(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_5, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_8 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_8      8
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_8(v)   ((((reg32_t) v) << 8) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_8)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_8(v)   (((v) << 8) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_8 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_8(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_8, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_9 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_9      9
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_9(v)   ((((reg32_t) v) << 9) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_9)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_9(v)   (((v) << 9) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_9 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_9(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_9, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_10 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_10      10
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_10(v)   ((((reg32_t) v) << 10) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_10)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_10(v)   (((v) << 10) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_10 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_10(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_10, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_11 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_11      11
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_11(v)   ((((reg32_t) v) << 11) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_11)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_11(v)   (((v) << 11) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_11 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_11(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_11, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_12 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_12      12
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_12(v)   ((((reg32_t) v) << 12) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_12)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_12(v)   (((v) << 12) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_12 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_12(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_12, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_13 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_13      13
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_13(v)   ((((reg32_t) v) << 13) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_13)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_13(v)   (((v) << 13) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_13 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_13(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_13, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_14 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_14      14
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_14(v)   ((((reg32_t) v) << 14) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_14)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_14(v)   (((v) << 14) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_14 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_14(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_14, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_15 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_15      15
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_15(v)   ((((reg32_t) v) << 15) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_15)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_15(v)   (((v) << 15) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_15 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_15(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_15, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_17 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_17      17
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_17      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_17(v)   ((((reg32_t) v) << 17) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_17)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_17(v)   (((v) << 17) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_17 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_17(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_17, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_18 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_18      18
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_18      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_18(v)   ((((reg32_t) v) << 18) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_18)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_18(v)   (((v) << 18) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_18 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_18(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_18, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_19 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_19      19
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_19      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_19(v)   ((((reg32_t) v) << 19) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_19)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_19(v)   (((v) << 19) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_19 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_19(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_19, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_20 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_20      20
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_20(v)   ((((reg32_t) v) << 20) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_20)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_20(v)   (((v) << 20) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_20 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_20(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_20, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_21 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_21      21
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_21(v)   ((((reg32_t) v) << 21) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_21)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_21(v)   (((v) << 21) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_21 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_21(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_21, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_22 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_22      22
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_22(v)   ((((reg32_t) v) << 22) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_22)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_22(v)   (((v) << 22) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_22 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_22(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_22, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_23 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_23      23
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_23(v)   ((((reg32_t) v) << 23) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_23)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_23(v)   (((v) << 23) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_23 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_23(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_23, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_24 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_24      24
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_24(v)   ((((reg32_t) v) << 24) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_24)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_24(v)   (((v) << 24) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_24 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_24(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_24, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_25 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_25      25
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_25)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_25(v)   (((v) << 25) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_25 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_25(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_25, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_26 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_26      26
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_26)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_26(v)   (((v) << 26) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_26 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_26(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_26, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_27 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_27      27
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_27(v)   ((((reg32_t) v) << 27) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_27)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_27(v)   (((v) << 27) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_27 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_27(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_27, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_28 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_28      28
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_28(v)   ((((reg32_t) v) << 28) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_28)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_28(v)   (((v) << 28) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_28 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_28(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_28, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_29 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_29      29
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_29(v)   ((((reg32_t) v) << 29) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_29)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_29(v)   (((v) << 29) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_29 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_29(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_29, v)
#endif


/* --- Register HW_IPU_INT_CTRL_3, field IDMAC_NFACK_EN_31 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_3_IDMAC_NFACK_EN_31      31
#define BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_31(v)   ((((reg32_t) v) << 31) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_31)
#else
#define BF_IPU_INT_CTRL_3_IDMAC_NFACK_EN_31(v)   (((v) << 31) & BM_IPU_INT_CTRL_3_IDMAC_NFACK_EN_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_31 field to a new value.
#define BW_IPU_INT_CTRL_3_IDMAC_NFACK_EN_31(v)   BF_CS1(IPU_INT_CTRL_3, IDMAC_NFACK_EN_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_4 - Interrupt Control Register 4 (RW)
 *
 * This register contains part of IPU interrupts controls. The controls of NFACK (New Frame Ack) of
 * DMA Channels interrupts [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_NFACK_EN_33 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_NFACK_EN_40 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_41 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_42 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_43 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_44 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_45 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_46 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_47 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_48 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_49 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_50 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_51 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_EN_52 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_int_ctrl_4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_4 register
 */
#define HW_IPU_INT_CTRL_4_ADDR(x)      (REGS_IPU_BASE(x) + 0x48)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_4(x)           (*(volatile hw_ipu_int_ctrl_4_t *) HW_IPU_INT_CTRL_4_ADDR(x))
#define HW_IPU_INT_CTRL_4_RD(x)        (HW_IPU_INT_CTRL_4(x).U)
#define HW_IPU_INT_CTRL_4_WR(x, v)     (HW_IPU_INT_CTRL_4(x).U = (v))
#define HW_IPU_INT_CTRL_4_SET(x, v)    (HW_IPU_INT_CTRL_4_WR(x, HW_IPU_INT_CTRL_4_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_4_CLR(x, v)    (HW_IPU_INT_CTRL_4_WR(x, HW_IPU_INT_CTRL_4_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_4_TOG(x, v)    (HW_IPU_INT_CTRL_4_WR(x, HW_IPU_INT_CTRL_4_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_4 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_33 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_33      1
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_33(v)   ((((reg32_t) v) << 1) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_33)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_33(v)   (((v) << 1) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_33 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_33(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_33, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_40 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_40      8
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_40      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_40(v)   ((((reg32_t) v) << 8) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_40)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_40(v)   (((v) << 8) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_40)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_40 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_40(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_40, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_41 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_41      9
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_41(v)   ((((reg32_t) v) << 9) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_41)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_41(v)   (((v) << 9) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_41 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_41(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_41, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_42 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_42      10
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_42(v)   ((((reg32_t) v) << 10) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_42)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_42(v)   (((v) << 10) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_42 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_42(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_42, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_43 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_43      11
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_43(v)   ((((reg32_t) v) << 11) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_43)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_43(v)   (((v) << 11) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_43 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_43(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_43, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_44 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_44      12
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_44(v)   ((((reg32_t) v) << 12) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_44)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_44(v)   (((v) << 12) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_44 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_44(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_44, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_45 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_45      13
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_45(v)   ((((reg32_t) v) << 13) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_45)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_45(v)   (((v) << 13) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_45 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_45(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_45, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_46 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_46      14
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_46(v)   ((((reg32_t) v) << 14) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_46)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_46(v)   (((v) << 14) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_46 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_46(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_46, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_47 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_47      15
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_47(v)   ((((reg32_t) v) << 15) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_47)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_47(v)   (((v) << 15) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_47 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_47(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_47, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_48 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_48      16
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_48(v)   ((((reg32_t) v) << 16) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_48)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_48(v)   (((v) << 16) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_48 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_48(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_48, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_49 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_49      17
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_49(v)   ((((reg32_t) v) << 17) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_49)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_49(v)   (((v) << 17) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_49 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_49(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_49, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_50 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_50      18
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_50(v)   ((((reg32_t) v) << 18) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_50)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_50(v)   (((v) << 18) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_50 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_50(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_50, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_51 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_51      19
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_51(v)   ((((reg32_t) v) << 19) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_51)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_51(v)   (((v) << 19) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_51 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_51(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_51, v)
#endif


/* --- Register HW_IPU_INT_CTRL_4, field IDMAC_NFACK_EN_52 (RW)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the control of New Frame Ack of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_4_IDMAC_NFACK_EN_52      20
#define BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_52(v)   ((((reg32_t) v) << 20) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_52)
#else
#define BF_IPU_INT_CTRL_4_IDMAC_NFACK_EN_52(v)   (((v) << 20) & BM_IPU_INT_CTRL_4_IDMAC_NFACK_EN_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_EN_52 field to a new value.
#define BW_IPU_INT_CTRL_4_IDMAC_NFACK_EN_52(v)   BF_CS1(IPU_INT_CTRL_4, IDMAC_NFACK_EN_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_5 - Interrupt Control Register 5 (RW)
 *
 * This register contains part of IPU interrupts controls. The controls of the New-frame before end-
 * of-frame indication (NFB4EOF) of DMA Channels interrupts [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_NFB4EOF_EN_0 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_1 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_2 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_3 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_NFB4EOF_EN_5 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_NFB4EOF_EN_8 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_9 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_10 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_11 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_12 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_13 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_14 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_15 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_NFB4EOF_EN_17 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_18 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_19 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_20 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_21 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_22 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_23 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_24 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_25 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_26 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_27 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_28 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_29 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_NFB4EOF_EN_31 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_int_ctrl_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_5 register
 */
#define HW_IPU_INT_CTRL_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x4c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_5(x)           (*(volatile hw_ipu_int_ctrl_5_t *) HW_IPU_INT_CTRL_5_ADDR(x))
#define HW_IPU_INT_CTRL_5_RD(x)        (HW_IPU_INT_CTRL_5(x).U)
#define HW_IPU_INT_CTRL_5_WR(x, v)     (HW_IPU_INT_CTRL_5(x).U = (v))
#define HW_IPU_INT_CTRL_5_SET(x, v)    (HW_IPU_INT_CTRL_5_WR(x, HW_IPU_INT_CTRL_5_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_5_CLR(x, v)    (HW_IPU_INT_CTRL_5_WR(x, HW_IPU_INT_CTRL_5_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_5_TOG(x, v)    (HW_IPU_INT_CTRL_5_WR(x, HW_IPU_INT_CTRL_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_5 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_0 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_0      0
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_0)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_0(v)   (((v) << 0) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_0 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_0(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_0, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_1 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_1      1
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_1(v)   ((((reg32_t) v) << 1) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_1)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_1(v)   (((v) << 1) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_1 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_1(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_1, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_2 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_2      2
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_2(v)   ((((reg32_t) v) << 2) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_2)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_2(v)   (((v) << 2) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_2 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_2(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_2, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_3 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_3      3
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_3(v)   ((((reg32_t) v) << 3) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_3)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_3(v)   (((v) << 3) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_3 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_3(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_3, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_5 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_5      5
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_5(v)   ((((reg32_t) v) << 5) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_5)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_5(v)   (((v) << 5) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_5 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_5(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_5, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_8 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_8      8
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_8(v)   ((((reg32_t) v) << 8) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_8)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_8(v)   (((v) << 8) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_8 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_8(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_8, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_9 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_9      9
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_9(v)   ((((reg32_t) v) << 9) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_9)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_9(v)   (((v) << 9) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_9 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_9(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_9, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_10 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_10      10
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_10(v)   ((((reg32_t) v) << 10) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_10)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_10(v)   (((v) << 10) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_10 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_10(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_10, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_11 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_11      11
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_11(v)   ((((reg32_t) v) << 11) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_11)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_11(v)   (((v) << 11) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_11 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_11(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_11, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_12 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_12      12
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_12(v)   ((((reg32_t) v) << 12) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_12)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_12(v)   (((v) << 12) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_12 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_12(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_12, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_13 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_13      13
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_13(v)   ((((reg32_t) v) << 13) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_13)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_13(v)   (((v) << 13) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_13 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_13(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_13, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_14 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_14      14
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_14(v)   ((((reg32_t) v) << 14) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_14)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_14(v)   (((v) << 14) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_14 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_14(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_14, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_15 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_15      15
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_15(v)   ((((reg32_t) v) << 15) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_15)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_15(v)   (((v) << 15) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_15 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_15(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_15, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_17 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_17      17
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_17      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_17(v)   ((((reg32_t) v) << 17) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_17)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_17(v)   (((v) << 17) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_17 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_17(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_17, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_18 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_18      18
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_18      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_18(v)   ((((reg32_t) v) << 18) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_18)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_18(v)   (((v) << 18) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_18 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_18(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_18, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_19 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_19      19
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_19      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_19(v)   ((((reg32_t) v) << 19) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_19)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_19(v)   (((v) << 19) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_19 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_19(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_19, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_20 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_20      20
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_20(v)   ((((reg32_t) v) << 20) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_20)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_20(v)   (((v) << 20) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_20 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_20(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_20, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_21 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_21      21
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_21(v)   ((((reg32_t) v) << 21) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_21)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_21(v)   (((v) << 21) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_21 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_21(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_21, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_22 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_22      22
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_22(v)   ((((reg32_t) v) << 22) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_22)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_22(v)   (((v) << 22) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_22 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_22(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_22, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_23 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_23      23
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_23(v)   ((((reg32_t) v) << 23) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_23)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_23(v)   (((v) << 23) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_23 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_23(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_23, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_24 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_24      24
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_24(v)   ((((reg32_t) v) << 24) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_24)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_24(v)   (((v) << 24) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_24 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_24(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_24, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_25 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_25      25
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_25)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_25(v)   (((v) << 25) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_25 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_25(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_25, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_26 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_26      26
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_26)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_26(v)   (((v) << 26) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_26 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_26(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_26, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_27 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_27      27
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_27(v)   ((((reg32_t) v) << 27) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_27)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_27(v)   (((v) << 27) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_27 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_27(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_27, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_28 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_28      28
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_28(v)   ((((reg32_t) v) << 28) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_28)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_28(v)   (((v) << 28) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_28 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_28(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_28, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_29 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_29      29
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_29(v)   ((((reg32_t) v) << 29) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_29)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_29(v)   (((v) << 29) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_29 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_29(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_29, v)
#endif


/* --- Register HW_IPU_INT_CTRL_5, field IDMAC_NFB4EOF_EN_31 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_31      31
#define BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_31(v)   ((((reg32_t) v) << 31) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_31)
#else
#define BF_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_31(v)   (((v) << 31) & BM_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_31 field to a new value.
#define BW_IPU_INT_CTRL_5_IDMAC_NFB4EOF_EN_31(v)   BF_CS1(IPU_INT_CTRL_5, IDMAC_NFB4EOF_EN_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_6 - Interrupt Control Register 6 (RW)
 *
 * This register contains part of IPU interrupts controls. The controls of the New-frame before end-
 * of-frame indication (NFB4EOF_ERR) of DMA Channels interrupts [63:32] can be found in this
 * register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_NFB4EOF_EN_33 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_NFB4EOF_EN_40 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_41 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_42 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_43 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_44 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_45 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_46 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_47 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_48 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_49 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_50 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_51 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_EN_52 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_int_ctrl_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_6 register
 */
#define HW_IPU_INT_CTRL_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x50)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_6(x)           (*(volatile hw_ipu_int_ctrl_6_t *) HW_IPU_INT_CTRL_6_ADDR(x))
#define HW_IPU_INT_CTRL_6_RD(x)        (HW_IPU_INT_CTRL_6(x).U)
#define HW_IPU_INT_CTRL_6_WR(x, v)     (HW_IPU_INT_CTRL_6(x).U = (v))
#define HW_IPU_INT_CTRL_6_SET(x, v)    (HW_IPU_INT_CTRL_6_WR(x, HW_IPU_INT_CTRL_6_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_6_CLR(x, v)    (HW_IPU_INT_CTRL_6_WR(x, HW_IPU_INT_CTRL_6_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_6_TOG(x, v)    (HW_IPU_INT_CTRL_6_WR(x, HW_IPU_INT_CTRL_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_6 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_33 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_33      1
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_33(v)   ((((reg32_t) v) << 1) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_33)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_33(v)   (((v) << 1) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_33 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_33(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_33, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_40 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_40      8
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_40      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_40(v)   ((((reg32_t) v) << 8) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_40)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_40(v)   (((v) << 8) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_40)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_40 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_40(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_40, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_41 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_41      9
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_41(v)   ((((reg32_t) v) << 9) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_41)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_41(v)   (((v) << 9) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_41 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_41(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_41, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_42 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_42      10
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_42(v)   ((((reg32_t) v) << 10) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_42)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_42(v)   (((v) << 10) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_42 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_42(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_42, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_43 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_43      11
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_43(v)   ((((reg32_t) v) << 11) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_43)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_43(v)   (((v) << 11) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_43 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_43(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_43, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_44 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_44      12
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_44(v)   ((((reg32_t) v) << 12) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_44)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_44(v)   (((v) << 12) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_44 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_44(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_44, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_45 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_45      13
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_45(v)   ((((reg32_t) v) << 13) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_45)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_45(v)   (((v) << 13) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_45 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_45(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_45, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_46 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_46      14
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_46(v)   ((((reg32_t) v) << 14) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_46)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_46(v)   (((v) << 14) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_46 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_46(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_46, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_47 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_47      15
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_47(v)   ((((reg32_t) v) << 15) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_47)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_47(v)   (((v) << 15) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_47 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_47(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_47, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_48 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_48      16
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_48(v)   ((((reg32_t) v) << 16) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_48)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_48(v)   (((v) << 16) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_48 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_48(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_48, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_49 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_49      17
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_49(v)   ((((reg32_t) v) << 17) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_49)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_49(v)   (((v) << 17) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_49 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_49(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_49, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_50 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_50      18
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_50(v)   ((((reg32_t) v) << 18) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_50)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_50(v)   (((v) << 18) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_50 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_50(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_50, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_51 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_51      19
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_51(v)   ((((reg32_t) v) << 19) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_51)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_51(v)   (((v) << 19) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_51 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_51(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_51, v)
#endif


/* --- Register HW_IPU_INT_CTRL_6, field IDMAC_NFB4EOF_EN_52 (RW)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the control of
 * New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_52      20
#define BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_52(v)   ((((reg32_t) v) << 20) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_52)
#else
#define BF_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_52(v)   (((v) << 20) & BM_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFB4EOF_EN_52 field to a new value.
#define BW_IPU_INT_CTRL_6_IDMAC_NFB4EOF_EN_52(v)   BF_CS1(IPU_INT_CTRL_6, IDMAC_NFB4EOF_EN_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_7 - Interrupt Control Register 7 (RW)
 *
 * This register contains part of IPUIPU interrupts controls. The controls of the End-of-Scroll
 * indication (EOS) of DMA Channels interrupts [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 19; //!< Reserved.
        unsigned IDMAC_EOS_EN_19 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 3; //!< Reserved.
        unsigned IDMAC_EOS_EN_23 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_24 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_25 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_26 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_27 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_28 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_29 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_EOS_EN_31 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_int_ctrl_7_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_7 register
 */
#define HW_IPU_INT_CTRL_7_ADDR(x)      (REGS_IPU_BASE(x) + 0x54)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_7(x)           (*(volatile hw_ipu_int_ctrl_7_t *) HW_IPU_INT_CTRL_7_ADDR(x))
#define HW_IPU_INT_CTRL_7_RD(x)        (HW_IPU_INT_CTRL_7(x).U)
#define HW_IPU_INT_CTRL_7_WR(x, v)     (HW_IPU_INT_CTRL_7(x).U = (v))
#define HW_IPU_INT_CTRL_7_SET(x, v)    (HW_IPU_INT_CTRL_7_WR(x, HW_IPU_INT_CTRL_7_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_7_CLR(x, v)    (HW_IPU_INT_CTRL_7_WR(x, HW_IPU_INT_CTRL_7_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_7_TOG(x, v)    (HW_IPU_INT_CTRL_7_WR(x, HW_IPU_INT_CTRL_7_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_7 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_7, field IDMAC_EOS_EN_19 (RW)
 *
 * End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_7_IDMAC_EOS_EN_19      19
#define BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_19      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_19(v)   ((((reg32_t) v) << 19) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_19)
#else
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_19(v)   (((v) << 19) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_19 field to a new value.
#define BW_IPU_INT_CTRL_7_IDMAC_EOS_EN_19(v)   BF_CS1(IPU_INT_CTRL_7, IDMAC_EOS_EN_19, v)
#endif


/* --- Register HW_IPU_INT_CTRL_7, field IDMAC_EOS_EN_23 (RW)
 *
 * End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_7_IDMAC_EOS_EN_23      23
#define BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_23(v)   ((((reg32_t) v) << 23) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_23)
#else
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_23(v)   (((v) << 23) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_23 field to a new value.
#define BW_IPU_INT_CTRL_7_IDMAC_EOS_EN_23(v)   BF_CS1(IPU_INT_CTRL_7, IDMAC_EOS_EN_23, v)
#endif


/* --- Register HW_IPU_INT_CTRL_7, field IDMAC_EOS_EN_24 (RW)
 *
 * End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_7_IDMAC_EOS_EN_24      24
#define BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_24(v)   ((((reg32_t) v) << 24) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_24)
#else
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_24(v)   (((v) << 24) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_24 field to a new value.
#define BW_IPU_INT_CTRL_7_IDMAC_EOS_EN_24(v)   BF_CS1(IPU_INT_CTRL_7, IDMAC_EOS_EN_24, v)
#endif


/* --- Register HW_IPU_INT_CTRL_7, field IDMAC_EOS_EN_25 (RW)
 *
 * End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_7_IDMAC_EOS_EN_25      25
#define BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_25)
#else
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_25(v)   (((v) << 25) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_25 field to a new value.
#define BW_IPU_INT_CTRL_7_IDMAC_EOS_EN_25(v)   BF_CS1(IPU_INT_CTRL_7, IDMAC_EOS_EN_25, v)
#endif


/* --- Register HW_IPU_INT_CTRL_7, field IDMAC_EOS_EN_26 (RW)
 *
 * End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_7_IDMAC_EOS_EN_26      26
#define BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_26)
#else
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_26(v)   (((v) << 26) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_26 field to a new value.
#define BW_IPU_INT_CTRL_7_IDMAC_EOS_EN_26(v)   BF_CS1(IPU_INT_CTRL_7, IDMAC_EOS_EN_26, v)
#endif


/* --- Register HW_IPU_INT_CTRL_7, field IDMAC_EOS_EN_27 (RW)
 *
 * End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_7_IDMAC_EOS_EN_27      27
#define BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_27(v)   ((((reg32_t) v) << 27) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_27)
#else
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_27(v)   (((v) << 27) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_27 field to a new value.
#define BW_IPU_INT_CTRL_7_IDMAC_EOS_EN_27(v)   BF_CS1(IPU_INT_CTRL_7, IDMAC_EOS_EN_27, v)
#endif


/* --- Register HW_IPU_INT_CTRL_7, field IDMAC_EOS_EN_28 (RW)
 *
 * End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_7_IDMAC_EOS_EN_28      28
#define BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_28(v)   ((((reg32_t) v) << 28) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_28)
#else
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_28(v)   (((v) << 28) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_28 field to a new value.
#define BW_IPU_INT_CTRL_7_IDMAC_EOS_EN_28(v)   BF_CS1(IPU_INT_CTRL_7, IDMAC_EOS_EN_28, v)
#endif


/* --- Register HW_IPU_INT_CTRL_7, field IDMAC_EOS_EN_29 (RW)
 *
 * End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_7_IDMAC_EOS_EN_29      29
#define BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_29(v)   ((((reg32_t) v) << 29) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_29)
#else
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_29(v)   (((v) << 29) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_29 field to a new value.
#define BW_IPU_INT_CTRL_7_IDMAC_EOS_EN_29(v)   BF_CS1(IPU_INT_CTRL_7, IDMAC_EOS_EN_29, v)
#endif


/* --- Register HW_IPU_INT_CTRL_7, field IDMAC_EOS_EN_31 (RW)
 *
 * End of Scroll indication of Channel interrupt. This bit is the control of End of Scroll interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_7_IDMAC_EOS_EN_31      31
#define BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_31(v)   ((((reg32_t) v) << 31) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_31)
#else
#define BF_IPU_INT_CTRL_7_IDMAC_EOS_EN_31(v)   (((v) << 31) & BM_IPU_INT_CTRL_7_IDMAC_EOS_EN_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_31 field to a new value.
#define BW_IPU_INT_CTRL_7_IDMAC_EOS_EN_31(v)   BF_CS1(IPU_INT_CTRL_7, IDMAC_EOS_EN_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_8 - Interrupt Control Register 8 (RW)
 *
 * This register contains part of IPU interrupts controls. The controls of the End of Scroll
 * indication (EOS) of DMA Channels interrupts [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_EOS_EN_33 : 1; //!< End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 7; //!< Reserved.
        unsigned IDMAC_EOS_EN_41 : 1; //!< End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_42 : 1; //!< End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_43 : 1; //!< End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_44 : 1; //!< End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 6; //!< Reserved.
        unsigned IDMAC_EOS_EN_51 : 1; //!< End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_52 : 1; //!< End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 11; //!< Reserved.
    } B;
} hw_ipu_int_ctrl_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_8 register
 */
#define HW_IPU_INT_CTRL_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x58)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_8(x)           (*(volatile hw_ipu_int_ctrl_8_t *) HW_IPU_INT_CTRL_8_ADDR(x))
#define HW_IPU_INT_CTRL_8_RD(x)        (HW_IPU_INT_CTRL_8(x).U)
#define HW_IPU_INT_CTRL_8_WR(x, v)     (HW_IPU_INT_CTRL_8(x).U = (v))
#define HW_IPU_INT_CTRL_8_SET(x, v)    (HW_IPU_INT_CTRL_8_WR(x, HW_IPU_INT_CTRL_8_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_8_CLR(x, v)    (HW_IPU_INT_CTRL_8_WR(x, HW_IPU_INT_CTRL_8_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_8_TOG(x, v)    (HW_IPU_INT_CTRL_8_WR(x, HW_IPU_INT_CTRL_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_8 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_8, field IDMAC_EOS_EN_33 (RW)
 *
 * End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_8_IDMAC_EOS_EN_33      1
#define BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_33(v)   ((((reg32_t) v) << 1) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_33)
#else
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_33(v)   (((v) << 1) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_33 field to a new value.
#define BW_IPU_INT_CTRL_8_IDMAC_EOS_EN_33(v)   BF_CS1(IPU_INT_CTRL_8, IDMAC_EOS_EN_33, v)
#endif


/* --- Register HW_IPU_INT_CTRL_8, field IDMAC_EOS_EN_41 (RW)
 *
 * End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_8_IDMAC_EOS_EN_41      9
#define BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_41(v)   ((((reg32_t) v) << 9) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_41)
#else
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_41(v)   (((v) << 9) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_41 field to a new value.
#define BW_IPU_INT_CTRL_8_IDMAC_EOS_EN_41(v)   BF_CS1(IPU_INT_CTRL_8, IDMAC_EOS_EN_41, v)
#endif


/* --- Register HW_IPU_INT_CTRL_8, field IDMAC_EOS_EN_42 (RW)
 *
 * End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_8_IDMAC_EOS_EN_42      10
#define BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_42(v)   ((((reg32_t) v) << 10) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_42)
#else
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_42(v)   (((v) << 10) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_42 field to a new value.
#define BW_IPU_INT_CTRL_8_IDMAC_EOS_EN_42(v)   BF_CS1(IPU_INT_CTRL_8, IDMAC_EOS_EN_42, v)
#endif


/* --- Register HW_IPU_INT_CTRL_8, field IDMAC_EOS_EN_43 (RW)
 *
 * End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_8_IDMAC_EOS_EN_43      11
#define BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_43(v)   ((((reg32_t) v) << 11) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_43)
#else
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_43(v)   (((v) << 11) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_43 field to a new value.
#define BW_IPU_INT_CTRL_8_IDMAC_EOS_EN_43(v)   BF_CS1(IPU_INT_CTRL_8, IDMAC_EOS_EN_43, v)
#endif


/* --- Register HW_IPU_INT_CTRL_8, field IDMAC_EOS_EN_44 (RW)
 *
 * End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_8_IDMAC_EOS_EN_44      12
#define BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_44(v)   ((((reg32_t) v) << 12) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_44)
#else
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_44(v)   (((v) << 12) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_44 field to a new value.
#define BW_IPU_INT_CTRL_8_IDMAC_EOS_EN_44(v)   BF_CS1(IPU_INT_CTRL_8, IDMAC_EOS_EN_44, v)
#endif


/* --- Register HW_IPU_INT_CTRL_8, field IDMAC_EOS_EN_51 (RW)
 *
 * End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_8_IDMAC_EOS_EN_51      19
#define BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_51(v)   ((((reg32_t) v) << 19) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_51)
#else
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_51(v)   (((v) << 19) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_51 field to a new value.
#define BW_IPU_INT_CTRL_8_IDMAC_EOS_EN_51(v)   BF_CS1(IPU_INT_CTRL_8, IDMAC_EOS_EN_51, v)
#endif


/* --- Register HW_IPU_INT_CTRL_8, field IDMAC_EOS_EN_52 (RW)
 *
 * End of Scroll of Channel interrupt. This bit is the control of End Of Scroll interrupt of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_8_IDMAC_EOS_EN_52      20
#define BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_52(v)   ((((reg32_t) v) << 20) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_52)
#else
#define BF_IPU_INT_CTRL_8_IDMAC_EOS_EN_52(v)   (((v) << 20) & BM_IPU_INT_CTRL_8_IDMAC_EOS_EN_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_EN_52 field to a new value.
#define BW_IPU_INT_CTRL_8_IDMAC_EOS_EN_52(v)   BF_CS1(IPU_INT_CTRL_8, IDMAC_EOS_EN_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_9 - Interrupt Control Register 9 (RW)
 *
 * This register contains part of IPU interrupts controls. This register controls error interrupt
 * signals coming from different sub-blocks within
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned VDI_FIFO1_OVF_EN : 1; //!< FIFO1 overflow Interrupt1 Enable The VDI C generates FIFO1 overflow interrupt1 when the write pointer of FIFO1 overruns read pointer.
        unsigned RESERVED0 : 25; //!< Reserved
        unsigned IC_BAYER_BUF_OVF_EN : 1; //!< This bit enables an interrupt that is a result of the IC Buffer overflow for bayer coming from the IC. The user needs to write 1 to this bit in order to clear it.
        unsigned IC_ENC_BUF_OVF_EN : 1; //!< This bit enables an interrupt that is a result of the IC Buffer overflow for encoding coming from the IC. The user needs to write 1 to this bit in order to clear it.
        unsigned IC_VF_BUF_OVF_EN : 1; //!< This bit enables an interrupt that is a result of the IC Buffer overflow for view finder coming from the IC. The user needs to write 1 to this bit in order to clear it.
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned CSI0_PUPE_EN : 1; //!< CSI0_PUPE_EN - CSI0 parameters update error interrupt enable. This bit enables an interrupt that is a result of an error generated by the CSI0. The error is generated in case where new frame arrived from the CSI0 before the completion of the CSI0's parameters update by the SRM
        unsigned CSI1_PUPE_EN : 1; //!< CSI1_PUPE_EN - CSI1 parameters update error interrupt enable. This bit enables an interrupt that is a result of an error generated by the CSI1. The error is generated in case where new frame arrived from the CSI1 before the completion of the CSI1's parameters update by the SRM
    } B;
} hw_ipu_int_ctrl_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_9 register
 */
#define HW_IPU_INT_CTRL_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x5c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_9(x)           (*(volatile hw_ipu_int_ctrl_9_t *) HW_IPU_INT_CTRL_9_ADDR(x))
#define HW_IPU_INT_CTRL_9_RD(x)        (HW_IPU_INT_CTRL_9(x).U)
#define HW_IPU_INT_CTRL_9_WR(x, v)     (HW_IPU_INT_CTRL_9(x).U = (v))
#define HW_IPU_INT_CTRL_9_SET(x, v)    (HW_IPU_INT_CTRL_9_WR(x, HW_IPU_INT_CTRL_9_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_9_CLR(x, v)    (HW_IPU_INT_CTRL_9_WR(x, HW_IPU_INT_CTRL_9_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_9_TOG(x, v)    (HW_IPU_INT_CTRL_9_WR(x, HW_IPU_INT_CTRL_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_9 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_9, field VDI_FIFO1_OVF_EN (RW)
 *
 * FIFO1 overflow Interrupt1 Enable The VDI C generates FIFO1 overflow interrupt1 when the write
 * pointer of FIFO1 overruns read pointer.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_9_VDI_FIFO1_OVF_EN      0
#define BM_IPU_INT_CTRL_9_VDI_FIFO1_OVF_EN      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_9_VDI_FIFO1_OVF_EN(v)   ((((reg32_t) v) << 0) & BM_IPU_INT_CTRL_9_VDI_FIFO1_OVF_EN)
#else
#define BF_IPU_INT_CTRL_9_VDI_FIFO1_OVF_EN(v)   (((v) << 0) & BM_IPU_INT_CTRL_9_VDI_FIFO1_OVF_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_FIFO1_OVF_EN field to a new value.
#define BW_IPU_INT_CTRL_9_VDI_FIFO1_OVF_EN(v)   BF_CS1(IPU_INT_CTRL_9, VDI_FIFO1_OVF_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_9, field IC_BAYER_BUF_OVF_EN (RW)
 *
 * This bit enables an interrupt that is a result of the IC Buffer overflow for bayer coming from
 * the IC. The user needs to write 1 to this bit in order to clear it.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_9_IC_BAYER_BUF_OVF_EN      26
#define BM_IPU_INT_CTRL_9_IC_BAYER_BUF_OVF_EN      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_9_IC_BAYER_BUF_OVF_EN(v)   ((((reg32_t) v) << 26) & BM_IPU_INT_CTRL_9_IC_BAYER_BUF_OVF_EN)
#else
#define BF_IPU_INT_CTRL_9_IC_BAYER_BUF_OVF_EN(v)   (((v) << 26) & BM_IPU_INT_CTRL_9_IC_BAYER_BUF_OVF_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_BAYER_BUF_OVF_EN field to a new value.
#define BW_IPU_INT_CTRL_9_IC_BAYER_BUF_OVF_EN(v)   BF_CS1(IPU_INT_CTRL_9, IC_BAYER_BUF_OVF_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_9, field IC_ENC_BUF_OVF_EN (RW)
 *
 * This bit enables an interrupt that is a result of the IC Buffer overflow for encoding coming from
 * the IC. The user needs to write 1 to this bit in order to clear it.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_9_IC_ENC_BUF_OVF_EN      27
#define BM_IPU_INT_CTRL_9_IC_ENC_BUF_OVF_EN      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_9_IC_ENC_BUF_OVF_EN(v)   ((((reg32_t) v) << 27) & BM_IPU_INT_CTRL_9_IC_ENC_BUF_OVF_EN)
#else
#define BF_IPU_INT_CTRL_9_IC_ENC_BUF_OVF_EN(v)   (((v) << 27) & BM_IPU_INT_CTRL_9_IC_ENC_BUF_OVF_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_ENC_BUF_OVF_EN field to a new value.
#define BW_IPU_INT_CTRL_9_IC_ENC_BUF_OVF_EN(v)   BF_CS1(IPU_INT_CTRL_9, IC_ENC_BUF_OVF_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_9, field IC_VF_BUF_OVF_EN (RW)
 *
 * This bit enables an interrupt that is a result of the IC Buffer overflow for view finder coming
 * from the IC. The user needs to write 1 to this bit in order to clear it.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_9_IC_VF_BUF_OVF_EN      28
#define BM_IPU_INT_CTRL_9_IC_VF_BUF_OVF_EN      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_9_IC_VF_BUF_OVF_EN(v)   ((((reg32_t) v) << 28) & BM_IPU_INT_CTRL_9_IC_VF_BUF_OVF_EN)
#else
#define BF_IPU_INT_CTRL_9_IC_VF_BUF_OVF_EN(v)   (((v) << 28) & BM_IPU_INT_CTRL_9_IC_VF_BUF_OVF_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_VF_BUF_OVF_EN field to a new value.
#define BW_IPU_INT_CTRL_9_IC_VF_BUF_OVF_EN(v)   BF_CS1(IPU_INT_CTRL_9, IC_VF_BUF_OVF_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_9, field CSI0_PUPE_EN (RW)
 *
 * CSI0_PUPE_EN - CSI0 parameters update error interrupt enable. This bit enables an interrupt that
 * is a result of an error generated by the CSI0. The error is generated in case where new frame
 * arrived from the CSI0 before the completion of the CSI0's parameters update by the SRM
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_9_CSI0_PUPE_EN      30
#define BM_IPU_INT_CTRL_9_CSI0_PUPE_EN      0x40000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_9_CSI0_PUPE_EN(v)   ((((reg32_t) v) << 30) & BM_IPU_INT_CTRL_9_CSI0_PUPE_EN)
#else
#define BF_IPU_INT_CTRL_9_CSI0_PUPE_EN(v)   (((v) << 30) & BM_IPU_INT_CTRL_9_CSI0_PUPE_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_PUPE_EN field to a new value.
#define BW_IPU_INT_CTRL_9_CSI0_PUPE_EN(v)   BF_CS1(IPU_INT_CTRL_9, CSI0_PUPE_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_9, field CSI1_PUPE_EN (RW)
 *
 * CSI1_PUPE_EN - CSI1 parameters update error interrupt enable. This bit enables an interrupt that
 * is a result of an error generated by the CSI1. The error is generated in case where new frame
 * arrived from the CSI1 before the completion of the CSI1's parameters update by the SRM
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_9_CSI1_PUPE_EN      31
#define BM_IPU_INT_CTRL_9_CSI1_PUPE_EN      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_9_CSI1_PUPE_EN(v)   ((((reg32_t) v) << 31) & BM_IPU_INT_CTRL_9_CSI1_PUPE_EN)
#else
#define BF_IPU_INT_CTRL_9_CSI1_PUPE_EN(v)   (((v) << 31) & BM_IPU_INT_CTRL_9_CSI1_PUPE_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_PUPE_EN field to a new value.
#define BW_IPU_INT_CTRL_9_CSI1_PUPE_EN(v)   BF_CS1(IPU_INT_CTRL_9, CSI1_PUPE_EN, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_10 - Interrupt Control Register 10 (RW)
 *
 * This register contains part of IPU interrupts controls. This register controls error interrupt
 * signals coming from different modules within
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SMFC0_FRM_LOST_EN : 1; //!< Frame Lost of SMFC channel 0 interrupt enable bit This bit enables an interrupt that is a result of a Frame Lost of SMFC channel 0.
        unsigned SMFC1_FRM_LOST_EN : 1; //!< Frame Lost of SMFC channel 1 interrupt enable bit This bit enables an interrupt that is a result of a Frame Lost of SMFC channel 1.
        unsigned SMFC2_FRM_LOST_EN : 1; //!< Frame Lost of SMFC channel 2 interrupt enable bit This bit enables an interrupt that is a result of a Frame Lost of SMFC channel 2.
        unsigned SMFC3_FRM_LOST_EN : 1; //!< Frame Lost of SMFC channel 3 interrupt enable bit This bit enables an interrupt that is a result of a Frame Lost of SMFC channel 3.
        unsigned RESERVED0 : 12; //!< Reserved
        unsigned DC_TEARING_ERR_1_EN : 1; //!< Tearing Error #1 enable This bit enables the interrupt that is a result of tearing error while the anti tearing mechanism is activated for DC channel 1
        unsigned DC_TEARING_ERR_2_EN : 1; //!< Tearing Error #2 enable This bit enables the interrupt that is a result of tearing error while the anti tearing mechanism is activated for DC channel 2
        unsigned DC_TEARING_ERR_6_EN : 1; //!< Tearing Error #6 enable This bit enables the interrupt that is a result of tearing error while the anti tearing mechanism is activated for DC channel 6
        unsigned DI0_SYNC_DISP_ERR_EN : 1; //!< DI0 Synchronous display error enable This bit enables the interrupt that is a result of an error during access to a synchronous display via DI0
        unsigned DI1_SYNC_DISP_ERR_EN : 1; //!< DI1 Synchronous display error enable This bit enables the interrupt that is a result of an error during access to a synchronous display via DI1
        unsigned DI0_TIME_OUT_ERR_EN : 1; //!< DI0 time outwore interrupt enable This bit enables the interrupt that is a result of a time out error during a read access via DI0
        unsigned DI1_TIME_OUT_ERR_EN : 1; //!< DI1 time out error interrupt enable This bit enables the interrupt that is a result of a time out error during a read access via DI1
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned IC_VF_FRM_LOST_ERR_EN : 1; //!< This bit enables an interrupt that is a result of IC's view finder frame lost.
        unsigned IC_ENC_FRM_LOST_ERR_EN : 1; //!< This bit enables an interrupt that is a result of IC's encoding frame lost.
        unsigned IC_BAYER_FRM_LOST_ERR_EN : 1; //!< This bit enables an interrupt that is a result of IC's Bayer frame lost.
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned NON_PRIVILEGED_ACC_ERR_EN : 1; //!< Non Privileged Access Error interrupt enable. The CPMEM and the DP can be accessed by the ARM platform in privileged mode only HPROT[1] =1. An attempt to access these regions in user mode will issue an interrupt. This bit enables the interrupt.
        unsigned AXIW_ERR_EN : 1; //!< This bit enables an interrupt that is a result of AXI write access resulted with error response.
        unsigned AXIR_ERR_EN : 1; //!< This bit enables an interrupt that is a result of AXI read access resulted with error response.
        unsigned RESERVED3 : 1; //!< Reserved
    } B;
} hw_ipu_int_ctrl_10_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_10 register
 */
#define HW_IPU_INT_CTRL_10_ADDR(x)      (REGS_IPU_BASE(x) + 0x60)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_10(x)           (*(volatile hw_ipu_int_ctrl_10_t *) HW_IPU_INT_CTRL_10_ADDR(x))
#define HW_IPU_INT_CTRL_10_RD(x)        (HW_IPU_INT_CTRL_10(x).U)
#define HW_IPU_INT_CTRL_10_WR(x, v)     (HW_IPU_INT_CTRL_10(x).U = (v))
#define HW_IPU_INT_CTRL_10_SET(x, v)    (HW_IPU_INT_CTRL_10_WR(x, HW_IPU_INT_CTRL_10_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_10_CLR(x, v)    (HW_IPU_INT_CTRL_10_WR(x, HW_IPU_INT_CTRL_10_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_10_TOG(x, v)    (HW_IPU_INT_CTRL_10_WR(x, HW_IPU_INT_CTRL_10_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_10 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_10, field SMFC0_FRM_LOST_EN (RW)
 *
 * Frame Lost of SMFC channel 0 interrupt enable bit This bit enables an interrupt that is a result
 * of a Frame Lost of SMFC channel 0.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_SMFC0_FRM_LOST_EN      0
#define BM_IPU_INT_CTRL_10_SMFC0_FRM_LOST_EN      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_SMFC0_FRM_LOST_EN(v)   ((((reg32_t) v) << 0) & BM_IPU_INT_CTRL_10_SMFC0_FRM_LOST_EN)
#else
#define BF_IPU_INT_CTRL_10_SMFC0_FRM_LOST_EN(v)   (((v) << 0) & BM_IPU_INT_CTRL_10_SMFC0_FRM_LOST_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SMFC0_FRM_LOST_EN field to a new value.
#define BW_IPU_INT_CTRL_10_SMFC0_FRM_LOST_EN(v)   BF_CS1(IPU_INT_CTRL_10, SMFC0_FRM_LOST_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field SMFC1_FRM_LOST_EN (RW)
 *
 * Frame Lost of SMFC channel 1 interrupt enable bit This bit enables an interrupt that is a result
 * of a Frame Lost of SMFC channel 1.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_SMFC1_FRM_LOST_EN      1
#define BM_IPU_INT_CTRL_10_SMFC1_FRM_LOST_EN      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_SMFC1_FRM_LOST_EN(v)   ((((reg32_t) v) << 1) & BM_IPU_INT_CTRL_10_SMFC1_FRM_LOST_EN)
#else
#define BF_IPU_INT_CTRL_10_SMFC1_FRM_LOST_EN(v)   (((v) << 1) & BM_IPU_INT_CTRL_10_SMFC1_FRM_LOST_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SMFC1_FRM_LOST_EN field to a new value.
#define BW_IPU_INT_CTRL_10_SMFC1_FRM_LOST_EN(v)   BF_CS1(IPU_INT_CTRL_10, SMFC1_FRM_LOST_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field SMFC2_FRM_LOST_EN (RW)
 *
 * Frame Lost of SMFC channel 2 interrupt enable bit This bit enables an interrupt that is a result
 * of a Frame Lost of SMFC channel 2.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_SMFC2_FRM_LOST_EN      2
#define BM_IPU_INT_CTRL_10_SMFC2_FRM_LOST_EN      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_SMFC2_FRM_LOST_EN(v)   ((((reg32_t) v) << 2) & BM_IPU_INT_CTRL_10_SMFC2_FRM_LOST_EN)
#else
#define BF_IPU_INT_CTRL_10_SMFC2_FRM_LOST_EN(v)   (((v) << 2) & BM_IPU_INT_CTRL_10_SMFC2_FRM_LOST_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SMFC2_FRM_LOST_EN field to a new value.
#define BW_IPU_INT_CTRL_10_SMFC2_FRM_LOST_EN(v)   BF_CS1(IPU_INT_CTRL_10, SMFC2_FRM_LOST_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field SMFC3_FRM_LOST_EN (RW)
 *
 * Frame Lost of SMFC channel 3 interrupt enable bit This bit enables an interrupt that is a result
 * of a Frame Lost of SMFC channel 3.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_SMFC3_FRM_LOST_EN      3
#define BM_IPU_INT_CTRL_10_SMFC3_FRM_LOST_EN      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_SMFC3_FRM_LOST_EN(v)   ((((reg32_t) v) << 3) & BM_IPU_INT_CTRL_10_SMFC3_FRM_LOST_EN)
#else
#define BF_IPU_INT_CTRL_10_SMFC3_FRM_LOST_EN(v)   (((v) << 3) & BM_IPU_INT_CTRL_10_SMFC3_FRM_LOST_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SMFC3_FRM_LOST_EN field to a new value.
#define BW_IPU_INT_CTRL_10_SMFC3_FRM_LOST_EN(v)   BF_CS1(IPU_INT_CTRL_10, SMFC3_FRM_LOST_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field DC_TEARING_ERR_1_EN (RW)
 *
 * Tearing Error #1 enable This bit enables the interrupt that is a result of tearing error while
 * the anti tearing mechanism is activated for DC channel 1
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_DC_TEARING_ERR_1_EN      16
#define BM_IPU_INT_CTRL_10_DC_TEARING_ERR_1_EN      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_DC_TEARING_ERR_1_EN(v)   ((((reg32_t) v) << 16) & BM_IPU_INT_CTRL_10_DC_TEARING_ERR_1_EN)
#else
#define BF_IPU_INT_CTRL_10_DC_TEARING_ERR_1_EN(v)   (((v) << 16) & BM_IPU_INT_CTRL_10_DC_TEARING_ERR_1_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_TEARING_ERR_1_EN field to a new value.
#define BW_IPU_INT_CTRL_10_DC_TEARING_ERR_1_EN(v)   BF_CS1(IPU_INT_CTRL_10, DC_TEARING_ERR_1_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field DC_TEARING_ERR_2_EN (RW)
 *
 * Tearing Error #2 enable This bit enables the interrupt that is a result of tearing error while
 * the anti tearing mechanism is activated for DC channel 2
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_DC_TEARING_ERR_2_EN      17
#define BM_IPU_INT_CTRL_10_DC_TEARING_ERR_2_EN      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_DC_TEARING_ERR_2_EN(v)   ((((reg32_t) v) << 17) & BM_IPU_INT_CTRL_10_DC_TEARING_ERR_2_EN)
#else
#define BF_IPU_INT_CTRL_10_DC_TEARING_ERR_2_EN(v)   (((v) << 17) & BM_IPU_INT_CTRL_10_DC_TEARING_ERR_2_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_TEARING_ERR_2_EN field to a new value.
#define BW_IPU_INT_CTRL_10_DC_TEARING_ERR_2_EN(v)   BF_CS1(IPU_INT_CTRL_10, DC_TEARING_ERR_2_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field DC_TEARING_ERR_6_EN (RW)
 *
 * Tearing Error #6 enable This bit enables the interrupt that is a result of tearing error while
 * the anti tearing mechanism is activated for DC channel 6
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_DC_TEARING_ERR_6_EN      18
#define BM_IPU_INT_CTRL_10_DC_TEARING_ERR_6_EN      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_DC_TEARING_ERR_6_EN(v)   ((((reg32_t) v) << 18) & BM_IPU_INT_CTRL_10_DC_TEARING_ERR_6_EN)
#else
#define BF_IPU_INT_CTRL_10_DC_TEARING_ERR_6_EN(v)   (((v) << 18) & BM_IPU_INT_CTRL_10_DC_TEARING_ERR_6_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_TEARING_ERR_6_EN field to a new value.
#define BW_IPU_INT_CTRL_10_DC_TEARING_ERR_6_EN(v)   BF_CS1(IPU_INT_CTRL_10, DC_TEARING_ERR_6_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field DI0_SYNC_DISP_ERR_EN (RW)
 *
 * DI0 Synchronous display error enable This bit enables the interrupt that is a result of an error
 * during access to a synchronous display via DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_DI0_SYNC_DISP_ERR_EN      19
#define BM_IPU_INT_CTRL_10_DI0_SYNC_DISP_ERR_EN      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_DI0_SYNC_DISP_ERR_EN(v)   ((((reg32_t) v) << 19) & BM_IPU_INT_CTRL_10_DI0_SYNC_DISP_ERR_EN)
#else
#define BF_IPU_INT_CTRL_10_DI0_SYNC_DISP_ERR_EN(v)   (((v) << 19) & BM_IPU_INT_CTRL_10_DI0_SYNC_DISP_ERR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SYNC_DISP_ERR_EN field to a new value.
#define BW_IPU_INT_CTRL_10_DI0_SYNC_DISP_ERR_EN(v)   BF_CS1(IPU_INT_CTRL_10, DI0_SYNC_DISP_ERR_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field DI1_SYNC_DISP_ERR_EN (RW)
 *
 * DI1 Synchronous display error enable This bit enables the interrupt that is a result of an error
 * during access to a synchronous display via DI1
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_DI1_SYNC_DISP_ERR_EN      20
#define BM_IPU_INT_CTRL_10_DI1_SYNC_DISP_ERR_EN      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_DI1_SYNC_DISP_ERR_EN(v)   ((((reg32_t) v) << 20) & BM_IPU_INT_CTRL_10_DI1_SYNC_DISP_ERR_EN)
#else
#define BF_IPU_INT_CTRL_10_DI1_SYNC_DISP_ERR_EN(v)   (((v) << 20) & BM_IPU_INT_CTRL_10_DI1_SYNC_DISP_ERR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SYNC_DISP_ERR_EN field to a new value.
#define BW_IPU_INT_CTRL_10_DI1_SYNC_DISP_ERR_EN(v)   BF_CS1(IPU_INT_CTRL_10, DI1_SYNC_DISP_ERR_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field DI0_TIME_OUT_ERR_EN (RW)
 *
 * DI0 time outwore interrupt enable This bit enables the interrupt that is a result of a time out
 * error during a read access via DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_DI0_TIME_OUT_ERR_EN      21
#define BM_IPU_INT_CTRL_10_DI0_TIME_OUT_ERR_EN      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_DI0_TIME_OUT_ERR_EN(v)   ((((reg32_t) v) << 21) & BM_IPU_INT_CTRL_10_DI0_TIME_OUT_ERR_EN)
#else
#define BF_IPU_INT_CTRL_10_DI0_TIME_OUT_ERR_EN(v)   (((v) << 21) & BM_IPU_INT_CTRL_10_DI0_TIME_OUT_ERR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_TIME_OUT_ERR_EN field to a new value.
#define BW_IPU_INT_CTRL_10_DI0_TIME_OUT_ERR_EN(v)   BF_CS1(IPU_INT_CTRL_10, DI0_TIME_OUT_ERR_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field DI1_TIME_OUT_ERR_EN (RW)
 *
 * DI1 time out error interrupt enable This bit enables the interrupt that is a result of a time out
 * error during a read access via DI1
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_DI1_TIME_OUT_ERR_EN      22
#define BM_IPU_INT_CTRL_10_DI1_TIME_OUT_ERR_EN      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_DI1_TIME_OUT_ERR_EN(v)   ((((reg32_t) v) << 22) & BM_IPU_INT_CTRL_10_DI1_TIME_OUT_ERR_EN)
#else
#define BF_IPU_INT_CTRL_10_DI1_TIME_OUT_ERR_EN(v)   (((v) << 22) & BM_IPU_INT_CTRL_10_DI1_TIME_OUT_ERR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_TIME_OUT_ERR_EN field to a new value.
#define BW_IPU_INT_CTRL_10_DI1_TIME_OUT_ERR_EN(v)   BF_CS1(IPU_INT_CTRL_10, DI1_TIME_OUT_ERR_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field IC_VF_FRM_LOST_ERR_EN (RW)
 *
 * This bit enables an interrupt that is a result of IC's view finder frame lost.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_IC_VF_FRM_LOST_ERR_EN      24
#define BM_IPU_INT_CTRL_10_IC_VF_FRM_LOST_ERR_EN      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_IC_VF_FRM_LOST_ERR_EN(v)   ((((reg32_t) v) << 24) & BM_IPU_INT_CTRL_10_IC_VF_FRM_LOST_ERR_EN)
#else
#define BF_IPU_INT_CTRL_10_IC_VF_FRM_LOST_ERR_EN(v)   (((v) << 24) & BM_IPU_INT_CTRL_10_IC_VF_FRM_LOST_ERR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_VF_FRM_LOST_ERR_EN field to a new value.
#define BW_IPU_INT_CTRL_10_IC_VF_FRM_LOST_ERR_EN(v)   BF_CS1(IPU_INT_CTRL_10, IC_VF_FRM_LOST_ERR_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field IC_ENC_FRM_LOST_ERR_EN (RW)
 *
 * This bit enables an interrupt that is a result of IC's encoding frame lost.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_IC_ENC_FRM_LOST_ERR_EN      25
#define BM_IPU_INT_CTRL_10_IC_ENC_FRM_LOST_ERR_EN      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_IC_ENC_FRM_LOST_ERR_EN(v)   ((((reg32_t) v) << 25) & BM_IPU_INT_CTRL_10_IC_ENC_FRM_LOST_ERR_EN)
#else
#define BF_IPU_INT_CTRL_10_IC_ENC_FRM_LOST_ERR_EN(v)   (((v) << 25) & BM_IPU_INT_CTRL_10_IC_ENC_FRM_LOST_ERR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_ENC_FRM_LOST_ERR_EN field to a new value.
#define BW_IPU_INT_CTRL_10_IC_ENC_FRM_LOST_ERR_EN(v)   BF_CS1(IPU_INT_CTRL_10, IC_ENC_FRM_LOST_ERR_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field IC_BAYER_FRM_LOST_ERR_EN (RW)
 *
 * This bit enables an interrupt that is a result of IC's Bayer frame lost.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_IC_BAYER_FRM_LOST_ERR_EN      26
#define BM_IPU_INT_CTRL_10_IC_BAYER_FRM_LOST_ERR_EN      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_IC_BAYER_FRM_LOST_ERR_EN(v)   ((((reg32_t) v) << 26) & BM_IPU_INT_CTRL_10_IC_BAYER_FRM_LOST_ERR_EN)
#else
#define BF_IPU_INT_CTRL_10_IC_BAYER_FRM_LOST_ERR_EN(v)   (((v) << 26) & BM_IPU_INT_CTRL_10_IC_BAYER_FRM_LOST_ERR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_BAYER_FRM_LOST_ERR_EN field to a new value.
#define BW_IPU_INT_CTRL_10_IC_BAYER_FRM_LOST_ERR_EN(v)   BF_CS1(IPU_INT_CTRL_10, IC_BAYER_FRM_LOST_ERR_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field NON_PRIVILEGED_ACC_ERR_EN (RW)
 *
 * Non Privileged Access Error interrupt enable. The CPMEM and the DP can be accessed by the ARM
 * platform in privileged mode only HPROT[1] =1. An attempt to access these regions in user mode
 * will issue an interrupt. This bit enables the interrupt.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_NON_PRIVILEGED_ACC_ERR_EN      28
#define BM_IPU_INT_CTRL_10_NON_PRIVILEGED_ACC_ERR_EN      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_NON_PRIVILEGED_ACC_ERR_EN(v)   ((((reg32_t) v) << 28) & BM_IPU_INT_CTRL_10_NON_PRIVILEGED_ACC_ERR_EN)
#else
#define BF_IPU_INT_CTRL_10_NON_PRIVILEGED_ACC_ERR_EN(v)   (((v) << 28) & BM_IPU_INT_CTRL_10_NON_PRIVILEGED_ACC_ERR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the NON_PRIVILEGED_ACC_ERR_EN field to a new value.
#define BW_IPU_INT_CTRL_10_NON_PRIVILEGED_ACC_ERR_EN(v)   BF_CS1(IPU_INT_CTRL_10, NON_PRIVILEGED_ACC_ERR_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field AXIW_ERR_EN (RW)
 *
 * This bit enables an interrupt that is a result of AXI write access resulted with error response.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_AXIW_ERR_EN      29
#define BM_IPU_INT_CTRL_10_AXIW_ERR_EN      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_AXIW_ERR_EN(v)   ((((reg32_t) v) << 29) & BM_IPU_INT_CTRL_10_AXIW_ERR_EN)
#else
#define BF_IPU_INT_CTRL_10_AXIW_ERR_EN(v)   (((v) << 29) & BM_IPU_INT_CTRL_10_AXIW_ERR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the AXIW_ERR_EN field to a new value.
#define BW_IPU_INT_CTRL_10_AXIW_ERR_EN(v)   BF_CS1(IPU_INT_CTRL_10, AXIW_ERR_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_10, field AXIR_ERR_EN (RW)
 *
 * This bit enables an interrupt that is a result of AXI read access resulted with error response.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_10_AXIR_ERR_EN      30
#define BM_IPU_INT_CTRL_10_AXIR_ERR_EN      0x40000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_10_AXIR_ERR_EN(v)   ((((reg32_t) v) << 30) & BM_IPU_INT_CTRL_10_AXIR_ERR_EN)
#else
#define BF_IPU_INT_CTRL_10_AXIR_ERR_EN(v)   (((v) << 30) & BM_IPU_INT_CTRL_10_AXIR_ERR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the AXIR_ERR_EN field to a new value.
#define BW_IPU_INT_CTRL_10_AXIR_ERR_EN(v)   BF_CS1(IPU_INT_CTRL_10, AXIR_ERR_EN, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_11 - Interrupt Control Register 11 (RW)
 *
 * This register contains part of IPU interrupts controls. The controls of the end-of-band
 * indication (EOBND) of DMA Channels interrupts [31:0] can be found in this register.  Editor's
 * Note: The conditional tag settings should be   Hide VDOA_SYNC for all versions  Show VDOA_SYNC
 * for IPUv3H version.  The table below tagged with other settings (like IPU3M_only) should be
 * hidden in IPUv3H version.   This requires some sophisticated conditional tag settings
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_EOBND_EN_0 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_1 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_2 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_3 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_EOBND_EN_5 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 5; //!< Reserved.
        unsigned IDMAC_EOBND_EN_11 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_12 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 7; //!< Reserved.
        unsigned IDMAC_EOBND_EN_20 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_21 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_22 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 2; //!< Reserved.
        unsigned IDMAC_EOBND_EN_25 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_26 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED4 : 5; //!< Reserved.
    } B;
} hw_ipu_int_ctrl_11_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_11 register
 */
#define HW_IPU_INT_CTRL_11_ADDR(x)      (REGS_IPU_BASE(x) + 0x64)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_11(x)           (*(volatile hw_ipu_int_ctrl_11_t *) HW_IPU_INT_CTRL_11_ADDR(x))
#define HW_IPU_INT_CTRL_11_RD(x)        (HW_IPU_INT_CTRL_11(x).U)
#define HW_IPU_INT_CTRL_11_WR(x, v)     (HW_IPU_INT_CTRL_11(x).U = (v))
#define HW_IPU_INT_CTRL_11_SET(x, v)    (HW_IPU_INT_CTRL_11_WR(x, HW_IPU_INT_CTRL_11_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_11_CLR(x, v)    (HW_IPU_INT_CTRL_11_WR(x, HW_IPU_INT_CTRL_11_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_11_TOG(x, v)    (HW_IPU_INT_CTRL_11_WR(x, HW_IPU_INT_CTRL_11_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_11 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_11, field IDMAC_EOBND_EN_0 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_11_IDMAC_EOBND_EN_0      0
#define BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_0)
#else
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_0(v)   (((v) << 0) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_0 field to a new value.
#define BW_IPU_INT_CTRL_11_IDMAC_EOBND_EN_0(v)   BF_CS1(IPU_INT_CTRL_11, IDMAC_EOBND_EN_0, v)
#endif


/* --- Register HW_IPU_INT_CTRL_11, field IDMAC_EOBND_EN_1 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_11_IDMAC_EOBND_EN_1      1
#define BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_1(v)   ((((reg32_t) v) << 1) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_1)
#else
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_1(v)   (((v) << 1) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_1 field to a new value.
#define BW_IPU_INT_CTRL_11_IDMAC_EOBND_EN_1(v)   BF_CS1(IPU_INT_CTRL_11, IDMAC_EOBND_EN_1, v)
#endif


/* --- Register HW_IPU_INT_CTRL_11, field IDMAC_EOBND_EN_2 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_11_IDMAC_EOBND_EN_2      2
#define BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_2(v)   ((((reg32_t) v) << 2) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_2)
#else
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_2(v)   (((v) << 2) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_2 field to a new value.
#define BW_IPU_INT_CTRL_11_IDMAC_EOBND_EN_2(v)   BF_CS1(IPU_INT_CTRL_11, IDMAC_EOBND_EN_2, v)
#endif


/* --- Register HW_IPU_INT_CTRL_11, field IDMAC_EOBND_EN_3 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_11_IDMAC_EOBND_EN_3      3
#define BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_3(v)   ((((reg32_t) v) << 3) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_3)
#else
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_3(v)   (((v) << 3) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_3 field to a new value.
#define BW_IPU_INT_CTRL_11_IDMAC_EOBND_EN_3(v)   BF_CS1(IPU_INT_CTRL_11, IDMAC_EOBND_EN_3, v)
#endif


/* --- Register HW_IPU_INT_CTRL_11, field IDMAC_EOBND_EN_5 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_11_IDMAC_EOBND_EN_5      5
#define BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_5(v)   ((((reg32_t) v) << 5) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_5)
#else
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_5(v)   (((v) << 5) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_5 field to a new value.
#define BW_IPU_INT_CTRL_11_IDMAC_EOBND_EN_5(v)   BF_CS1(IPU_INT_CTRL_11, IDMAC_EOBND_EN_5, v)
#endif


/* --- Register HW_IPU_INT_CTRL_11, field IDMAC_EOBND_EN_11 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_11_IDMAC_EOBND_EN_11      11
#define BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_11(v)   ((((reg32_t) v) << 11) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_11)
#else
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_11(v)   (((v) << 11) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_11 field to a new value.
#define BW_IPU_INT_CTRL_11_IDMAC_EOBND_EN_11(v)   BF_CS1(IPU_INT_CTRL_11, IDMAC_EOBND_EN_11, v)
#endif


/* --- Register HW_IPU_INT_CTRL_11, field IDMAC_EOBND_EN_12 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_11_IDMAC_EOBND_EN_12      12
#define BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_12(v)   ((((reg32_t) v) << 12) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_12)
#else
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_12(v)   (((v) << 12) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_12 field to a new value.
#define BW_IPU_INT_CTRL_11_IDMAC_EOBND_EN_12(v)   BF_CS1(IPU_INT_CTRL_11, IDMAC_EOBND_EN_12, v)
#endif


/* --- Register HW_IPU_INT_CTRL_11, field IDMAC_EOBND_EN_20 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_11_IDMAC_EOBND_EN_20      20
#define BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_20(v)   ((((reg32_t) v) << 20) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_20)
#else
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_20(v)   (((v) << 20) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_20 field to a new value.
#define BW_IPU_INT_CTRL_11_IDMAC_EOBND_EN_20(v)   BF_CS1(IPU_INT_CTRL_11, IDMAC_EOBND_EN_20, v)
#endif


/* --- Register HW_IPU_INT_CTRL_11, field IDMAC_EOBND_EN_21 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_11_IDMAC_EOBND_EN_21      21
#define BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_21(v)   ((((reg32_t) v) << 21) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_21)
#else
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_21(v)   (((v) << 21) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_21 field to a new value.
#define BW_IPU_INT_CTRL_11_IDMAC_EOBND_EN_21(v)   BF_CS1(IPU_INT_CTRL_11, IDMAC_EOBND_EN_21, v)
#endif


/* --- Register HW_IPU_INT_CTRL_11, field IDMAC_EOBND_EN_22 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_11_IDMAC_EOBND_EN_22      22
#define BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_22(v)   ((((reg32_t) v) << 22) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_22)
#else
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_22(v)   (((v) << 22) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_22 field to a new value.
#define BW_IPU_INT_CTRL_11_IDMAC_EOBND_EN_22(v)   BF_CS1(IPU_INT_CTRL_11, IDMAC_EOBND_EN_22, v)
#endif


/* --- Register HW_IPU_INT_CTRL_11, field IDMAC_EOBND_EN_25 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_11_IDMAC_EOBND_EN_25      25
#define BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_25)
#else
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_25(v)   (((v) << 25) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_25 field to a new value.
#define BW_IPU_INT_CTRL_11_IDMAC_EOBND_EN_25(v)   BF_CS1(IPU_INT_CTRL_11, IDMAC_EOBND_EN_25, v)
#endif


/* --- Register HW_IPU_INT_CTRL_11, field IDMAC_EOBND_EN_26 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control of end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_11_IDMAC_EOBND_EN_26      26
#define BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_26)
#else
#define BF_IPU_INT_CTRL_11_IDMAC_EOBND_EN_26(v)   (((v) << 26) & BM_IPU_INT_CTRL_11_IDMAC_EOBND_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_26 field to a new value.
#define BW_IPU_INT_CTRL_11_IDMAC_EOBND_EN_26(v)   BF_CS1(IPU_INT_CTRL_11, IDMAC_EOBND_EN_26, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_12 - Interrupt Control Register 12 (RW)
 *
 * This register contains part of IPU interrupts controls. The controls of the end-of-band
 * indication (EOBND) of DMA Channels interrupts [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 13; //!< Reserved.
        unsigned IDMAC_EOBND_EN_45 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_46 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_47 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_48 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_49 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_50 : 1; //!< end-of-band indication of Channel interrupt. This bit is the control end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 13; //!< Reserved.
    } B;
} hw_ipu_int_ctrl_12_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_12 register
 */
#define HW_IPU_INT_CTRL_12_ADDR(x)      (REGS_IPU_BASE(x) + 0x68)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_12(x)           (*(volatile hw_ipu_int_ctrl_12_t *) HW_IPU_INT_CTRL_12_ADDR(x))
#define HW_IPU_INT_CTRL_12_RD(x)        (HW_IPU_INT_CTRL_12(x).U)
#define HW_IPU_INT_CTRL_12_WR(x, v)     (HW_IPU_INT_CTRL_12(x).U = (v))
#define HW_IPU_INT_CTRL_12_SET(x, v)    (HW_IPU_INT_CTRL_12_WR(x, HW_IPU_INT_CTRL_12_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_12_CLR(x, v)    (HW_IPU_INT_CTRL_12_WR(x, HW_IPU_INT_CTRL_12_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_12_TOG(x, v)    (HW_IPU_INT_CTRL_12_WR(x, HW_IPU_INT_CTRL_12_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_12 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_12, field IDMAC_EOBND_EN_45 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_12_IDMAC_EOBND_EN_45      13
#define BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_12_IDMAC_EOBND_EN_45(v)   ((((reg32_t) v) << 13) & BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_45)
#else
#define BF_IPU_INT_CTRL_12_IDMAC_EOBND_EN_45(v)   (((v) << 13) & BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_45 field to a new value.
#define BW_IPU_INT_CTRL_12_IDMAC_EOBND_EN_45(v)   BF_CS1(IPU_INT_CTRL_12, IDMAC_EOBND_EN_45, v)
#endif


/* --- Register HW_IPU_INT_CTRL_12, field IDMAC_EOBND_EN_46 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_12_IDMAC_EOBND_EN_46      14
#define BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_12_IDMAC_EOBND_EN_46(v)   ((((reg32_t) v) << 14) & BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_46)
#else
#define BF_IPU_INT_CTRL_12_IDMAC_EOBND_EN_46(v)   (((v) << 14) & BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_46 field to a new value.
#define BW_IPU_INT_CTRL_12_IDMAC_EOBND_EN_46(v)   BF_CS1(IPU_INT_CTRL_12, IDMAC_EOBND_EN_46, v)
#endif


/* --- Register HW_IPU_INT_CTRL_12, field IDMAC_EOBND_EN_47 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_12_IDMAC_EOBND_EN_47      15
#define BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_12_IDMAC_EOBND_EN_47(v)   ((((reg32_t) v) << 15) & BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_47)
#else
#define BF_IPU_INT_CTRL_12_IDMAC_EOBND_EN_47(v)   (((v) << 15) & BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_47 field to a new value.
#define BW_IPU_INT_CTRL_12_IDMAC_EOBND_EN_47(v)   BF_CS1(IPU_INT_CTRL_12, IDMAC_EOBND_EN_47, v)
#endif


/* --- Register HW_IPU_INT_CTRL_12, field IDMAC_EOBND_EN_48 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_12_IDMAC_EOBND_EN_48      16
#define BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_12_IDMAC_EOBND_EN_48(v)   ((((reg32_t) v) << 16) & BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_48)
#else
#define BF_IPU_INT_CTRL_12_IDMAC_EOBND_EN_48(v)   (((v) << 16) & BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_48 field to a new value.
#define BW_IPU_INT_CTRL_12_IDMAC_EOBND_EN_48(v)   BF_CS1(IPU_INT_CTRL_12, IDMAC_EOBND_EN_48, v)
#endif


/* --- Register HW_IPU_INT_CTRL_12, field IDMAC_EOBND_EN_49 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_12_IDMAC_EOBND_EN_49      17
#define BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_12_IDMAC_EOBND_EN_49(v)   ((((reg32_t) v) << 17) & BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_49)
#else
#define BF_IPU_INT_CTRL_12_IDMAC_EOBND_EN_49(v)   (((v) << 17) & BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_49 field to a new value.
#define BW_IPU_INT_CTRL_12_IDMAC_EOBND_EN_49(v)   BF_CS1(IPU_INT_CTRL_12, IDMAC_EOBND_EN_49, v)
#endif


/* --- Register HW_IPU_INT_CTRL_12, field IDMAC_EOBND_EN_50 (RW)
 *
 * end-of-band indication of Channel interrupt. This bit is the control end-of-band interrupt of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_12_IDMAC_EOBND_EN_50      18
#define BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_12_IDMAC_EOBND_EN_50(v)   ((((reg32_t) v) << 18) & BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_50)
#else
#define BF_IPU_INT_CTRL_12_IDMAC_EOBND_EN_50(v)   (((v) << 18) & BM_IPU_INT_CTRL_12_IDMAC_EOBND_EN_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_EN_50 field to a new value.
#define BW_IPU_INT_CTRL_12_IDMAC_EOBND_EN_50(v)   BF_CS1(IPU_INT_CTRL_12, IDMAC_EOBND_EN_50, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_13 - Interrupt Control Register 13 (RW)
 *
 * This register contains part of IPU interrupts controls. The controls of the threshold crossing
 * indication (TH) of DMA Channels interrupts [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_TH_EN_0 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_1 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_2 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_3 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_TH_EN_5 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_TH_EN_8 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_9 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_10 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_11 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_12 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_13 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_14 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_15 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_TH_EN_17 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_18 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_19 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_20 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_21 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_22 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_23 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_24 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_25 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_26 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_27 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_28 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_29 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_TH_EN_31 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_int_ctrl_13_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_13 register
 */
#define HW_IPU_INT_CTRL_13_ADDR(x)      (REGS_IPU_BASE(x) + 0x6c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_13(x)           (*(volatile hw_ipu_int_ctrl_13_t *) HW_IPU_INT_CTRL_13_ADDR(x))
#define HW_IPU_INT_CTRL_13_RD(x)        (HW_IPU_INT_CTRL_13(x).U)
#define HW_IPU_INT_CTRL_13_WR(x, v)     (HW_IPU_INT_CTRL_13(x).U = (v))
#define HW_IPU_INT_CTRL_13_SET(x, v)    (HW_IPU_INT_CTRL_13_WR(x, HW_IPU_INT_CTRL_13_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_13_CLR(x, v)    (HW_IPU_INT_CTRL_13_WR(x, HW_IPU_INT_CTRL_13_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_13_TOG(x, v)    (HW_IPU_INT_CTRL_13_WR(x, HW_IPU_INT_CTRL_13_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_13 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_0 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_0      0
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_0)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_0(v)   (((v) << 0) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_0 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_0(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_0, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_1 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_1      1
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_1(v)   ((((reg32_t) v) << 1) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_1)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_1(v)   (((v) << 1) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_1 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_1(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_1, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_2 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_2      2
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_2(v)   ((((reg32_t) v) << 2) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_2)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_2(v)   (((v) << 2) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_2 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_2(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_2, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_3 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_3      3
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_3(v)   ((((reg32_t) v) << 3) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_3)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_3(v)   (((v) << 3) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_3 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_3(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_3, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_5 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_5      5
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_5(v)   ((((reg32_t) v) << 5) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_5)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_5(v)   (((v) << 5) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_5 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_5(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_5, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_8 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_8      8
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_8(v)   ((((reg32_t) v) << 8) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_8)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_8(v)   (((v) << 8) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_8 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_8(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_8, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_9 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_9      9
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_9(v)   ((((reg32_t) v) << 9) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_9)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_9(v)   (((v) << 9) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_9 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_9(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_9, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_10 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_10      10
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_10(v)   ((((reg32_t) v) << 10) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_10)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_10(v)   (((v) << 10) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_10 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_10(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_10, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_11 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_11      11
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_11(v)   ((((reg32_t) v) << 11) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_11)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_11(v)   (((v) << 11) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_11 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_11(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_11, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_12 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_12      12
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_12(v)   ((((reg32_t) v) << 12) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_12)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_12(v)   (((v) << 12) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_12 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_12(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_12, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_13 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_13      13
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_13(v)   ((((reg32_t) v) << 13) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_13)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_13(v)   (((v) << 13) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_13 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_13(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_13, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_14 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_14      14
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_14(v)   ((((reg32_t) v) << 14) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_14)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_14(v)   (((v) << 14) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_14 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_14(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_14, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_15 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_15      15
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_15(v)   ((((reg32_t) v) << 15) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_15)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_15(v)   (((v) << 15) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_15 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_15(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_15, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_17 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_17      17
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_17      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_17(v)   ((((reg32_t) v) << 17) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_17)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_17(v)   (((v) << 17) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_17 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_17(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_17, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_18 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_18      18
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_18      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_18(v)   ((((reg32_t) v) << 18) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_18)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_18(v)   (((v) << 18) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_18 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_18(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_18, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_19 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_19      19
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_19      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_19(v)   ((((reg32_t) v) << 19) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_19)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_19(v)   (((v) << 19) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_19 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_19(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_19, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_20 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_20      20
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_20(v)   ((((reg32_t) v) << 20) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_20)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_20(v)   (((v) << 20) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_20 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_20(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_20, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_21 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_21      21
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_21(v)   ((((reg32_t) v) << 21) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_21)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_21(v)   (((v) << 21) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_21 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_21(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_21, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_22 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_22      22
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_22(v)   ((((reg32_t) v) << 22) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_22)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_22(v)   (((v) << 22) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_22 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_22(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_22, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_23 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_23      23
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_23(v)   ((((reg32_t) v) << 23) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_23)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_23(v)   (((v) << 23) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_23 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_23(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_23, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_24 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_24      24
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_24(v)   ((((reg32_t) v) << 24) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_24)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_24(v)   (((v) << 24) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_24 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_24(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_24, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_25 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_25      25
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_25)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_25(v)   (((v) << 25) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_25 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_25(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_25, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_26 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_26      26
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_26)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_26(v)   (((v) << 26) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_26 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_26(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_26, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_27 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_27      27
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_27(v)   ((((reg32_t) v) << 27) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_27)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_27(v)   (((v) << 27) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_27 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_27(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_27, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_28 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_28      28
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_28(v)   ((((reg32_t) v) << 28) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_28)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_28(v)   (((v) << 28) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_28 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_28(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_28, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_29 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_29      29
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_29(v)   ((((reg32_t) v) << 29) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_29)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_29(v)   (((v) << 29) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_29 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_29(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_29, v)
#endif


/* --- Register HW_IPU_INT_CTRL_13, field IDMAC_TH_EN_31 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control of Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_13_IDMAC_TH_EN_31      31
#define BM_IPU_INT_CTRL_13_IDMAC_TH_EN_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_31(v)   ((((reg32_t) v) << 31) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_31)
#else
#define BF_IPU_INT_CTRL_13_IDMAC_TH_EN_31(v)   (((v) << 31) & BM_IPU_INT_CTRL_13_IDMAC_TH_EN_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_31 field to a new value.
#define BW_IPU_INT_CTRL_13_IDMAC_TH_EN_31(v)   BF_CS1(IPU_INT_CTRL_13, IDMAC_TH_EN_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_14 - Interrupt Control Register 14 (RW)
 *
 * This register contains part of IPU interrupts controls. The controls of the Threshold crossing
 * indication (TH) of DMA Channels interrupts [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_TH_EN_33 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_TH_EN_40 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_41 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_42 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_43 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_44 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_45 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_46 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_47 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_48 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_49 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_50 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_51 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_EN_52 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_int_ctrl_14_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_14 register
 */
#define HW_IPU_INT_CTRL_14_ADDR(x)      (REGS_IPU_BASE(x) + 0x70)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_14(x)           (*(volatile hw_ipu_int_ctrl_14_t *) HW_IPU_INT_CTRL_14_ADDR(x))
#define HW_IPU_INT_CTRL_14_RD(x)        (HW_IPU_INT_CTRL_14(x).U)
#define HW_IPU_INT_CTRL_14_WR(x, v)     (HW_IPU_INT_CTRL_14(x).U = (v))
#define HW_IPU_INT_CTRL_14_SET(x, v)    (HW_IPU_INT_CTRL_14_WR(x, HW_IPU_INT_CTRL_14_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_14_CLR(x, v)    (HW_IPU_INT_CTRL_14_WR(x, HW_IPU_INT_CTRL_14_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_14_TOG(x, v)    (HW_IPU_INT_CTRL_14_WR(x, HW_IPU_INT_CTRL_14_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_14 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_33 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_33      1
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_33(v)   ((((reg32_t) v) << 1) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_33)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_33(v)   (((v) << 1) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_33 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_33(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_33, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_40 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_40      8
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_40      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_40(v)   ((((reg32_t) v) << 8) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_40)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_40(v)   (((v) << 8) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_40)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_40 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_40(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_40, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_41 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_41      9
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_41(v)   ((((reg32_t) v) << 9) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_41)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_41(v)   (((v) << 9) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_41 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_41(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_41, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_42 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_42      10
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_42(v)   ((((reg32_t) v) << 10) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_42)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_42(v)   (((v) << 10) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_42 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_42(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_42, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_43 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_43      11
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_43(v)   ((((reg32_t) v) << 11) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_43)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_43(v)   (((v) << 11) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_43 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_43(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_43, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_44 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_44      12
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_44(v)   ((((reg32_t) v) << 12) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_44)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_44(v)   (((v) << 12) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_44 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_44(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_44, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_45 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_45      13
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_45(v)   ((((reg32_t) v) << 13) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_45)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_45(v)   (((v) << 13) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_45 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_45(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_45, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_46 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_46      14
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_46(v)   ((((reg32_t) v) << 14) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_46)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_46(v)   (((v) << 14) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_46 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_46(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_46, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_47 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_47      15
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_47(v)   ((((reg32_t) v) << 15) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_47)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_47(v)   (((v) << 15) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_47 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_47(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_47, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_48 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_48      16
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_48(v)   ((((reg32_t) v) << 16) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_48)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_48(v)   (((v) << 16) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_48 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_48(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_48, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_49 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_49      17
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_49(v)   ((((reg32_t) v) << 17) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_49)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_49(v)   (((v) << 17) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_49 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_49(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_49, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_50 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_50      18
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_50(v)   ((((reg32_t) v) << 18) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_50)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_50(v)   (((v) << 18) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_50 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_50(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_50, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_51 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_51      19
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_51(v)   ((((reg32_t) v) << 19) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_51)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_51(v)   (((v) << 19) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_51 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_51(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_51, v)
#endif


/* --- Register HW_IPU_INT_CTRL_14, field IDMAC_TH_EN_52 (RW)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the control Threshold crossing
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_14_IDMAC_TH_EN_52      20
#define BM_IPU_INT_CTRL_14_IDMAC_TH_EN_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_52(v)   ((((reg32_t) v) << 20) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_52)
#else
#define BF_IPU_INT_CTRL_14_IDMAC_TH_EN_52(v)   (((v) << 20) & BM_IPU_INT_CTRL_14_IDMAC_TH_EN_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_EN_52 field to a new value.
#define BW_IPU_INT_CTRL_14_IDMAC_TH_EN_52(v)   BF_CS1(IPU_INT_CTRL_14, IDMAC_TH_EN_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_CTRL_15 - Interrupt Control Register15 (RW)
 *
 * This register contains part of IPU interrupts controls. The controls of general purpose
 * interrupts can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SNOOPING1_INT_EN : 1; //!< IPU snooping 1 interrupt enable bit. This bit enables the interrupt that is a result of the detection of a snooping 1 signal assertion coming to the IPU
        unsigned SNOOPING2_INT_EN : 1; //!< IPU snooping 2 interrupt enable bit. This bit enables the interrupt that is a result of the detection of a snooping 2 signal assertion coming to the IPU
        unsigned DP_SF_START_EN : 1; //!< DP Sync Flow Start enable bit. This bit enables the interrupt that is a result of the Sync flow start at the DP
        unsigned DP_SF_END_EN : 1; //!< DP Sync Flow End enable bit. This bit enables the interrupt that is a result of the Sync flow end at the DP
        unsigned DP_ASF_START_EN : 1; //!< DP Async Flow Start enable bit. This bit enables the interrupt that is a result of the Async flow start at the DP
        unsigned DP_ASF_END_EN : 1; //!< DP Async Flow End enable bit. This bit enables the interrupt that is a result of the Async flow end at the DP
        unsigned DP_SF_BRAKE_EN : 1; //!< DP Sync Flow Brake enable bit. This bit enables the interrupt that is a result of the Sync flow brake at the DP
        unsigned DP_ASF_BRAKE_EN : 1; //!< DP Async Flow Brake enable bit. This bit enables the interrupt that is a result of the async flow brake at the DP
        unsigned DC_FC_0_EN : 1; //!< This bit enables they'd Frame Complete on channel #0 interrupt
        unsigned DC_FC_1_EN : 1; //!< This bit enables they'd Frame Complete on channel #1 interrupt
        unsigned DC_FC_2_EN : 1; //!< This bit enables the DC Frame Complete on channel #2 interrupt
        unsigned DC_FC_3_EN : 1; //!< This bit enables the DC Frame Complete on channel #3 interrupt
        unsigned DC_FC_4_EN : 1; //!< This bit enables the DC Frame Complete on channel #4 interrupt
        unsigned DC_FC_6_EN : 1; //!< This bit enables the DC Frame Complete on channel #6 interrupt
        unsigned DI_VSYNC_PRE_0_EN : 1; //!< This bit enables the DI0 interrupt indicating of a VSYNC signal asserted 2 rows before the VSYNC sent to the display
        unsigned DI_VSYNC_PRE_1_EN : 1; //!< This bit enables the DI1 interrupt indicating of a VSYNC signal asserted 2 rows before the VSYNC sent to the display
        unsigned DC_DP_START_EN : 1; //!< This bit enables the interrupt asserted anytime the DP start a new sync or async flow or when an async flow is interrupted by a sync flow
        unsigned DC_ASYNC_STOP_EN : 1; //!< This bit enables the interrupt asserted anytime the DP stops an async flow and moves to a sync flow
        unsigned DI0_CNT_EN_PRE_0_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #0 of DI0
        unsigned DI0_CNT_EN_PRE_1_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #1 of DI0
        unsigned DI0_CNT_EN_PRE_2_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #2 of DI0
        unsigned DI0_CNT_EN_PRE_3_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #3 of DI0
        unsigned DI0_CNT_EN_PRE_4_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #4 of DI0
        unsigned DI0_CNT_EN_PRE_5_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #5 of DI0
        unsigned DI0_CNT_EN_PRE_6_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #6 of DI0
        unsigned DI0_CNT_EN_PRE_7_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #7 of DI0
        unsigned DI0_CNT_EN_PRE_8_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #8 of DI0
        unsigned DI0_CNT_EN_PRE_9_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #9 of DI0
        unsigned DI0_CNT_EN_PRE_10_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #10 of DI0
        unsigned DI1_DISP_CLK_EN_PRE_EN : 1; //!< DI1_DISP_CLK_EN_PRE_EN
        unsigned DI1_CNT_EN_PRE_3_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #3 of DI1
        unsigned DI1_CNT_EN_PRE_8_EN : 1; //!< This bit enables the interrupt that is a result of a trigger generated by counter #8 of DI1
    } B;
} hw_ipu_int_ctrl_15_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_CTRL_15 register
 */
#define HW_IPU_INT_CTRL_15_ADDR(x)      (REGS_IPU_BASE(x) + 0x74)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_CTRL_15(x)           (*(volatile hw_ipu_int_ctrl_15_t *) HW_IPU_INT_CTRL_15_ADDR(x))
#define HW_IPU_INT_CTRL_15_RD(x)        (HW_IPU_INT_CTRL_15(x).U)
#define HW_IPU_INT_CTRL_15_WR(x, v)     (HW_IPU_INT_CTRL_15(x).U = (v))
#define HW_IPU_INT_CTRL_15_SET(x, v)    (HW_IPU_INT_CTRL_15_WR(x, HW_IPU_INT_CTRL_15_RD(x) |  (v)))
#define HW_IPU_INT_CTRL_15_CLR(x, v)    (HW_IPU_INT_CTRL_15_WR(x, HW_IPU_INT_CTRL_15_RD(x) & ~(v)))
#define HW_IPU_INT_CTRL_15_TOG(x, v)    (HW_IPU_INT_CTRL_15_WR(x, HW_IPU_INT_CTRL_15_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_INT_CTRL_15 bitfields
 */

/* --- Register HW_IPU_INT_CTRL_15, field SNOOPING1_INT_EN (RW)
 *
 * IPU snooping 1 interrupt enable bit. This bit enables the interrupt that is a result of the
 * detection of a snooping 1 signal assertion coming to the IPU
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_SNOOPING1_INT_EN      0
#define BM_IPU_INT_CTRL_15_SNOOPING1_INT_EN      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_SNOOPING1_INT_EN(v)   ((((reg32_t) v) << 0) & BM_IPU_INT_CTRL_15_SNOOPING1_INT_EN)
#else
#define BF_IPU_INT_CTRL_15_SNOOPING1_INT_EN(v)   (((v) << 0) & BM_IPU_INT_CTRL_15_SNOOPING1_INT_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SNOOPING1_INT_EN field to a new value.
#define BW_IPU_INT_CTRL_15_SNOOPING1_INT_EN(v)   BF_CS1(IPU_INT_CTRL_15, SNOOPING1_INT_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field SNOOPING2_INT_EN (RW)
 *
 * IPU snooping 2 interrupt enable bit. This bit enables the interrupt that is a result of the
 * detection of a snooping 2 signal assertion coming to the IPU
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_SNOOPING2_INT_EN      1
#define BM_IPU_INT_CTRL_15_SNOOPING2_INT_EN      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_SNOOPING2_INT_EN(v)   ((((reg32_t) v) << 1) & BM_IPU_INT_CTRL_15_SNOOPING2_INT_EN)
#else
#define BF_IPU_INT_CTRL_15_SNOOPING2_INT_EN(v)   (((v) << 1) & BM_IPU_INT_CTRL_15_SNOOPING2_INT_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SNOOPING2_INT_EN field to a new value.
#define BW_IPU_INT_CTRL_15_SNOOPING2_INT_EN(v)   BF_CS1(IPU_INT_CTRL_15, SNOOPING2_INT_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DP_SF_START_EN (RW)
 *
 * DP Sync Flow Start enable bit. This bit enables the interrupt that is a result of the Sync flow
 * start at the DP
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DP_SF_START_EN      2
#define BM_IPU_INT_CTRL_15_DP_SF_START_EN      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DP_SF_START_EN(v)   ((((reg32_t) v) << 2) & BM_IPU_INT_CTRL_15_DP_SF_START_EN)
#else
#define BF_IPU_INT_CTRL_15_DP_SF_START_EN(v)   (((v) << 2) & BM_IPU_INT_CTRL_15_DP_SF_START_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_SF_START_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DP_SF_START_EN(v)   BF_CS1(IPU_INT_CTRL_15, DP_SF_START_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DP_SF_END_EN (RW)
 *
 * DP Sync Flow End enable bit. This bit enables the interrupt that is a result of the Sync flow end
 * at the DP
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DP_SF_END_EN      3
#define BM_IPU_INT_CTRL_15_DP_SF_END_EN      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DP_SF_END_EN(v)   ((((reg32_t) v) << 3) & BM_IPU_INT_CTRL_15_DP_SF_END_EN)
#else
#define BF_IPU_INT_CTRL_15_DP_SF_END_EN(v)   (((v) << 3) & BM_IPU_INT_CTRL_15_DP_SF_END_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_SF_END_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DP_SF_END_EN(v)   BF_CS1(IPU_INT_CTRL_15, DP_SF_END_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DP_ASF_START_EN (RW)
 *
 * DP Async Flow Start enable bit. This bit enables the interrupt that is a result of the Async flow
 * start at the DP
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DP_ASF_START_EN      4
#define BM_IPU_INT_CTRL_15_DP_ASF_START_EN      0x00000010

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DP_ASF_START_EN(v)   ((((reg32_t) v) << 4) & BM_IPU_INT_CTRL_15_DP_ASF_START_EN)
#else
#define BF_IPU_INT_CTRL_15_DP_ASF_START_EN(v)   (((v) << 4) & BM_IPU_INT_CTRL_15_DP_ASF_START_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_ASF_START_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DP_ASF_START_EN(v)   BF_CS1(IPU_INT_CTRL_15, DP_ASF_START_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DP_ASF_END_EN (RW)
 *
 * DP Async Flow End enable bit. This bit enables the interrupt that is a result of the Async flow
 * end at the DP
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DP_ASF_END_EN      5
#define BM_IPU_INT_CTRL_15_DP_ASF_END_EN      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DP_ASF_END_EN(v)   ((((reg32_t) v) << 5) & BM_IPU_INT_CTRL_15_DP_ASF_END_EN)
#else
#define BF_IPU_INT_CTRL_15_DP_ASF_END_EN(v)   (((v) << 5) & BM_IPU_INT_CTRL_15_DP_ASF_END_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_ASF_END_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DP_ASF_END_EN(v)   BF_CS1(IPU_INT_CTRL_15, DP_ASF_END_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DP_SF_BRAKE_EN (RW)
 *
 * DP Sync Flow Brake enable bit. This bit enables the interrupt that is a result of the Sync flow
 * brake at the DP
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DP_SF_BRAKE_EN      6
#define BM_IPU_INT_CTRL_15_DP_SF_BRAKE_EN      0x00000040

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DP_SF_BRAKE_EN(v)   ((((reg32_t) v) << 6) & BM_IPU_INT_CTRL_15_DP_SF_BRAKE_EN)
#else
#define BF_IPU_INT_CTRL_15_DP_SF_BRAKE_EN(v)   (((v) << 6) & BM_IPU_INT_CTRL_15_DP_SF_BRAKE_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_SF_BRAKE_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DP_SF_BRAKE_EN(v)   BF_CS1(IPU_INT_CTRL_15, DP_SF_BRAKE_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DP_ASF_BRAKE_EN (RW)
 *
 * DP Async Flow Brake enable bit. This bit enables the interrupt that is a result of the async flow
 * brake at the DP
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DP_ASF_BRAKE_EN      7
#define BM_IPU_INT_CTRL_15_DP_ASF_BRAKE_EN      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DP_ASF_BRAKE_EN(v)   ((((reg32_t) v) << 7) & BM_IPU_INT_CTRL_15_DP_ASF_BRAKE_EN)
#else
#define BF_IPU_INT_CTRL_15_DP_ASF_BRAKE_EN(v)   (((v) << 7) & BM_IPU_INT_CTRL_15_DP_ASF_BRAKE_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_ASF_BRAKE_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DP_ASF_BRAKE_EN(v)   BF_CS1(IPU_INT_CTRL_15, DP_ASF_BRAKE_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DC_FC_0_EN (RW)
 *
 * This bit enables they'd Frame Complete on channel #0 interrupt
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DC_FC_0_EN      8
#define BM_IPU_INT_CTRL_15_DC_FC_0_EN      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DC_FC_0_EN(v)   ((((reg32_t) v) << 8) & BM_IPU_INT_CTRL_15_DC_FC_0_EN)
#else
#define BF_IPU_INT_CTRL_15_DC_FC_0_EN(v)   (((v) << 8) & BM_IPU_INT_CTRL_15_DC_FC_0_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_FC_0_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DC_FC_0_EN(v)   BF_CS1(IPU_INT_CTRL_15, DC_FC_0_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DC_FC_1_EN (RW)
 *
 * This bit enables they'd Frame Complete on channel #1 interrupt
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DC_FC_1_EN      9
#define BM_IPU_INT_CTRL_15_DC_FC_1_EN      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DC_FC_1_EN(v)   ((((reg32_t) v) << 9) & BM_IPU_INT_CTRL_15_DC_FC_1_EN)
#else
#define BF_IPU_INT_CTRL_15_DC_FC_1_EN(v)   (((v) << 9) & BM_IPU_INT_CTRL_15_DC_FC_1_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_FC_1_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DC_FC_1_EN(v)   BF_CS1(IPU_INT_CTRL_15, DC_FC_1_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DC_FC_2_EN (RW)
 *
 * This bit enables the DC Frame Complete on channel #2 interrupt
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DC_FC_2_EN      10
#define BM_IPU_INT_CTRL_15_DC_FC_2_EN      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DC_FC_2_EN(v)   ((((reg32_t) v) << 10) & BM_IPU_INT_CTRL_15_DC_FC_2_EN)
#else
#define BF_IPU_INT_CTRL_15_DC_FC_2_EN(v)   (((v) << 10) & BM_IPU_INT_CTRL_15_DC_FC_2_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_FC_2_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DC_FC_2_EN(v)   BF_CS1(IPU_INT_CTRL_15, DC_FC_2_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DC_FC_3_EN (RW)
 *
 * This bit enables the DC Frame Complete on channel #3 interrupt
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DC_FC_3_EN      11
#define BM_IPU_INT_CTRL_15_DC_FC_3_EN      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DC_FC_3_EN(v)   ((((reg32_t) v) << 11) & BM_IPU_INT_CTRL_15_DC_FC_3_EN)
#else
#define BF_IPU_INT_CTRL_15_DC_FC_3_EN(v)   (((v) << 11) & BM_IPU_INT_CTRL_15_DC_FC_3_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_FC_3_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DC_FC_3_EN(v)   BF_CS1(IPU_INT_CTRL_15, DC_FC_3_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DC_FC_4_EN (RW)
 *
 * This bit enables the DC Frame Complete on channel #4 interrupt
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DC_FC_4_EN      12
#define BM_IPU_INT_CTRL_15_DC_FC_4_EN      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DC_FC_4_EN(v)   ((((reg32_t) v) << 12) & BM_IPU_INT_CTRL_15_DC_FC_4_EN)
#else
#define BF_IPU_INT_CTRL_15_DC_FC_4_EN(v)   (((v) << 12) & BM_IPU_INT_CTRL_15_DC_FC_4_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_FC_4_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DC_FC_4_EN(v)   BF_CS1(IPU_INT_CTRL_15, DC_FC_4_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DC_FC_6_EN (RW)
 *
 * This bit enables the DC Frame Complete on channel #6 interrupt
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DC_FC_6_EN      13
#define BM_IPU_INT_CTRL_15_DC_FC_6_EN      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DC_FC_6_EN(v)   ((((reg32_t) v) << 13) & BM_IPU_INT_CTRL_15_DC_FC_6_EN)
#else
#define BF_IPU_INT_CTRL_15_DC_FC_6_EN(v)   (((v) << 13) & BM_IPU_INT_CTRL_15_DC_FC_6_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_FC_6_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DC_FC_6_EN(v)   BF_CS1(IPU_INT_CTRL_15, DC_FC_6_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI_VSYNC_PRE_0_EN (RW)
 *
 * This bit enables the DI0 interrupt indicating of a VSYNC signal asserted 2 rows before the VSYNC
 * sent to the display
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI_VSYNC_PRE_0_EN      14
#define BM_IPU_INT_CTRL_15_DI_VSYNC_PRE_0_EN      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI_VSYNC_PRE_0_EN(v)   ((((reg32_t) v) << 14) & BM_IPU_INT_CTRL_15_DI_VSYNC_PRE_0_EN)
#else
#define BF_IPU_INT_CTRL_15_DI_VSYNC_PRE_0_EN(v)   (((v) << 14) & BM_IPU_INT_CTRL_15_DI_VSYNC_PRE_0_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI_VSYNC_PRE_0_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI_VSYNC_PRE_0_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI_VSYNC_PRE_0_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI_VSYNC_PRE_1_EN (RW)
 *
 * This bit enables the DI1 interrupt indicating of a VSYNC signal asserted 2 rows before the VSYNC
 * sent to the display
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI_VSYNC_PRE_1_EN      15
#define BM_IPU_INT_CTRL_15_DI_VSYNC_PRE_1_EN      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI_VSYNC_PRE_1_EN(v)   ((((reg32_t) v) << 15) & BM_IPU_INT_CTRL_15_DI_VSYNC_PRE_1_EN)
#else
#define BF_IPU_INT_CTRL_15_DI_VSYNC_PRE_1_EN(v)   (((v) << 15) & BM_IPU_INT_CTRL_15_DI_VSYNC_PRE_1_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI_VSYNC_PRE_1_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI_VSYNC_PRE_1_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI_VSYNC_PRE_1_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DC_DP_START_EN (RW)
 *
 * This bit enables the interrupt asserted anytime the DP start a new sync or async flow or when an
 * async flow is interrupted by a sync flow
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DC_DP_START_EN      16
#define BM_IPU_INT_CTRL_15_DC_DP_START_EN      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DC_DP_START_EN(v)   ((((reg32_t) v) << 16) & BM_IPU_INT_CTRL_15_DC_DP_START_EN)
#else
#define BF_IPU_INT_CTRL_15_DC_DP_START_EN(v)   (((v) << 16) & BM_IPU_INT_CTRL_15_DC_DP_START_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_DP_START_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DC_DP_START_EN(v)   BF_CS1(IPU_INT_CTRL_15, DC_DP_START_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DC_ASYNC_STOP_EN (RW)
 *
 * This bit enables the interrupt asserted anytime the DP stops an async flow and moves to a sync
 * flow
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DC_ASYNC_STOP_EN      17
#define BM_IPU_INT_CTRL_15_DC_ASYNC_STOP_EN      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DC_ASYNC_STOP_EN(v)   ((((reg32_t) v) << 17) & BM_IPU_INT_CTRL_15_DC_ASYNC_STOP_EN)
#else
#define BF_IPU_INT_CTRL_15_DC_ASYNC_STOP_EN(v)   (((v) << 17) & BM_IPU_INT_CTRL_15_DC_ASYNC_STOP_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_ASYNC_STOP_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DC_ASYNC_STOP_EN(v)   BF_CS1(IPU_INT_CTRL_15, DC_ASYNC_STOP_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI0_CNT_EN_PRE_0_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #0 of DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_0_EN      18
#define BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_0_EN      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_0_EN(v)   ((((reg32_t) v) << 18) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_0_EN)
#else
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_0_EN(v)   (((v) << 18) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_0_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_EN_PRE_0_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_0_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI0_CNT_EN_PRE_0_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI0_CNT_EN_PRE_1_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #1 of DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_1_EN      19
#define BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_1_EN      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_1_EN(v)   ((((reg32_t) v) << 19) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_1_EN)
#else
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_1_EN(v)   (((v) << 19) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_1_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_EN_PRE_1_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_1_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI0_CNT_EN_PRE_1_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI0_CNT_EN_PRE_2_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #2 of DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_2_EN      20
#define BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_2_EN      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_2_EN(v)   ((((reg32_t) v) << 20) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_2_EN)
#else
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_2_EN(v)   (((v) << 20) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_2_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_EN_PRE_2_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_2_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI0_CNT_EN_PRE_2_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI0_CNT_EN_PRE_3_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #3 of DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_3_EN      21
#define BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_3_EN      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_3_EN(v)   ((((reg32_t) v) << 21) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_3_EN)
#else
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_3_EN(v)   (((v) << 21) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_3_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_EN_PRE_3_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_3_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI0_CNT_EN_PRE_3_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI0_CNT_EN_PRE_4_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #4 of DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_4_EN      22
#define BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_4_EN      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_4_EN(v)   ((((reg32_t) v) << 22) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_4_EN)
#else
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_4_EN(v)   (((v) << 22) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_4_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_EN_PRE_4_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_4_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI0_CNT_EN_PRE_4_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI0_CNT_EN_PRE_5_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #5 of DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_5_EN      23
#define BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_5_EN      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_5_EN(v)   ((((reg32_t) v) << 23) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_5_EN)
#else
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_5_EN(v)   (((v) << 23) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_5_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_EN_PRE_5_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_5_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI0_CNT_EN_PRE_5_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI0_CNT_EN_PRE_6_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #6 of DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_6_EN      24
#define BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_6_EN      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_6_EN(v)   ((((reg32_t) v) << 24) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_6_EN)
#else
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_6_EN(v)   (((v) << 24) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_6_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_EN_PRE_6_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_6_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI0_CNT_EN_PRE_6_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI0_CNT_EN_PRE_7_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #7 of DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_7_EN      25
#define BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_7_EN      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_7_EN(v)   ((((reg32_t) v) << 25) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_7_EN)
#else
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_7_EN(v)   (((v) << 25) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_7_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_EN_PRE_7_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_7_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI0_CNT_EN_PRE_7_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI0_CNT_EN_PRE_8_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #8 of DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_8_EN      26
#define BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_8_EN      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_8_EN(v)   ((((reg32_t) v) << 26) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_8_EN)
#else
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_8_EN(v)   (((v) << 26) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_8_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_EN_PRE_8_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_8_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI0_CNT_EN_PRE_8_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI0_CNT_EN_PRE_9_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #9 of DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_9_EN      27
#define BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_9_EN      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_9_EN(v)   ((((reg32_t) v) << 27) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_9_EN)
#else
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_9_EN(v)   (((v) << 27) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_9_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_EN_PRE_9_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_9_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI0_CNT_EN_PRE_9_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI0_CNT_EN_PRE_10_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #10 of DI0
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_10_EN      28
#define BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_10_EN      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_10_EN(v)   ((((reg32_t) v) << 28) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_10_EN)
#else
#define BF_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_10_EN(v)   (((v) << 28) & BM_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_10_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_EN_PRE_10_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI0_CNT_EN_PRE_10_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI0_CNT_EN_PRE_10_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI1_DISP_CLK_EN_PRE_EN (RW)
 *
 * DI1_DISP_CLK_EN_PRE_EN
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI1_DISP_CLK_EN_PRE_EN      29
#define BM_IPU_INT_CTRL_15_DI1_DISP_CLK_EN_PRE_EN      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI1_DISP_CLK_EN_PRE_EN(v)   ((((reg32_t) v) << 29) & BM_IPU_INT_CTRL_15_DI1_DISP_CLK_EN_PRE_EN)
#else
#define BF_IPU_INT_CTRL_15_DI1_DISP_CLK_EN_PRE_EN(v)   (((v) << 29) & BM_IPU_INT_CTRL_15_DI1_DISP_CLK_EN_PRE_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DISP_CLK_EN_PRE_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI1_DISP_CLK_EN_PRE_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI1_DISP_CLK_EN_PRE_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI1_CNT_EN_PRE_3_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #3 of DI1
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_3_EN      30
#define BM_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_3_EN      0x40000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_3_EN(v)   ((((reg32_t) v) << 30) & BM_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_3_EN)
#else
#define BF_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_3_EN(v)   (((v) << 30) & BM_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_3_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_EN_PRE_3_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_3_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI1_CNT_EN_PRE_3_EN, v)
#endif


/* --- Register HW_IPU_INT_CTRL_15, field DI1_CNT_EN_PRE_8_EN (RW)
 *
 * This bit enables the interrupt that is a result of a trigger generated by counter #8 of DI1
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_8_EN      31
#define BM_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_8_EN      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_8_EN(v)   ((((reg32_t) v) << 31) & BM_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_8_EN)
#else
#define BF_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_8_EN(v)   (((v) << 31) & BM_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_8_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_EN_PRE_8_EN field to a new value.
#define BW_IPU_INT_CTRL_15_DI1_CNT_EN_PRE_8_EN(v)   BF_CS1(IPU_INT_CTRL_15, DI1_CNT_EN_PRE_8_EN, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SDMA_EVENT_1 - SDMA Event Control Register 1 (RW)
 *
 * This register contains part of IPU SDMA events controls. The controls of EOF (end of frame) of
 * DMA Channels SDMA events [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_EOF_SDMA_EN_0 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_1 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_2 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_3 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_EOF_SDMA_EN_5 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_EOF_SDMA_EN_8 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_9 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_10 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_11 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_12 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_13 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_14 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_15 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_EOF_SDMA_EN_17 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_18 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_19 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_20 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_21 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_22 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_23 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_24 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_25 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_26 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_27 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_28 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_29 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_EOF_SDMA_EN_31 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_sdma_event_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SDMA_EVENT_1 register
 */
#define HW_IPU_SDMA_EVENT_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x78)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SDMA_EVENT_1(x)           (*(volatile hw_ipu_sdma_event_1_t *) HW_IPU_SDMA_EVENT_1_ADDR(x))
#define HW_IPU_SDMA_EVENT_1_RD(x)        (HW_IPU_SDMA_EVENT_1(x).U)
#define HW_IPU_SDMA_EVENT_1_WR(x, v)     (HW_IPU_SDMA_EVENT_1(x).U = (v))
#define HW_IPU_SDMA_EVENT_1_SET(x, v)    (HW_IPU_SDMA_EVENT_1_WR(x, HW_IPU_SDMA_EVENT_1_RD(x) |  (v)))
#define HW_IPU_SDMA_EVENT_1_CLR(x, v)    (HW_IPU_SDMA_EVENT_1_WR(x, HW_IPU_SDMA_EVENT_1_RD(x) & ~(v)))
#define HW_IPU_SDMA_EVENT_1_TOG(x, v)    (HW_IPU_SDMA_EVENT_1_WR(x, HW_IPU_SDMA_EVENT_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SDMA_EVENT_1 bitfields
 */

/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_0 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_0      0
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_0)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_0(v)   (((v) << 0) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_0 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_0(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_0, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_1 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_1      1
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_1(v)   ((((reg32_t) v) << 1) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_1)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_1(v)   (((v) << 1) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_1 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_1(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_1, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_2 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_2      2
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_2(v)   ((((reg32_t) v) << 2) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_2)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_2(v)   (((v) << 2) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_2 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_2(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_2, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_3 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_3      3
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_3(v)   ((((reg32_t) v) << 3) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_3)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_3(v)   (((v) << 3) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_3 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_3(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_3, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_5 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_5      5
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_5(v)   ((((reg32_t) v) << 5) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_5)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_5(v)   (((v) << 5) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_5 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_5(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_5, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_8 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_8      8
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_8(v)   ((((reg32_t) v) << 8) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_8)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_8(v)   (((v) << 8) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_8 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_8(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_8, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_9 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_9      9
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_9(v)   ((((reg32_t) v) << 9) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_9)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_9(v)   (((v) << 9) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_9 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_9(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_9, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_10 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_10      10
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_10(v)   ((((reg32_t) v) << 10) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_10)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_10(v)   (((v) << 10) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_10 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_10(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_10, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_11 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_11      11
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_11(v)   ((((reg32_t) v) << 11) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_11)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_11(v)   (((v) << 11) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_11 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_11(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_11, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_12 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_12      12
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_12(v)   ((((reg32_t) v) << 12) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_12)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_12(v)   (((v) << 12) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_12 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_12(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_12, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_13 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_13      13
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_13(v)   ((((reg32_t) v) << 13) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_13)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_13(v)   (((v) << 13) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_13 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_13(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_13, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_14 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_14      14
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_14(v)   ((((reg32_t) v) << 14) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_14)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_14(v)   (((v) << 14) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_14 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_14(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_14, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_15 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_15      15
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_15(v)   ((((reg32_t) v) << 15) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_15)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_15(v)   (((v) << 15) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_15 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_15(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_15, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_17 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_17      17
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_17      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_17(v)   ((((reg32_t) v) << 17) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_17)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_17(v)   (((v) << 17) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_17 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_17(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_17, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_18 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_18      18
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_18      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_18(v)   ((((reg32_t) v) << 18) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_18)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_18(v)   (((v) << 18) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_18 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_18(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_18, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_19 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_19      19
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_19      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_19(v)   ((((reg32_t) v) << 19) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_19)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_19(v)   (((v) << 19) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_19 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_19(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_19, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_20 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_20      20
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_20(v)   ((((reg32_t) v) << 20) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_20)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_20(v)   (((v) << 20) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_20 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_20(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_20, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_21 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_21      21
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_21(v)   ((((reg32_t) v) << 21) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_21)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_21(v)   (((v) << 21) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_21 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_21(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_21, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_22 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_22      22
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_22(v)   ((((reg32_t) v) << 22) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_22)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_22(v)   (((v) << 22) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_22 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_22(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_22, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_23 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_23      23
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_23(v)   ((((reg32_t) v) << 23) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_23)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_23(v)   (((v) << 23) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_23 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_23(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_23, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_24 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_24      24
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_24(v)   ((((reg32_t) v) << 24) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_24)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_24(v)   (((v) << 24) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_24 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_24(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_24, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_25 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_25      25
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_25)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_25(v)   (((v) << 25) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_25 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_25(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_25, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_26 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_26      26
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_26)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_26(v)   (((v) << 26) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_26 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_26(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_26, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_27 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_27      27
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_27(v)   ((((reg32_t) v) << 27) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_27)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_27(v)   (((v) << 27) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_27 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_27(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_27, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_28 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_28      28
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_28(v)   ((((reg32_t) v) << 28) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_28)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_28(v)   (((v) << 28) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_28 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_28(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_28, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_29 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_29      29
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_29(v)   ((((reg32_t) v) << 29) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_29)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_29(v)   (((v) << 29) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_29 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_29(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_29, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_1, field IDMAC_EOF_SDMA_EN_31 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_31      31
#define BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_31(v)   ((((reg32_t) v) << 31) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_31)
#else
#define BF_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_31(v)   (((v) << 31) & BM_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_31 field to a new value.
#define BW_IPU_SDMA_EVENT_1_IDMAC_EOF_SDMA_EN_31(v)   BF_CS1(IPU_SDMA_EVENT_1, IDMAC_EOF_SDMA_EN_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SDMA_EVENT_2 - SDMA Event Control Register 2 (RW)
 *
 * This register contains part of IPU SDMA events controls. The controls of EOF (end of frame) of
 * DMA Channels SDMA events [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_EOF_SDMA_EN_33 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_EOF_SDMA_EN_40 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_41 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_42 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_43 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_44 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_45 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_46 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_47 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_48 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_49 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_50 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_51 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_SDMA_EN_52 : 1; //!< Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_sdma_event_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SDMA_EVENT_2 register
 */
#define HW_IPU_SDMA_EVENT_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x7c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SDMA_EVENT_2(x)           (*(volatile hw_ipu_sdma_event_2_t *) HW_IPU_SDMA_EVENT_2_ADDR(x))
#define HW_IPU_SDMA_EVENT_2_RD(x)        (HW_IPU_SDMA_EVENT_2(x).U)
#define HW_IPU_SDMA_EVENT_2_WR(x, v)     (HW_IPU_SDMA_EVENT_2(x).U = (v))
#define HW_IPU_SDMA_EVENT_2_SET(x, v)    (HW_IPU_SDMA_EVENT_2_WR(x, HW_IPU_SDMA_EVENT_2_RD(x) |  (v)))
#define HW_IPU_SDMA_EVENT_2_CLR(x, v)    (HW_IPU_SDMA_EVENT_2_WR(x, HW_IPU_SDMA_EVENT_2_RD(x) & ~(v)))
#define HW_IPU_SDMA_EVENT_2_TOG(x, v)    (HW_IPU_SDMA_EVENT_2_WR(x, HW_IPU_SDMA_EVENT_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SDMA_EVENT_2 bitfields
 */

/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_33 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_33      1
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_33(v)   ((((reg32_t) v) << 1) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_33)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_33(v)   (((v) << 1) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_33 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_33(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_33, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_40 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_40      8
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_40      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_40(v)   ((((reg32_t) v) << 8) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_40)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_40(v)   (((v) << 8) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_40)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_40 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_40(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_40, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_41 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_41      9
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_41(v)   ((((reg32_t) v) << 9) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_41)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_41(v)   (((v) << 9) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_41 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_41(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_41, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_42 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_42      10
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_42(v)   ((((reg32_t) v) << 10) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_42)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_42(v)   (((v) << 10) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_42 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_42(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_42, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_43 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_43      11
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_43(v)   ((((reg32_t) v) << 11) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_43)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_43(v)   (((v) << 11) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_43 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_43(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_43, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_44 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_44      12
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_44(v)   ((((reg32_t) v) << 12) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_44)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_44(v)   (((v) << 12) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_44 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_44(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_44, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_45 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_45      13
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_45(v)   ((((reg32_t) v) << 13) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_45)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_45(v)   (((v) << 13) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_45 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_45(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_45, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_46 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_46      14
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_46(v)   ((((reg32_t) v) << 14) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_46)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_46(v)   (((v) << 14) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_46 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_46(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_46, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_47 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_47      15
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_47(v)   ((((reg32_t) v) << 15) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_47)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_47(v)   (((v) << 15) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_47 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_47(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_47, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_48 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_48      16
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_48(v)   ((((reg32_t) v) << 16) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_48)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_48(v)   (((v) << 16) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_48 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_48(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_48, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_49 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_49      17
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_49(v)   ((((reg32_t) v) << 17) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_49)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_49(v)   (((v) << 17) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_49 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_49(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_49, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_50 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_50      18
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_50(v)   ((((reg32_t) v) << 18) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_50)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_50(v)   (((v) << 18) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_50 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_50(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_50, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_51 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_51      19
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_51(v)   ((((reg32_t) v) << 19) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_51)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_51(v)   (((v) << 19) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_51 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_51(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_51, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_2, field IDMAC_EOF_SDMA_EN_52 (RW)
 *
 * Enable End of Frame of Channel SDMA event. This bit is the control of End Of Frame of Channel #n.
 * n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_52      20
#define BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_52(v)   ((((reg32_t) v) << 20) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_52)
#else
#define BF_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_52(v)   (((v) << 20) & BM_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOF_SDMA_EN_52 field to a new value.
#define BW_IPU_SDMA_EVENT_2_IDMAC_EOF_SDMA_EN_52(v)   BF_CS1(IPU_SDMA_EVENT_2, IDMAC_EOF_SDMA_EN_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SDMA_EVENT_3 - SDMA Event Control Register 3 (RW)
 *
 * This register contains part of IPU SDMA events controls. The controls of NFACK (New Frame
 * Acknowledge) of DMA Channels SDMA events [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_NFACK_SDMA_EN_0 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_1 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_2 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_3 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_NFACK_SDMA_EN_5 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_NFACK_SDMA_EN_8 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_9 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_10 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_11 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_12 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_13 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_14 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_15 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_NFACK_SDMA_EN_17 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_18 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_19 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_20 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_21 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_22 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_23 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_24 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_25 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_26 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_27 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_28 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_29 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_NFACK_SDMA_EN_31 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_sdma_event_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SDMA_EVENT_3 register
 */
#define HW_IPU_SDMA_EVENT_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x80)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SDMA_EVENT_3(x)           (*(volatile hw_ipu_sdma_event_3_t *) HW_IPU_SDMA_EVENT_3_ADDR(x))
#define HW_IPU_SDMA_EVENT_3_RD(x)        (HW_IPU_SDMA_EVENT_3(x).U)
#define HW_IPU_SDMA_EVENT_3_WR(x, v)     (HW_IPU_SDMA_EVENT_3(x).U = (v))
#define HW_IPU_SDMA_EVENT_3_SET(x, v)    (HW_IPU_SDMA_EVENT_3_WR(x, HW_IPU_SDMA_EVENT_3_RD(x) |  (v)))
#define HW_IPU_SDMA_EVENT_3_CLR(x, v)    (HW_IPU_SDMA_EVENT_3_WR(x, HW_IPU_SDMA_EVENT_3_RD(x) & ~(v)))
#define HW_IPU_SDMA_EVENT_3_TOG(x, v)    (HW_IPU_SDMA_EVENT_3_WR(x, HW_IPU_SDMA_EVENT_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SDMA_EVENT_3 bitfields
 */

/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_0 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_0      0
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_0)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_0(v)   (((v) << 0) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_0 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_0(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_0, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_1 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_1      1
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_1(v)   ((((reg32_t) v) << 1) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_1)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_1(v)   (((v) << 1) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_1 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_1(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_1, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_2 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_2      2
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_2(v)   ((((reg32_t) v) << 2) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_2)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_2(v)   (((v) << 2) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_2 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_2(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_2, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_3 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_3      3
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_3(v)   ((((reg32_t) v) << 3) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_3)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_3(v)   (((v) << 3) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_3 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_3(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_3, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_5 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_5      5
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_5(v)   ((((reg32_t) v) << 5) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_5)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_5(v)   (((v) << 5) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_5 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_5(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_5, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_8 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_8      8
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_8(v)   ((((reg32_t) v) << 8) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_8)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_8(v)   (((v) << 8) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_8 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_8(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_8, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_9 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_9      9
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_9(v)   ((((reg32_t) v) << 9) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_9)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_9(v)   (((v) << 9) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_9 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_9(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_9, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_10 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_10      10
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_10(v)   ((((reg32_t) v) << 10) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_10)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_10(v)   (((v) << 10) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_10 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_10(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_10, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_11 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_11      11
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_11(v)   ((((reg32_t) v) << 11) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_11)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_11(v)   (((v) << 11) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_11 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_11(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_11, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_12 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_12      12
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_12(v)   ((((reg32_t) v) << 12) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_12)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_12(v)   (((v) << 12) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_12 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_12(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_12, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_13 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_13      13
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_13(v)   ((((reg32_t) v) << 13) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_13)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_13(v)   (((v) << 13) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_13 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_13(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_13, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_14 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_14      14
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_14(v)   ((((reg32_t) v) << 14) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_14)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_14(v)   (((v) << 14) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_14 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_14(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_14, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_15 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_15      15
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_15(v)   ((((reg32_t) v) << 15) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_15)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_15(v)   (((v) << 15) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_15 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_15(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_15, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_17 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_17      17
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_17      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_17(v)   ((((reg32_t) v) << 17) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_17)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_17(v)   (((v) << 17) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_17 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_17(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_17, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_18 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_18      18
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_18      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_18(v)   ((((reg32_t) v) << 18) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_18)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_18(v)   (((v) << 18) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_18 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_18(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_18, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_19 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_19      19
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_19      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_19(v)   ((((reg32_t) v) << 19) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_19)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_19(v)   (((v) << 19) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_19 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_19(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_19, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_20 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_20      20
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_20(v)   ((((reg32_t) v) << 20) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_20)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_20(v)   (((v) << 20) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_20 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_20(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_20, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_21 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_21      21
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_21(v)   ((((reg32_t) v) << 21) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_21)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_21(v)   (((v) << 21) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_21 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_21(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_21, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_22 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_22      22
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_22(v)   ((((reg32_t) v) << 22) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_22)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_22(v)   (((v) << 22) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_22 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_22(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_22, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_23 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_23      23
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_23(v)   ((((reg32_t) v) << 23) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_23)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_23(v)   (((v) << 23) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_23 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_23(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_23, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_24 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_24      24
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_24(v)   ((((reg32_t) v) << 24) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_24)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_24(v)   (((v) << 24) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_24 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_24(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_24, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_25 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_25      25
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_25)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_25(v)   (((v) << 25) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_25 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_25(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_25, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_26 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_26      26
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_26)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_26(v)   (((v) << 26) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_26 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_26(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_26, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_27 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_27      27
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_27(v)   ((((reg32_t) v) << 27) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_27)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_27(v)   (((v) << 27) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_27 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_27(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_27, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_28 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_28      28
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_28(v)   ((((reg32_t) v) << 28) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_28)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_28(v)   (((v) << 28) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_28 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_28(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_28, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_29 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_29      29
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_29(v)   ((((reg32_t) v) << 29) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_29)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_29(v)   (((v) << 29) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_29 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_29(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_29, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_3, field IDMAC_NFACK_SDMA_EN_31 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_31      31
#define BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_31(v)   ((((reg32_t) v) << 31) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_31)
#else
#define BF_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_31(v)   (((v) << 31) & BM_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_31 field to a new value.
#define BW_IPU_SDMA_EVENT_3_IDMAC_NFACK_SDMA_EN_31(v)   BF_CS1(IPU_SDMA_EVENT_3, IDMAC_NFACK_SDMA_EN_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SDMA_EVENT_4 - SDMA Event Control Register 4 (RW)
 *
 * This register contains part of IPU SDMA events controls. The controls of NFACK (New Frame
 * Acknowledge) of DMA Channels SDMA events [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_NFACK_SDMA_EN_33 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_NFACK_SDMA_EN_40 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_41 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_42 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_43 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_44 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_45 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_46 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_47 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_48 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_49 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_50 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_51 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_SDMA_EN_52 : 1; //!< Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_sdma_event_4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SDMA_EVENT_4 register
 */
#define HW_IPU_SDMA_EVENT_4_ADDR(x)      (REGS_IPU_BASE(x) + 0x84)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SDMA_EVENT_4(x)           (*(volatile hw_ipu_sdma_event_4_t *) HW_IPU_SDMA_EVENT_4_ADDR(x))
#define HW_IPU_SDMA_EVENT_4_RD(x)        (HW_IPU_SDMA_EVENT_4(x).U)
#define HW_IPU_SDMA_EVENT_4_WR(x, v)     (HW_IPU_SDMA_EVENT_4(x).U = (v))
#define HW_IPU_SDMA_EVENT_4_SET(x, v)    (HW_IPU_SDMA_EVENT_4_WR(x, HW_IPU_SDMA_EVENT_4_RD(x) |  (v)))
#define HW_IPU_SDMA_EVENT_4_CLR(x, v)    (HW_IPU_SDMA_EVENT_4_WR(x, HW_IPU_SDMA_EVENT_4_RD(x) & ~(v)))
#define HW_IPU_SDMA_EVENT_4_TOG(x, v)    (HW_IPU_SDMA_EVENT_4_WR(x, HW_IPU_SDMA_EVENT_4_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SDMA_EVENT_4 bitfields
 */

/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_33 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_33      1
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_33(v)   ((((reg32_t) v) << 1) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_33)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_33(v)   (((v) << 1) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_33 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_33(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_33, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_40 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_40      8
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_40      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_40(v)   ((((reg32_t) v) << 8) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_40)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_40(v)   (((v) << 8) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_40)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_40 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_40(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_40, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_41 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_41      9
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_41(v)   ((((reg32_t) v) << 9) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_41)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_41(v)   (((v) << 9) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_41 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_41(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_41, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_42 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_42      10
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_42(v)   ((((reg32_t) v) << 10) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_42)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_42(v)   (((v) << 10) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_42 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_42(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_42, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_43 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_43      11
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_43(v)   ((((reg32_t) v) << 11) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_43)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_43(v)   (((v) << 11) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_43 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_43(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_43, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_44 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_44      12
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_44(v)   ((((reg32_t) v) << 12) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_44)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_44(v)   (((v) << 12) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_44 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_44(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_44, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_45 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_45      13
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_45(v)   ((((reg32_t) v) << 13) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_45)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_45(v)   (((v) << 13) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_45 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_45(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_45, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_46 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_46      14
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_46(v)   ((((reg32_t) v) << 14) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_46)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_46(v)   (((v) << 14) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_46 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_46(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_46, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_47 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_47      15
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_47(v)   ((((reg32_t) v) << 15) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_47)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_47(v)   (((v) << 15) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_47 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_47(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_47, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_48 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_48      16
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_48(v)   ((((reg32_t) v) << 16) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_48)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_48(v)   (((v) << 16) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_48 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_48(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_48, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_49 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_49      17
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_49(v)   ((((reg32_t) v) << 17) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_49)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_49(v)   (((v) << 17) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_49 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_49(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_49, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_50 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_50      18
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_50(v)   ((((reg32_t) v) << 18) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_50)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_50(v)   (((v) << 18) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_50 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_50(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_50, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_51 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_51      19
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_51(v)   ((((reg32_t) v) << 19) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_51)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_51(v)   (((v) << 19) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_51 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_51(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_51, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_4, field IDMAC_NFACK_SDMA_EN_52 (RW)
 *
 * Enable New Frame Acknowledge of Channel SDMA event. This bit is the control of New Frame
 * Acknowledge of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_52      20
#define BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_52(v)   ((((reg32_t) v) << 20) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_52)
#else
#define BF_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_52(v)   (((v) << 20) & BM_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_NFACK_SDMA_EN_52 field to a new value.
#define BW_IPU_SDMA_EVENT_4_IDMAC_NFACK_SDMA_EN_52(v)   BF_CS1(IPU_SDMA_EVENT_4, IDMAC_NFACK_SDMA_EN_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SDMA_EVENT_7 - SDMA Event Control Register 7 (RW)
 *
 * This register contains part of IPU SDMA events controls. The controls of EOS (End of Scroll) of
 * DMA Channels SDMA events [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 19; //!< Reserved.
        unsigned IDMAC_EOS_SDMA_EN_19 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 3; //!< Reserved.
        unsigned IDMAC_EOS_SDMA_EN_23 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_SDMA_EN_24 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_SDMA_EN_25 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_SDMA_EN_26 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_SDMA_EN_27 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_SDMA_EN_28 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_SDMA_EN_29 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_EOS_SDMA_EN_31 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_sdma_event_7_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SDMA_EVENT_7 register
 */
#define HW_IPU_SDMA_EVENT_7_ADDR(x)      (REGS_IPU_BASE(x) + 0x88)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SDMA_EVENT_7(x)           (*(volatile hw_ipu_sdma_event_7_t *) HW_IPU_SDMA_EVENT_7_ADDR(x))
#define HW_IPU_SDMA_EVENT_7_RD(x)        (HW_IPU_SDMA_EVENT_7(x).U)
#define HW_IPU_SDMA_EVENT_7_WR(x, v)     (HW_IPU_SDMA_EVENT_7(x).U = (v))
#define HW_IPU_SDMA_EVENT_7_SET(x, v)    (HW_IPU_SDMA_EVENT_7_WR(x, HW_IPU_SDMA_EVENT_7_RD(x) |  (v)))
#define HW_IPU_SDMA_EVENT_7_CLR(x, v)    (HW_IPU_SDMA_EVENT_7_WR(x, HW_IPU_SDMA_EVENT_7_RD(x) & ~(v)))
#define HW_IPU_SDMA_EVENT_7_TOG(x, v)    (HW_IPU_SDMA_EVENT_7_WR(x, HW_IPU_SDMA_EVENT_7_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SDMA_EVENT_7 bitfields
 */

/* --- Register HW_IPU_SDMA_EVENT_7, field IDMAC_EOS_SDMA_EN_19 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_19      19
#define BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_19      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_19(v)   ((((reg32_t) v) << 19) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_19)
#else
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_19(v)   (((v) << 19) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_19 field to a new value.
#define BW_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_19(v)   BF_CS1(IPU_SDMA_EVENT_7, IDMAC_EOS_SDMA_EN_19, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_7, field IDMAC_EOS_SDMA_EN_23 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_23      23
#define BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_23(v)   ((((reg32_t) v) << 23) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_23)
#else
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_23(v)   (((v) << 23) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_23 field to a new value.
#define BW_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_23(v)   BF_CS1(IPU_SDMA_EVENT_7, IDMAC_EOS_SDMA_EN_23, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_7, field IDMAC_EOS_SDMA_EN_24 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_24      24
#define BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_24(v)   ((((reg32_t) v) << 24) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_24)
#else
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_24(v)   (((v) << 24) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_24 field to a new value.
#define BW_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_24(v)   BF_CS1(IPU_SDMA_EVENT_7, IDMAC_EOS_SDMA_EN_24, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_7, field IDMAC_EOS_SDMA_EN_25 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_25      25
#define BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_25)
#else
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_25(v)   (((v) << 25) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_25 field to a new value.
#define BW_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_25(v)   BF_CS1(IPU_SDMA_EVENT_7, IDMAC_EOS_SDMA_EN_25, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_7, field IDMAC_EOS_SDMA_EN_26 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_26      26
#define BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_26)
#else
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_26(v)   (((v) << 26) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_26 field to a new value.
#define BW_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_26(v)   BF_CS1(IPU_SDMA_EVENT_7, IDMAC_EOS_SDMA_EN_26, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_7, field IDMAC_EOS_SDMA_EN_27 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_27      27
#define BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_27(v)   ((((reg32_t) v) << 27) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_27)
#else
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_27(v)   (((v) << 27) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_27 field to a new value.
#define BW_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_27(v)   BF_CS1(IPU_SDMA_EVENT_7, IDMAC_EOS_SDMA_EN_27, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_7, field IDMAC_EOS_SDMA_EN_28 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_28      28
#define BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_28(v)   ((((reg32_t) v) << 28) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_28)
#else
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_28(v)   (((v) << 28) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_28 field to a new value.
#define BW_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_28(v)   BF_CS1(IPU_SDMA_EVENT_7, IDMAC_EOS_SDMA_EN_28, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_7, field IDMAC_EOS_SDMA_EN_29 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_29      29
#define BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_29(v)   ((((reg32_t) v) << 29) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_29)
#else
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_29(v)   (((v) << 29) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_29 field to a new value.
#define BW_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_29(v)   BF_CS1(IPU_SDMA_EVENT_7, IDMAC_EOS_SDMA_EN_29, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_7, field IDMAC_EOS_SDMA_EN_31 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_31      31
#define BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_31(v)   ((((reg32_t) v) << 31) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_31)
#else
#define BF_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_31(v)   (((v) << 31) & BM_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_31 field to a new value.
#define BW_IPU_SDMA_EVENT_7_IDMAC_EOS_SDMA_EN_31(v)   BF_CS1(IPU_SDMA_EVENT_7, IDMAC_EOS_SDMA_EN_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SDMA_EVENT_8 - SDMA Event Control Register 8 (RW)
 *
 * This register contains part of IPU SDMA events controls. The controls of EOS (End of Scroll) of
 * DMA Channels SDMA events [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_EOS_SDMA_EN_33 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 7; //!< Reserved.
        unsigned IDMAC_EOS_SDMA_EN_41 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_SDMA_EN_42 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_SDMA_EN_43 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_SDMA_EN_44 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 6; //!< Reserved.
        unsigned IDMAC_EOS_SDMA_EN_51 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_SDMA_EN_52 : 1; //!< Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 11; //!< Reserved.
    } B;
} hw_ipu_sdma_event_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SDMA_EVENT_8 register
 */
#define HW_IPU_SDMA_EVENT_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x8c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SDMA_EVENT_8(x)           (*(volatile hw_ipu_sdma_event_8_t *) HW_IPU_SDMA_EVENT_8_ADDR(x))
#define HW_IPU_SDMA_EVENT_8_RD(x)        (HW_IPU_SDMA_EVENT_8(x).U)
#define HW_IPU_SDMA_EVENT_8_WR(x, v)     (HW_IPU_SDMA_EVENT_8(x).U = (v))
#define HW_IPU_SDMA_EVENT_8_SET(x, v)    (HW_IPU_SDMA_EVENT_8_WR(x, HW_IPU_SDMA_EVENT_8_RD(x) |  (v)))
#define HW_IPU_SDMA_EVENT_8_CLR(x, v)    (HW_IPU_SDMA_EVENT_8_WR(x, HW_IPU_SDMA_EVENT_8_RD(x) & ~(v)))
#define HW_IPU_SDMA_EVENT_8_TOG(x, v)    (HW_IPU_SDMA_EVENT_8_WR(x, HW_IPU_SDMA_EVENT_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SDMA_EVENT_8 bitfields
 */

/* --- Register HW_IPU_SDMA_EVENT_8, field IDMAC_EOS_SDMA_EN_33 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_33      1
#define BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_33(v)   ((((reg32_t) v) << 1) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_33)
#else
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_33(v)   (((v) << 1) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_33 field to a new value.
#define BW_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_33(v)   BF_CS1(IPU_SDMA_EVENT_8, IDMAC_EOS_SDMA_EN_33, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_8, field IDMAC_EOS_SDMA_EN_41 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_41      9
#define BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_41(v)   ((((reg32_t) v) << 9) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_41)
#else
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_41(v)   (((v) << 9) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_41 field to a new value.
#define BW_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_41(v)   BF_CS1(IPU_SDMA_EVENT_8, IDMAC_EOS_SDMA_EN_41, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_8, field IDMAC_EOS_SDMA_EN_42 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_42      10
#define BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_42(v)   ((((reg32_t) v) << 10) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_42)
#else
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_42(v)   (((v) << 10) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_42 field to a new value.
#define BW_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_42(v)   BF_CS1(IPU_SDMA_EVENT_8, IDMAC_EOS_SDMA_EN_42, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_8, field IDMAC_EOS_SDMA_EN_43 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_43      11
#define BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_43(v)   ((((reg32_t) v) << 11) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_43)
#else
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_43(v)   (((v) << 11) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_43 field to a new value.
#define BW_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_43(v)   BF_CS1(IPU_SDMA_EVENT_8, IDMAC_EOS_SDMA_EN_43, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_8, field IDMAC_EOS_SDMA_EN_44 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_44      12
#define BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_44(v)   ((((reg32_t) v) << 12) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_44)
#else
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_44(v)   (((v) << 12) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_44 field to a new value.
#define BW_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_44(v)   BF_CS1(IPU_SDMA_EVENT_8, IDMAC_EOS_SDMA_EN_44, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_8, field IDMAC_EOS_SDMA_EN_51 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_51      19
#define BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_51(v)   ((((reg32_t) v) << 19) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_51)
#else
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_51(v)   (((v) << 19) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_51 field to a new value.
#define BW_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_51(v)   BF_CS1(IPU_SDMA_EVENT_8, IDMAC_EOS_SDMA_EN_51, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_8, field IDMAC_EOS_SDMA_EN_52 (RW)
 *
 * Enable End of Scroll of Channel SDMA event. This bit is the control of End Of Scroll of Channel
 * #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_52      20
#define BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_52(v)   ((((reg32_t) v) << 20) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_52)
#else
#define BF_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_52(v)   (((v) << 20) & BM_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOS_SDMA_EN_52 field to a new value.
#define BW_IPU_SDMA_EVENT_8_IDMAC_EOS_SDMA_EN_52(v)   BF_CS1(IPU_SDMA_EVENT_8, IDMAC_EOS_SDMA_EN_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SDMA_EVENT_11 - SDMA Event Control Register 11 (RW)
 *
 * This register contains part of IPU SDMA events controls. The controls of EOBND (End of Band) of
 * DMA Channels SDMA events [31:0] can be found in this register.  Editor's Note: The conditional
 * tag settings should be   Hide VDOA_SYNC for all versions  Show VDOA_SYNC for IPUv3H version.  The
 * table below tagged with other settings (like IPU3M_only) should be hidden in IPUv3H version.
 * This requires some sophisticated conditional tag settings
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_EOBND_SDMA_EN_0 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_SDMA_EN_1 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_SDMA_EN_2 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_SDMA_EN_3 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_EOBND_SDMA_EN_5 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 5; //!< Reserved.
        unsigned IDMAC_EOBND_SDMA_EN_11 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_SDMA_EN_12 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 7; //!< Reserved.
        unsigned IDMAC_EOBND_SDMA_EN_20 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_SDMA_EN_21 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_SDMA_EN_22 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 2; //!< Reserved.
        unsigned IDMAC_EOBND_SDMA_EN_25 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_SDMA_EN_26 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED4 : 5; //!< Reserved.
    } B;
} hw_ipu_sdma_event_11_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SDMA_EVENT_11 register
 */
#define HW_IPU_SDMA_EVENT_11_ADDR(x)      (REGS_IPU_BASE(x) + 0x90)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SDMA_EVENT_11(x)           (*(volatile hw_ipu_sdma_event_11_t *) HW_IPU_SDMA_EVENT_11_ADDR(x))
#define HW_IPU_SDMA_EVENT_11_RD(x)        (HW_IPU_SDMA_EVENT_11(x).U)
#define HW_IPU_SDMA_EVENT_11_WR(x, v)     (HW_IPU_SDMA_EVENT_11(x).U = (v))
#define HW_IPU_SDMA_EVENT_11_SET(x, v)    (HW_IPU_SDMA_EVENT_11_WR(x, HW_IPU_SDMA_EVENT_11_RD(x) |  (v)))
#define HW_IPU_SDMA_EVENT_11_CLR(x, v)    (HW_IPU_SDMA_EVENT_11_WR(x, HW_IPU_SDMA_EVENT_11_RD(x) & ~(v)))
#define HW_IPU_SDMA_EVENT_11_TOG(x, v)    (HW_IPU_SDMA_EVENT_11_WR(x, HW_IPU_SDMA_EVENT_11_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SDMA_EVENT_11 bitfields
 */

/* --- Register HW_IPU_SDMA_EVENT_11, field IDMAC_EOBND_SDMA_EN_0 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_0      0
#define BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_0)
#else
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_0(v)   (((v) << 0) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_0 field to a new value.
#define BW_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_0(v)   BF_CS1(IPU_SDMA_EVENT_11, IDMAC_EOBND_SDMA_EN_0, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_11, field IDMAC_EOBND_SDMA_EN_1 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_1      1
#define BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_1(v)   ((((reg32_t) v) << 1) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_1)
#else
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_1(v)   (((v) << 1) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_1 field to a new value.
#define BW_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_1(v)   BF_CS1(IPU_SDMA_EVENT_11, IDMAC_EOBND_SDMA_EN_1, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_11, field IDMAC_EOBND_SDMA_EN_2 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_2      2
#define BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_2(v)   ((((reg32_t) v) << 2) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_2)
#else
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_2(v)   (((v) << 2) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_2 field to a new value.
#define BW_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_2(v)   BF_CS1(IPU_SDMA_EVENT_11, IDMAC_EOBND_SDMA_EN_2, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_11, field IDMAC_EOBND_SDMA_EN_3 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_3      3
#define BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_3(v)   ((((reg32_t) v) << 3) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_3)
#else
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_3(v)   (((v) << 3) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_3 field to a new value.
#define BW_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_3(v)   BF_CS1(IPU_SDMA_EVENT_11, IDMAC_EOBND_SDMA_EN_3, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_11, field IDMAC_EOBND_SDMA_EN_5 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_5      5
#define BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_5(v)   ((((reg32_t) v) << 5) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_5)
#else
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_5(v)   (((v) << 5) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_5 field to a new value.
#define BW_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_5(v)   BF_CS1(IPU_SDMA_EVENT_11, IDMAC_EOBND_SDMA_EN_5, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_11, field IDMAC_EOBND_SDMA_EN_11 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_11      11
#define BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_11(v)   ((((reg32_t) v) << 11) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_11)
#else
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_11(v)   (((v) << 11) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_11 field to a new value.
#define BW_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_11(v)   BF_CS1(IPU_SDMA_EVENT_11, IDMAC_EOBND_SDMA_EN_11, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_11, field IDMAC_EOBND_SDMA_EN_12 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_12      12
#define BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_12(v)   ((((reg32_t) v) << 12) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_12)
#else
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_12(v)   (((v) << 12) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_12 field to a new value.
#define BW_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_12(v)   BF_CS1(IPU_SDMA_EVENT_11, IDMAC_EOBND_SDMA_EN_12, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_11, field IDMAC_EOBND_SDMA_EN_20 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_20      20
#define BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_20(v)   ((((reg32_t) v) << 20) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_20)
#else
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_20(v)   (((v) << 20) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_20 field to a new value.
#define BW_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_20(v)   BF_CS1(IPU_SDMA_EVENT_11, IDMAC_EOBND_SDMA_EN_20, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_11, field IDMAC_EOBND_SDMA_EN_21 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_21      21
#define BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_21(v)   ((((reg32_t) v) << 21) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_21)
#else
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_21(v)   (((v) << 21) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_21 field to a new value.
#define BW_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_21(v)   BF_CS1(IPU_SDMA_EVENT_11, IDMAC_EOBND_SDMA_EN_21, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_11, field IDMAC_EOBND_SDMA_EN_22 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_22      22
#define BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_22(v)   ((((reg32_t) v) << 22) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_22)
#else
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_22(v)   (((v) << 22) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_22 field to a new value.
#define BW_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_22(v)   BF_CS1(IPU_SDMA_EVENT_11, IDMAC_EOBND_SDMA_EN_22, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_11, field IDMAC_EOBND_SDMA_EN_25 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_25      25
#define BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_25)
#else
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_25(v)   (((v) << 25) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_25 field to a new value.
#define BW_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_25(v)   BF_CS1(IPU_SDMA_EVENT_11, IDMAC_EOBND_SDMA_EN_25, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_11, field IDMAC_EOBND_SDMA_EN_26 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_26      26
#define BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_26)
#else
#define BF_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_26(v)   (((v) << 26) & BM_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_26 field to a new value.
#define BW_IPU_SDMA_EVENT_11_IDMAC_EOBND_SDMA_EN_26(v)   BF_CS1(IPU_SDMA_EVENT_11, IDMAC_EOBND_SDMA_EN_26, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SDMA_EVENT_12 - SDMA Event Control Register 12 (RW)
 *
 * This register contains part of IPU SDMA events controls. The controls of EOBND (End of Band) of
 * DMA Channels SDMA events [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 13; //!< Reserved.
        unsigned IDMAC_EOBND_SDMA_EN_45 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_SDMA_EN_46 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_SDMA_EN_47 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_SDMA_EN_48 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_SDMA_EN_49 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_SDMA_EN_50 : 1; //!< Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 13; //!< Reserved.
    } B;
} hw_ipu_sdma_event_12_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SDMA_EVENT_12 register
 */
#define HW_IPU_SDMA_EVENT_12_ADDR(x)      (REGS_IPU_BASE(x) + 0x94)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SDMA_EVENT_12(x)           (*(volatile hw_ipu_sdma_event_12_t *) HW_IPU_SDMA_EVENT_12_ADDR(x))
#define HW_IPU_SDMA_EVENT_12_RD(x)        (HW_IPU_SDMA_EVENT_12(x).U)
#define HW_IPU_SDMA_EVENT_12_WR(x, v)     (HW_IPU_SDMA_EVENT_12(x).U = (v))
#define HW_IPU_SDMA_EVENT_12_SET(x, v)    (HW_IPU_SDMA_EVENT_12_WR(x, HW_IPU_SDMA_EVENT_12_RD(x) |  (v)))
#define HW_IPU_SDMA_EVENT_12_CLR(x, v)    (HW_IPU_SDMA_EVENT_12_WR(x, HW_IPU_SDMA_EVENT_12_RD(x) & ~(v)))
#define HW_IPU_SDMA_EVENT_12_TOG(x, v)    (HW_IPU_SDMA_EVENT_12_WR(x, HW_IPU_SDMA_EVENT_12_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SDMA_EVENT_12 bitfields
 */

/* --- Register HW_IPU_SDMA_EVENT_12, field IDMAC_EOBND_SDMA_EN_45 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_45      13
#define BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_45(v)   ((((reg32_t) v) << 13) & BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_45)
#else
#define BF_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_45(v)   (((v) << 13) & BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_45 field to a new value.
#define BW_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_45(v)   BF_CS1(IPU_SDMA_EVENT_12, IDMAC_EOBND_SDMA_EN_45, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_12, field IDMAC_EOBND_SDMA_EN_46 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_46      14
#define BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_46(v)   ((((reg32_t) v) << 14) & BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_46)
#else
#define BF_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_46(v)   (((v) << 14) & BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_46 field to a new value.
#define BW_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_46(v)   BF_CS1(IPU_SDMA_EVENT_12, IDMAC_EOBND_SDMA_EN_46, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_12, field IDMAC_EOBND_SDMA_EN_47 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_47      15
#define BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_47(v)   ((((reg32_t) v) << 15) & BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_47)
#else
#define BF_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_47(v)   (((v) << 15) & BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_47 field to a new value.
#define BW_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_47(v)   BF_CS1(IPU_SDMA_EVENT_12, IDMAC_EOBND_SDMA_EN_47, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_12, field IDMAC_EOBND_SDMA_EN_48 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_48      16
#define BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_48(v)   ((((reg32_t) v) << 16) & BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_48)
#else
#define BF_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_48(v)   (((v) << 16) & BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_48 field to a new value.
#define BW_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_48(v)   BF_CS1(IPU_SDMA_EVENT_12, IDMAC_EOBND_SDMA_EN_48, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_12, field IDMAC_EOBND_SDMA_EN_49 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_49      17
#define BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_49(v)   ((((reg32_t) v) << 17) & BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_49)
#else
#define BF_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_49(v)   (((v) << 17) & BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_49 field to a new value.
#define BW_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_49(v)   BF_CS1(IPU_SDMA_EVENT_12, IDMAC_EOBND_SDMA_EN_49, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_12, field IDMAC_EOBND_SDMA_EN_50 (RW)
 *
 * Enable End of Band of Channel SDMA event. This bit is the control of End Of Band of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_50      18
#define BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_50(v)   ((((reg32_t) v) << 18) & BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_50)
#else
#define BF_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_50(v)   (((v) << 18) & BM_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_EOBND_SDMA_EN_50 field to a new value.
#define BW_IPU_SDMA_EVENT_12_IDMAC_EOBND_SDMA_EN_50(v)   BF_CS1(IPU_SDMA_EVENT_12, IDMAC_EOBND_SDMA_EN_50, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SDMA_EVENT_13 - SDMA Event Control Register 13 (RW)
 *
 * This register contains part of IPU SDMA events controls. The controls of TH (Threshold) of DMA
 * Channels SDMA events [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_TH_SDMA_EN_0 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_1 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_2 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_3 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_TH_SDMA_EN_5 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_TH_SDMA_EN_8 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_9 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_10 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_11 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_12 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_13 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_14 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_15 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_TH_SDMA_EN_17 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_18 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_19 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_20 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_21 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_22 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_23 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_24 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_25 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_26 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_27 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_28 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_29 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_TH_SDMA_EN_31 : 1; //!< Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_sdma_event_13_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SDMA_EVENT_13 register
 */
#define HW_IPU_SDMA_EVENT_13_ADDR(x)      (REGS_IPU_BASE(x) + 0x98)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SDMA_EVENT_13(x)           (*(volatile hw_ipu_sdma_event_13_t *) HW_IPU_SDMA_EVENT_13_ADDR(x))
#define HW_IPU_SDMA_EVENT_13_RD(x)        (HW_IPU_SDMA_EVENT_13(x).U)
#define HW_IPU_SDMA_EVENT_13_WR(x, v)     (HW_IPU_SDMA_EVENT_13(x).U = (v))
#define HW_IPU_SDMA_EVENT_13_SET(x, v)    (HW_IPU_SDMA_EVENT_13_WR(x, HW_IPU_SDMA_EVENT_13_RD(x) |  (v)))
#define HW_IPU_SDMA_EVENT_13_CLR(x, v)    (HW_IPU_SDMA_EVENT_13_WR(x, HW_IPU_SDMA_EVENT_13_RD(x) & ~(v)))
#define HW_IPU_SDMA_EVENT_13_TOG(x, v)    (HW_IPU_SDMA_EVENT_13_WR(x, HW_IPU_SDMA_EVENT_13_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SDMA_EVENT_13 bitfields
 */

/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_0 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_0      0
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_0)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_0(v)   (((v) << 0) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_0 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_0(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_0, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_1 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_1      1
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_1(v)   ((((reg32_t) v) << 1) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_1)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_1(v)   (((v) << 1) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_1 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_1(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_1, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_2 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_2      2
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_2(v)   ((((reg32_t) v) << 2) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_2)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_2(v)   (((v) << 2) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_2 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_2(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_2, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_3 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_3      3
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_3(v)   ((((reg32_t) v) << 3) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_3)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_3(v)   (((v) << 3) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_3 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_3(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_3, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_5 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_5      5
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_5(v)   ((((reg32_t) v) << 5) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_5)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_5(v)   (((v) << 5) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_5 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_5(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_5, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_8 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_8      8
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_8(v)   ((((reg32_t) v) << 8) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_8)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_8(v)   (((v) << 8) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_8 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_8(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_8, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_9 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_9      9
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_9(v)   ((((reg32_t) v) << 9) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_9)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_9(v)   (((v) << 9) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_9 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_9(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_9, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_10 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_10      10
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_10(v)   ((((reg32_t) v) << 10) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_10)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_10(v)   (((v) << 10) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_10 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_10(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_10, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_11 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_11      11
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_11(v)   ((((reg32_t) v) << 11) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_11)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_11(v)   (((v) << 11) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_11 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_11(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_11, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_12 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_12      12
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_12(v)   ((((reg32_t) v) << 12) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_12)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_12(v)   (((v) << 12) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_12 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_12(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_12, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_13 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_13      13
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_13(v)   ((((reg32_t) v) << 13) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_13)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_13(v)   (((v) << 13) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_13 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_13(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_13, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_14 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_14      14
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_14(v)   ((((reg32_t) v) << 14) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_14)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_14(v)   (((v) << 14) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_14 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_14(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_14, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_15 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_15      15
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_15(v)   ((((reg32_t) v) << 15) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_15)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_15(v)   (((v) << 15) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_15 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_15(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_15, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_17 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_17      17
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_17      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_17(v)   ((((reg32_t) v) << 17) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_17)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_17(v)   (((v) << 17) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_17 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_17(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_17, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_18 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_18      18
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_18      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_18(v)   ((((reg32_t) v) << 18) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_18)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_18(v)   (((v) << 18) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_18 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_18(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_18, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_19 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_19      19
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_19      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_19(v)   ((((reg32_t) v) << 19) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_19)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_19(v)   (((v) << 19) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_19 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_19(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_19, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_20 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_20      20
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_20(v)   ((((reg32_t) v) << 20) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_20)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_20(v)   (((v) << 20) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_20 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_20(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_20, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_21 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_21      21
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_21(v)   ((((reg32_t) v) << 21) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_21)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_21(v)   (((v) << 21) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_21 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_21(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_21, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_22 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_22      22
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_22(v)   ((((reg32_t) v) << 22) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_22)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_22(v)   (((v) << 22) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_22 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_22(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_22, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_23 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_23      23
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_23(v)   ((((reg32_t) v) << 23) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_23)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_23(v)   (((v) << 23) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_23 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_23(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_23, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_24 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_24      24
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_24(v)   ((((reg32_t) v) << 24) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_24)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_24(v)   (((v) << 24) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_24 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_24(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_24, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_25 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_25      25
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_25)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_25(v)   (((v) << 25) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_25 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_25(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_25, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_26 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_26      26
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_26)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_26(v)   (((v) << 26) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_26 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_26(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_26, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_27 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_27      27
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_27(v)   ((((reg32_t) v) << 27) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_27)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_27(v)   (((v) << 27) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_27 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_27(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_27, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_28 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_28      28
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_28(v)   ((((reg32_t) v) << 28) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_28)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_28(v)   (((v) << 28) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_28 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_28(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_28, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_29 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_29      29
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_29(v)   ((((reg32_t) v) << 29) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_29)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_29(v)   (((v) << 29) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_29 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_29(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_29, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_13, field IDMAC_TH_SDMA_EN_31 (RW)
 *
 * Enable Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_31      31
#define BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_31(v)   ((((reg32_t) v) << 31) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_31)
#else
#define BF_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_31(v)   (((v) << 31) & BM_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_31 field to a new value.
#define BW_IPU_SDMA_EVENT_13_IDMAC_TH_SDMA_EN_31(v)   BF_CS1(IPU_SDMA_EVENT_13, IDMAC_TH_SDMA_EN_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SDMA_EVENT_14 - SDMA Event Control Register 14 (RW)
 *
 * This register contains part of IPU SDMA events controls. The controls of TH (Threshold) of DMA
 * Channels SDMA events [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_TH_SDMA_EN_33 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_TH_SDMA_EN_40 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_41 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_42 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_43 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_44 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_45 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_46 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_47 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_48 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_49 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_50 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_51 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_SDMA_EN_52 : 1; //!< Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_sdma_event_14_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SDMA_EVENT_14 register
 */
#define HW_IPU_SDMA_EVENT_14_ADDR(x)      (REGS_IPU_BASE(x) + 0x9c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SDMA_EVENT_14(x)           (*(volatile hw_ipu_sdma_event_14_t *) HW_IPU_SDMA_EVENT_14_ADDR(x))
#define HW_IPU_SDMA_EVENT_14_RD(x)        (HW_IPU_SDMA_EVENT_14(x).U)
#define HW_IPU_SDMA_EVENT_14_WR(x, v)     (HW_IPU_SDMA_EVENT_14(x).U = (v))
#define HW_IPU_SDMA_EVENT_14_SET(x, v)    (HW_IPU_SDMA_EVENT_14_WR(x, HW_IPU_SDMA_EVENT_14_RD(x) |  (v)))
#define HW_IPU_SDMA_EVENT_14_CLR(x, v)    (HW_IPU_SDMA_EVENT_14_WR(x, HW_IPU_SDMA_EVENT_14_RD(x) & ~(v)))
#define HW_IPU_SDMA_EVENT_14_TOG(x, v)    (HW_IPU_SDMA_EVENT_14_WR(x, HW_IPU_SDMA_EVENT_14_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SDMA_EVENT_14 bitfields
 */

/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_33 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_33      1
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_33(v)   ((((reg32_t) v) << 1) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_33)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_33(v)   (((v) << 1) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_33 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_33(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_33, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_40 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_40      8
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_40      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_40(v)   ((((reg32_t) v) << 8) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_40)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_40(v)   (((v) << 8) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_40)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_40 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_40(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_40, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_41 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_41      9
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_41(v)   ((((reg32_t) v) << 9) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_41)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_41(v)   (((v) << 9) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_41 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_41(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_41, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_42 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_42      10
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_42(v)   ((((reg32_t) v) << 10) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_42)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_42(v)   (((v) << 10) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_42 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_42(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_42, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_43 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_43      11
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_43(v)   ((((reg32_t) v) << 11) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_43)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_43(v)   (((v) << 11) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_43 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_43(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_43, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_44 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_44      12
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_44(v)   ((((reg32_t) v) << 12) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_44)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_44(v)   (((v) << 12) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_44 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_44(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_44, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_45 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_45      13
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_45(v)   ((((reg32_t) v) << 13) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_45)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_45(v)   (((v) << 13) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_45 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_45(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_45, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_46 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_46      14
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_46(v)   ((((reg32_t) v) << 14) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_46)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_46(v)   (((v) << 14) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_46 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_46(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_46, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_47 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_47      15
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_47(v)   ((((reg32_t) v) << 15) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_47)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_47(v)   (((v) << 15) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_47 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_47(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_47, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_48 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_48      16
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_48(v)   ((((reg32_t) v) << 16) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_48)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_48(v)   (((v) << 16) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_48 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_48(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_48, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_49 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_49      17
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_49(v)   ((((reg32_t) v) << 17) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_49)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_49(v)   (((v) << 17) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_49 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_49(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_49, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_50 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_50      18
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_50(v)   ((((reg32_t) v) << 18) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_50)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_50(v)   (((v) << 18) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_50 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_50(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_50, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_51 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_51      19
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_51(v)   ((((reg32_t) v) << 19) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_51)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_51(v)   (((v) << 19) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_51 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_51(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_51, v)
#endif


/* --- Register HW_IPU_SDMA_EVENT_14, field IDMAC_TH_SDMA_EN_52 (RW)
 *
 * Threshold of Channel SDMA event. This bit is the control of Threshold of Channel #n. n Indicates
 * the corresponding DMA channel number. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - SDMA event is disabled.
 * 1 - SDMA event is enabled.
 */

#define BP_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_52      20
#define BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_52(v)   ((((reg32_t) v) << 20) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_52)
#else
#define BF_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_52(v)   (((v) << 20) & BM_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_TH_SDMA_EN_52 field to a new value.
#define BW_IPU_SDMA_EVENT_14_IDMAC_TH_SDMA_EN_52(v)   BF_CS1(IPU_SDMA_EVENT_14, IDMAC_TH_SDMA_EN_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SRM_PRI1 - Shadow Registers Memory Priority 1 Register (RW)
 *
 * The register controls the priority of SRM updates. The priority level for each block that has a
 * shadow of its registers in the SRM should be unique. The priority level defines the order of SRM
 * updates. A block with priority set to 010 will be updated before a block with priority set to
 * 001.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_SRM_PRI : 3; //!< CSI1 SRM priority This bits define the priority of the CSI0 module
        unsigned CSI1_SRM_MODE : 2; //!< CSI1 SRM Mode This field controls the SRM logic that handles the CSI1 registers
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned CSI0_SRM_PRI : 3; //!< CSI0 SRM priority This bits define the priority of the CSI1 block
        unsigned CSI0_SRM_MODE : 2; //!< CSI0 SRM Mode This field controls the SRM logic that handles the CSI0 registers
        unsigned RESERVED1 : 19; //!< Reserved
    } B;
} hw_ipu_srm_pri1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SRM_PRI1 register
 */
#define HW_IPU_SRM_PRI1_ADDR(x)      (REGS_IPU_BASE(x) + 0xa0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SRM_PRI1(x)           (*(volatile hw_ipu_srm_pri1_t *) HW_IPU_SRM_PRI1_ADDR(x))
#define HW_IPU_SRM_PRI1_RD(x)        (HW_IPU_SRM_PRI1(x).U)
#define HW_IPU_SRM_PRI1_WR(x, v)     (HW_IPU_SRM_PRI1(x).U = (v))
#define HW_IPU_SRM_PRI1_SET(x, v)    (HW_IPU_SRM_PRI1_WR(x, HW_IPU_SRM_PRI1_RD(x) |  (v)))
#define HW_IPU_SRM_PRI1_CLR(x, v)    (HW_IPU_SRM_PRI1_WR(x, HW_IPU_SRM_PRI1_RD(x) & ~(v)))
#define HW_IPU_SRM_PRI1_TOG(x, v)    (HW_IPU_SRM_PRI1_WR(x, HW_IPU_SRM_PRI1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SRM_PRI1 bitfields
 */

/* --- Register HW_IPU_SRM_PRI1, field CSI1_SRM_PRI (RW)
 *
 * CSI1 SRM priority This bits define the priority of the CSI0 module
 */

#define BP_IPU_SRM_PRI1_CSI1_SRM_PRI      0
#define BM_IPU_SRM_PRI1_CSI1_SRM_PRI      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI1_CSI1_SRM_PRI(v)   ((((reg32_t) v) << 0) & BM_IPU_SRM_PRI1_CSI1_SRM_PRI)
#else
#define BF_IPU_SRM_PRI1_CSI1_SRM_PRI(v)   (((v) << 0) & BM_IPU_SRM_PRI1_CSI1_SRM_PRI)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_SRM_PRI field to a new value.
#define BW_IPU_SRM_PRI1_CSI1_SRM_PRI(v)   BF_CS1(IPU_SRM_PRI1, CSI1_SRM_PRI, v)
#endif

/* --- Register HW_IPU_SRM_PRI1, field CSI1_SRM_MODE (RW)
 *
 * CSI1 SRM Mode This field controls the SRM logic that handles the CSI1 registers
 *
 * Values:
 * 00 - Automatic swapping is disabled; ARM platform is allowed to access the CSI0's region in the RAM
 * 01 - The SRM logic is controlled by the FSU. The update will be done of the next frame.
 * 10 - The SRM logic is controlled by the FSU. Registers are swapped continuously frame by frame
 * 11 - Update now. The SRM is controlled by the ARM platform. The Register will be update now
 */

#define BP_IPU_SRM_PRI1_CSI1_SRM_MODE      3
#define BM_IPU_SRM_PRI1_CSI1_SRM_MODE      0x00000018

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI1_CSI1_SRM_MODE(v)   ((((reg32_t) v) << 3) & BM_IPU_SRM_PRI1_CSI1_SRM_MODE)
#else
#define BF_IPU_SRM_PRI1_CSI1_SRM_MODE(v)   (((v) << 3) & BM_IPU_SRM_PRI1_CSI1_SRM_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_SRM_MODE field to a new value.
#define BW_IPU_SRM_PRI1_CSI1_SRM_MODE(v)   BF_CS1(IPU_SRM_PRI1, CSI1_SRM_MODE, v)
#endif


/* --- Register HW_IPU_SRM_PRI1, field CSI0_SRM_PRI (RW)
 *
 * CSI0 SRM priority This bits define the priority of the CSI1 block
 */

#define BP_IPU_SRM_PRI1_CSI0_SRM_PRI      8
#define BM_IPU_SRM_PRI1_CSI0_SRM_PRI      0x00000700

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI1_CSI0_SRM_PRI(v)   ((((reg32_t) v) << 8) & BM_IPU_SRM_PRI1_CSI0_SRM_PRI)
#else
#define BF_IPU_SRM_PRI1_CSI0_SRM_PRI(v)   (((v) << 8) & BM_IPU_SRM_PRI1_CSI0_SRM_PRI)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_SRM_PRI field to a new value.
#define BW_IPU_SRM_PRI1_CSI0_SRM_PRI(v)   BF_CS1(IPU_SRM_PRI1, CSI0_SRM_PRI, v)
#endif

/* --- Register HW_IPU_SRM_PRI1, field CSI0_SRM_MODE (RW)
 *
 * CSI0 SRM Mode This field controls the SRM logic that handles the CSI0 registers
 *
 * Values:
 * 00 - Automatic swapping is disabled; ARM platform is allowed to access the CSI1's region in the RAM
 * 01 - The SRM logic is controlled by the FSU. The update will be done of the next frame.
 * 10 - The SRM logic is controlled by the FSU. Registers are swapped continuously frame by frame
 * 11 - Update now. The SRM is controlled by the ARM Platform. The Register will be update now
 */

#define BP_IPU_SRM_PRI1_CSI0_SRM_MODE      11
#define BM_IPU_SRM_PRI1_CSI0_SRM_MODE      0x00001800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI1_CSI0_SRM_MODE(v)   ((((reg32_t) v) << 11) & BM_IPU_SRM_PRI1_CSI0_SRM_MODE)
#else
#define BF_IPU_SRM_PRI1_CSI0_SRM_MODE(v)   (((v) << 11) & BM_IPU_SRM_PRI1_CSI0_SRM_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_SRM_MODE field to a new value.
#define BW_IPU_SRM_PRI1_CSI0_SRM_MODE(v)   BF_CS1(IPU_SRM_PRI1, CSI0_SRM_MODE, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SRM_PRI2 - Shadow Registers Memory Priority 2 Register (RW)
 *
 * The register controls the priority of SRM updates. The priority level for each block that has a
 * shadow of its registers in the SRM should be unique. The priority level defines the order of SRM
 * updates. a block with priority set to 010 will be updated before a block with priority set to
 * 001.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_SRM_PRI : 3; //!< DP SRM priority This bits define the priority of the DP module
        unsigned DP_S_SRM_MODE : 2; //!< DP sync flow SRM Mode This field controls the SRM logic that handles the DP sync flow registers
        unsigned DP_A0_SRM_MODE : 2; //!< DP Async flow #0 SRM Mode This field controls the SRM logic that handles the DP Async flow #0 registers
        unsigned DP_A1_SRM_MODE : 2; //!< DP Async flow #1 SRM Mode This field controls the SRM logic that handles the DP Async flow #1 registers
        unsigned DC_SRM_PRI : 3; //!< DC SRM priority This bits define the priority of the DC module
        unsigned DC_2_SRM_MODE : 2; //!< DC Group #2 SRM Mode This field controls the SRM logic that handles the DC Group #2 registers
        unsigned DC_6_SRM_MODE : 2; //!< DC Group #6 SRM Mode This field controls the SRM logic that handles the DC Group #6 registers
        unsigned DI0_SRM_PRI : 3; //!< DI0 SRM priority This bits define the priority of the DI0 module
        unsigned DI0_SRM_MCU_USE : 2; //!< DI0 SRM is used by ARM platform This bit indicates that the registers of the DI0 are currently being updated by the ARM platform. The ARM platform should set this bit before accessing the SRM part that is relevant to the DI0. The ARM platform should clear this bit when the update procedure is finished. When this bit is set the SRM mechanism will not update the DI0's registers to avoid data coherency problems.
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned DI1_SRM_PRI : 3; //!< DI1 SRM priority This bits define the priority of the DI1 module
        unsigned DI1_SRM_MODE : 2; //!< DCI1 SRM Mode This field controls the SRM logic that handles the DI1 registers
        unsigned RESERVED1 : 3; //!< Reserved
    } B;
} hw_ipu_srm_pri2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SRM_PRI2 register
 */
#define HW_IPU_SRM_PRI2_ADDR(x)      (REGS_IPU_BASE(x) + 0xa4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SRM_PRI2(x)           (*(volatile hw_ipu_srm_pri2_t *) HW_IPU_SRM_PRI2_ADDR(x))
#define HW_IPU_SRM_PRI2_RD(x)        (HW_IPU_SRM_PRI2(x).U)
#define HW_IPU_SRM_PRI2_WR(x, v)     (HW_IPU_SRM_PRI2(x).U = (v))
#define HW_IPU_SRM_PRI2_SET(x, v)    (HW_IPU_SRM_PRI2_WR(x, HW_IPU_SRM_PRI2_RD(x) |  (v)))
#define HW_IPU_SRM_PRI2_CLR(x, v)    (HW_IPU_SRM_PRI2_WR(x, HW_IPU_SRM_PRI2_RD(x) & ~(v)))
#define HW_IPU_SRM_PRI2_TOG(x, v)    (HW_IPU_SRM_PRI2_WR(x, HW_IPU_SRM_PRI2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SRM_PRI2 bitfields
 */

/* --- Register HW_IPU_SRM_PRI2, field DP_SRM_PRI (RW)
 *
 * DP SRM priority This bits define the priority of the DP module
 */

#define BP_IPU_SRM_PRI2_DP_SRM_PRI      0
#define BM_IPU_SRM_PRI2_DP_SRM_PRI      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI2_DP_SRM_PRI(v)   ((((reg32_t) v) << 0) & BM_IPU_SRM_PRI2_DP_SRM_PRI)
#else
#define BF_IPU_SRM_PRI2_DP_SRM_PRI(v)   (((v) << 0) & BM_IPU_SRM_PRI2_DP_SRM_PRI)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_SRM_PRI field to a new value.
#define BW_IPU_SRM_PRI2_DP_SRM_PRI(v)   BF_CS1(IPU_SRM_PRI2, DP_SRM_PRI, v)
#endif

/* --- Register HW_IPU_SRM_PRI2, field DP_S_SRM_MODE (RW)
 *
 * DP sync flow SRM Mode This field controls the SRM logic that handles the DP sync flow registers
 *
 * Values:
 * 00 - Automatic swapping is disabled; ARM platform is allowed to access the DP sync flow region in the RAM
 * 01 - The SRM logic is controlled by the FSU. The update will be done on the next frame.
 * 10 - Reserved
 * 11 - Update now. The SRM is controlled by the ARM platform. The Register will be update now
 */

#define BP_IPU_SRM_PRI2_DP_S_SRM_MODE      3
#define BM_IPU_SRM_PRI2_DP_S_SRM_MODE      0x00000018

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI2_DP_S_SRM_MODE(v)   ((((reg32_t) v) << 3) & BM_IPU_SRM_PRI2_DP_S_SRM_MODE)
#else
#define BF_IPU_SRM_PRI2_DP_S_SRM_MODE(v)   (((v) << 3) & BM_IPU_SRM_PRI2_DP_S_SRM_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_S_SRM_MODE field to a new value.
#define BW_IPU_SRM_PRI2_DP_S_SRM_MODE(v)   BF_CS1(IPU_SRM_PRI2, DP_S_SRM_MODE, v)
#endif


/* --- Register HW_IPU_SRM_PRI2, field DP_A0_SRM_MODE (RW)
 *
 * DP Async flow #0 SRM Mode This field controls the SRM logic that handles the DP Async flow #0
 * registers
 *
 * Values:
 * 00 - Automatic swapping is disabled; ARM platform is allowed to access the DP Async flow #0 region in the
 *     RAM
 * 01 - The SRM logic is controlled by the FSU. The update will be done of the next frame.
 * 10 - The SRM logic is controlled by the FSU. Registers are swapped continuously frame by frame
 * 11 - Update now. The SRM is controlled by the ARM platform. The Register will be update now
 */

#define BP_IPU_SRM_PRI2_DP_A0_SRM_MODE      5
#define BM_IPU_SRM_PRI2_DP_A0_SRM_MODE      0x00000060

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI2_DP_A0_SRM_MODE(v)   ((((reg32_t) v) << 5) & BM_IPU_SRM_PRI2_DP_A0_SRM_MODE)
#else
#define BF_IPU_SRM_PRI2_DP_A0_SRM_MODE(v)   (((v) << 5) & BM_IPU_SRM_PRI2_DP_A0_SRM_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_A0_SRM_MODE field to a new value.
#define BW_IPU_SRM_PRI2_DP_A0_SRM_MODE(v)   BF_CS1(IPU_SRM_PRI2, DP_A0_SRM_MODE, v)
#endif


/* --- Register HW_IPU_SRM_PRI2, field DP_A1_SRM_MODE (RW)
 *
 * DP Async flow #1 SRM Mode This field controls the SRM logic that handles the DP Async flow #1
 * registers
 *
 * Values:
 * 00 - Automatic swapping is disabled; ARM platform is allowed to access the DP Async flow #1 region in the
 *     RAM
 * 01 - The SRM logic is controlled by the FSU. The update will be done of the next frame.
 * 10 - The SRM logic is controlled by the FSU. Registers are swapped continuously frame by frame
 * 11 - Update now. The SRM is controlled by the ARM platform. The Register will be update now
 */

#define BP_IPU_SRM_PRI2_DP_A1_SRM_MODE      7
#define BM_IPU_SRM_PRI2_DP_A1_SRM_MODE      0x00000180

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI2_DP_A1_SRM_MODE(v)   ((((reg32_t) v) << 7) & BM_IPU_SRM_PRI2_DP_A1_SRM_MODE)
#else
#define BF_IPU_SRM_PRI2_DP_A1_SRM_MODE(v)   (((v) << 7) & BM_IPU_SRM_PRI2_DP_A1_SRM_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_A1_SRM_MODE field to a new value.
#define BW_IPU_SRM_PRI2_DP_A1_SRM_MODE(v)   BF_CS1(IPU_SRM_PRI2, DP_A1_SRM_MODE, v)
#endif


/* --- Register HW_IPU_SRM_PRI2, field DC_SRM_PRI (RW)
 *
 * DC SRM priority This bits define the priority of the DC module
 */

#define BP_IPU_SRM_PRI2_DC_SRM_PRI      9
#define BM_IPU_SRM_PRI2_DC_SRM_PRI      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI2_DC_SRM_PRI(v)   ((((reg32_t) v) << 9) & BM_IPU_SRM_PRI2_DC_SRM_PRI)
#else
#define BF_IPU_SRM_PRI2_DC_SRM_PRI(v)   (((v) << 9) & BM_IPU_SRM_PRI2_DC_SRM_PRI)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_SRM_PRI field to a new value.
#define BW_IPU_SRM_PRI2_DC_SRM_PRI(v)   BF_CS1(IPU_SRM_PRI2, DC_SRM_PRI, v)
#endif

/* --- Register HW_IPU_SRM_PRI2, field DC_2_SRM_MODE (RW)
 *
 * DC Group #2 SRM Mode This field controls the SRM logic that handles the DC Group #2 registers
 *
 * Values:
 * 00 - Automatic swapping is disabled; ARM platform is allowed to access the DC Group #2's region in the
 *     RAM
 * 01 - The SRM logic is controlled by the FSU. The update will be done of the next frame.
 * 10 - The SRM logic is controlled by the FSU. Registers are swapped continuously frame by frame
 * 11 - Update now. The SRM is controlled by the ARM platform. The Register will be update now
 */

#define BP_IPU_SRM_PRI2_DC_2_SRM_MODE      12
#define BM_IPU_SRM_PRI2_DC_2_SRM_MODE      0x00003000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI2_DC_2_SRM_MODE(v)   ((((reg32_t) v) << 12) & BM_IPU_SRM_PRI2_DC_2_SRM_MODE)
#else
#define BF_IPU_SRM_PRI2_DC_2_SRM_MODE(v)   (((v) << 12) & BM_IPU_SRM_PRI2_DC_2_SRM_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_2_SRM_MODE field to a new value.
#define BW_IPU_SRM_PRI2_DC_2_SRM_MODE(v)   BF_CS1(IPU_SRM_PRI2, DC_2_SRM_MODE, v)
#endif


/* --- Register HW_IPU_SRM_PRI2, field DC_6_SRM_MODE (RW)
 *
 * DC Group #6 SRM Mode This field controls the SRM logic that handles the DC Group #6 registers
 *
 * Values:
 * 00 - Automatic swapping is disabled; ARM platform is allowed to access the DC Group #6's region in the
 *     RAM
 * 01 - The SRM logic is controlled by the FSU. The update will be done of the next frame.
 * 10 - The SRM logic is controlled by the FSU. Registers are swapped continuously frame by frame
 * 11 - Update now. The SRM is controlled by the ARM platform. The Register will be update now
 */

#define BP_IPU_SRM_PRI2_DC_6_SRM_MODE      14
#define BM_IPU_SRM_PRI2_DC_6_SRM_MODE      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI2_DC_6_SRM_MODE(v)   ((((reg32_t) v) << 14) & BM_IPU_SRM_PRI2_DC_6_SRM_MODE)
#else
#define BF_IPU_SRM_PRI2_DC_6_SRM_MODE(v)   (((v) << 14) & BM_IPU_SRM_PRI2_DC_6_SRM_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_6_SRM_MODE field to a new value.
#define BW_IPU_SRM_PRI2_DC_6_SRM_MODE(v)   BF_CS1(IPU_SRM_PRI2, DC_6_SRM_MODE, v)
#endif


/* --- Register HW_IPU_SRM_PRI2, field DI0_SRM_PRI (RW)
 *
 * DI0 SRM priority This bits define the priority of the DI0 module
 */

#define BP_IPU_SRM_PRI2_DI0_SRM_PRI      16
#define BM_IPU_SRM_PRI2_DI0_SRM_PRI      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI2_DI0_SRM_PRI(v)   ((((reg32_t) v) << 16) & BM_IPU_SRM_PRI2_DI0_SRM_PRI)
#else
#define BF_IPU_SRM_PRI2_DI0_SRM_PRI(v)   (((v) << 16) & BM_IPU_SRM_PRI2_DI0_SRM_PRI)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SRM_PRI field to a new value.
#define BW_IPU_SRM_PRI2_DI0_SRM_PRI(v)   BF_CS1(IPU_SRM_PRI2, DI0_SRM_PRI, v)
#endif

/* --- Register HW_IPU_SRM_PRI2, field DI0_SRM_MCU_USE (RW)
 *
 * DI0 SRM is used by ARM platform This bit indicates that the registers of the DI0 are currently
 * being updated by the ARM platform. The ARM platform should set this bit before accessing the SRM
 * part that is relevant to the DI0. The ARM platform should clear this bit when the update
 * procedure is finished. When this bit is set the SRM mechanism will not update the DI0's registers
 * to avoid data coherency problems.
 *
 * Values:
 * 0 - DI0 SRM s currently not updated by the ARM platform
 * 1 - DI0 SRM is currently updated by the ARM platform
 */

#define BP_IPU_SRM_PRI2_DI0_SRM_MCU_USE      19
#define BM_IPU_SRM_PRI2_DI0_SRM_MCU_USE      0x00180000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI2_DI0_SRM_MCU_USE(v)   ((((reg32_t) v) << 19) & BM_IPU_SRM_PRI2_DI0_SRM_MCU_USE)
#else
#define BF_IPU_SRM_PRI2_DI0_SRM_MCU_USE(v)   (((v) << 19) & BM_IPU_SRM_PRI2_DI0_SRM_MCU_USE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SRM_MCU_USE field to a new value.
#define BW_IPU_SRM_PRI2_DI0_SRM_MCU_USE(v)   BF_CS1(IPU_SRM_PRI2, DI0_SRM_MCU_USE, v)
#endif


/* --- Register HW_IPU_SRM_PRI2, field DI1_SRM_PRI (RW)
 *
 * DI1 SRM priority This bits define the priority of the DI1 module
 */

#define BP_IPU_SRM_PRI2_DI1_SRM_PRI      24
#define BM_IPU_SRM_PRI2_DI1_SRM_PRI      0x07000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI2_DI1_SRM_PRI(v)   ((((reg32_t) v) << 24) & BM_IPU_SRM_PRI2_DI1_SRM_PRI)
#else
#define BF_IPU_SRM_PRI2_DI1_SRM_PRI(v)   (((v) << 24) & BM_IPU_SRM_PRI2_DI1_SRM_PRI)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SRM_PRI field to a new value.
#define BW_IPU_SRM_PRI2_DI1_SRM_PRI(v)   BF_CS1(IPU_SRM_PRI2, DI1_SRM_PRI, v)
#endif

/* --- Register HW_IPU_SRM_PRI2, field DI1_SRM_MODE (RW)
 *
 * DCI1 SRM Mode This field controls the SRM logic that handles the DI1 registers
 *
 * Values:
 * 00 - Automatic swapping is disabled; ARM platform is allowed to access the DI1 region in the RAM
 * 01 - The SRM logic is controlled by the FSU. The update will be done of the next frame.
 * 10 - The SRM logic is controlled by the FSU. Registers are swapped continuously frame by frame
 * 11 - Update now. The SRM is controlled by the ARM platform. The Register will be update now
 */

#define BP_IPU_SRM_PRI2_DI1_SRM_MODE      27
#define BM_IPU_SRM_PRI2_DI1_SRM_MODE      0x18000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SRM_PRI2_DI1_SRM_MODE(v)   ((((reg32_t) v) << 27) & BM_IPU_SRM_PRI2_DI1_SRM_MODE)
#else
#define BF_IPU_SRM_PRI2_DI1_SRM_MODE(v)   (((v) << 27) & BM_IPU_SRM_PRI2_DI1_SRM_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SRM_MODE field to a new value.
#define BW_IPU_SRM_PRI2_DI1_SRM_MODE(v)   BF_CS1(IPU_SRM_PRI2, DI1_SRM_MODE, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_FS_PROC_FLOW1 - FSU Processing Flow 1 Register (RW)
 *
 * This register contain controls for IPU's tasks.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned PRPENC_ROT_SRC_SEL : 4; //!< Source select for the encoding task of the IRT
        unsigned RESERVED0 : 4; //!< Reserved
        unsigned PRPVF_ROT_SRC_SEL : 4; //!< Source select for the view finder task of the IRT 0000 ARM platform
        unsigned PP_SRC_SEL : 4; //!< Source select for the pre processing task of the IC
        unsigned PP_ROT_SRC_SEL : 4; //!< Source select for the pre processing task of the IRT (CH 50)
        unsigned VDI1_SRC_SEL : 2; //!< Source select for the VDIC plane #1 (IDMAC's CH26) This field is relevant only if the VDIC works in combining mode (VDI_CMB_EN bit is set)
        unsigned VDI3_SRC_SEL : 2; //!< Source select for the VDIC plane #3 (IDMAC's CH 25)
        unsigned PRP_SRC_SEL : 4; //!< Source select for the Pre Processing Task 0000 ARM platform
        unsigned VDI_SRC_SEL : 2; //!< Source select for the VDI C This field is relevant if the VDIC works in de-interlacing mode (when VDI_CMB_EN bit is clear)
        unsigned ENC_IN_VALID : 1; //!< Encoding Input valid. Setting this bit indicates that the buffer in memory for encoding is validated by the ARM platform (valid only when RWS_EN is '1').
        unsigned VF_IN_VALID : 1; //!< View-finder Input valid. Setting this bit indicates that the buffer in memory for viewfinder is validated by the ARM platform (valid only when RWS_EN is '1').
    } B;
} hw_ipu_fs_proc_flow1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_FS_PROC_FLOW1 register
 */
#define HW_IPU_FS_PROC_FLOW1_ADDR(x)      (REGS_IPU_BASE(x) + 0xa8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_FS_PROC_FLOW1(x)           (*(volatile hw_ipu_fs_proc_flow1_t *) HW_IPU_FS_PROC_FLOW1_ADDR(x))
#define HW_IPU_FS_PROC_FLOW1_RD(x)        (HW_IPU_FS_PROC_FLOW1(x).U)
#define HW_IPU_FS_PROC_FLOW1_WR(x, v)     (HW_IPU_FS_PROC_FLOW1(x).U = (v))
#define HW_IPU_FS_PROC_FLOW1_SET(x, v)    (HW_IPU_FS_PROC_FLOW1_WR(x, HW_IPU_FS_PROC_FLOW1_RD(x) |  (v)))
#define HW_IPU_FS_PROC_FLOW1_CLR(x, v)    (HW_IPU_FS_PROC_FLOW1_WR(x, HW_IPU_FS_PROC_FLOW1_RD(x) & ~(v)))
#define HW_IPU_FS_PROC_FLOW1_TOG(x, v)    (HW_IPU_FS_PROC_FLOW1_WR(x, HW_IPU_FS_PROC_FLOW1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_FS_PROC_FLOW1 bitfields
 */

/* --- Register HW_IPU_FS_PROC_FLOW1, field PRPENC_ROT_SRC_SEL (RW)
 *
 * Source select for the encoding task of the IRT
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - capture0 (smfc0)
 * 0010 - capture1 (smfc1)
 * 0011 - capture2 (smfc2)
 * 0100 - capture3 (smfc3)
 * 0101 - IC direct (cb7)
 * 0110 - Reserved
 * 0111 - encoding
 * 1000 - Reserved
 * 1001 - Reserved
 * 1010 - Reserved
 * 1011 - autoref
 * 1100 - autoref+snoop1
 * 1101 - autoref+snoop2
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_PROC_FLOW1_PRPENC_ROT_SRC_SEL      0
#define BM_IPU_FS_PROC_FLOW1_PRPENC_ROT_SRC_SEL      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW1_PRPENC_ROT_SRC_SEL(v)   ((((reg32_t) v) << 0) & BM_IPU_FS_PROC_FLOW1_PRPENC_ROT_SRC_SEL)
#else
#define BF_IPU_FS_PROC_FLOW1_PRPENC_ROT_SRC_SEL(v)   (((v) << 0) & BM_IPU_FS_PROC_FLOW1_PRPENC_ROT_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPENC_ROT_SRC_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW1_PRPENC_ROT_SRC_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW1, PRPENC_ROT_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW1, field PRPVF_ROT_SRC_SEL (RW)
 *
 * Source select for the view finder task of the IRT 0000 ARM platform
 *
 * Values:
 * 0001 - capture0 (smfc0)
 * 0010 - capture1 (smfc1)
 * 0011 - capture2 (smfc2)
 * 0100 - capture3 (smfc3)
 * 0101 - IC direct (cb7)
 * 0110 - Reserved
 * 0111 - Reserved
 * 1000 - View-finder
 * 1001 - Reserved
 * 1010 - Reserved
 * 1011 - autoref
 * 1100 - autoref+snoop1
 * 1101 - autoref+snoop2
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_PROC_FLOW1_PRPVF_ROT_SRC_SEL      8
#define BM_IPU_FS_PROC_FLOW1_PRPVF_ROT_SRC_SEL      0x00000f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW1_PRPVF_ROT_SRC_SEL(v)   ((((reg32_t) v) << 8) & BM_IPU_FS_PROC_FLOW1_PRPVF_ROT_SRC_SEL)
#else
#define BF_IPU_FS_PROC_FLOW1_PRPVF_ROT_SRC_SEL(v)   (((v) << 8) & BM_IPU_FS_PROC_FLOW1_PRPVF_ROT_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPVF_ROT_SRC_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW1_PRPVF_ROT_SRC_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW1, PRPVF_ROT_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW1, field PP_SRC_SEL (RW)
 *
 * Source select for the pre processing task of the IC
 *
 * Values:
 * 0000 - ARM platform (Editor note: 1000 setting for IPUv3H it is VDOA, for IPUv3M it is reserved)
 * 0001 - capture0 (smfc0)
 * 0010 - Reserved
 * 0011 - capture2 (smfc2)
 * 0100 - Reserved
 * 0101 - Reserved
 * 0110 - Rotation for post-processing
 * 0111 - Reserved
 * 1000 - Reserved
 * 1000 - VDOA
 * 1001 - Reserved
 * 1010 - Reserved
 * 1011 - autoref
 * 1100 - autoref+snoop1
 * 1101 - autoref+snoop2
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_PROC_FLOW1_PP_SRC_SEL      12
#define BM_IPU_FS_PROC_FLOW1_PP_SRC_SEL      0x0000f000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW1_PP_SRC_SEL(v)   ((((reg32_t) v) << 12) & BM_IPU_FS_PROC_FLOW1_PP_SRC_SEL)
#else
#define BF_IPU_FS_PROC_FLOW1_PP_SRC_SEL(v)   (((v) << 12) & BM_IPU_FS_PROC_FLOW1_PP_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_SRC_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW1_PP_SRC_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW1, PP_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW1, field PP_ROT_SRC_SEL (RW)
 *
 * Source select for the pre processing task of the IRT (CH 50)
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - capture0 (smfc0)
 * 0010 - Reserved
 * 0011 - capture2 (smfc2)
 * 0100 - Reserved
 * 0101 - Post-processing
 * 0110 - Reserved
 * 0111 - Reserved
 * 1000 - Reserved
 * 1001 - Reserved
 * 1010 - Reserved
 * 1011 - autoref
 * 1100 - autoref+snoop1
 * 1101 - autoref+snoop2
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_PROC_FLOW1_PP_ROT_SRC_SEL      16
#define BM_IPU_FS_PROC_FLOW1_PP_ROT_SRC_SEL      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW1_PP_ROT_SRC_SEL(v)   ((((reg32_t) v) << 16) & BM_IPU_FS_PROC_FLOW1_PP_ROT_SRC_SEL)
#else
#define BF_IPU_FS_PROC_FLOW1_PP_ROT_SRC_SEL(v)   (((v) << 16) & BM_IPU_FS_PROC_FLOW1_PP_ROT_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_ROT_SRC_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW1_PP_ROT_SRC_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW1, PP_ROT_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW1, field VDI1_SRC_SEL (RW)
 *
 * Source select for the VDIC plane #1 (IDMAC's CH26) This field is relevant only if the VDIC works
 * in combining mode (VDI_CMB_EN bit is set)
 *
 * Values:
 * 00 - ARM platform
 * 01 - IRT viewfinder
 * 10 - IRT playback
 * 11 - post-processing
 */

#define BP_IPU_FS_PROC_FLOW1_VDI1_SRC_SEL      20
#define BM_IPU_FS_PROC_FLOW1_VDI1_SRC_SEL      0x00300000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW1_VDI1_SRC_SEL(v)   ((((reg32_t) v) << 20) & BM_IPU_FS_PROC_FLOW1_VDI1_SRC_SEL)
#else
#define BF_IPU_FS_PROC_FLOW1_VDI1_SRC_SEL(v)   (((v) << 20) & BM_IPU_FS_PROC_FLOW1_VDI1_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI1_SRC_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW1_VDI1_SRC_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW1, VDI1_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW1, field VDI3_SRC_SEL (RW)
 *
 * Source select for the VDIC plane #3 (IDMAC's CH 25)
 *
 * Values:
 * 00 - ARM platform This field is relevant only if the VDIC works in combining mode (VDI_CMB_EN bit is set)
 * 01 - IRT viewfinder (ch 49)
 * 10 - IRT playback (ch 50)
 * 11 - post-processing (ch 22)
 */

#define BP_IPU_FS_PROC_FLOW1_VDI3_SRC_SEL      22
#define BM_IPU_FS_PROC_FLOW1_VDI3_SRC_SEL      0x00c00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW1_VDI3_SRC_SEL(v)   ((((reg32_t) v) << 22) & BM_IPU_FS_PROC_FLOW1_VDI3_SRC_SEL)
#else
#define BF_IPU_FS_PROC_FLOW1_VDI3_SRC_SEL(v)   (((v) << 22) & BM_IPU_FS_PROC_FLOW1_VDI3_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI3_SRC_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW1_VDI3_SRC_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW1, VDI3_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW1, field PRP_SRC_SEL (RW)
 *
 * Source select for the Pre Processing Task 0000 ARM platform
 *
 * Values:
 * 0001 - capture0 (smfc0)
 * 0011 - capture2 (smfc2)
 * 0101 - IC direct (cb7)
 * 0110 - IRT Encoding
 * 0111 - IRT viewfinder
 * 1000 - Reserved
 * 1001 - Reserved
 * 1010 - Reserved
 * 1011 - autoref
 * 1100 - autoref+snoop1
 * 1101 - autoref+snoop2
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_PROC_FLOW1_PRP_SRC_SEL      24
#define BM_IPU_FS_PROC_FLOW1_PRP_SRC_SEL      0x0f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW1_PRP_SRC_SEL(v)   ((((reg32_t) v) << 24) & BM_IPU_FS_PROC_FLOW1_PRP_SRC_SEL)
#else
#define BF_IPU_FS_PROC_FLOW1_PRP_SRC_SEL(v)   (((v) << 24) & BM_IPU_FS_PROC_FLOW1_PRP_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRP_SRC_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW1_PRP_SRC_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW1, PRP_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW1, field VDI_SRC_SEL (RW)
 *
 * Source select for the VDI C This field is relevant if the VDIC works in de-interlacing mode (when
 * VDI_CMB_EN bit is clear)
 *
 * Values:
 * 00 - ARM platform
 * 01 - CSI direct (cb7)
 * 10 - Reserved (Editor note: for IPUv3H it is VDOA all the others it is reserved)
 * 10 - VDOA
 * 11 - Reserved
 */

#define BP_IPU_FS_PROC_FLOW1_VDI_SRC_SEL      28
#define BM_IPU_FS_PROC_FLOW1_VDI_SRC_SEL      0x30000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW1_VDI_SRC_SEL(v)   ((((reg32_t) v) << 28) & BM_IPU_FS_PROC_FLOW1_VDI_SRC_SEL)
#else
#define BF_IPU_FS_PROC_FLOW1_VDI_SRC_SEL(v)   (((v) << 28) & BM_IPU_FS_PROC_FLOW1_VDI_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_SRC_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW1_VDI_SRC_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW1, VDI_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW1, field ENC_IN_VALID (RW)
 *
 * Encoding Input valid. Setting this bit indicates that the buffer in memory for encoding is
 * validated by the ARM platform (valid only when RWS_EN is '1').
 *
 * Values:
 * 0 - Encoding should skip buffer in memory.
 * 1 - Encoding should use buffer in memory.
 */

#define BP_IPU_FS_PROC_FLOW1_ENC_IN_VALID      30
#define BM_IPU_FS_PROC_FLOW1_ENC_IN_VALID      0x40000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW1_ENC_IN_VALID(v)   ((((reg32_t) v) << 30) & BM_IPU_FS_PROC_FLOW1_ENC_IN_VALID)
#else
#define BF_IPU_FS_PROC_FLOW1_ENC_IN_VALID(v)   (((v) << 30) & BM_IPU_FS_PROC_FLOW1_ENC_IN_VALID)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ENC_IN_VALID field to a new value.
#define BW_IPU_FS_PROC_FLOW1_ENC_IN_VALID(v)   BF_CS1(IPU_FS_PROC_FLOW1, ENC_IN_VALID, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW1, field VF_IN_VALID (RW)
 *
 * View-finder Input valid. Setting this bit indicates that the buffer in memory for viewfinder is
 * validated by the ARM platform (valid only when RWS_EN is '1').
 *
 * Values:
 * 0 - View-finder should skip buffer in memory.
 * 1 - View-finder should use buffer in memory.
 */

#define BP_IPU_FS_PROC_FLOW1_VF_IN_VALID      31
#define BM_IPU_FS_PROC_FLOW1_VF_IN_VALID      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW1_VF_IN_VALID(v)   ((((reg32_t) v) << 31) & BM_IPU_FS_PROC_FLOW1_VF_IN_VALID)
#else
#define BF_IPU_FS_PROC_FLOW1_VF_IN_VALID(v)   (((v) << 31) & BM_IPU_FS_PROC_FLOW1_VF_IN_VALID)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VF_IN_VALID field to a new value.
#define BW_IPU_FS_PROC_FLOW1_VF_IN_VALID(v)   BF_CS1(IPU_FS_PROC_FLOW1, VF_IN_VALID, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_FS_PROC_FLOW2 - FSU Processing Flow 2 Register (RW)
 *
 * This register contains controls for IPU's tasks.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned PRP_ENC_DEST_SEL : 4; //!< Destination select for Encoding task
        unsigned PRPVF_DEST_SEL : 4; //!< Destination select for View finder task
        unsigned PRPVF_ROT_DEST_SEL : 4; //!< Destination select for Rotation task coming from the View finder input
        unsigned PP_DEST_SEL : 4; //!< Destination select for post processing task
        unsigned PP_ROT_DEST_SEL : 4; //!< Destination select for Rotation task coming from the Post Processing input
        unsigned PRPENC_ROT_DEST_SEL : 4; //!< Destination select for Rotation task coming from the Encoding input
        unsigned PRP_DEST_SEL : 4; //!< Pre processing destination select (for channel DMAIC_7)
        unsigned RESERVED0 : 4; //!< Reserved
    } B;
} hw_ipu_fs_proc_flow2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_FS_PROC_FLOW2 register
 */
#define HW_IPU_FS_PROC_FLOW2_ADDR(x)      (REGS_IPU_BASE(x) + 0xac)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_FS_PROC_FLOW2(x)           (*(volatile hw_ipu_fs_proc_flow2_t *) HW_IPU_FS_PROC_FLOW2_ADDR(x))
#define HW_IPU_FS_PROC_FLOW2_RD(x)        (HW_IPU_FS_PROC_FLOW2(x).U)
#define HW_IPU_FS_PROC_FLOW2_WR(x, v)     (HW_IPU_FS_PROC_FLOW2(x).U = (v))
#define HW_IPU_FS_PROC_FLOW2_SET(x, v)    (HW_IPU_FS_PROC_FLOW2_WR(x, HW_IPU_FS_PROC_FLOW2_RD(x) |  (v)))
#define HW_IPU_FS_PROC_FLOW2_CLR(x, v)    (HW_IPU_FS_PROC_FLOW2_WR(x, HW_IPU_FS_PROC_FLOW2_RD(x) & ~(v)))
#define HW_IPU_FS_PROC_FLOW2_TOG(x, v)    (HW_IPU_FS_PROC_FLOW2_WR(x, HW_IPU_FS_PROC_FLOW2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_FS_PROC_FLOW2 bitfields
 */

/* --- Register HW_IPU_FS_PROC_FLOW2, field PRP_ENC_DEST_SEL (RW)
 *
 * Destination select for Encoding task
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - IRT Encoding
 * 0010 - Reserved
 * 0011 - Reserved
 * 0100 - Reserved
 * 0101 - Reserved
 * 0110 - Reserved
 * 0111 - DC1 (ch28)
 * 1000 - DC2 (ch41)
 * 1001 -  DP_SYNC0 (ch23)
 * 1010 -  DP_SYNC1 (ch27)
 * 1011 -  DP_ASYNC1 (ch24)
 * 1100 -  DP_ASYNC0 (ch29)
 * 1101 - Alt DC2 (ch41)
 * 1110 - Alt DP_ASYNC1 (ch24)
 * 1111 - Alt DP_ASYNC0 (ch29)
 */

#define BP_IPU_FS_PROC_FLOW2_PRP_ENC_DEST_SEL      0
#define BM_IPU_FS_PROC_FLOW2_PRP_ENC_DEST_SEL      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW2_PRP_ENC_DEST_SEL(v)   ((((reg32_t) v) << 0) & BM_IPU_FS_PROC_FLOW2_PRP_ENC_DEST_SEL)
#else
#define BF_IPU_FS_PROC_FLOW2_PRP_ENC_DEST_SEL(v)   (((v) << 0) & BM_IPU_FS_PROC_FLOW2_PRP_ENC_DEST_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRP_ENC_DEST_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW2_PRP_ENC_DEST_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW2, PRP_ENC_DEST_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW2, field PRPVF_DEST_SEL (RW)
 *
 * Destination select for View finder task
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - IRT viewfinder
 * 0010 - Reserved
 * 0011 - Reserved
 * 0100 - Reserved
 * 0101 - Reserved
 * 0110 - Reserved
 * 0111 - DC1 (ch28)
 * 1000 - DC2 (ch41)
 * 1001 -  DP_SYNC0 (ch23)
 * 1010 -  DP_SYNC1 (ch27)
 * 1011 -  DP_ASYNC1 (ch24)
 * 1100 -  DP_ASYNC0 (ch29)
 * 1101 - Alt DC2 (ch41)
 * 1110 - Alt DP_ASYNC1 (ch24)
 * 1111 - Alt DP_ASYNC0 (ch29)
 */

#define BP_IPU_FS_PROC_FLOW2_PRPVF_DEST_SEL      4
#define BM_IPU_FS_PROC_FLOW2_PRPVF_DEST_SEL      0x000000f0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW2_PRPVF_DEST_SEL(v)   ((((reg32_t) v) << 4) & BM_IPU_FS_PROC_FLOW2_PRPVF_DEST_SEL)
#else
#define BF_IPU_FS_PROC_FLOW2_PRPVF_DEST_SEL(v)   (((v) << 4) & BM_IPU_FS_PROC_FLOW2_PRPVF_DEST_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPVF_DEST_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW2_PRPVF_DEST_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW2, PRPVF_DEST_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW2, field PRPVF_ROT_DEST_SEL (RW)
 *
 * Destination select for Rotation task coming from the View finder input
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - Reserved
 * 0010 - Reserved
 * 0011 - VDI_PLANE3 (Ch 25)
 * 0100 - VDI_PLANE1 (Ch 26)
 * 0101 - IC Pre Processing
 * 0110 - Reserved
 * 0111 - DC1 (ch28)
 * 1000 - DC2 (ch41)
 * 1001 -  DP_SYNC0 (ch23)
 * 1010 -  DP_SYNC1 (ch27)
 * 1011 -  DP_ASYNC1 (ch24)
 * 1100 -  DP_ASYNC0 (ch29)
 * 1101 - Alt DC2 (ch41)
 * 1110 - Alt DP_ASYNC1 (ch24)
 * 1111 - Alt DP_ASYNC0 (ch29)
 */

#define BP_IPU_FS_PROC_FLOW2_PRPVF_ROT_DEST_SEL      8
#define BM_IPU_FS_PROC_FLOW2_PRPVF_ROT_DEST_SEL      0x00000f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW2_PRPVF_ROT_DEST_SEL(v)   ((((reg32_t) v) << 8) & BM_IPU_FS_PROC_FLOW2_PRPVF_ROT_DEST_SEL)
#else
#define BF_IPU_FS_PROC_FLOW2_PRPVF_ROT_DEST_SEL(v)   (((v) << 8) & BM_IPU_FS_PROC_FLOW2_PRPVF_ROT_DEST_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPVF_ROT_DEST_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW2_PRPVF_ROT_DEST_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW2, PRPVF_ROT_DEST_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW2, field PP_DEST_SEL (RW)
 *
 * Destination select for post processing task
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - Reserved
 * 0010 - Reserved
 * 0011 - IRT playback
 * 0100 - VDI_PLANE3 (Ch 25)
 * 0101 - VDI_PLANE1 (Ch 26)
 * 0110 - Reserved
 * 0111 - DC1 (ch28)
 * 1000 - DC2 (ch41)
 * 1001 -  DP_SYNC0 (ch23)
 * 1010 -  DP_SYNC1 (ch27)
 * 1011 -  DP_ASYNC1 (ch24)
 * 1100 -  DP_ASYNC0 (ch29)
 * 1101 - Alt DC2 (ch41)
 * 1110 - Alt DP_ASYNC1 (ch24)
 * 1111 - Alt DP_ASYNC0 (ch29)
 */

#define BP_IPU_FS_PROC_FLOW2_PP_DEST_SEL      12
#define BM_IPU_FS_PROC_FLOW2_PP_DEST_SEL      0x0000f000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW2_PP_DEST_SEL(v)   ((((reg32_t) v) << 12) & BM_IPU_FS_PROC_FLOW2_PP_DEST_SEL)
#else
#define BF_IPU_FS_PROC_FLOW2_PP_DEST_SEL(v)   (((v) << 12) & BM_IPU_FS_PROC_FLOW2_PP_DEST_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_DEST_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW2_PP_DEST_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW2, PP_DEST_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW2, field PP_ROT_DEST_SEL (RW)
 *
 * Destination select for Rotation task coming from the Post Processing input
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - Reserved
 * 0010 - Reserved
 * 0011 - Reserved
 * 0100 - IC Playback (Post Processing)
 * 0101 - VDI_PLANE3 (Ch 25)
 * 0110 - VDI_PLANE1 (Ch 26)
 * 0111 - DC1 (ch28)
 * 1000 - DC2 (ch41)
 * 1001 -  DP_SYNC0 (ch23)
 * 1010 -  DP_SYNC1 (ch27)
 * 1011 -  DP_ASYNC1 (ch24)
 * 1100 -  DP_ASYNC0 (ch29)
 * 1101 - Alt DC2 (ch41)
 * 1110 - Alt DP_ASYNC1 (ch24)
 * 1111 - Alt DP_ASYNC0 (ch29)
 */

#define BP_IPU_FS_PROC_FLOW2_PP_ROT_DEST_SEL      16
#define BM_IPU_FS_PROC_FLOW2_PP_ROT_DEST_SEL      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW2_PP_ROT_DEST_SEL(v)   ((((reg32_t) v) << 16) & BM_IPU_FS_PROC_FLOW2_PP_ROT_DEST_SEL)
#else
#define BF_IPU_FS_PROC_FLOW2_PP_ROT_DEST_SEL(v)   (((v) << 16) & BM_IPU_FS_PROC_FLOW2_PP_ROT_DEST_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_ROT_DEST_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW2_PP_ROT_DEST_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW2, PP_ROT_DEST_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW2, field PRPENC_ROT_DEST_SEL (RW)
 *
 * Destination select for Rotation task coming from the Encoding input
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - Reserved
 * 0010 - Reserved
 * 0011 - Reserved
 * 0100 - Reserved
 * 0101 - IC Pre Processing
 * 0110 - Reserved
 * 0111 - DC1 (ch28)
 * 1000 - DC2 (ch41)
 * 1001 -  DP_SYNC0 (ch23)
 * 1010 -  DP_SYNC1 (ch27)
 * 1011 -  DP_ASYNC1 (ch24)
 * 1100 -  DP_ASYNC0 (ch29)
 * 1101 - Alt DC2 (ch41)
 * 1110 - Alt DP_ASYNC1 (ch24)
 * 1111 - Alt DP_ASYNC0 (ch29)
 */

#define BP_IPU_FS_PROC_FLOW2_PRPENC_ROT_DEST_SEL      20
#define BM_IPU_FS_PROC_FLOW2_PRPENC_ROT_DEST_SEL      0x00f00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW2_PRPENC_ROT_DEST_SEL(v)   ((((reg32_t) v) << 20) & BM_IPU_FS_PROC_FLOW2_PRPENC_ROT_DEST_SEL)
#else
#define BF_IPU_FS_PROC_FLOW2_PRPENC_ROT_DEST_SEL(v)   (((v) << 20) & BM_IPU_FS_PROC_FLOW2_PRPENC_ROT_DEST_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPENC_ROT_DEST_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW2_PRPENC_ROT_DEST_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW2, PRPENC_ROT_DEST_SEL, v)
#endif


/* --- Register HW_IPU_FS_PROC_FLOW2, field PRP_DEST_SEL (RW)
 *
 * Pre processing destination select (for channel DMAIC_7)
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - IC input buffer (ch12)
 * 0010 - PP (ch11)
 * 0011 - PP_ROT (ch47)
 * 0100 - DC1 (ch28)
 * 0101 - DC2 (ch41)
 * 0110 - DP_ASYNC1 (ch24)
 * 0111 - DP_ASYNC0 (ch29)
 * 1000 - DP_SYNC1 (ch27)
 * 1001 - DP_SYNC0 (ch23)
 * 1010 - Alt DC2 (ch41)
 * 1011 - Alt DP_ASYNC1 (ch24)
 * 1100 - Alt DP_ASYNC0 (ch29)
 * 1111 - Reserved
 */

#define BP_IPU_FS_PROC_FLOW2_PRP_DEST_SEL      24
#define BM_IPU_FS_PROC_FLOW2_PRP_DEST_SEL      0x0f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_PROC_FLOW2_PRP_DEST_SEL(v)   ((((reg32_t) v) << 24) & BM_IPU_FS_PROC_FLOW2_PRP_DEST_SEL)
#else
#define BF_IPU_FS_PROC_FLOW2_PRP_DEST_SEL(v)   (((v) << 24) & BM_IPU_FS_PROC_FLOW2_PRP_DEST_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRP_DEST_SEL field to a new value.
#define BW_IPU_FS_PROC_FLOW2_PRP_DEST_SEL(v)   BF_CS1(IPU_FS_PROC_FLOW2, PRP_DEST_SEL, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_FS_DISP_FLOW1 - FSU Displaying Flow 1 Register (RW)
 *
 * This register contains controls for IPU's tasks.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_SYNC0_SRC_SEL : 4; //!< Source select for DS2 - MG (graphics) plane (ch23)
        unsigned DP_SYNC1_SRC_SEL : 4; //!< Source select for DS1/DS2 - Vx (video) plane (ch27)
        unsigned DP_ASYNC0_SRC_SEL : 4; //!< Source select for DS2 - MG (graphics) plane (ch29)
        unsigned DP_ASYNC1_SRC_SEL : 4; //!< Source select for DS1/DS2 - Vx (video) plane (ch24)
        unsigned DC2_SRC_SEL : 4; //!< Source select for DS3 (ch41)
        unsigned DC1_SRC_SEL : 4; //!< Source select for DS1/DS2 - MG (graphics) plane (ch28)
        unsigned RESERVED0 : 8; //!< Reserved
    } B;
} hw_ipu_fs_disp_flow1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_FS_DISP_FLOW1 register
 */
#define HW_IPU_FS_DISP_FLOW1_ADDR(x)      (REGS_IPU_BASE(x) + 0xb4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_FS_DISP_FLOW1(x)           (*(volatile hw_ipu_fs_disp_flow1_t *) HW_IPU_FS_DISP_FLOW1_ADDR(x))
#define HW_IPU_FS_DISP_FLOW1_RD(x)        (HW_IPU_FS_DISP_FLOW1(x).U)
#define HW_IPU_FS_DISP_FLOW1_WR(x, v)     (HW_IPU_FS_DISP_FLOW1(x).U = (v))
#define HW_IPU_FS_DISP_FLOW1_SET(x, v)    (HW_IPU_FS_DISP_FLOW1_WR(x, HW_IPU_FS_DISP_FLOW1_RD(x) |  (v)))
#define HW_IPU_FS_DISP_FLOW1_CLR(x, v)    (HW_IPU_FS_DISP_FLOW1_WR(x, HW_IPU_FS_DISP_FLOW1_RD(x) & ~(v)))
#define HW_IPU_FS_DISP_FLOW1_TOG(x, v)    (HW_IPU_FS_DISP_FLOW1_WR(x, HW_IPU_FS_DISP_FLOW1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_FS_DISP_FLOW1 bitfields
 */

/* --- Register HW_IPU_FS_DISP_FLOW1, field DP_SYNC0_SRC_SEL (RW)
 *
 * Source select for DS2 - MG (graphics) plane (ch23)
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - capture0 (smfc0)
 * 0010 - capture2 (smfc2)
 * 0011 - IC encoding
 * 0100 - IC viewfinder
 * 0101 - IC playback
 * 0110 - IRT Encoding
 * 0111 - IRT viewfinder
 * 1000 - IRT playback
 * 1001 - Reserved
 * 1010 - Reserved
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_DISP_FLOW1_DP_SYNC0_SRC_SEL      0
#define BM_IPU_FS_DISP_FLOW1_DP_SYNC0_SRC_SEL      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_DISP_FLOW1_DP_SYNC0_SRC_SEL(v)   ((((reg32_t) v) << 0) & BM_IPU_FS_DISP_FLOW1_DP_SYNC0_SRC_SEL)
#else
#define BF_IPU_FS_DISP_FLOW1_DP_SYNC0_SRC_SEL(v)   (((v) << 0) & BM_IPU_FS_DISP_FLOW1_DP_SYNC0_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_SYNC0_SRC_SEL field to a new value.
#define BW_IPU_FS_DISP_FLOW1_DP_SYNC0_SRC_SEL(v)   BF_CS1(IPU_FS_DISP_FLOW1, DP_SYNC0_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_DISP_FLOW1, field DP_SYNC1_SRC_SEL (RW)
 *
 * Source select for DS1/DS2 - Vx (video) plane (ch27)
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - capture0 (smfc0)
 * 0010 - capture2 (smfc2)
 * 0011 - IC encoding
 * 0100 - IC viewfinder
 * 0101 - IC playback
 * 0110 - IRT Encoding
 * 0111 - IRT viewfinder
 * 1000 - IRT playback
 * 1001 - Reserved
 * 1010 - Reserved
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_DISP_FLOW1_DP_SYNC1_SRC_SEL      4
#define BM_IPU_FS_DISP_FLOW1_DP_SYNC1_SRC_SEL      0x000000f0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_DISP_FLOW1_DP_SYNC1_SRC_SEL(v)   ((((reg32_t) v) << 4) & BM_IPU_FS_DISP_FLOW1_DP_SYNC1_SRC_SEL)
#else
#define BF_IPU_FS_DISP_FLOW1_DP_SYNC1_SRC_SEL(v)   (((v) << 4) & BM_IPU_FS_DISP_FLOW1_DP_SYNC1_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_SYNC1_SRC_SEL field to a new value.
#define BW_IPU_FS_DISP_FLOW1_DP_SYNC1_SRC_SEL(v)   BF_CS1(IPU_FS_DISP_FLOW1, DP_SYNC1_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_DISP_FLOW1, field DP_ASYNC0_SRC_SEL (RW)
 *
 * Source select for DS2 - MG (graphics) plane (ch29)
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - capture0 (smfc0)
 * 0010 - capture2 (smfc2)
 * 0011 - IC encoding
 * 0100 - IC viewfinder
 * 0101 - IC playback
 * 0110 - IRT Encoding
 * 0111 - IRT viewfinder
 * 1000 - IRT playback
 * 1001 - Reserved
 * 1010 - Reserved
 * 1011 - autoref
 * 1100 - autoref+snoop1
 * 1101 - autoref+snoop2
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_DISP_FLOW1_DP_ASYNC0_SRC_SEL      8
#define BM_IPU_FS_DISP_FLOW1_DP_ASYNC0_SRC_SEL      0x00000f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_DISP_FLOW1_DP_ASYNC0_SRC_SEL(v)   ((((reg32_t) v) << 8) & BM_IPU_FS_DISP_FLOW1_DP_ASYNC0_SRC_SEL)
#else
#define BF_IPU_FS_DISP_FLOW1_DP_ASYNC0_SRC_SEL(v)   (((v) << 8) & BM_IPU_FS_DISP_FLOW1_DP_ASYNC0_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_ASYNC0_SRC_SEL field to a new value.
#define BW_IPU_FS_DISP_FLOW1_DP_ASYNC0_SRC_SEL(v)   BF_CS1(IPU_FS_DISP_FLOW1, DP_ASYNC0_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_DISP_FLOW1, field DP_ASYNC1_SRC_SEL (RW)
 *
 * Source select for DS1/DS2 - Vx (video) plane (ch24)
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - capture0 (smfc0)
 * 0010 - capture2 (smfc2)
 * 0011 - IC encoding
 * 0100 - IC viewfinder
 * 0101 - IC playback
 * 0110 - IRT Encoding
 * 0111 - IRT viewfinder
 * 1000 - IRT playback
 * 1001 - Reserved
 * 1010 - Reserved
 * 1011 - autoref
 * 1100 - autoref+snoop1
 * 1101 - autoref+snoop2
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_DISP_FLOW1_DP_ASYNC1_SRC_SEL      12
#define BM_IPU_FS_DISP_FLOW1_DP_ASYNC1_SRC_SEL      0x0000f000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_DISP_FLOW1_DP_ASYNC1_SRC_SEL(v)   ((((reg32_t) v) << 12) & BM_IPU_FS_DISP_FLOW1_DP_ASYNC1_SRC_SEL)
#else
#define BF_IPU_FS_DISP_FLOW1_DP_ASYNC1_SRC_SEL(v)   (((v) << 12) & BM_IPU_FS_DISP_FLOW1_DP_ASYNC1_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_ASYNC1_SRC_SEL field to a new value.
#define BW_IPU_FS_DISP_FLOW1_DP_ASYNC1_SRC_SEL(v)   BF_CS1(IPU_FS_DISP_FLOW1, DP_ASYNC1_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_DISP_FLOW1, field DC2_SRC_SEL (RW)
 *
 * Source select for DS3 (ch41)
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - capture0 (smfc0)
 * 0010 - capture2 (smfc2)
 * 0011 - IC encoding
 * 0100 - IC viewfinder
 * 0101 - IC playback
 * 0110 - IRT Encoding
 * 0111 - IRT viewfinder
 * 1000 - IRT playback
 * 1001 - Reserved
 * 1010 - Reserved
 * 1011 - autoref
 * 1100 - autoref+snoop1
 * 1101 - autoref+snoop2
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_DISP_FLOW1_DC2_SRC_SEL      16
#define BM_IPU_FS_DISP_FLOW1_DC2_SRC_SEL      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_DISP_FLOW1_DC2_SRC_SEL(v)   ((((reg32_t) v) << 16) & BM_IPU_FS_DISP_FLOW1_DC2_SRC_SEL)
#else
#define BF_IPU_FS_DISP_FLOW1_DC2_SRC_SEL(v)   (((v) << 16) & BM_IPU_FS_DISP_FLOW1_DC2_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC2_SRC_SEL field to a new value.
#define BW_IPU_FS_DISP_FLOW1_DC2_SRC_SEL(v)   BF_CS1(IPU_FS_DISP_FLOW1, DC2_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_DISP_FLOW1, field DC1_SRC_SEL (RW)
 *
 * Source select for DS1/DS2 - MG (graphics) plane (ch28)
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - capture0 (smfc0)
 * 0010 - capture2 (smfc2)
 * 0011 - IC encoding
 * 0100 - IC viewfinder
 * 0101 - IC playback
 * 0110 - IRT Encoding
 * 0111 - IRT viewfinder
 * 1000 - IRT playback
 * 1001 - Reserved
 * 1010 - Reserved
 * 1011 - autoref
 * 1100 - autoref+snoop1
 * 1101 - External source #1 (e.g. an external block like GPU)
 * 1110 - snoop1
 * 1111 - External source #2 (e.g. an external block like GPU)
 */

#define BP_IPU_FS_DISP_FLOW1_DC1_SRC_SEL      20
#define BM_IPU_FS_DISP_FLOW1_DC1_SRC_SEL      0x00f00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_DISP_FLOW1_DC1_SRC_SEL(v)   ((((reg32_t) v) << 20) & BM_IPU_FS_DISP_FLOW1_DC1_SRC_SEL)
#else
#define BF_IPU_FS_DISP_FLOW1_DC1_SRC_SEL(v)   (((v) << 20) & BM_IPU_FS_DISP_FLOW1_DC1_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC1_SRC_SEL field to a new value.
#define BW_IPU_FS_DISP_FLOW1_DC1_SRC_SEL(v)   BF_CS1(IPU_FS_DISP_FLOW1, DC1_SRC_SEL, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_FS_DISP_FLOW2 - FSU Displaying Flow 2 Register (RW)
 *
 * This register contains controls for IPU's tasks.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_ASYNC0_ALT_SRC_SEL : 4; //!< Source select for alternate DS2 - MG (graphics) plane (ch29)
        unsigned DP_ASYNC1_ALT_SRC_SEL : 4; //!< Source select for alternate DS1/DS2 - Vx (video) plane (ch24)
        unsigned RESERVED0 : 8; //!< Reserved
        unsigned DC2_ALT_SRC_SEL : 4; //!< Source select for Alternate DS3 (ch41)
        unsigned RESERVED1 : 12; //!< Reserved
    } B;
} hw_ipu_fs_disp_flow2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_FS_DISP_FLOW2 register
 */
#define HW_IPU_FS_DISP_FLOW2_ADDR(x)      (REGS_IPU_BASE(x) + 0xb8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_FS_DISP_FLOW2(x)           (*(volatile hw_ipu_fs_disp_flow2_t *) HW_IPU_FS_DISP_FLOW2_ADDR(x))
#define HW_IPU_FS_DISP_FLOW2_RD(x)        (HW_IPU_FS_DISP_FLOW2(x).U)
#define HW_IPU_FS_DISP_FLOW2_WR(x, v)     (HW_IPU_FS_DISP_FLOW2(x).U = (v))
#define HW_IPU_FS_DISP_FLOW2_SET(x, v)    (HW_IPU_FS_DISP_FLOW2_WR(x, HW_IPU_FS_DISP_FLOW2_RD(x) |  (v)))
#define HW_IPU_FS_DISP_FLOW2_CLR(x, v)    (HW_IPU_FS_DISP_FLOW2_WR(x, HW_IPU_FS_DISP_FLOW2_RD(x) & ~(v)))
#define HW_IPU_FS_DISP_FLOW2_TOG(x, v)    (HW_IPU_FS_DISP_FLOW2_WR(x, HW_IPU_FS_DISP_FLOW2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_FS_DISP_FLOW2 bitfields
 */

/* --- Register HW_IPU_FS_DISP_FLOW2, field DP_ASYNC0_ALT_SRC_SEL (RW)
 *
 * Source select for alternate DS2 - MG (graphics) plane (ch29)
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - capture0 (smfc0)
 * 0010 - capture2 (smfc2)
 * 0011 - IC encoding
 * 0100 - IC viewfinder
 * 0101 - IC playback
 * 0110 - IRT Encoding
 * 0111 - IRT viewfinder
 * 1000 - IRT playback
 * 1001 - Reserved
 * 1010 - Reserved
 * 1011 - autoref
 * 1100 - autoref+snoop1
 * 1101 - autoref+snoop2
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_DISP_FLOW2_DP_ASYNC0_ALT_SRC_SEL      0
#define BM_IPU_FS_DISP_FLOW2_DP_ASYNC0_ALT_SRC_SEL      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_DISP_FLOW2_DP_ASYNC0_ALT_SRC_SEL(v)   ((((reg32_t) v) << 0) & BM_IPU_FS_DISP_FLOW2_DP_ASYNC0_ALT_SRC_SEL)
#else
#define BF_IPU_FS_DISP_FLOW2_DP_ASYNC0_ALT_SRC_SEL(v)   (((v) << 0) & BM_IPU_FS_DISP_FLOW2_DP_ASYNC0_ALT_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_ASYNC0_ALT_SRC_SEL field to a new value.
#define BW_IPU_FS_DISP_FLOW2_DP_ASYNC0_ALT_SRC_SEL(v)   BF_CS1(IPU_FS_DISP_FLOW2, DP_ASYNC0_ALT_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_DISP_FLOW2, field DP_ASYNC1_ALT_SRC_SEL (RW)
 *
 * Source select for alternate DS1/DS2 - Vx (video) plane (ch24)
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - capture0 (smfc0)
 * 0010 - capture2 (smfc2)
 * 0011 - IC encoding
 * 0100 - IC viewfinder
 * 0101 - IC playback
 * 0110 - IRT Encoding
 * 0111 - IRT viewfinder
 * 1000 - IRT playback
 * 1001 - Reserved
 * 1010 - Reserved
 * 1011 - autoref
 * 1100 - autoref+snoop1
 * 1101 - autoref+snoop2
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_DISP_FLOW2_DP_ASYNC1_ALT_SRC_SEL      4
#define BM_IPU_FS_DISP_FLOW2_DP_ASYNC1_ALT_SRC_SEL      0x000000f0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_DISP_FLOW2_DP_ASYNC1_ALT_SRC_SEL(v)   ((((reg32_t) v) << 4) & BM_IPU_FS_DISP_FLOW2_DP_ASYNC1_ALT_SRC_SEL)
#else
#define BF_IPU_FS_DISP_FLOW2_DP_ASYNC1_ALT_SRC_SEL(v)   (((v) << 4) & BM_IPU_FS_DISP_FLOW2_DP_ASYNC1_ALT_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_ASYNC1_ALT_SRC_SEL field to a new value.
#define BW_IPU_FS_DISP_FLOW2_DP_ASYNC1_ALT_SRC_SEL(v)   BF_CS1(IPU_FS_DISP_FLOW2, DP_ASYNC1_ALT_SRC_SEL, v)
#endif


/* --- Register HW_IPU_FS_DISP_FLOW2, field DC2_ALT_SRC_SEL (RW)
 *
 * Source select for Alternate DS3 (ch41)
 *
 * Values:
 * 0000 - ARM platform
 * 0001 - capture0 (smfc0)
 * 0010 - capture2 (smfc2)
 * 0011 - IC encoding
 * 0100 - IC viewfinder
 * 0101 - IC playback
 * 0110 - IRT Encoding
 * 0111 - IRT viewfinder
 * 1000 - IRT playback
 * 1001 - Reserved
 * 1010 - Reserved
 * 1011 - autoref
 * 1100 - autoref+snoop1
 * 1101 - autoref+snoop2
 * 1110 - snoop1
 * 1111 - snoop2
 */

#define BP_IPU_FS_DISP_FLOW2_DC2_ALT_SRC_SEL      16
#define BM_IPU_FS_DISP_FLOW2_DC2_ALT_SRC_SEL      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_FS_DISP_FLOW2_DC2_ALT_SRC_SEL(v)   ((((reg32_t) v) << 16) & BM_IPU_FS_DISP_FLOW2_DC2_ALT_SRC_SEL)
#else
#define BF_IPU_FS_DISP_FLOW2_DC2_ALT_SRC_SEL(v)   (((v) << 16) & BM_IPU_FS_DISP_FLOW2_DC2_ALT_SRC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC2_ALT_SRC_SEL field to a new value.
#define BW_IPU_FS_DISP_FLOW2_DC2_ALT_SRC_SEL(v)   BF_CS1(IPU_FS_DISP_FLOW2, DC2_ALT_SRC_SEL, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SKIP - SKIP Register (RW)
 *
 * This register controls the different frame skipping supported by the IPU.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI_MAX_RATIO_SKIP_IC_ENC : 3; //!< CSI Maximum Ratio Skip for IC (encoding task) These bits define the number of frames in a skipping set. The maximum value of this bits is 4. When set to 0 the skipping is disabled.
        unsigned CSI_SKIP_IC_ENC : 5; //!< CSI SKIP IC_ENC These 5 bits define the skipping pattern of the frames send to the IC for encoding task from one of the CSIs as defined on the CSI_SEL and IC_INPUT bits Skipping is done for a set of frames. The number of frames in a set is defined at CSI_MAX_RATIO_SKIP_IC_ENC. when CSI_MAX_RATIO_SKIP_IC_ENC = 1 => CSI_SKIP_IC_ENC[1:0] are used; other bits are ignored when CSI_MAX_RATIO_SKIP_IC_ENC = 2 => CSI_SKIP_IC_ENC[2:0] are used; other bits are ignored when CSI_MAX_RATIO_SKIP_IC_ENC = 3 => CSI_SKIP_IC_ENC[3:0] are used; other bits are ignored when CSI_MAX_RATIO_SKIP_IC_ENC = 4 => CSI_SKIP_IC_ENC[4:0] are used; Setting bit #n of CSI_SKIP_IC_ENC means that the #n frame in the set is skipped. For example: if CSI_MAX_RATIO_SKIP_IC_ENC = 4 and CSI_SKIP_IC_ENC = 11010 Frames #0 & Frame #2 will not be skipped as bit0 and bit2 are cleared Frames #1 & Frame #3 will be skipped as bit1 and bit3 are set bit #4 is ignored as CSI_MAX_RATIO_SKIP_IC_ENC is set to 4
        unsigned CSI_MAX_RATIO_SKIP_IC_VF : 3; //!< CSI Maximum Ratio Skip for IC (view finder task) These bits define the number of frames in a skipping set. The maximum value of this bits is 4. When set to 0 the skipping is disabled.
        unsigned CSI_SKIP_IC_VF : 5; //!< CSI SKIP IC_VF These 5 bits define the skipping pattern of the frames send to the IC for view finder task from one of the CSIs as defined on the CSI_SEL and IC_INPUT bits Skipping is done for a set of frames. The number of frames in a set is defined at CSI_MAX_RATIO_SKIP_IC_VF. when CSI_MAX_RATIO_SKIP_IC_VF = 1 => CSI_SKIP_IC_VF[1:0] are used; other bits are ignored when CSI_MAX_RATIO_SKIP_IC_VF = 2 => CSI_SKIP_IC_VF[2:0] are used; other bits are ignored when CSI_MAX_RATIO_SKIP_IC_VF =3 => CSI_SKIP_IC_VF[3:0] are used; other bits are ignored when CSI_MAX_RATIO_SKIP_IC_VF = 4 => CSI_SKIP_IC_VF[4:0] are used; Setting bit #n of CSI_SKIP_IC_VF means that the #n frame in the set is skipped. For example: if CSI_MAX_RATIO_SKIP_IC_VF = 4 and CSI_SKIP_IC_VF = 11010 Frames #0 & Frame #2 will not be skipped as bit0 and bit2 are cleared Frames #1 & Frame #3 will be skipped as bit1 and bit3 are set bit #4 is ignored as CSI_MAX_RATIO_SKIP_IC_VF is set to 4
        unsigned VDI_MAX_RATIO_SKIP : 4; //!< Maximum Ratio Skip for VDI C These bits define the number of frames in a skipping set. The maximum value of this bits is 11. When set to 0 the skipping is disabled.
        unsigned VDI_SKIP : 12; //!< VDI_SKIP These 12 bits define the skipping pattern of the frames send from the VDI C . The VDI C avoids reading fields from the memory if the output frame is skipped. Skipping is relevant only if the source to the VDI C is coming from the CSI. Skipping is done for a set of frames. The number of frames in a set is defined at VDI_MAX_RATIO_SKIP. when VDI_MAX_RATIO_SKIP = 1 => VDI_SKIP[1:0] is used; other bits are ignored when VDI_MAX_RATIO_SKIP = 2 => VDI_SKIP[2:0] are used; other bits are ignored .. .. when VDI_MAX_RATIO_SKIP = 11 => VDI_SKIP[11:0] are used;
    } B;
} hw_ipu_skip_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SKIP register
 */
#define HW_IPU_SKIP_ADDR(x)      (REGS_IPU_BASE(x) + 0xbc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SKIP(x)           (*(volatile hw_ipu_skip_t *) HW_IPU_SKIP_ADDR(x))
#define HW_IPU_SKIP_RD(x)        (HW_IPU_SKIP(x).U)
#define HW_IPU_SKIP_WR(x, v)     (HW_IPU_SKIP(x).U = (v))
#define HW_IPU_SKIP_SET(x, v)    (HW_IPU_SKIP_WR(x, HW_IPU_SKIP_RD(x) |  (v)))
#define HW_IPU_SKIP_CLR(x, v)    (HW_IPU_SKIP_WR(x, HW_IPU_SKIP_RD(x) & ~(v)))
#define HW_IPU_SKIP_TOG(x, v)    (HW_IPU_SKIP_WR(x, HW_IPU_SKIP_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SKIP bitfields
 */

/* --- Register HW_IPU_SKIP, field CSI_MAX_RATIO_SKIP_IC_ENC (RW)
 *
 * CSI Maximum Ratio Skip for IC (encoding task) These bits define the number of frames in a
 * skipping set. The maximum value of this bits is 4. When set to 0 the skipping is disabled.
 */

#define BP_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_ENC      0
#define BM_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_ENC      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_ENC(v)   ((((reg32_t) v) << 0) & BM_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_ENC)
#else
#define BF_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_ENC(v)   (((v) << 0) & BM_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_ENC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI_MAX_RATIO_SKIP_IC_ENC field to a new value.
#define BW_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_ENC(v)   BF_CS1(IPU_SKIP, CSI_MAX_RATIO_SKIP_IC_ENC, v)
#endif

/* --- Register HW_IPU_SKIP, field CSI_SKIP_IC_ENC (RW)
 *
 * CSI SKIP IC_ENC These 5 bits define the skipping pattern of the frames send to the IC for
 * encoding task from one of the CSIs as defined on the CSI_SEL and IC_INPUT bits Skipping is done
 * for a set of frames. The number of frames in a set is defined at CSI_MAX_RATIO_SKIP_IC_ENC. when
 * CSI_MAX_RATIO_SKIP_IC_ENC = 1 => CSI_SKIP_IC_ENC[1:0] are used; other bits are ignored when
 * CSI_MAX_RATIO_SKIP_IC_ENC = 2 => CSI_SKIP_IC_ENC[2:0] are used; other bits are ignored when
 * CSI_MAX_RATIO_SKIP_IC_ENC = 3 => CSI_SKIP_IC_ENC[3:0] are used; other bits are ignored when
 * CSI_MAX_RATIO_SKIP_IC_ENC = 4 => CSI_SKIP_IC_ENC[4:0] are used; Setting bit #n of CSI_SKIP_IC_ENC
 * means that the #n frame in the set is skipped. For example: if CSI_MAX_RATIO_SKIP_IC_ENC = 4 and
 * CSI_SKIP_IC_ENC = 11010 Frames #0 & Frame #2 will not be skipped as bit0 and bit2 are cleared
 * Frames #1 & Frame #3 will be skipped as bit1 and bit3 are set bit #4 is ignored as
 * CSI_MAX_RATIO_SKIP_IC_ENC is set to 4
 */

#define BP_IPU_SKIP_CSI_SKIP_IC_ENC      3
#define BM_IPU_SKIP_CSI_SKIP_IC_ENC      0x000000f8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SKIP_CSI_SKIP_IC_ENC(v)   ((((reg32_t) v) << 3) & BM_IPU_SKIP_CSI_SKIP_IC_ENC)
#else
#define BF_IPU_SKIP_CSI_SKIP_IC_ENC(v)   (((v) << 3) & BM_IPU_SKIP_CSI_SKIP_IC_ENC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI_SKIP_IC_ENC field to a new value.
#define BW_IPU_SKIP_CSI_SKIP_IC_ENC(v)   BF_CS1(IPU_SKIP, CSI_SKIP_IC_ENC, v)
#endif

/* --- Register HW_IPU_SKIP, field CSI_MAX_RATIO_SKIP_IC_VF (RW)
 *
 * CSI Maximum Ratio Skip for IC (view finder task) These bits define the number of frames in a
 * skipping set. The maximum value of this bits is 4. When set to 0 the skipping is disabled.
 */

#define BP_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_VF      8
#define BM_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_VF      0x00000700

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_VF(v)   ((((reg32_t) v) << 8) & BM_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_VF)
#else
#define BF_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_VF(v)   (((v) << 8) & BM_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_VF)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI_MAX_RATIO_SKIP_IC_VF field to a new value.
#define BW_IPU_SKIP_CSI_MAX_RATIO_SKIP_IC_VF(v)   BF_CS1(IPU_SKIP, CSI_MAX_RATIO_SKIP_IC_VF, v)
#endif

/* --- Register HW_IPU_SKIP, field CSI_SKIP_IC_VF (RW)
 *
 * CSI SKIP IC_VF These 5 bits define the skipping pattern of the frames send to the IC for view
 * finder task from one of the CSIs as defined on the CSI_SEL and IC_INPUT bits Skipping is done for
 * a set of frames. The number of frames in a set is defined at CSI_MAX_RATIO_SKIP_IC_VF. when
 * CSI_MAX_RATIO_SKIP_IC_VF = 1 => CSI_SKIP_IC_VF[1:0] are used; other bits are ignored when
 * CSI_MAX_RATIO_SKIP_IC_VF = 2 => CSI_SKIP_IC_VF[2:0] are used; other bits are ignored when
 * CSI_MAX_RATIO_SKIP_IC_VF =3 => CSI_SKIP_IC_VF[3:0] are used; other bits are ignored when
 * CSI_MAX_RATIO_SKIP_IC_VF = 4 => CSI_SKIP_IC_VF[4:0] are used; Setting bit #n of CSI_SKIP_IC_VF
 * means that the #n frame in the set is skipped. For example: if CSI_MAX_RATIO_SKIP_IC_VF = 4 and
 * CSI_SKIP_IC_VF = 11010 Frames #0 & Frame #2 will not be skipped as bit0 and bit2 are cleared
 * Frames #1 & Frame #3 will be skipped as bit1 and bit3 are set bit #4 is ignored as
 * CSI_MAX_RATIO_SKIP_IC_VF is set to 4
 */

#define BP_IPU_SKIP_CSI_SKIP_IC_VF      11
#define BM_IPU_SKIP_CSI_SKIP_IC_VF      0x0000f800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SKIP_CSI_SKIP_IC_VF(v)   ((((reg32_t) v) << 11) & BM_IPU_SKIP_CSI_SKIP_IC_VF)
#else
#define BF_IPU_SKIP_CSI_SKIP_IC_VF(v)   (((v) << 11) & BM_IPU_SKIP_CSI_SKIP_IC_VF)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI_SKIP_IC_VF field to a new value.
#define BW_IPU_SKIP_CSI_SKIP_IC_VF(v)   BF_CS1(IPU_SKIP, CSI_SKIP_IC_VF, v)
#endif

/* --- Register HW_IPU_SKIP, field VDI_MAX_RATIO_SKIP (RW)
 *
 * Maximum Ratio Skip for VDI C These bits define the number of frames in a skipping set. The
 * maximum value of this bits is 11. When set to 0 the skipping is disabled.
 */

#define BP_IPU_SKIP_VDI_MAX_RATIO_SKIP      16
#define BM_IPU_SKIP_VDI_MAX_RATIO_SKIP      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SKIP_VDI_MAX_RATIO_SKIP(v)   ((((reg32_t) v) << 16) & BM_IPU_SKIP_VDI_MAX_RATIO_SKIP)
#else
#define BF_IPU_SKIP_VDI_MAX_RATIO_SKIP(v)   (((v) << 16) & BM_IPU_SKIP_VDI_MAX_RATIO_SKIP)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_MAX_RATIO_SKIP field to a new value.
#define BW_IPU_SKIP_VDI_MAX_RATIO_SKIP(v)   BF_CS1(IPU_SKIP, VDI_MAX_RATIO_SKIP, v)
#endif

/* --- Register HW_IPU_SKIP, field VDI_SKIP (RW)
 *
 * VDI_SKIP These 12 bits define the skipping pattern of the frames send from the VDI C . The VDI C
 * avoids reading fields from the memory if the output frame is skipped. Skipping is relevant only
 * if the source to the VDI C is coming from the CSI. Skipping is done for a set of frames. The
 * number of frames in a set is defined at VDI_MAX_RATIO_SKIP. when VDI_MAX_RATIO_SKIP = 1 =>
 * VDI_SKIP[1:0] is used; other bits are ignored when VDI_MAX_RATIO_SKIP = 2 => VDI_SKIP[2:0] are
 * used; other bits are ignored .. .. when VDI_MAX_RATIO_SKIP = 11 => VDI_SKIP[11:0] are used;
 */

#define BP_IPU_SKIP_VDI_SKIP      20
#define BM_IPU_SKIP_VDI_SKIP      0xfff00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SKIP_VDI_SKIP(v)   ((((reg32_t) v) << 20) & BM_IPU_SKIP_VDI_SKIP)
#else
#define BF_IPU_SKIP_VDI_SKIP(v)   (((v) << 20) & BM_IPU_SKIP_VDI_SKIP)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_SKIP field to a new value.
#define BW_IPU_SKIP_VDI_SKIP(v)   BF_CS1(IPU_SKIP, VDI_SKIP, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DISP_ALT_CONF - Display Alternate Configuration Register (RW)
 *
 * This register controls various parameters that are used for alternate flows related to the
 * display modules.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 32; //!< Reserved
    } B;
} hw_ipu_disp_alt_conf_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DISP_ALT_CONF register
 */
#define HW_IPU_DISP_ALT_CONF_ADDR(x)      (REGS_IPU_BASE(x) + 0xc0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DISP_ALT_CONF(x)           (*(volatile hw_ipu_disp_alt_conf_t *) HW_IPU_DISP_ALT_CONF_ADDR(x))
#define HW_IPU_DISP_ALT_CONF_RD(x)        (HW_IPU_DISP_ALT_CONF(x).U)
#define HW_IPU_DISP_ALT_CONF_WR(x, v)     (HW_IPU_DISP_ALT_CONF(x).U = (v))
#define HW_IPU_DISP_ALT_CONF_SET(x, v)    (HW_IPU_DISP_ALT_CONF_WR(x, HW_IPU_DISP_ALT_CONF_RD(x) |  (v)))
#define HW_IPU_DISP_ALT_CONF_CLR(x, v)    (HW_IPU_DISP_ALT_CONF_WR(x, HW_IPU_DISP_ALT_CONF_RD(x) & ~(v)))
#define HW_IPU_DISP_ALT_CONF_TOG(x, v)    (HW_IPU_DISP_ALT_CONF_WR(x, HW_IPU_DISP_ALT_CONF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DISP_ALT_CONF bitfields
 */

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DISP_GEN - Display General Control Register (RW)
 *
 * This register controls various aspects of the display port.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_DUAL_MODE : 1; //!< DI0 dual mode control
        unsigned DI1_DUAL_MODE : 1; //!< DI1 dual mode control
        unsigned DC2_DOUBLE_FLOW : 1; //!< DC2 Double Flow. This bit define how many flows are currently handles via DC2 channel (ch41)
        unsigned DP_ASYNC_DOUBLE_FLOW : 1; //!< DP Async Double Flow. This bit define how many async flows are currently handles via DP channel (ch24+29)
        unsigned DP_FG_EN_ASYNC0 : 1; //!< FG_EN - partial plane Enable for async flow 0. This bit enables the partial plane channel.
        unsigned DP_FG_EN_ASYNC1 : 1; //!< FG_EN - partial plane Enable for async flow 1. This bit enables the partial plane channel.
        unsigned DP_PIPE_CLR : 1; //!< DP Pipe Clear This bit clears the internal pipe of the DP. The user may use this bit in case of an error condition This is a self clear bit
        unsigned RESERVED0 : 9; //!< Reserved
        unsigned MCU_DI_ID_8 : 1; //!< MCU_DI_ID_8 - DI ID via DC channel 8. This bit defines the DI that the ARM platform DC's access via channel #8
        unsigned MCU_DI_ID_9 : 1; //!< MCU_DI_ID_9 - DI ID via DC channel 9. This bit defines the DI that the ARM platform DC's access via channel #9
        unsigned MCU_T : 4; //!< The address space for accesses through the AHB-lite slave port is 512 128 MB and it is split internally (with 32MB resolution) according to bits [28:25] of the address. Using the following notation: Address = (ID[31:29], MSB[28:25], LSB[24:0]) The address is used as follows ("T" is a configurable integer between 0 and 13): MSB<T: access to an external device, with address = (MSB, LSB) T<=MSB<14: access to an external device, with address (MSB-T, LSB)
        unsigned MCU_MAX_BURST_STOP : 1; //!< ARM platform Maximal burst This bit limit the maximal unspecified length burst.
        unsigned CSI_VSYNC_DEST : 1; //!< CSI_VSYNC destination This bit defines the destination of the VSYNC coming from the CSI's
        unsigned DI0_COUNTER_RELEASE : 1; //!< DI1 Counter release By default the DI0 counters responsible for waveform generation for sync flow are frozen. For the first attempt to use the DI in sync flow the user should set this bit
        unsigned DI1_COUNTER_RELEASE : 1; //!< DI1 Counter release By default the DI0 counters responsible for waveform generation for sync flow are frozen. For the first attempt to use the DI in sync flow the user should set this bit
        unsigned RESERVED1 : 6; //!< Reserved
    } B;
} hw_ipu_disp_gen_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DISP_GEN register
 */
#define HW_IPU_DISP_GEN_ADDR(x)      (REGS_IPU_BASE(x) + 0xc4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DISP_GEN(x)           (*(volatile hw_ipu_disp_gen_t *) HW_IPU_DISP_GEN_ADDR(x))
#define HW_IPU_DISP_GEN_RD(x)        (HW_IPU_DISP_GEN(x).U)
#define HW_IPU_DISP_GEN_WR(x, v)     (HW_IPU_DISP_GEN(x).U = (v))
#define HW_IPU_DISP_GEN_SET(x, v)    (HW_IPU_DISP_GEN_WR(x, HW_IPU_DISP_GEN_RD(x) |  (v)))
#define HW_IPU_DISP_GEN_CLR(x, v)    (HW_IPU_DISP_GEN_WR(x, HW_IPU_DISP_GEN_RD(x) & ~(v)))
#define HW_IPU_DISP_GEN_TOG(x, v)    (HW_IPU_DISP_GEN_WR(x, HW_IPU_DISP_GEN_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DISP_GEN bitfields
 */

/* --- Register HW_IPU_DISP_GEN, field DI0_DUAL_MODE (RW)
 *
 * DI0 dual mode control
 *
 * Values:
 * 1 - DI0 operates in dual mode
 * 0 - DI0 is not in dual mode
 */

#define BP_IPU_DISP_GEN_DI0_DUAL_MODE      0
#define BM_IPU_DISP_GEN_DI0_DUAL_MODE      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_DI0_DUAL_MODE(v)   ((((reg32_t) v) << 0) & BM_IPU_DISP_GEN_DI0_DUAL_MODE)
#else
#define BF_IPU_DISP_GEN_DI0_DUAL_MODE(v)   (((v) << 0) & BM_IPU_DISP_GEN_DI0_DUAL_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DUAL_MODE field to a new value.
#define BW_IPU_DISP_GEN_DI0_DUAL_MODE(v)   BF_CS1(IPU_DISP_GEN, DI0_DUAL_MODE, v)
#endif


/* --- Register HW_IPU_DISP_GEN, field DI1_DUAL_MODE (RW)
 *
 * DI1 dual mode control
 *
 * Values:
 * 1 - DI1 operates in dual mode
 * 0 - DI1 is not in dual mode
 */

#define BP_IPU_DISP_GEN_DI1_DUAL_MODE      1
#define BM_IPU_DISP_GEN_DI1_DUAL_MODE      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_DI1_DUAL_MODE(v)   ((((reg32_t) v) << 1) & BM_IPU_DISP_GEN_DI1_DUAL_MODE)
#else
#define BF_IPU_DISP_GEN_DI1_DUAL_MODE(v)   (((v) << 1) & BM_IPU_DISP_GEN_DI1_DUAL_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DUAL_MODE field to a new value.
#define BW_IPU_DISP_GEN_DI1_DUAL_MODE(v)   BF_CS1(IPU_DISP_GEN, DI1_DUAL_MODE, v)
#endif


/* --- Register HW_IPU_DISP_GEN, field DC2_DOUBLE_FLOW (RW)
 *
 * DC2 Double Flow. This bit define how many flows are currently handles via DC2 channel (ch41)
 *
 * Values:
 * 1 - 2 flows are handled via DC2
 * 0 - single flow is handled via DC2
 */

#define BP_IPU_DISP_GEN_DC2_DOUBLE_FLOW      2
#define BM_IPU_DISP_GEN_DC2_DOUBLE_FLOW      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_DC2_DOUBLE_FLOW(v)   ((((reg32_t) v) << 2) & BM_IPU_DISP_GEN_DC2_DOUBLE_FLOW)
#else
#define BF_IPU_DISP_GEN_DC2_DOUBLE_FLOW(v)   (((v) << 2) & BM_IPU_DISP_GEN_DC2_DOUBLE_FLOW)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC2_DOUBLE_FLOW field to a new value.
#define BW_IPU_DISP_GEN_DC2_DOUBLE_FLOW(v)   BF_CS1(IPU_DISP_GEN, DC2_DOUBLE_FLOW, v)
#endif


/* --- Register HW_IPU_DISP_GEN, field DP_ASYNC_DOUBLE_FLOW (RW)
 *
 * DP Async Double Flow. This bit define how many async flows are currently handles via DP channel
 * (ch24+29)
 *
 * Values:
 * 1 - 2 flows are handled via DP
 * 0 - single flow is handled via DP
 */

#define BP_IPU_DISP_GEN_DP_ASYNC_DOUBLE_FLOW      3
#define BM_IPU_DISP_GEN_DP_ASYNC_DOUBLE_FLOW      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_DP_ASYNC_DOUBLE_FLOW(v)   ((((reg32_t) v) << 3) & BM_IPU_DISP_GEN_DP_ASYNC_DOUBLE_FLOW)
#else
#define BF_IPU_DISP_GEN_DP_ASYNC_DOUBLE_FLOW(v)   (((v) << 3) & BM_IPU_DISP_GEN_DP_ASYNC_DOUBLE_FLOW)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_ASYNC_DOUBLE_FLOW field to a new value.
#define BW_IPU_DISP_GEN_DP_ASYNC_DOUBLE_FLOW(v)   BF_CS1(IPU_DISP_GEN, DP_ASYNC_DOUBLE_FLOW, v)
#endif


/* --- Register HW_IPU_DISP_GEN, field DP_FG_EN_ASYNC0 (RW)
 *
 * FG_EN - partial plane Enable for async flow 0. This bit enables the partial plane channel.
 *
 * Values:
 * 1 - partial plane channel is enabled.
 * 0 - partial plane channel is disabled.
 */

#define BP_IPU_DISP_GEN_DP_FG_EN_ASYNC0      4
#define BM_IPU_DISP_GEN_DP_FG_EN_ASYNC0      0x00000010

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_DP_FG_EN_ASYNC0(v)   ((((reg32_t) v) << 4) & BM_IPU_DISP_GEN_DP_FG_EN_ASYNC0)
#else
#define BF_IPU_DISP_GEN_DP_FG_EN_ASYNC0(v)   (((v) << 4) & BM_IPU_DISP_GEN_DP_FG_EN_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_FG_EN_ASYNC0 field to a new value.
#define BW_IPU_DISP_GEN_DP_FG_EN_ASYNC0(v)   BF_CS1(IPU_DISP_GEN, DP_FG_EN_ASYNC0, v)
#endif


/* --- Register HW_IPU_DISP_GEN, field DP_FG_EN_ASYNC1 (RW)
 *
 * FG_EN - partial plane Enable for async flow 1. This bit enables the partial plane channel.
 *
 * Values:
 * 1 - partial plane channel is enabled.
 * 0 - partial plane channel is disabled.
 */

#define BP_IPU_DISP_GEN_DP_FG_EN_ASYNC1      5
#define BM_IPU_DISP_GEN_DP_FG_EN_ASYNC1      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_DP_FG_EN_ASYNC1(v)   ((((reg32_t) v) << 5) & BM_IPU_DISP_GEN_DP_FG_EN_ASYNC1)
#else
#define BF_IPU_DISP_GEN_DP_FG_EN_ASYNC1(v)   (((v) << 5) & BM_IPU_DISP_GEN_DP_FG_EN_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_FG_EN_ASYNC1 field to a new value.
#define BW_IPU_DISP_GEN_DP_FG_EN_ASYNC1(v)   BF_CS1(IPU_DISP_GEN, DP_FG_EN_ASYNC1, v)
#endif


/* --- Register HW_IPU_DISP_GEN, field DP_PIPE_CLR (WORZ)
 *
 * DP Pipe Clear This bit clears the internal pipe of the DP. The user may use this bit in case of
 * an error condition This is a self clear bit
 *
 * Values:
 * 1 - Clear the internal pipe of the DP
 * 0 - Idle - does nothing
 */

#define BP_IPU_DISP_GEN_DP_PIPE_CLR      6
#define BM_IPU_DISP_GEN_DP_PIPE_CLR      0x00000040


/* --- Register HW_IPU_DISP_GEN, field MCU_DI_ID_8 (RW)
 *
 * MCU_DI_ID_8 - DI ID via DC channel 8. This bit defines the DI that the ARM platform DC's access
 * via channel #8
 *
 * Values:
 * 1 - ARM platform accesses DC's channel #8 via DI1.
 * 0 - ARM platform accesses DC's channel #8 via DI0.
 */

#define BP_IPU_DISP_GEN_MCU_DI_ID_8      16
#define BM_IPU_DISP_GEN_MCU_DI_ID_8      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_MCU_DI_ID_8(v)   ((((reg32_t) v) << 16) & BM_IPU_DISP_GEN_MCU_DI_ID_8)
#else
#define BF_IPU_DISP_GEN_MCU_DI_ID_8(v)   (((v) << 16) & BM_IPU_DISP_GEN_MCU_DI_ID_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_DI_ID_8 field to a new value.
#define BW_IPU_DISP_GEN_MCU_DI_ID_8(v)   BF_CS1(IPU_DISP_GEN, MCU_DI_ID_8, v)
#endif


/* --- Register HW_IPU_DISP_GEN, field MCU_DI_ID_9 (RW)
 *
 * MCU_DI_ID_9 - DI ID via DC channel 9. This bit defines the DI that the ARM platform DC's access
 * via channel #9
 *
 * Values:
 * 1 - ARM platform accesses DC's channel #9 via DI1.
 * 0 - ARM platform accesses DC's channel #9 via DI0.
 */

#define BP_IPU_DISP_GEN_MCU_DI_ID_9      17
#define BM_IPU_DISP_GEN_MCU_DI_ID_9      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_MCU_DI_ID_9(v)   ((((reg32_t) v) << 17) & BM_IPU_DISP_GEN_MCU_DI_ID_9)
#else
#define BF_IPU_DISP_GEN_MCU_DI_ID_9(v)   (((v) << 17) & BM_IPU_DISP_GEN_MCU_DI_ID_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_DI_ID_9 field to a new value.
#define BW_IPU_DISP_GEN_MCU_DI_ID_9(v)   BF_CS1(IPU_DISP_GEN, MCU_DI_ID_9, v)
#endif


/* --- Register HW_IPU_DISP_GEN, field MCU_T (RW)
 *
 * The address space for accesses through the AHB-lite slave port is 512 128 MB and it is split
 * internally (with 32MB resolution) according to bits [28:25] of the address. Using the following
 * notation: Address = (ID[31:29], MSB[28:25], LSB[24:0]) The address is used as follows ("T" is a
 * configurable integer between 0 and 13): MSB<T: access to an external device, with address = (MSB,
 * LSB) T<=MSB<14: access to an external device, with address (MSB-T, LSB)
 */

#define BP_IPU_DISP_GEN_MCU_T      18
#define BM_IPU_DISP_GEN_MCU_T      0x003c0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_MCU_T(v)   ((((reg32_t) v) << 18) & BM_IPU_DISP_GEN_MCU_T)
#else
#define BF_IPU_DISP_GEN_MCU_T(v)   (((v) << 18) & BM_IPU_DISP_GEN_MCU_T)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_T field to a new value.
#define BW_IPU_DISP_GEN_MCU_T(v)   BF_CS1(IPU_DISP_GEN, MCU_T, v)
#endif

/* --- Register HW_IPU_DISP_GEN, field MCU_MAX_BURST_STOP (RW)
 *
 * ARM platform Maximal burst This bit limit the maximal unspecified length burst.
 *
 * Values:
 * 1 - The maximum unspecified burst length is 8-beat
 * 0 - The unspecified burst length is unlimited
 */

#define BP_IPU_DISP_GEN_MCU_MAX_BURST_STOP      22
#define BM_IPU_DISP_GEN_MCU_MAX_BURST_STOP      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_MCU_MAX_BURST_STOP(v)   ((((reg32_t) v) << 22) & BM_IPU_DISP_GEN_MCU_MAX_BURST_STOP)
#else
#define BF_IPU_DISP_GEN_MCU_MAX_BURST_STOP(v)   (((v) << 22) & BM_IPU_DISP_GEN_MCU_MAX_BURST_STOP)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_MAX_BURST_STOP field to a new value.
#define BW_IPU_DISP_GEN_MCU_MAX_BURST_STOP(v)   BF_CS1(IPU_DISP_GEN, MCU_MAX_BURST_STOP, v)
#endif


/* --- Register HW_IPU_DISP_GEN, field CSI_VSYNC_DEST (RW)
 *
 * CSI_VSYNC destination This bit defines the destination of the VSYNC coming from the CSI's
 *
 * Values:
 * 1 - csi1_vsync is connected to DI0; csi0_vsync is connected to DI1
 * 0 - csi0_vsync is connected to DI0; csi1_vsync is connected to DI1
 */

#define BP_IPU_DISP_GEN_CSI_VSYNC_DEST      23
#define BM_IPU_DISP_GEN_CSI_VSYNC_DEST      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_CSI_VSYNC_DEST(v)   ((((reg32_t) v) << 23) & BM_IPU_DISP_GEN_CSI_VSYNC_DEST)
#else
#define BF_IPU_DISP_GEN_CSI_VSYNC_DEST(v)   (((v) << 23) & BM_IPU_DISP_GEN_CSI_VSYNC_DEST)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI_VSYNC_DEST field to a new value.
#define BW_IPU_DISP_GEN_CSI_VSYNC_DEST(v)   BF_CS1(IPU_DISP_GEN, CSI_VSYNC_DEST, v)
#endif


/* --- Register HW_IPU_DISP_GEN, field DI0_COUNTER_RELEASE (RW)
 *
 * DI1 Counter release By default the DI0 counters responsible for waveform generation for sync flow
 * are frozen. For the first attempt to use the DI in sync flow the user should set this bit
 *
 * Values:
 * 1 - counter is released and running
 * 0 - counter is cleared and stopped
 */

#define BP_IPU_DISP_GEN_DI0_COUNTER_RELEASE      24
#define BM_IPU_DISP_GEN_DI0_COUNTER_RELEASE      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_DI0_COUNTER_RELEASE(v)   ((((reg32_t) v) << 24) & BM_IPU_DISP_GEN_DI0_COUNTER_RELEASE)
#else
#define BF_IPU_DISP_GEN_DI0_COUNTER_RELEASE(v)   (((v) << 24) & BM_IPU_DISP_GEN_DI0_COUNTER_RELEASE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_COUNTER_RELEASE field to a new value.
#define BW_IPU_DISP_GEN_DI0_COUNTER_RELEASE(v)   BF_CS1(IPU_DISP_GEN, DI0_COUNTER_RELEASE, v)
#endif


/* --- Register HW_IPU_DISP_GEN, field DI1_COUNTER_RELEASE (RW)
 *
 * DI1 Counter release By default the DI0 counters responsible for waveform generation for sync flow
 * are frozen. For the first attempt to use the DI in sync flow the user should set this bit
 *
 * Values:
 * 1 - counter is released and running
 * 0 - counter is cleared and stopped
 */

#define BP_IPU_DISP_GEN_DI1_COUNTER_RELEASE      25
#define BM_IPU_DISP_GEN_DI1_COUNTER_RELEASE      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_GEN_DI1_COUNTER_RELEASE(v)   ((((reg32_t) v) << 25) & BM_IPU_DISP_GEN_DI1_COUNTER_RELEASE)
#else
#define BF_IPU_DISP_GEN_DI1_COUNTER_RELEASE(v)   (((v) << 25) & BM_IPU_DISP_GEN_DI1_COUNTER_RELEASE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_COUNTER_RELEASE field to a new value.
#define BW_IPU_DISP_GEN_DI1_COUNTER_RELEASE(v)   BF_CS1(IPU_DISP_GEN, DI1_COUNTER_RELEASE, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DISP_ALT1 - Display Alternate Flow Control Register 1 (RW)
 *
 * This register controls various aspects of the display port.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RUN_VALUE_M1_ALT_0 : 12; //!< Counter pre defined value This fields defines the counter pre defines value. real value- 1
        unsigned CNT_CLR_SEL_ALT_0 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned CNT_AUTO_RELOAD_ALT_0 : 1; //!< Counter auto reload mode
        unsigned STEP_REPEAT_ALT_0 : 12; //!< This fields defines the amount of repetitions that will be performed by the counter
        unsigned SEL_ALT_0 : 4; //!< Select alternative parameters instead of DI Sync Wave Gen counter#. The DI is selected according to DP's synchronous channel destination 0000-disable
    } B;
} hw_ipu_disp_alt1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DISP_ALT1 register
 */
#define HW_IPU_DISP_ALT1_ADDR(x)      (REGS_IPU_BASE(x) + 0xc8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DISP_ALT1(x)           (*(volatile hw_ipu_disp_alt1_t *) HW_IPU_DISP_ALT1_ADDR(x))
#define HW_IPU_DISP_ALT1_RD(x)        (HW_IPU_DISP_ALT1(x).U)
#define HW_IPU_DISP_ALT1_WR(x, v)     (HW_IPU_DISP_ALT1(x).U = (v))
#define HW_IPU_DISP_ALT1_SET(x, v)    (HW_IPU_DISP_ALT1_WR(x, HW_IPU_DISP_ALT1_RD(x) |  (v)))
#define HW_IPU_DISP_ALT1_CLR(x, v)    (HW_IPU_DISP_ALT1_WR(x, HW_IPU_DISP_ALT1_RD(x) & ~(v)))
#define HW_IPU_DISP_ALT1_TOG(x, v)    (HW_IPU_DISP_ALT1_WR(x, HW_IPU_DISP_ALT1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DISP_ALT1 bitfields
 */

/* --- Register HW_IPU_DISP_ALT1, field RUN_VALUE_M1_ALT_0 (RW)
 *
 * Counter pre defined value This fields defines the counter pre defines value. real value- 1
 */

#define BP_IPU_DISP_ALT1_RUN_VALUE_M1_ALT_0      0
#define BM_IPU_DISP_ALT1_RUN_VALUE_M1_ALT_0      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT1_RUN_VALUE_M1_ALT_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DISP_ALT1_RUN_VALUE_M1_ALT_0)
#else
#define BF_IPU_DISP_ALT1_RUN_VALUE_M1_ALT_0(v)   (((v) << 0) & BM_IPU_DISP_ALT1_RUN_VALUE_M1_ALT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the RUN_VALUE_M1_ALT_0 field to a new value.
#define BW_IPU_DISP_ALT1_RUN_VALUE_M1_ALT_0(v)   BF_CS1(IPU_DISP_ALT1, RUN_VALUE_M1_ALT_0, v)
#endif

/* --- Register HW_IPU_DISP_ALT1, field CNT_CLR_SEL_ALT_0 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - Reserved
 * 011 - Reserved
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DISP_ALT1_CNT_CLR_SEL_ALT_0      12
#define BM_IPU_DISP_ALT1_CNT_CLR_SEL_ALT_0      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT1_CNT_CLR_SEL_ALT_0(v)   ((((reg32_t) v) << 12) & BM_IPU_DISP_ALT1_CNT_CLR_SEL_ALT_0)
#else
#define BF_IPU_DISP_ALT1_CNT_CLR_SEL_ALT_0(v)   (((v) << 12) & BM_IPU_DISP_ALT1_CNT_CLR_SEL_ALT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CNT_CLR_SEL_ALT_0 field to a new value.
#define BW_IPU_DISP_ALT1_CNT_CLR_SEL_ALT_0(v)   BF_CS1(IPU_DISP_ALT1, CNT_CLR_SEL_ALT_0, v)
#endif


/* --- Register HW_IPU_DISP_ALT1, field CNT_AUTO_RELOAD_ALT_0 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the step_repeat_alt_0
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the step_repeat_alt_0 field
 */

#define BP_IPU_DISP_ALT1_CNT_AUTO_RELOAD_ALT_0      15
#define BM_IPU_DISP_ALT1_CNT_AUTO_RELOAD_ALT_0      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT1_CNT_AUTO_RELOAD_ALT_0(v)   ((((reg32_t) v) << 15) & BM_IPU_DISP_ALT1_CNT_AUTO_RELOAD_ALT_0)
#else
#define BF_IPU_DISP_ALT1_CNT_AUTO_RELOAD_ALT_0(v)   (((v) << 15) & BM_IPU_DISP_ALT1_CNT_AUTO_RELOAD_ALT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CNT_AUTO_RELOAD_ALT_0 field to a new value.
#define BW_IPU_DISP_ALT1_CNT_AUTO_RELOAD_ALT_0(v)   BF_CS1(IPU_DISP_ALT1, CNT_AUTO_RELOAD_ALT_0, v)
#endif


/* --- Register HW_IPU_DISP_ALT1, field STEP_REPEAT_ALT_0 (RW)
 *
 * This fields defines the amount of repetitions that will be performed by the counter
 */

#define BP_IPU_DISP_ALT1_STEP_REPEAT_ALT_0      16
#define BM_IPU_DISP_ALT1_STEP_REPEAT_ALT_0      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT1_STEP_REPEAT_ALT_0(v)   ((((reg32_t) v) << 16) & BM_IPU_DISP_ALT1_STEP_REPEAT_ALT_0)
#else
#define BF_IPU_DISP_ALT1_STEP_REPEAT_ALT_0(v)   (((v) << 16) & BM_IPU_DISP_ALT1_STEP_REPEAT_ALT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the STEP_REPEAT_ALT_0 field to a new value.
#define BW_IPU_DISP_ALT1_STEP_REPEAT_ALT_0(v)   BF_CS1(IPU_DISP_ALT1, STEP_REPEAT_ALT_0, v)
#endif

/* --- Register HW_IPU_DISP_ALT1, field SEL_ALT_0 (RW)
 *
 * Select alternative parameters instead of DI Sync Wave Gen counter#. The DI is selected according
 * to DP's synchronous channel destination 0000-disable
 *
 * Values:
 * 0001 - instead of counter 1
 * 0010 - instead of counter 2
 * 1000 - instead of counter 8
 */

#define BP_IPU_DISP_ALT1_SEL_ALT_0      28
#define BM_IPU_DISP_ALT1_SEL_ALT_0      0xf0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT1_SEL_ALT_0(v)   ((((reg32_t) v) << 28) & BM_IPU_DISP_ALT1_SEL_ALT_0)
#else
#define BF_IPU_DISP_ALT1_SEL_ALT_0(v)   (((v) << 28) & BM_IPU_DISP_ALT1_SEL_ALT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SEL_ALT_0 field to a new value.
#define BW_IPU_DISP_ALT1_SEL_ALT_0(v)   BF_CS1(IPU_DISP_ALT1, SEL_ALT_0, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DISP_ALT2 - Display Alternate Flow Control Register 2 (RW)
 *
 * This register controls various aspects of the display port.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned OFFSET_VALUE_ALT_0 : 12; //!< Counter offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned OFFSET_RESOLUTION_ALT_0 : 3; //!< Counter offset Resolution This field defines the trigger causing the offset counter to increment The counter offset resolution should be defined in the same way as in original DI's counter#
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned RUN_RESOLUTION_ALT_0 : 3; //!< Counter Run Resolution This field defines the trigger causing the counter to increment. The counter run resolution should be defined in the same way as in original DI's counter#
        unsigned RESERVED1 : 13; //!< Reserved
    } B;
} hw_ipu_disp_alt2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DISP_ALT2 register
 */
#define HW_IPU_DISP_ALT2_ADDR(x)      (REGS_IPU_BASE(x) + 0xcc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DISP_ALT2(x)           (*(volatile hw_ipu_disp_alt2_t *) HW_IPU_DISP_ALT2_ADDR(x))
#define HW_IPU_DISP_ALT2_RD(x)        (HW_IPU_DISP_ALT2(x).U)
#define HW_IPU_DISP_ALT2_WR(x, v)     (HW_IPU_DISP_ALT2(x).U = (v))
#define HW_IPU_DISP_ALT2_SET(x, v)    (HW_IPU_DISP_ALT2_WR(x, HW_IPU_DISP_ALT2_RD(x) |  (v)))
#define HW_IPU_DISP_ALT2_CLR(x, v)    (HW_IPU_DISP_ALT2_WR(x, HW_IPU_DISP_ALT2_RD(x) & ~(v)))
#define HW_IPU_DISP_ALT2_TOG(x, v)    (HW_IPU_DISP_ALT2_WR(x, HW_IPU_DISP_ALT2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DISP_ALT2 bitfields
 */

/* --- Register HW_IPU_DISP_ALT2, field OFFSET_VALUE_ALT_0 (RW)
 *
 * Counter offset value The counter can start counting after a pre defined delay This field defines
 * the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DISP_ALT2_OFFSET_VALUE_ALT_0      0
#define BM_IPU_DISP_ALT2_OFFSET_VALUE_ALT_0      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT2_OFFSET_VALUE_ALT_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DISP_ALT2_OFFSET_VALUE_ALT_0)
#else
#define BF_IPU_DISP_ALT2_OFFSET_VALUE_ALT_0(v)   (((v) << 0) & BM_IPU_DISP_ALT2_OFFSET_VALUE_ALT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OFFSET_VALUE_ALT_0 field to a new value.
#define BW_IPU_DISP_ALT2_OFFSET_VALUE_ALT_0(v)   BF_CS1(IPU_DISP_ALT2, OFFSET_VALUE_ALT_0, v)
#endif

/* --- Register HW_IPU_DISP_ALT2, field OFFSET_RESOLUTION_ALT_0 (RW)
 *
 * Counter offset Resolution This field defines the trigger causing the offset counter to increment
 * The counter offset resolution should be defined in the same way as in original DI's counter#
 */

#define BP_IPU_DISP_ALT2_OFFSET_RESOLUTION_ALT_0      12
#define BM_IPU_DISP_ALT2_OFFSET_RESOLUTION_ALT_0      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT2_OFFSET_RESOLUTION_ALT_0(v)   ((((reg32_t) v) << 12) & BM_IPU_DISP_ALT2_OFFSET_RESOLUTION_ALT_0)
#else
#define BF_IPU_DISP_ALT2_OFFSET_RESOLUTION_ALT_0(v)   (((v) << 12) & BM_IPU_DISP_ALT2_OFFSET_RESOLUTION_ALT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OFFSET_RESOLUTION_ALT_0 field to a new value.
#define BW_IPU_DISP_ALT2_OFFSET_RESOLUTION_ALT_0(v)   BF_CS1(IPU_DISP_ALT2, OFFSET_RESOLUTION_ALT_0, v)
#endif

/* --- Register HW_IPU_DISP_ALT2, field RUN_RESOLUTION_ALT_0 (RW)
 *
 * Counter Run Resolution This field defines the trigger causing the counter to increment. The
 * counter run resolution should be defined in the same way as in original DI's counter#
 */

#define BP_IPU_DISP_ALT2_RUN_RESOLUTION_ALT_0      16
#define BM_IPU_DISP_ALT2_RUN_RESOLUTION_ALT_0      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT2_RUN_RESOLUTION_ALT_0(v)   ((((reg32_t) v) << 16) & BM_IPU_DISP_ALT2_RUN_RESOLUTION_ALT_0)
#else
#define BF_IPU_DISP_ALT2_RUN_RESOLUTION_ALT_0(v)   (((v) << 16) & BM_IPU_DISP_ALT2_RUN_RESOLUTION_ALT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the RUN_RESOLUTION_ALT_0 field to a new value.
#define BW_IPU_DISP_ALT2_RUN_RESOLUTION_ALT_0(v)   BF_CS1(IPU_DISP_ALT2, RUN_RESOLUTION_ALT_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DISP_ALT3 - Display Alternate Flow Control Register 3 (RW)
 *
 * This register controls various aspects of the display port.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RUN_VALUE_M1_ALT_1 : 12; //!< Counter pre defined value This fields defines the counter pre defines value. real value- 1
        unsigned CNT_CLR_SEL_ALT_1 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned CNT_AUTO_RELOAD_ALT_1 : 1; //!< Counter auto reload mode
        unsigned STEP_REPEAT_ALT_1 : 12; //!< This fields defines the amount of repetitions that will be performed by the counter
        unsigned SEL_ALT_1 : 4; //!< Select alternative parameters instead of DI Sync Wave Gen counter#. The DI is selected according to DP's synchronous channel destination
    } B;
} hw_ipu_disp_alt3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DISP_ALT3 register
 */
#define HW_IPU_DISP_ALT3_ADDR(x)      (REGS_IPU_BASE(x) + 0xd0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DISP_ALT3(x)           (*(volatile hw_ipu_disp_alt3_t *) HW_IPU_DISP_ALT3_ADDR(x))
#define HW_IPU_DISP_ALT3_RD(x)        (HW_IPU_DISP_ALT3(x).U)
#define HW_IPU_DISP_ALT3_WR(x, v)     (HW_IPU_DISP_ALT3(x).U = (v))
#define HW_IPU_DISP_ALT3_SET(x, v)    (HW_IPU_DISP_ALT3_WR(x, HW_IPU_DISP_ALT3_RD(x) |  (v)))
#define HW_IPU_DISP_ALT3_CLR(x, v)    (HW_IPU_DISP_ALT3_WR(x, HW_IPU_DISP_ALT3_RD(x) & ~(v)))
#define HW_IPU_DISP_ALT3_TOG(x, v)    (HW_IPU_DISP_ALT3_WR(x, HW_IPU_DISP_ALT3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DISP_ALT3 bitfields
 */

/* --- Register HW_IPU_DISP_ALT3, field RUN_VALUE_M1_ALT_1 (RW)
 *
 * Counter pre defined value This fields defines the counter pre defines value. real value- 1
 */

#define BP_IPU_DISP_ALT3_RUN_VALUE_M1_ALT_1      0
#define BM_IPU_DISP_ALT3_RUN_VALUE_M1_ALT_1      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT3_RUN_VALUE_M1_ALT_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DISP_ALT3_RUN_VALUE_M1_ALT_1)
#else
#define BF_IPU_DISP_ALT3_RUN_VALUE_M1_ALT_1(v)   (((v) << 0) & BM_IPU_DISP_ALT3_RUN_VALUE_M1_ALT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the RUN_VALUE_M1_ALT_1 field to a new value.
#define BW_IPU_DISP_ALT3_RUN_VALUE_M1_ALT_1(v)   BF_CS1(IPU_DISP_ALT3, RUN_VALUE_M1_ALT_1, v)
#endif

/* --- Register HW_IPU_DISP_ALT3, field CNT_CLR_SEL_ALT_1 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - Reserved
 * 011 - Reserved
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DISP_ALT3_CNT_CLR_SEL_ALT_1      12
#define BM_IPU_DISP_ALT3_CNT_CLR_SEL_ALT_1      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT3_CNT_CLR_SEL_ALT_1(v)   ((((reg32_t) v) << 12) & BM_IPU_DISP_ALT3_CNT_CLR_SEL_ALT_1)
#else
#define BF_IPU_DISP_ALT3_CNT_CLR_SEL_ALT_1(v)   (((v) << 12) & BM_IPU_DISP_ALT3_CNT_CLR_SEL_ALT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CNT_CLR_SEL_ALT_1 field to a new value.
#define BW_IPU_DISP_ALT3_CNT_CLR_SEL_ALT_1(v)   BF_CS1(IPU_DISP_ALT3, CNT_CLR_SEL_ALT_1, v)
#endif


/* --- Register HW_IPU_DISP_ALT3, field CNT_AUTO_RELOAD_ALT_1 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the step_repeat_alt_0
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the step_repeat_alt_0 field
 */

#define BP_IPU_DISP_ALT3_CNT_AUTO_RELOAD_ALT_1      15
#define BM_IPU_DISP_ALT3_CNT_AUTO_RELOAD_ALT_1      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT3_CNT_AUTO_RELOAD_ALT_1(v)   ((((reg32_t) v) << 15) & BM_IPU_DISP_ALT3_CNT_AUTO_RELOAD_ALT_1)
#else
#define BF_IPU_DISP_ALT3_CNT_AUTO_RELOAD_ALT_1(v)   (((v) << 15) & BM_IPU_DISP_ALT3_CNT_AUTO_RELOAD_ALT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CNT_AUTO_RELOAD_ALT_1 field to a new value.
#define BW_IPU_DISP_ALT3_CNT_AUTO_RELOAD_ALT_1(v)   BF_CS1(IPU_DISP_ALT3, CNT_AUTO_RELOAD_ALT_1, v)
#endif


/* --- Register HW_IPU_DISP_ALT3, field STEP_REPEAT_ALT_1 (RW)
 *
 * This fields defines the amount of repetitions that will be performed by the counter
 */

#define BP_IPU_DISP_ALT3_STEP_REPEAT_ALT_1      16
#define BM_IPU_DISP_ALT3_STEP_REPEAT_ALT_1      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT3_STEP_REPEAT_ALT_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DISP_ALT3_STEP_REPEAT_ALT_1)
#else
#define BF_IPU_DISP_ALT3_STEP_REPEAT_ALT_1(v)   (((v) << 16) & BM_IPU_DISP_ALT3_STEP_REPEAT_ALT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the STEP_REPEAT_ALT_1 field to a new value.
#define BW_IPU_DISP_ALT3_STEP_REPEAT_ALT_1(v)   BF_CS1(IPU_DISP_ALT3, STEP_REPEAT_ALT_1, v)
#endif

/* --- Register HW_IPU_DISP_ALT3, field SEL_ALT_1 (RW)
 *
 * Select alternative parameters instead of DI Sync Wave Gen counter#. The DI is selected according
 * to DP's synchronous channel destination
 *
 * Values:
 * 0000 - disable
 * 0001 - instead of counter 1
 * 0010 - instead of counter 2
 * 1000 - instead of counter 8
 */

#define BP_IPU_DISP_ALT3_SEL_ALT_1      28
#define BM_IPU_DISP_ALT3_SEL_ALT_1      0xf0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT3_SEL_ALT_1(v)   ((((reg32_t) v) << 28) & BM_IPU_DISP_ALT3_SEL_ALT_1)
#else
#define BF_IPU_DISP_ALT3_SEL_ALT_1(v)   (((v) << 28) & BM_IPU_DISP_ALT3_SEL_ALT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SEL_ALT_1 field to a new value.
#define BW_IPU_DISP_ALT3_SEL_ALT_1(v)   BF_CS1(IPU_DISP_ALT3, SEL_ALT_1, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DISP_ALT4 - Display Alternate Flow Control Register 4 (RW)
 *
 * This register controls various aspects of the display port.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned OFFSET_VALUE_ALT_1 : 12; //!< Counter offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned OFFSET_RESOLUTION_ALT_1 : 3; //!< Counter offset Resolution This field defines the trigger causing the offset counter to increment The counter offset resolution should be defined in the same way as in original DI's counter#
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned RUN_RESOLUTION_ALT_1 : 3; //!< Counter Run Resolution This field defines the trigger causing the counter to increment. The counter run resolution should be defined in the same way as in original DI's counter#
        unsigned RESERVED1 : 13; //!< Reserved
    } B;
} hw_ipu_disp_alt4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DISP_ALT4 register
 */
#define HW_IPU_DISP_ALT4_ADDR(x)      (REGS_IPU_BASE(x) + 0xd4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DISP_ALT4(x)           (*(volatile hw_ipu_disp_alt4_t *) HW_IPU_DISP_ALT4_ADDR(x))
#define HW_IPU_DISP_ALT4_RD(x)        (HW_IPU_DISP_ALT4(x).U)
#define HW_IPU_DISP_ALT4_WR(x, v)     (HW_IPU_DISP_ALT4(x).U = (v))
#define HW_IPU_DISP_ALT4_SET(x, v)    (HW_IPU_DISP_ALT4_WR(x, HW_IPU_DISP_ALT4_RD(x) |  (v)))
#define HW_IPU_DISP_ALT4_CLR(x, v)    (HW_IPU_DISP_ALT4_WR(x, HW_IPU_DISP_ALT4_RD(x) & ~(v)))
#define HW_IPU_DISP_ALT4_TOG(x, v)    (HW_IPU_DISP_ALT4_WR(x, HW_IPU_DISP_ALT4_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DISP_ALT4 bitfields
 */

/* --- Register HW_IPU_DISP_ALT4, field OFFSET_VALUE_ALT_1 (RW)
 *
 * Counter offset value The counter can start counting after a pre defined delay This field defines
 * the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DISP_ALT4_OFFSET_VALUE_ALT_1      0
#define BM_IPU_DISP_ALT4_OFFSET_VALUE_ALT_1      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT4_OFFSET_VALUE_ALT_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DISP_ALT4_OFFSET_VALUE_ALT_1)
#else
#define BF_IPU_DISP_ALT4_OFFSET_VALUE_ALT_1(v)   (((v) << 0) & BM_IPU_DISP_ALT4_OFFSET_VALUE_ALT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OFFSET_VALUE_ALT_1 field to a new value.
#define BW_IPU_DISP_ALT4_OFFSET_VALUE_ALT_1(v)   BF_CS1(IPU_DISP_ALT4, OFFSET_VALUE_ALT_1, v)
#endif

/* --- Register HW_IPU_DISP_ALT4, field OFFSET_RESOLUTION_ALT_1 (RW)
 *
 * Counter offset Resolution This field defines the trigger causing the offset counter to increment
 * The counter offset resolution should be defined in the same way as in original DI's counter#
 */

#define BP_IPU_DISP_ALT4_OFFSET_RESOLUTION_ALT_1      12
#define BM_IPU_DISP_ALT4_OFFSET_RESOLUTION_ALT_1      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT4_OFFSET_RESOLUTION_ALT_1(v)   ((((reg32_t) v) << 12) & BM_IPU_DISP_ALT4_OFFSET_RESOLUTION_ALT_1)
#else
#define BF_IPU_DISP_ALT4_OFFSET_RESOLUTION_ALT_1(v)   (((v) << 12) & BM_IPU_DISP_ALT4_OFFSET_RESOLUTION_ALT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OFFSET_RESOLUTION_ALT_1 field to a new value.
#define BW_IPU_DISP_ALT4_OFFSET_RESOLUTION_ALT_1(v)   BF_CS1(IPU_DISP_ALT4, OFFSET_RESOLUTION_ALT_1, v)
#endif

/* --- Register HW_IPU_DISP_ALT4, field RUN_RESOLUTION_ALT_1 (RW)
 *
 * Counter Run Resolution This field defines the trigger causing the counter to increment. The
 * counter run resolution should be defined in the same way as in original DI's counter#
 */

#define BP_IPU_DISP_ALT4_RUN_RESOLUTION_ALT_1      16
#define BM_IPU_DISP_ALT4_RUN_RESOLUTION_ALT_1      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DISP_ALT4_RUN_RESOLUTION_ALT_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DISP_ALT4_RUN_RESOLUTION_ALT_1)
#else
#define BF_IPU_DISP_ALT4_RUN_RESOLUTION_ALT_1(v)   (((v) << 16) & BM_IPU_DISP_ALT4_RUN_RESOLUTION_ALT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the RUN_RESOLUTION_ALT_1 field to a new value.
#define BW_IPU_DISP_ALT4_RUN_RESOLUTION_ALT_1(v)   BF_CS1(IPU_DISP_ALT4, RUN_RESOLUTION_ALT_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SNOOP - Autorefresh and Snooping Control Register (RW)
 *
 * This register controls the snooping mechanism
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned AUTOREF_PER : 10; //!< Autorefresh period minus 1. The actual value of autorefresh period is equal to the high speed clock (HSP_CLK) period multiplied by 2^17*(AUTO_REF_PER+1).
        unsigned RESERVED0 : 6; //!< Reserved
        unsigned SNOOP2_SYNC_BYP : 1; //!< This bits control the bypass of the synchronizer on emi_snooping2 signal. This bit is for test purposes only. The user should not set this bit
        unsigned RESERVED1 : 15; //!< Reserved
    } B;
} hw_ipu_snoop_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SNOOP register
 */
#define HW_IPU_SNOOP_ADDR(x)      (REGS_IPU_BASE(x) + 0xd8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SNOOP(x)           (*(volatile hw_ipu_snoop_t *) HW_IPU_SNOOP_ADDR(x))
#define HW_IPU_SNOOP_RD(x)        (HW_IPU_SNOOP(x).U)
#define HW_IPU_SNOOP_WR(x, v)     (HW_IPU_SNOOP(x).U = (v))
#define HW_IPU_SNOOP_SET(x, v)    (HW_IPU_SNOOP_WR(x, HW_IPU_SNOOP_RD(x) |  (v)))
#define HW_IPU_SNOOP_CLR(x, v)    (HW_IPU_SNOOP_WR(x, HW_IPU_SNOOP_RD(x) & ~(v)))
#define HW_IPU_SNOOP_TOG(x, v)    (HW_IPU_SNOOP_WR(x, HW_IPU_SNOOP_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SNOOP bitfields
 */

/* --- Register HW_IPU_SNOOP, field AUTOREF_PER (RW)
 *
 * Autorefresh period minus 1. The actual value of autorefresh period is equal to the high speed
 * clock (HSP_CLK) period multiplied by 2^17*(AUTO_REF_PER+1).
 */

#define BP_IPU_SNOOP_AUTOREF_PER      0
#define BM_IPU_SNOOP_AUTOREF_PER      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SNOOP_AUTOREF_PER(v)   ((((reg32_t) v) << 0) & BM_IPU_SNOOP_AUTOREF_PER)
#else
#define BF_IPU_SNOOP_AUTOREF_PER(v)   (((v) << 0) & BM_IPU_SNOOP_AUTOREF_PER)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the AUTOREF_PER field to a new value.
#define BW_IPU_SNOOP_AUTOREF_PER(v)   BF_CS1(IPU_SNOOP, AUTOREF_PER, v)
#endif

/* --- Register HW_IPU_SNOOP, field SNOOP2_SYNC_BYP (RW)
 *
 * This bits control the bypass of the synchronizer on emi_snooping2 signal. This bit is for test
 * purposes only. The user should not set this bit
 *
 * Values:
 * 1 - bypass the emi_snooping2 synchronizer
 * 0 - normal mode emi_snooping2 is internally synchronized
 */

#define BP_IPU_SNOOP_SNOOP2_SYNC_BYP      16
#define BM_IPU_SNOOP_SNOOP2_SYNC_BYP      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SNOOP_SNOOP2_SYNC_BYP(v)   ((((reg32_t) v) << 16) & BM_IPU_SNOOP_SNOOP2_SYNC_BYP)
#else
#define BF_IPU_SNOOP_SNOOP2_SYNC_BYP(v)   (((v) << 16) & BM_IPU_SNOOP_SNOOP2_SYNC_BYP)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SNOOP2_SYNC_BYP field to a new value.
#define BW_IPU_SNOOP_SNOOP2_SYNC_BYP(v)   BF_CS1(IPU_SNOOP, SNOOP2_SYNC_BYP, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_MEM_RST - Memory Reset Control Register (RW)
 *
 * This register controls the memory reset mechanism. IPU has a hardware mechanism for clearing the
 * content of the internal memories. This allows the user to clear the content of or more of the
 * internal memories without the need to perform write accesses to the memories.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RST_MEM_EN : 23; //!< Reset Memory Enable Each bit on this field enables the memory reset mechanism for a specific memory. The user should set the relevant bits for the memories that need to be cleared. Below is the list of memories and their corresponding bit. srm = rst_mem_en[0] alpha = rst_mem_en[1] cpmem = rst_mem_en[2] tpm = rst_mem_en[3] mpm = rst_mem_en[4] bm = rst_mem_en[5] rm = rst_mem_en[6] dstm = rst_mem_en[7] dsom = rst_mem_en[8] lut0 = rst_mem_en[9] lut1 = rst_mem_en[10] ram_smfc = rst_mem_en[11] isp_st vdi_fifo2 = rst_mem_en[12] isp_hist vdi_fifo3 = rst_mem_en[13] ram_pp1 icb = rst_mem_en[14] ram_mix1 vdi_fifo1 = rst_mem_en[15] ram_pp0 = rst_mem_en[16] ram_mix0 = rst_mem_en[17] fifo_ram = rst_mem_en[18] isp_tbpr = rst_mem_en[19] dc_template = rst_mem_en[20] dmfc_rd = rst_mem_en[21] dmfc_wr = rst_mem_en[22]
        unsigned RESERVED0 : 8; //!< Reserved
        unsigned RST_MEM_START : 1; //!< Memory Reset Start Writing one to this bit activate the memory reset mechanism. The memories that their corresponding RST_MEM_EN bit is set will be cleared. When the memory reset mechanism completes the memory clearing procedure this bit will be automatically cleared.
    } B;
} hw_ipu_mem_rst_t;
#endif

/*
 * constants & macros for entire multi-block IPU_MEM_RST register
 */
#define HW_IPU_MEM_RST_ADDR(x)      (REGS_IPU_BASE(x) + 0xdc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_MEM_RST(x)           (*(volatile hw_ipu_mem_rst_t *) HW_IPU_MEM_RST_ADDR(x))
#define HW_IPU_MEM_RST_RD(x)        (HW_IPU_MEM_RST(x).U)
#define HW_IPU_MEM_RST_WR(x, v)     (HW_IPU_MEM_RST(x).U = (v))
#define HW_IPU_MEM_RST_SET(x, v)    (HW_IPU_MEM_RST_WR(x, HW_IPU_MEM_RST_RD(x) |  (v)))
#define HW_IPU_MEM_RST_CLR(x, v)    (HW_IPU_MEM_RST_WR(x, HW_IPU_MEM_RST_RD(x) & ~(v)))
#define HW_IPU_MEM_RST_TOG(x, v)    (HW_IPU_MEM_RST_WR(x, HW_IPU_MEM_RST_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_MEM_RST bitfields
 */

/* --- Register HW_IPU_MEM_RST, field RST_MEM_EN (RW)
 *
 * Reset Memory Enable Each bit on this field enables the memory reset mechanism for a specific
 * memory. The user should set the relevant bits for the memories that need to be cleared. Below is
 * the list of memories and their corresponding bit. srm = rst_mem_en[0] alpha = rst_mem_en[1] cpmem
 * = rst_mem_en[2] tpm = rst_mem_en[3] mpm = rst_mem_en[4] bm = rst_mem_en[5] rm = rst_mem_en[6]
 * dstm = rst_mem_en[7] dsom = rst_mem_en[8] lut0 = rst_mem_en[9] lut1 = rst_mem_en[10] ram_smfc =
 * rst_mem_en[11] isp_st vdi_fifo2 = rst_mem_en[12] isp_hist vdi_fifo3 = rst_mem_en[13] ram_pp1 icb
 * = rst_mem_en[14] ram_mix1 vdi_fifo1 = rst_mem_en[15] ram_pp0 = rst_mem_en[16] ram_mix0 =
 * rst_mem_en[17] fifo_ram = rst_mem_en[18] isp_tbpr = rst_mem_en[19] dc_template = rst_mem_en[20]
 * dmfc_rd = rst_mem_en[21] dmfc_wr = rst_mem_en[22]
 */

#define BP_IPU_MEM_RST_RST_MEM_EN      0
#define BM_IPU_MEM_RST_RST_MEM_EN      0x007fffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_MEM_RST_RST_MEM_EN(v)   ((((reg32_t) v) << 0) & BM_IPU_MEM_RST_RST_MEM_EN)
#else
#define BF_IPU_MEM_RST_RST_MEM_EN(v)   (((v) << 0) & BM_IPU_MEM_RST_RST_MEM_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the RST_MEM_EN field to a new value.
#define BW_IPU_MEM_RST_RST_MEM_EN(v)   BF_CS1(IPU_MEM_RST, RST_MEM_EN, v)
#endif

/* --- Register HW_IPU_MEM_RST, field RST_MEM_START (RW)
 *
 * Memory Reset Start Writing one to this bit activate the memory reset mechanism. The memories that
 * their corresponding RST_MEM_EN bit is set will be cleared. When the memory reset mechanism
 * completes the memory clearing procedure this bit will be automatically cleared.
 *
 * Values:
 * 1 - The memory reset mechanism is activated and busy
 * 0 - Idle, the memory reset mechanism is not working.
 */

#define BP_IPU_MEM_RST_RST_MEM_START      31
#define BM_IPU_MEM_RST_RST_MEM_START      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_MEM_RST_RST_MEM_START(v)   ((((reg32_t) v) << 31) & BM_IPU_MEM_RST_RST_MEM_START)
#else
#define BF_IPU_MEM_RST_RST_MEM_START(v)   (((v) << 31) & BM_IPU_MEM_RST_RST_MEM_START)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the RST_MEM_START field to a new value.
#define BW_IPU_MEM_RST_RST_MEM_START(v)   BF_CS1(IPU_MEM_RST, RST_MEM_START, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_PM - Power Modes Control Register (RW)
 *
 * This register controls the automatic transitions of the IPU between different power modes of the
 * SoC and handles the clock change modes.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_CLK_PERIOD_0 : 7; //!< DI0_CLK period option 0. This parameter defines the period of the clock that the DI0 works with. This parameter contains integer part (bits [6:4]) and fractional part (bits [3:0]). Setting this value to 1.0 (default) means that the DI0 works on the fastest possible clock. Setting a value smaller than 1.0 is not allowed. The value to be programmed to the DI0_CLK_PERIOD_1 field is equal to: Fast_freq/Target_freq Where: Target_freq = The frequency that the DI clock works with Fast_freq = fastest possible clock that the DI can work with
        unsigned DI0_CLK_PERIOD_1 : 7; //!< DI0_CLK period option 1. This parameter defines the period of the clock that the DI0 works with. This parameter contains integer part (bits [6:4]) and fractional part (bits [3:0]). Setting this value to 1.0 (default) means that the DI0 works on the fastest possible clock. Setting a value smaller than 1.0 is not allowed. The value to be programmed to the DI0_CLK_PERIOD_1 field is equal to: Fast_freq/Target_freq Where: Target_freq = The frequency that the DI clock works with Fast_freq = fastest possible clock that the DI can work with
        unsigned DI0_SRM_CLOCK_CHANGE_MODE : 1; //!< SRM clock change mode When the clock is going to be changed to any new ratio other then 1:1, 1:2. 1:4. The user needs to prepare an alternate set of DI setting in the SRM. This bit enable this mode. This bit is self cleared.
        unsigned CLCOK_MODE_STAT : 1; //!< Clock mode status This is a read only bit indicating what is the current clock mode
        unsigned DI1_CLK_PERIOD_0 : 7; //!< DI1_CLK period option 0. This parameter defines the period of the clock that the DI1 works with. This parameter contains integer part (bits [6:4]) and fractional part (bits [3:0]). Setting this value to 1.0 (default) means that the DI1 works on the fastest possible clock. Setting a value smaller than 1.0 is not allowed. The value to be programmed to the DI1_CLK_PERIOD_1 field is equal to: Fast_freq/Target_freq Where: Target_freq = The frequency that the DI clock works with Fast_freq = fastest possible clock that the DI can work with
        unsigned DI1_CLK_PERIOD_1 : 7; //!< DI1_CLK period option 1. This parameter defines the period of the clock that the DI1 works with. This parameter contains integer part (bits [6:4]) and fractional part (bits [3:0]). Setting this value to 1.0 (default) means that the DI1 works on the fastest possible clock. Setting a value smaller than 1.0 is not allowed. The value to be programmed to the DI1_CLK_PERIOD_1 field is equal to: Fast_freq/Target_freq Where: Target_freq = The frequency that the DI clock works with Fast_freq = fastest possible clock that the DI can work with
        unsigned DI1_SRM_CLOCK_CHANGE_MODE : 1; //!< SRM clock change mode When the clock is going to be changed to any new ratio other then 1:1, 1:2. 1:4. The user needs to prepare an alternate set of DI setting in the SRM. This bit enable this mode. This bit is self cleared.
        unsigned LPSR_MODE : 1; //!< LPSR Mode This bit indicates that the next attempt for entering low power mode is an attempt to move to LPST mode. Setting this bit by the user is essential in order to assure proper response of the IPU to the assertion of the stop request from the CCM.
    } B;
} hw_ipu_pm_t;
#endif

/*
 * constants & macros for entire multi-block IPU_PM register
 */
#define HW_IPU_PM_ADDR(x)      (REGS_IPU_BASE(x) + 0xe0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_PM(x)           (*(volatile hw_ipu_pm_t *) HW_IPU_PM_ADDR(x))
#define HW_IPU_PM_RD(x)        (HW_IPU_PM(x).U)
#define HW_IPU_PM_WR(x, v)     (HW_IPU_PM(x).U = (v))
#define HW_IPU_PM_SET(x, v)    (HW_IPU_PM_WR(x, HW_IPU_PM_RD(x) |  (v)))
#define HW_IPU_PM_CLR(x, v)    (HW_IPU_PM_WR(x, HW_IPU_PM_RD(x) & ~(v)))
#define HW_IPU_PM_TOG(x, v)    (HW_IPU_PM_WR(x, HW_IPU_PM_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_PM bitfields
 */

/* --- Register HW_IPU_PM, field DI0_CLK_PERIOD_0 (RW)
 *
 * DI0_CLK period option 0. This parameter defines the period of the clock that the DI0 works with.
 * This parameter contains integer part (bits [6:4]) and fractional part (bits [3:0]). Setting this
 * value to 1.0 (default) means that the DI0 works on the fastest possible clock. Setting a value
 * smaller than 1.0 is not allowed. The value to be programmed to the DI0_CLK_PERIOD_1 field is
 * equal to: Fast_freq/Target_freq Where: Target_freq = The frequency that the DI clock works with
 * Fast_freq = fastest possible clock that the DI can work with
 */

#define BP_IPU_PM_DI0_CLK_PERIOD_0      0
#define BM_IPU_PM_DI0_CLK_PERIOD_0      0x0000007f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_PM_DI0_CLK_PERIOD_0(v)   ((((reg32_t) v) << 0) & BM_IPU_PM_DI0_CLK_PERIOD_0)
#else
#define BF_IPU_PM_DI0_CLK_PERIOD_0(v)   (((v) << 0) & BM_IPU_PM_DI0_CLK_PERIOD_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CLK_PERIOD_0 field to a new value.
#define BW_IPU_PM_DI0_CLK_PERIOD_0(v)   BF_CS1(IPU_PM, DI0_CLK_PERIOD_0, v)
#endif

/* --- Register HW_IPU_PM, field DI0_CLK_PERIOD_1 (RW)
 *
 * DI0_CLK period option 1. This parameter defines the period of the clock that the DI0 works with.
 * This parameter contains integer part (bits [6:4]) and fractional part (bits [3:0]). Setting this
 * value to 1.0 (default) means that the DI0 works on the fastest possible clock. Setting a value
 * smaller than 1.0 is not allowed. The value to be programmed to the DI0_CLK_PERIOD_1 field is
 * equal to: Fast_freq/Target_freq Where: Target_freq = The frequency that the DI clock works with
 * Fast_freq = fastest possible clock that the DI can work with
 */

#define BP_IPU_PM_DI0_CLK_PERIOD_1      7
#define BM_IPU_PM_DI0_CLK_PERIOD_1      0x00003f80

#ifndef __LANGUAGE_ASM__
#define BF_IPU_PM_DI0_CLK_PERIOD_1(v)   ((((reg32_t) v) << 7) & BM_IPU_PM_DI0_CLK_PERIOD_1)
#else
#define BF_IPU_PM_DI0_CLK_PERIOD_1(v)   (((v) << 7) & BM_IPU_PM_DI0_CLK_PERIOD_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CLK_PERIOD_1 field to a new value.
#define BW_IPU_PM_DI0_CLK_PERIOD_1(v)   BF_CS1(IPU_PM, DI0_CLK_PERIOD_1, v)
#endif

/* --- Register HW_IPU_PM, field DI0_SRM_CLOCK_CHANGE_MODE (RW)
 *
 * SRM clock change mode When the clock is going to be changed to any new ratio other then 1:1, 1:2.
 * 1:4. The user needs to prepare an alternate set of DI setting in the SRM. This bit enable this
 * mode. This bit is self cleared.
 *
 * Values:
 * 1 - SRM clock change mode is enabled; the next clock change will be done by updating the DI settings
 *     from the SRM
 * 0 - SRM clock change mode is disabled.
 */

#define BP_IPU_PM_DI0_SRM_CLOCK_CHANGE_MODE      14
#define BM_IPU_PM_DI0_SRM_CLOCK_CHANGE_MODE      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_PM_DI0_SRM_CLOCK_CHANGE_MODE(v)   ((((reg32_t) v) << 14) & BM_IPU_PM_DI0_SRM_CLOCK_CHANGE_MODE)
#else
#define BF_IPU_PM_DI0_SRM_CLOCK_CHANGE_MODE(v)   (((v) << 14) & BM_IPU_PM_DI0_SRM_CLOCK_CHANGE_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SRM_CLOCK_CHANGE_MODE field to a new value.
#define BW_IPU_PM_DI0_SRM_CLOCK_CHANGE_MODE(v)   BF_CS1(IPU_PM, DI0_SRM_CLOCK_CHANGE_MODE, v)
#endif


/* --- Register HW_IPU_PM, field CLCOK_MODE_STAT (RO)
 *
 * Clock mode status This is a read only bit indicating what is the current clock mode
 *
 * Values:
 * 1 - current clock mode is 1
 * 0 - current clock mode is 0
 */

#define BP_IPU_PM_CLCOK_MODE_STAT      15
#define BM_IPU_PM_CLCOK_MODE_STAT      0x00008000


/* --- Register HW_IPU_PM, field DI1_CLK_PERIOD_0 (RW)
 *
 * DI1_CLK period option 0. This parameter defines the period of the clock that the DI1 works with.
 * This parameter contains integer part (bits [6:4]) and fractional part (bits [3:0]). Setting this
 * value to 1.0 (default) means that the DI1 works on the fastest possible clock. Setting a value
 * smaller than 1.0 is not allowed. The value to be programmed to the DI1_CLK_PERIOD_1 field is
 * equal to: Fast_freq/Target_freq Where: Target_freq = The frequency that the DI clock works with
 * Fast_freq = fastest possible clock that the DI can work with
 */

#define BP_IPU_PM_DI1_CLK_PERIOD_0      16
#define BM_IPU_PM_DI1_CLK_PERIOD_0      0x007f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_PM_DI1_CLK_PERIOD_0(v)   ((((reg32_t) v) << 16) & BM_IPU_PM_DI1_CLK_PERIOD_0)
#else
#define BF_IPU_PM_DI1_CLK_PERIOD_0(v)   (((v) << 16) & BM_IPU_PM_DI1_CLK_PERIOD_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CLK_PERIOD_0 field to a new value.
#define BW_IPU_PM_DI1_CLK_PERIOD_0(v)   BF_CS1(IPU_PM, DI1_CLK_PERIOD_0, v)
#endif

/* --- Register HW_IPU_PM, field DI1_CLK_PERIOD_1 (RW)
 *
 * DI1_CLK period option 1. This parameter defines the period of the clock that the DI1 works with.
 * This parameter contains integer part (bits [6:4]) and fractional part (bits [3:0]). Setting this
 * value to 1.0 (default) means that the DI1 works on the fastest possible clock. Setting a value
 * smaller than 1.0 is not allowed. The value to be programmed to the DI1_CLK_PERIOD_1 field is
 * equal to: Fast_freq/Target_freq Where: Target_freq = The frequency that the DI clock works with
 * Fast_freq = fastest possible clock that the DI can work with
 */

#define BP_IPU_PM_DI1_CLK_PERIOD_1      23
#define BM_IPU_PM_DI1_CLK_PERIOD_1      0x3f800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_PM_DI1_CLK_PERIOD_1(v)   ((((reg32_t) v) << 23) & BM_IPU_PM_DI1_CLK_PERIOD_1)
#else
#define BF_IPU_PM_DI1_CLK_PERIOD_1(v)   (((v) << 23) & BM_IPU_PM_DI1_CLK_PERIOD_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CLK_PERIOD_1 field to a new value.
#define BW_IPU_PM_DI1_CLK_PERIOD_1(v)   BF_CS1(IPU_PM, DI1_CLK_PERIOD_1, v)
#endif

/* --- Register HW_IPU_PM, field DI1_SRM_CLOCK_CHANGE_MODE (RW)
 *
 * SRM clock change mode When the clock is going to be changed to any new ratio other then 1:1, 1:2.
 * 1:4. The user needs to prepare an alternate set of DI setting in the SRM. This bit enable this
 * mode. This bit is self cleared.
 *
 * Values:
 * 1 - SRM clock change mode is enabled; the next clock change will be done by updating the DI settings
 *     from the SRM
 * 0 - SRM clock change mode is disabled.
 */

#define BP_IPU_PM_DI1_SRM_CLOCK_CHANGE_MODE      30
#define BM_IPU_PM_DI1_SRM_CLOCK_CHANGE_MODE      0x40000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_PM_DI1_SRM_CLOCK_CHANGE_MODE(v)   ((((reg32_t) v) << 30) & BM_IPU_PM_DI1_SRM_CLOCK_CHANGE_MODE)
#else
#define BF_IPU_PM_DI1_SRM_CLOCK_CHANGE_MODE(v)   (((v) << 30) & BM_IPU_PM_DI1_SRM_CLOCK_CHANGE_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SRM_CLOCK_CHANGE_MODE field to a new value.
#define BW_IPU_PM_DI1_SRM_CLOCK_CHANGE_MODE(v)   BF_CS1(IPU_PM, DI1_SRM_CLOCK_CHANGE_MODE, v)
#endif


/* --- Register HW_IPU_PM, field LPSR_MODE (RW)
 *
 * LPSR Mode This bit indicates that the next attempt for entering low power mode is an attempt to
 * move to LPST mode. Setting this bit by the user is essential in order to assure proper response
 * of the IPU to the assertion of the stop request from the CCM.
 *
 * Values:
 * 1 - Next low power mode will be LPSR
 * 0 - Next low power mode is not LPSR
 */

#define BP_IPU_PM_LPSR_MODE      31
#define BM_IPU_PM_LPSR_MODE      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_PM_LPSR_MODE(v)   ((((reg32_t) v) << 31) & BM_IPU_PM_LPSR_MODE)
#else
#define BF_IPU_PM_LPSR_MODE(v)   (((v) << 31) & BM_IPU_PM_LPSR_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the LPSR_MODE field to a new value.
#define BW_IPU_PM_LPSR_MODE(v)   BF_CS1(IPU_PM, LPSR_MODE, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_GPR - General Purpose Register (RW)
 *
 * The register contains general purpose bits.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IPU_GPN : 19; //!< IPU General Purpose bit. n Indicates the corresponding DMA channel number. This bits are general Read/Write bits, reserved for future use
        unsigned VF_TSTAT_CLR : 1; //!< Reset viewfinder state machine. The bit is not self cleared - In case of writing 1 to this bit, the bit has to be cleared in order to exit the IDLE state.
        unsigned RESERVED0 : 2; //!< Reserved.
        unsigned IPU_DI0_CLK_CHANGE_ACK_DIS : 1; //!< Disable DI0's clock change mechanism.
        unsigned IPU_DI1_CLK_CHANGE_ACK_DIS : 1; //!< Disable DI1's clock change mechanism.
        unsigned IPU_ALT_CH_BUF0_RDY0_CLR : 1; //!< This bit defines the IPU_ALT_CH_BUF0_RDY0 properties. This register can be a write one to clear OR write one to set.
        unsigned IPU_ALT_CH_BUF0_RDY1_CLR : 1; //!< This bit defines the IPU_ALT_CH_BUF0_RDY1 properties. This register can be a write one to clear OR write one to set.
        unsigned IPU_ALT_CH_BUF1_RDY0_CLR : 1; //!< This bit defines the IPU_ALT_CH_BUF1_RDY0 properties. This register can be a write one to clear OR write one to set.
        unsigned IPU_ALT_CH_BUF1_RDY1_CLR : 1; //!< This bit defines the IPU_ALT_CH_BUF1_RDY1 properties. This register can be a write one to clear OR write one to set.
        unsigned IPU_CH_BUF0_RDY0_CLR : 1; //!< This bit defines the IPU_CH_BUF0_RDY0 properties. This register can be a write one to clear OR write one to set.
        unsigned IPU_CH_BUF0_RDY1_CLR : 1; //!< This bit defines the IPU_CH_BUF0_RDY1 properties. This register can be a write one to clear OR write one to set.
        unsigned IPU_CH_BUF1_RDY0_CLR : 1; //!< This bit defines the IPU_CH_BUF1_RDY0 properties. This register can be a write one to clear OR write one to set.
        unsigned IPU_CH_BUF1_RDY1_CLR : 1; //!< This bit defines the IPU_CH_BUF1_RDY1 properties. This register can be a write one to clear OR write one to set.
    } B;
} hw_ipu_gpr_t;
#endif

/*
 * constants & macros for entire multi-block IPU_GPR register
 */
#define HW_IPU_GPR_ADDR(x)      (REGS_IPU_BASE(x) + 0xe4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_GPR(x)           (*(volatile hw_ipu_gpr_t *) HW_IPU_GPR_ADDR(x))
#define HW_IPU_GPR_RD(x)        (HW_IPU_GPR(x).U)
#define HW_IPU_GPR_WR(x, v)     (HW_IPU_GPR(x).U = (v))
#define HW_IPU_GPR_SET(x, v)    (HW_IPU_GPR_WR(x, HW_IPU_GPR_RD(x) |  (v)))
#define HW_IPU_GPR_CLR(x, v)    (HW_IPU_GPR_WR(x, HW_IPU_GPR_RD(x) & ~(v)))
#define HW_IPU_GPR_TOG(x, v)    (HW_IPU_GPR_WR(x, HW_IPU_GPR_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_GPR bitfields
 */

/* --- Register HW_IPU_GPR, field IPU_GPN (RW)
 *
 * IPU General Purpose bit. n Indicates the corresponding DMA channel number. This bits are general
 * Read/Write bits, reserved for future use
 */

#define BP_IPU_GPR_IPU_GPN      0
#define BM_IPU_GPR_IPU_GPN      0x0007ffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_GPR_IPU_GPN(v)   ((((reg32_t) v) << 0) & BM_IPU_GPR_IPU_GPN)
#else
#define BF_IPU_GPR_IPU_GPN(v)   (((v) << 0) & BM_IPU_GPR_IPU_GPN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_GPN field to a new value.
#define BW_IPU_GPR_IPU_GPN(v)   BF_CS1(IPU_GPR, IPU_GPN, v)
#endif

/* --- Register HW_IPU_GPR, field VF_TSTAT_CLR (RW)
 *
 * Reset viewfinder state machine. The bit is not self cleared - In case of writing 1 to this bit,
 * the bit has to be cleared in order to exit the IDLE state.
 *
 * Values:
 * 1 - writing 1 to this bit manually resets the viewfinder task state machine to IDLE
 * 0 - no affect (exit IDLE state after manual reset)
 */

#define BP_IPU_GPR_VF_TSTAT_CLR      19
#define BM_IPU_GPR_VF_TSTAT_CLR      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_GPR_VF_TSTAT_CLR(v)   ((((reg32_t) v) << 19) & BM_IPU_GPR_VF_TSTAT_CLR)
#else
#define BF_IPU_GPR_VF_TSTAT_CLR(v)   (((v) << 19) & BM_IPU_GPR_VF_TSTAT_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VF_TSTAT_CLR field to a new value.
#define BW_IPU_GPR_VF_TSTAT_CLR(v)   BF_CS1(IPU_GPR, VF_TSTAT_CLR, v)
#endif


/* --- Register HW_IPU_GPR, field IPU_DI0_CLK_CHANGE_ACK_DIS (RW)
 *
 * Disable DI0's clock change mechanism.
 *
 * Values:
 * 1 - clock change mechanism is disabled. DI automatically acknowledges a clock change request
 * 0 - clock change mechanism is disabled. DI performs the clock change procedure
 */

#define BP_IPU_GPR_IPU_DI0_CLK_CHANGE_ACK_DIS      22
#define BM_IPU_GPR_IPU_DI0_CLK_CHANGE_ACK_DIS      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_GPR_IPU_DI0_CLK_CHANGE_ACK_DIS(v)   ((((reg32_t) v) << 22) & BM_IPU_GPR_IPU_DI0_CLK_CHANGE_ACK_DIS)
#else
#define BF_IPU_GPR_IPU_DI0_CLK_CHANGE_ACK_DIS(v)   (((v) << 22) & BM_IPU_GPR_IPU_DI0_CLK_CHANGE_ACK_DIS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_DI0_CLK_CHANGE_ACK_DIS field to a new value.
#define BW_IPU_GPR_IPU_DI0_CLK_CHANGE_ACK_DIS(v)   BF_CS1(IPU_GPR, IPU_DI0_CLK_CHANGE_ACK_DIS, v)
#endif


/* --- Register HW_IPU_GPR, field IPU_DI1_CLK_CHANGE_ACK_DIS (RW)
 *
 * Disable DI1's clock change mechanism.
 *
 * Values:
 * 1 - clock change mechanism is disabled. DI automatically acknowledges a clock change request
 * 0 - clock change mechanism is disabled. DI performs the clock change procedure
 */

#define BP_IPU_GPR_IPU_DI1_CLK_CHANGE_ACK_DIS      23
#define BM_IPU_GPR_IPU_DI1_CLK_CHANGE_ACK_DIS      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_GPR_IPU_DI1_CLK_CHANGE_ACK_DIS(v)   ((((reg32_t) v) << 23) & BM_IPU_GPR_IPU_DI1_CLK_CHANGE_ACK_DIS)
#else
#define BF_IPU_GPR_IPU_DI1_CLK_CHANGE_ACK_DIS(v)   (((v) << 23) & BM_IPU_GPR_IPU_DI1_CLK_CHANGE_ACK_DIS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_DI1_CLK_CHANGE_ACK_DIS field to a new value.
#define BW_IPU_GPR_IPU_DI1_CLK_CHANGE_ACK_DIS(v)   BF_CS1(IPU_GPR, IPU_DI1_CLK_CHANGE_ACK_DIS, v)
#endif


/* --- Register HW_IPU_GPR, field IPU_ALT_CH_BUF0_RDY0_CLR (RW)
 *
 * This bit defines the IPU_ALT_CH_BUF0_RDY0 properties. This register can be a write one to clear
 * OR write one to set.
 *
 * Values:
 * 1 - writing one to a bit of this register clears this bit; IPU_ALT_CH_BUF0_RDY0 is w1c register
 * 0 - writing one to a bit of this register sets this bit IPU_ALT_CH_BUF0_RDY0 is w1s register
 */

#define BP_IPU_GPR_IPU_ALT_CH_BUF0_RDY0_CLR      24
#define BM_IPU_GPR_IPU_ALT_CH_BUF0_RDY0_CLR      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_GPR_IPU_ALT_CH_BUF0_RDY0_CLR(v)   ((((reg32_t) v) << 24) & BM_IPU_GPR_IPU_ALT_CH_BUF0_RDY0_CLR)
#else
#define BF_IPU_GPR_IPU_ALT_CH_BUF0_RDY0_CLR(v)   (((v) << 24) & BM_IPU_GPR_IPU_ALT_CH_BUF0_RDY0_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_ALT_CH_BUF0_RDY0_CLR field to a new value.
#define BW_IPU_GPR_IPU_ALT_CH_BUF0_RDY0_CLR(v)   BF_CS1(IPU_GPR, IPU_ALT_CH_BUF0_RDY0_CLR, v)
#endif


/* --- Register HW_IPU_GPR, field IPU_ALT_CH_BUF0_RDY1_CLR (RW)
 *
 * This bit defines the IPU_ALT_CH_BUF0_RDY1 properties. This register can be a write one to clear
 * OR write one to set.
 *
 * Values:
 * 1 - writing one to a bit of this register clears this bit; IPU_ALT_CH_BUF0_RDY1 is w1c register
 * 0 - writing one to a bit of this register sets this bit IPU_ALT_CH_BUF0_RDY1 is w1s register
 */

#define BP_IPU_GPR_IPU_ALT_CH_BUF0_RDY1_CLR      25
#define BM_IPU_GPR_IPU_ALT_CH_BUF0_RDY1_CLR      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_GPR_IPU_ALT_CH_BUF0_RDY1_CLR(v)   ((((reg32_t) v) << 25) & BM_IPU_GPR_IPU_ALT_CH_BUF0_RDY1_CLR)
#else
#define BF_IPU_GPR_IPU_ALT_CH_BUF0_RDY1_CLR(v)   (((v) << 25) & BM_IPU_GPR_IPU_ALT_CH_BUF0_RDY1_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_ALT_CH_BUF0_RDY1_CLR field to a new value.
#define BW_IPU_GPR_IPU_ALT_CH_BUF0_RDY1_CLR(v)   BF_CS1(IPU_GPR, IPU_ALT_CH_BUF0_RDY1_CLR, v)
#endif


/* --- Register HW_IPU_GPR, field IPU_ALT_CH_BUF1_RDY0_CLR (RW)
 *
 * This bit defines the IPU_ALT_CH_BUF1_RDY0 properties. This register can be a write one to clear
 * OR write one to set.
 *
 * Values:
 * 1 - writing one to a bit of this register clears this bit; IPU_ALT_CH_BUF1_RDY0 is w1c register
 * 0 - writing one to a bit of this register sets this bit IPU_ALT_CH_BUF1_RDY0 is w1s register
 */

#define BP_IPU_GPR_IPU_ALT_CH_BUF1_RDY0_CLR      26
#define BM_IPU_GPR_IPU_ALT_CH_BUF1_RDY0_CLR      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_GPR_IPU_ALT_CH_BUF1_RDY0_CLR(v)   ((((reg32_t) v) << 26) & BM_IPU_GPR_IPU_ALT_CH_BUF1_RDY0_CLR)
#else
#define BF_IPU_GPR_IPU_ALT_CH_BUF1_RDY0_CLR(v)   (((v) << 26) & BM_IPU_GPR_IPU_ALT_CH_BUF1_RDY0_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_ALT_CH_BUF1_RDY0_CLR field to a new value.
#define BW_IPU_GPR_IPU_ALT_CH_BUF1_RDY0_CLR(v)   BF_CS1(IPU_GPR, IPU_ALT_CH_BUF1_RDY0_CLR, v)
#endif


/* --- Register HW_IPU_GPR, field IPU_ALT_CH_BUF1_RDY1_CLR (RW)
 *
 * This bit defines the IPU_ALT_CH_BUF1_RDY1 properties. This register can be a write one to clear
 * OR write one to set.
 *
 * Values:
 * 1 - writing one to a bit of this register clears this bit; IPU_ALT_CH_BUF1_RDY1 is w1c register
 * 0 - writing one to a bit of this register sets this bit IPU_ALT_CH_BUF1_RDY1 is w1s register
 */

#define BP_IPU_GPR_IPU_ALT_CH_BUF1_RDY1_CLR      27
#define BM_IPU_GPR_IPU_ALT_CH_BUF1_RDY1_CLR      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_GPR_IPU_ALT_CH_BUF1_RDY1_CLR(v)   ((((reg32_t) v) << 27) & BM_IPU_GPR_IPU_ALT_CH_BUF1_RDY1_CLR)
#else
#define BF_IPU_GPR_IPU_ALT_CH_BUF1_RDY1_CLR(v)   (((v) << 27) & BM_IPU_GPR_IPU_ALT_CH_BUF1_RDY1_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_ALT_CH_BUF1_RDY1_CLR field to a new value.
#define BW_IPU_GPR_IPU_ALT_CH_BUF1_RDY1_CLR(v)   BF_CS1(IPU_GPR, IPU_ALT_CH_BUF1_RDY1_CLR, v)
#endif


/* --- Register HW_IPU_GPR, field IPU_CH_BUF0_RDY0_CLR (RW)
 *
 * This bit defines the IPU_CH_BUF0_RDY0 properties. This register can be a write one to clear OR
 * write one to set.
 *
 * Values:
 * 1 - writing one to a bit of this register clears this bit; IPU_CH_BUF0_RDY0 is w1c register
 * 0 - writing one to a bit of this register sets this bit IPU_CH_BUF0_RDY0 is w1s register
 */

#define BP_IPU_GPR_IPU_CH_BUF0_RDY0_CLR      28
#define BM_IPU_GPR_IPU_CH_BUF0_RDY0_CLR      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_GPR_IPU_CH_BUF0_RDY0_CLR(v)   ((((reg32_t) v) << 28) & BM_IPU_GPR_IPU_CH_BUF0_RDY0_CLR)
#else
#define BF_IPU_GPR_IPU_CH_BUF0_RDY0_CLR(v)   (((v) << 28) & BM_IPU_GPR_IPU_CH_BUF0_RDY0_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_CH_BUF0_RDY0_CLR field to a new value.
#define BW_IPU_GPR_IPU_CH_BUF0_RDY0_CLR(v)   BF_CS1(IPU_GPR, IPU_CH_BUF0_RDY0_CLR, v)
#endif


/* --- Register HW_IPU_GPR, field IPU_CH_BUF0_RDY1_CLR (RW)
 *
 * This bit defines the IPU_CH_BUF0_RDY1 properties. This register can be a write one to clear OR
 * write one to set.
 *
 * Values:
 * 1 - writing one to a bit of this register clears this bit; IPU_CH_BUF0_RDY1 is w1c register
 * 0 - writing one to a bit of this register sets this bit IPU_CH_BUF0_RDY1 is w1s register
 */

#define BP_IPU_GPR_IPU_CH_BUF0_RDY1_CLR      29
#define BM_IPU_GPR_IPU_CH_BUF0_RDY1_CLR      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_GPR_IPU_CH_BUF0_RDY1_CLR(v)   ((((reg32_t) v) << 29) & BM_IPU_GPR_IPU_CH_BUF0_RDY1_CLR)
#else
#define BF_IPU_GPR_IPU_CH_BUF0_RDY1_CLR(v)   (((v) << 29) & BM_IPU_GPR_IPU_CH_BUF0_RDY1_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_CH_BUF0_RDY1_CLR field to a new value.
#define BW_IPU_GPR_IPU_CH_BUF0_RDY1_CLR(v)   BF_CS1(IPU_GPR, IPU_CH_BUF0_RDY1_CLR, v)
#endif


/* --- Register HW_IPU_GPR, field IPU_CH_BUF1_RDY0_CLR (RW)
 *
 * This bit defines the IPU_CH_BUF1_RDY0 properties. This register can be a write one to clear OR
 * write one to set.
 *
 * Values:
 * 1 - writing one to a bit of this register clears this bit; IPU_CH_BUF1_RDY0 is w1c register
 * 0 - writing one to a bit of this register sets this bit IPU_CH_BUF1_RDY0 is w1s register
 */

#define BP_IPU_GPR_IPU_CH_BUF1_RDY0_CLR      30
#define BM_IPU_GPR_IPU_CH_BUF1_RDY0_CLR      0x40000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_GPR_IPU_CH_BUF1_RDY0_CLR(v)   ((((reg32_t) v) << 30) & BM_IPU_GPR_IPU_CH_BUF1_RDY0_CLR)
#else
#define BF_IPU_GPR_IPU_CH_BUF1_RDY0_CLR(v)   (((v) << 30) & BM_IPU_GPR_IPU_CH_BUF1_RDY0_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_CH_BUF1_RDY0_CLR field to a new value.
#define BW_IPU_GPR_IPU_CH_BUF1_RDY0_CLR(v)   BF_CS1(IPU_GPR, IPU_CH_BUF1_RDY0_CLR, v)
#endif


/* --- Register HW_IPU_GPR, field IPU_CH_BUF1_RDY1_CLR (RW)
 *
 * This bit defines the IPU_CH_BUF1_RDY1 properties. This register can be a write one to clear OR
 * write one to set.
 *
 * Values:
 * 1 - writing one to a bit of this register clears this bit; IPU_CH_BUF1_RDY1 is w1c register
 * 0 - writing one to a bit of this register sets this bit IPU_CH_BUF1_RDY1 is w1s register
 */

#define BP_IPU_GPR_IPU_CH_BUF1_RDY1_CLR      31
#define BM_IPU_GPR_IPU_CH_BUF1_RDY1_CLR      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_GPR_IPU_CH_BUF1_RDY1_CLR(v)   ((((reg32_t) v) << 31) & BM_IPU_GPR_IPU_CH_BUF1_RDY1_CLR)
#else
#define BF_IPU_GPR_IPU_CH_BUF1_RDY1_CLR(v)   (((v) << 31) & BM_IPU_GPR_IPU_CH_BUF1_RDY1_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IPU_CH_BUF1_RDY1_CLR field to a new value.
#define BW_IPU_GPR_IPU_CH_BUF1_RDY1_CLR(v)   BF_CS1(IPU_GPR, IPU_CH_BUF1_RDY1_CLR, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CH_DB_MODE_SEL0 - Channel Double Buffer Mode Select 0 Register (RW)
 *
 * The register contains double buffer mode select control information for 32 IPU's DMA channels.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMA_CH_DB_MODE_SEL_0 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_1 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_2 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_3 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DMA_CH_DB_MODE_SEL_5 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned DMA_CH_DB_MODE_SEL_8 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_9 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_10 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_11 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_12 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_13 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_14 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_15 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned DMA_CH_DB_MODE_SEL_17 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_18 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_19 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_20 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_21 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_22 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_23 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_24 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_25 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_26 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_27 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_28 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_29 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned DMA_CH_DB_MODE_SEL_31 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_ch_db_mode_sel0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CH_DB_MODE_SEL0 register
 */
#define HW_IPU_CH_DB_MODE_SEL0_ADDR(x)      (REGS_IPU_BASE(x) + 0x150)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CH_DB_MODE_SEL0(x)           (*(volatile hw_ipu_ch_db_mode_sel0_t *) HW_IPU_CH_DB_MODE_SEL0_ADDR(x))
#define HW_IPU_CH_DB_MODE_SEL0_RD(x)        (HW_IPU_CH_DB_MODE_SEL0(x).U)
#define HW_IPU_CH_DB_MODE_SEL0_WR(x, v)     (HW_IPU_CH_DB_MODE_SEL0(x).U = (v))
#define HW_IPU_CH_DB_MODE_SEL0_SET(x, v)    (HW_IPU_CH_DB_MODE_SEL0_WR(x, HW_IPU_CH_DB_MODE_SEL0_RD(x) |  (v)))
#define HW_IPU_CH_DB_MODE_SEL0_CLR(x, v)    (HW_IPU_CH_DB_MODE_SEL0_WR(x, HW_IPU_CH_DB_MODE_SEL0_RD(x) & ~(v)))
#define HW_IPU_CH_DB_MODE_SEL0_TOG(x, v)    (HW_IPU_CH_DB_MODE_SEL0_WR(x, HW_IPU_CH_DB_MODE_SEL0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CH_DB_MODE_SEL0 bitfields
 */

/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_0 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_0      0
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_0(v)   ((((reg32_t) v) << 0) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_0)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_0(v)   (((v) << 0) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_0 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_0(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_0, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_1 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_1      1
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_1(v)   ((((reg32_t) v) << 1) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_1)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_1(v)   (((v) << 1) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_1 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_1(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_1, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_2 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_2      2
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_2(v)   ((((reg32_t) v) << 2) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_2)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_2(v)   (((v) << 2) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_2 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_2(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_2, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_3 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_3      3
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_3(v)   ((((reg32_t) v) << 3) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_3)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_3(v)   (((v) << 3) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_3 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_3(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_3, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_5 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_5      5
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_5(v)   ((((reg32_t) v) << 5) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_5)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_5(v)   (((v) << 5) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_5 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_5(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_5, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_8 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_8      8
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_8(v)   ((((reg32_t) v) << 8) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_8)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_8(v)   (((v) << 8) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_8 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_8(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_8, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_9 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_9      9
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_9(v)   ((((reg32_t) v) << 9) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_9)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_9(v)   (((v) << 9) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_9 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_9(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_9, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_10 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_10      10
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_10(v)   ((((reg32_t) v) << 10) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_10)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_10(v)   (((v) << 10) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_10 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_10(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_10, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_11 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_11      11
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_11(v)   ((((reg32_t) v) << 11) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_11)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_11(v)   (((v) << 11) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_11 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_11(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_11, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_12 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_12      12
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_12(v)   ((((reg32_t) v) << 12) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_12)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_12(v)   (((v) << 12) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_12 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_12(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_12, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_13 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_13      13
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_13(v)   ((((reg32_t) v) << 13) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_13)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_13(v)   (((v) << 13) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_13 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_13(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_13, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_14 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_14      14
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_14(v)   ((((reg32_t) v) << 14) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_14)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_14(v)   (((v) << 14) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_14 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_14(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_14, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_15 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_15      15
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_15(v)   ((((reg32_t) v) << 15) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_15)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_15(v)   (((v) << 15) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_15 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_15(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_15, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_17 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_17      17
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_17      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_17(v)   ((((reg32_t) v) << 17) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_17)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_17(v)   (((v) << 17) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_17 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_17(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_17, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_18 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_18      18
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_18      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_18(v)   ((((reg32_t) v) << 18) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_18)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_18(v)   (((v) << 18) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_18 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_18(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_18, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_19 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_19      19
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_19      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_19(v)   ((((reg32_t) v) << 19) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_19)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_19(v)   (((v) << 19) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_19 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_19(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_19, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_20 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_20      20
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_20(v)   ((((reg32_t) v) << 20) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_20)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_20(v)   (((v) << 20) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_20 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_20(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_20, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_21 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_21      21
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_21(v)   ((((reg32_t) v) << 21) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_21)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_21(v)   (((v) << 21) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_21 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_21(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_21, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_22 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_22      22
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_22(v)   ((((reg32_t) v) << 22) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_22)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_22(v)   (((v) << 22) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_22 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_22(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_22, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_23 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_23      23
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_23(v)   ((((reg32_t) v) << 23) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_23)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_23(v)   (((v) << 23) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_23 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_23(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_23, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_24 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_24      24
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_24(v)   ((((reg32_t) v) << 24) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_24)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_24(v)   (((v) << 24) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_24 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_24(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_24, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_25 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_25      25
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_25(v)   ((((reg32_t) v) << 25) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_25)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_25(v)   (((v) << 25) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_25 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_25(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_25, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_26 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_26      26
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_26(v)   ((((reg32_t) v) << 26) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_26)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_26(v)   (((v) << 26) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_26 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_26(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_26, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_27 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_27      27
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_27(v)   ((((reg32_t) v) << 27) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_27)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_27(v)   (((v) << 27) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_27 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_27(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_27, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_28 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_28      28
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_28(v)   ((((reg32_t) v) << 28) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_28)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_28(v)   (((v) << 28) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_28 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_28(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_28, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_29 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_29      29
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_29(v)   ((((reg32_t) v) << 29) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_29)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_29(v)   (((v) << 29) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_29 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_29(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_29, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL0, field DMA_CH_DB_MODE_SEL_31 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_31      31
#define BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_31(v)   ((((reg32_t) v) << 31) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_31)
#else
#define BF_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_31(v)   (((v) << 31) & BM_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_31 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL0_DMA_CH_DB_MODE_SEL_31(v)   BF_CS1(IPU_CH_DB_MODE_SEL0, DMA_CH_DB_MODE_SEL_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CH_DB_MODE_SEL1 - Channel Double Buffer Mode Select 1 Register (RW)
 *
 * The register contains double buffer mode select control information for 32 IPU's DMA channels.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DMA_CH_DB_MODE_SEL_33 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned DMA_CH_DB_MODE_SEL_40 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_41 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_42 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_43 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_44 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_45 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_46 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_47 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_48 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_49 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_50 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_51 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_DB_MODE_SEL_52 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_ch_db_mode_sel1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CH_DB_MODE_SEL1 register
 */
#define HW_IPU_CH_DB_MODE_SEL1_ADDR(x)      (REGS_IPU_BASE(x) + 0x154)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CH_DB_MODE_SEL1(x)           (*(volatile hw_ipu_ch_db_mode_sel1_t *) HW_IPU_CH_DB_MODE_SEL1_ADDR(x))
#define HW_IPU_CH_DB_MODE_SEL1_RD(x)        (HW_IPU_CH_DB_MODE_SEL1(x).U)
#define HW_IPU_CH_DB_MODE_SEL1_WR(x, v)     (HW_IPU_CH_DB_MODE_SEL1(x).U = (v))
#define HW_IPU_CH_DB_MODE_SEL1_SET(x, v)    (HW_IPU_CH_DB_MODE_SEL1_WR(x, HW_IPU_CH_DB_MODE_SEL1_RD(x) |  (v)))
#define HW_IPU_CH_DB_MODE_SEL1_CLR(x, v)    (HW_IPU_CH_DB_MODE_SEL1_WR(x, HW_IPU_CH_DB_MODE_SEL1_RD(x) & ~(v)))
#define HW_IPU_CH_DB_MODE_SEL1_TOG(x, v)    (HW_IPU_CH_DB_MODE_SEL1_WR(x, HW_IPU_CH_DB_MODE_SEL1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CH_DB_MODE_SEL1 bitfields
 */

/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_33 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_33      1
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_33(v)   ((((reg32_t) v) << 1) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_33)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_33(v)   (((v) << 1) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_33 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_33(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_33, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_40 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_40      8
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_40      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_40(v)   ((((reg32_t) v) << 8) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_40)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_40(v)   (((v) << 8) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_40)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_40 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_40(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_40, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_41 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_41      9
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_41(v)   ((((reg32_t) v) << 9) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_41)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_41(v)   (((v) << 9) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_41 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_41(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_41, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_42 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_42      10
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_42(v)   ((((reg32_t) v) << 10) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_42)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_42(v)   (((v) << 10) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_42 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_42(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_42, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_43 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_43      11
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_43(v)   ((((reg32_t) v) << 11) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_43)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_43(v)   (((v) << 11) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_43 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_43(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_43, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_44 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_44      12
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_44(v)   ((((reg32_t) v) << 12) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_44)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_44(v)   (((v) << 12) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_44 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_44(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_44, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_45 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_45      13
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_45(v)   ((((reg32_t) v) << 13) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_45)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_45(v)   (((v) << 13) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_45 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_45(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_45, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_46 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_46      14
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_46(v)   ((((reg32_t) v) << 14) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_46)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_46(v)   (((v) << 14) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_46 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_46(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_46, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_47 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_47      15
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_47(v)   ((((reg32_t) v) << 15) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_47)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_47(v)   (((v) << 15) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_47 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_47(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_47, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_48 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_48      16
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_48(v)   ((((reg32_t) v) << 16) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_48)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_48(v)   (((v) << 16) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_48 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_48(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_48, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_49 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_49      17
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_49(v)   ((((reg32_t) v) << 17) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_49)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_49(v)   (((v) << 17) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_49 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_49(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_49, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_50 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_50      18
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_50(v)   ((((reg32_t) v) << 18) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_50)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_50(v)   (((v) << 18) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_50 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_50(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_50, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_51 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_51      19
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_51(v)   ((((reg32_t) v) << 19) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_51)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_51(v)   (((v) << 19) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_51 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_51(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_51, v)
#endif


/* --- Register HW_IPU_CH_DB_MODE_SEL1, field DMA_CH_DB_MODE_SEL_52 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_52      20
#define BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_52(v)   ((((reg32_t) v) << 20) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_52)
#else
#define BF_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_52(v)   (((v) << 20) & BM_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_DB_MODE_SEL_52 field to a new value.
#define BW_IPU_CH_DB_MODE_SEL1_DMA_CH_DB_MODE_SEL_52(v)   BF_CS1(IPU_CH_DB_MODE_SEL1, DMA_CH_DB_MODE_SEL_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_ALT_CH_DB_MODE_SEL0 - Alternate Channel Double Buffer Mode Select 0 Register (RW)
 *
 * The register contains double buffer mode select control information for 32 IPU's DMA channels.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned DMA_CH_ALT_DB_MODE_SEL_4 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_ALT_DB_MODE_SEL_5 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_ALT_DB_MODE_SEL_6 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_ALT_DB_MODE_SEL_7 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 16; //!< Reserved.
        unsigned DMA_CH_ALT_DB_MODE_SEL_24 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 4; //!< Reserved.
        unsigned DMA_CH_ALT_DB_MODE_SEL_29 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 2; //!< Reserved.
    } B;
} hw_ipu_alt_ch_db_mode_sel0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_ALT_CH_DB_MODE_SEL0 register
 */
#define HW_IPU_ALT_CH_DB_MODE_SEL0_ADDR(x)      (REGS_IPU_BASE(x) + 0x168)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_ALT_CH_DB_MODE_SEL0(x)           (*(volatile hw_ipu_alt_ch_db_mode_sel0_t *) HW_IPU_ALT_CH_DB_MODE_SEL0_ADDR(x))
#define HW_IPU_ALT_CH_DB_MODE_SEL0_RD(x)        (HW_IPU_ALT_CH_DB_MODE_SEL0(x).U)
#define HW_IPU_ALT_CH_DB_MODE_SEL0_WR(x, v)     (HW_IPU_ALT_CH_DB_MODE_SEL0(x).U = (v))
#define HW_IPU_ALT_CH_DB_MODE_SEL0_SET(x, v)    (HW_IPU_ALT_CH_DB_MODE_SEL0_WR(x, HW_IPU_ALT_CH_DB_MODE_SEL0_RD(x) |  (v)))
#define HW_IPU_ALT_CH_DB_MODE_SEL0_CLR(x, v)    (HW_IPU_ALT_CH_DB_MODE_SEL0_WR(x, HW_IPU_ALT_CH_DB_MODE_SEL0_RD(x) & ~(v)))
#define HW_IPU_ALT_CH_DB_MODE_SEL0_TOG(x, v)    (HW_IPU_ALT_CH_DB_MODE_SEL0_WR(x, HW_IPU_ALT_CH_DB_MODE_SEL0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_ALT_CH_DB_MODE_SEL0 bitfields
 */

/* --- Register HW_IPU_ALT_CH_DB_MODE_SEL0, field DMA_CH_ALT_DB_MODE_SEL_4 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_4      4
#define BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_4      0x00000010

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_4(v)   ((((reg32_t) v) << 4) & BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_4)
#else
#define BF_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_4(v)   (((v) << 4) & BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_DB_MODE_SEL_4 field to a new value.
#define BW_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_4(v)   BF_CS1(IPU_ALT_CH_DB_MODE_SEL0, DMA_CH_ALT_DB_MODE_SEL_4, v)
#endif


/* --- Register HW_IPU_ALT_CH_DB_MODE_SEL0, field DMA_CH_ALT_DB_MODE_SEL_5 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_5      5
#define BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_5(v)   ((((reg32_t) v) << 5) & BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_5)
#else
#define BF_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_5(v)   (((v) << 5) & BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_DB_MODE_SEL_5 field to a new value.
#define BW_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_5(v)   BF_CS1(IPU_ALT_CH_DB_MODE_SEL0, DMA_CH_ALT_DB_MODE_SEL_5, v)
#endif


/* --- Register HW_IPU_ALT_CH_DB_MODE_SEL0, field DMA_CH_ALT_DB_MODE_SEL_6 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_6      6
#define BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_6      0x00000040

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_6(v)   ((((reg32_t) v) << 6) & BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_6)
#else
#define BF_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_6(v)   (((v) << 6) & BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_DB_MODE_SEL_6 field to a new value.
#define BW_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_6(v)   BF_CS1(IPU_ALT_CH_DB_MODE_SEL0, DMA_CH_ALT_DB_MODE_SEL_6, v)
#endif


/* --- Register HW_IPU_ALT_CH_DB_MODE_SEL0, field DMA_CH_ALT_DB_MODE_SEL_7 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_7      7
#define BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_7      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_7(v)   ((((reg32_t) v) << 7) & BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_7)
#else
#define BF_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_7(v)   (((v) << 7) & BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_DB_MODE_SEL_7 field to a new value.
#define BW_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_7(v)   BF_CS1(IPU_ALT_CH_DB_MODE_SEL0, DMA_CH_ALT_DB_MODE_SEL_7, v)
#endif


/* --- Register HW_IPU_ALT_CH_DB_MODE_SEL0, field DMA_CH_ALT_DB_MODE_SEL_24 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_24      24
#define BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_24(v)   ((((reg32_t) v) << 24) & BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_24)
#else
#define BF_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_24(v)   (((v) << 24) & BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_DB_MODE_SEL_24 field to a new value.
#define BW_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_24(v)   BF_CS1(IPU_ALT_CH_DB_MODE_SEL0, DMA_CH_ALT_DB_MODE_SEL_24, v)
#endif


/* --- Register HW_IPU_ALT_CH_DB_MODE_SEL0, field DMA_CH_ALT_DB_MODE_SEL_29 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_29      29
#define BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_29(v)   ((((reg32_t) v) << 29) & BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_29)
#else
#define BF_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_29(v)   (((v) << 29) & BM_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_DB_MODE_SEL_29 field to a new value.
#define BW_IPU_ALT_CH_DB_MODE_SEL0_DMA_CH_ALT_DB_MODE_SEL_29(v)   BF_CS1(IPU_ALT_CH_DB_MODE_SEL0, DMA_CH_ALT_DB_MODE_SEL_29, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_ALT_CH_DB_MODE_SEL1 - Alternate Channel Double Buffer Mode Select1 Register (RW)
 *
 * The register contains double buffer mode select control information for 32 IPU's DMA channels.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DMA_CH_ALT_DB_MODE_SEL_33 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 7; //!< Reserved.
        unsigned DMA_CH_ALT_DB_MODE_SEL_41 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 10; //!< Reserved.
        unsigned DMA_CH_ALT_DB_MODE_SEL_52 : 1; //!< Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 11; //!< Reserved.
    } B;
} hw_ipu_alt_ch_db_mode_sel1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_ALT_CH_DB_MODE_SEL1 register
 */
#define HW_IPU_ALT_CH_DB_MODE_SEL1_ADDR(x)      (REGS_IPU_BASE(x) + 0x16c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_ALT_CH_DB_MODE_SEL1(x)           (*(volatile hw_ipu_alt_ch_db_mode_sel1_t *) HW_IPU_ALT_CH_DB_MODE_SEL1_ADDR(x))
#define HW_IPU_ALT_CH_DB_MODE_SEL1_RD(x)        (HW_IPU_ALT_CH_DB_MODE_SEL1(x).U)
#define HW_IPU_ALT_CH_DB_MODE_SEL1_WR(x, v)     (HW_IPU_ALT_CH_DB_MODE_SEL1(x).U = (v))
#define HW_IPU_ALT_CH_DB_MODE_SEL1_SET(x, v)    (HW_IPU_ALT_CH_DB_MODE_SEL1_WR(x, HW_IPU_ALT_CH_DB_MODE_SEL1_RD(x) |  (v)))
#define HW_IPU_ALT_CH_DB_MODE_SEL1_CLR(x, v)    (HW_IPU_ALT_CH_DB_MODE_SEL1_WR(x, HW_IPU_ALT_CH_DB_MODE_SEL1_RD(x) & ~(v)))
#define HW_IPU_ALT_CH_DB_MODE_SEL1_TOG(x, v)    (HW_IPU_ALT_CH_DB_MODE_SEL1_WR(x, HW_IPU_ALT_CH_DB_MODE_SEL1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_ALT_CH_DB_MODE_SEL1 bitfields
 */

/* --- Register HW_IPU_ALT_CH_DB_MODE_SEL1, field DMA_CH_ALT_DB_MODE_SEL_33 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_33      1
#define BM_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_33(v)   ((((reg32_t) v) << 1) & BM_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_33)
#else
#define BF_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_33(v)   (((v) << 1) & BM_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_DB_MODE_SEL_33 field to a new value.
#define BW_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_33(v)   BF_CS1(IPU_ALT_CH_DB_MODE_SEL1, DMA_CH_ALT_DB_MODE_SEL_33, v)
#endif


/* --- Register HW_IPU_ALT_CH_DB_MODE_SEL1, field DMA_CH_ALT_DB_MODE_SEL_41 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_41      9
#define BM_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_41(v)   ((((reg32_t) v) << 9) & BM_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_41)
#else
#define BF_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_41(v)   (((v) << 9) & BM_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_DB_MODE_SEL_41 field to a new value.
#define BW_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_41(v)   BF_CS1(IPU_ALT_CH_DB_MODE_SEL1, DMA_CH_ALT_DB_MODE_SEL_41, v)
#endif


/* --- Register HW_IPU_ALT_CH_DB_MODE_SEL1, field DMA_CH_ALT_DB_MODE_SEL_52 (RW)
 *
 * Double Buffer Mode Select. This bit indicates if a double buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Double buffer is not used for this channel.
 * 1 - Double buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_52      20
#define BM_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_52(v)   ((((reg32_t) v) << 20) & BM_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_52)
#else
#define BF_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_52(v)   (((v) << 20) & BM_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_DB_MODE_SEL_52 field to a new value.
#define BW_IPU_ALT_CH_DB_MODE_SEL1_DMA_CH_ALT_DB_MODE_SEL_52(v)   BF_CS1(IPU_ALT_CH_DB_MODE_SEL1, DMA_CH_ALT_DB_MODE_SEL_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_ALT_CH_TRB_MODE_SEL0 - Alternate Channel Triple Buffer Mode Select 0 Register (RW)
 *
 * The register contains triple buffer mode select control information for 32 IPU's DMA channels.
 * When the channel is configured for triple buffer mode. The double buffer mode settings configured
 * on the corresponding DB_MODE_SEL bit are overridden.  Editor's Note: The conditional tag settings
 * should be   Hide VPU_SUB_FRAME_SYNC for all versions  Show VPU_SUB_FRAME_SYNC for IPUv3H version.
 * The table below tagged with other settings (like IPU3M_only) should be hidden in IPUv3H version.
 * This requires some sophisticated conditional tag settings
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 8; //!< Reserved.
        unsigned DMA_CH_TRB_MODE_SEL_8 : 1; //!< Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_TRB_MODE_SEL_9 : 1; //!< Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_TRB_MODE_SEL_10 : 1; //!< Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned DMA_CH_TRB_MODE_SEL_13 : 1; //!< Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 7; //!< Reserved.
        unsigned DMA_CH_TRB_MODE_SEL_21 : 1; //!< Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned DMA_CH_TRB_MODE_SEL_23 : 1; //!< Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED4 : 3; //!< Reserved.
        unsigned DMA_CH_TRB_MODE_SEL_27 : 1; //!< Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_TRB_MODE_SEL_28 : 1; //!< Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n Indicates the corresponding DMA channel number.
        unsigned RESERVED5 : 3; //!< Reserved.
    } B;
} hw_ipu_alt_ch_trb_mode_sel0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_ALT_CH_TRB_MODE_SEL0 register
 */
#define HW_IPU_ALT_CH_TRB_MODE_SEL0_ADDR(x)      (REGS_IPU_BASE(x) + 0x178)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_ALT_CH_TRB_MODE_SEL0(x)           (*(volatile hw_ipu_alt_ch_trb_mode_sel0_t *) HW_IPU_ALT_CH_TRB_MODE_SEL0_ADDR(x))
#define HW_IPU_ALT_CH_TRB_MODE_SEL0_RD(x)        (HW_IPU_ALT_CH_TRB_MODE_SEL0(x).U)
#define HW_IPU_ALT_CH_TRB_MODE_SEL0_WR(x, v)     (HW_IPU_ALT_CH_TRB_MODE_SEL0(x).U = (v))
#define HW_IPU_ALT_CH_TRB_MODE_SEL0_SET(x, v)    (HW_IPU_ALT_CH_TRB_MODE_SEL0_WR(x, HW_IPU_ALT_CH_TRB_MODE_SEL0_RD(x) |  (v)))
#define HW_IPU_ALT_CH_TRB_MODE_SEL0_CLR(x, v)    (HW_IPU_ALT_CH_TRB_MODE_SEL0_WR(x, HW_IPU_ALT_CH_TRB_MODE_SEL0_RD(x) & ~(v)))
#define HW_IPU_ALT_CH_TRB_MODE_SEL0_TOG(x, v)    (HW_IPU_ALT_CH_TRB_MODE_SEL0_WR(x, HW_IPU_ALT_CH_TRB_MODE_SEL0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_ALT_CH_TRB_MODE_SEL0 bitfields
 */

/* --- Register HW_IPU_ALT_CH_TRB_MODE_SEL0, field DMA_CH_TRB_MODE_SEL_8 (RW)
 *
 * Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Triple buffer is not used for this channel.
 * 1 - Triple buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_8      8
#define BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_8(v)   ((((reg32_t) v) << 8) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_8)
#else
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_8(v)   (((v) << 8) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_TRB_MODE_SEL_8 field to a new value.
#define BW_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_8(v)   BF_CS1(IPU_ALT_CH_TRB_MODE_SEL0, DMA_CH_TRB_MODE_SEL_8, v)
#endif


/* --- Register HW_IPU_ALT_CH_TRB_MODE_SEL0, field DMA_CH_TRB_MODE_SEL_9 (RW)
 *
 * Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Triple buffer is not used for this channel.
 * 1 - Triple buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_9      9
#define BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_9(v)   ((((reg32_t) v) << 9) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_9)
#else
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_9(v)   (((v) << 9) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_TRB_MODE_SEL_9 field to a new value.
#define BW_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_9(v)   BF_CS1(IPU_ALT_CH_TRB_MODE_SEL0, DMA_CH_TRB_MODE_SEL_9, v)
#endif


/* --- Register HW_IPU_ALT_CH_TRB_MODE_SEL0, field DMA_CH_TRB_MODE_SEL_10 (RW)
 *
 * Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Triple buffer is not used for this channel.
 * 1 - Triple buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_10      10
#define BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_10(v)   ((((reg32_t) v) << 10) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_10)
#else
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_10(v)   (((v) << 10) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_TRB_MODE_SEL_10 field to a new value.
#define BW_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_10(v)   BF_CS1(IPU_ALT_CH_TRB_MODE_SEL0, DMA_CH_TRB_MODE_SEL_10, v)
#endif


/* --- Register HW_IPU_ALT_CH_TRB_MODE_SEL0, field DMA_CH_TRB_MODE_SEL_13 (RW)
 *
 * Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Triple buffer is not used for this channel.
 * 1 - Triple buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_13      13
#define BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_13(v)   ((((reg32_t) v) << 13) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_13)
#else
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_13(v)   (((v) << 13) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_TRB_MODE_SEL_13 field to a new value.
#define BW_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_13(v)   BF_CS1(IPU_ALT_CH_TRB_MODE_SEL0, DMA_CH_TRB_MODE_SEL_13, v)
#endif


/* --- Register HW_IPU_ALT_CH_TRB_MODE_SEL0, field DMA_CH_TRB_MODE_SEL_21 (RW)
 *
 * Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Triple buffer is not used for this channel.
 * 1 - Triple buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_21      21
#define BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_21(v)   ((((reg32_t) v) << 21) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_21)
#else
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_21(v)   (((v) << 21) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_TRB_MODE_SEL_21 field to a new value.
#define BW_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_21(v)   BF_CS1(IPU_ALT_CH_TRB_MODE_SEL0, DMA_CH_TRB_MODE_SEL_21, v)
#endif


/* --- Register HW_IPU_ALT_CH_TRB_MODE_SEL0, field DMA_CH_TRB_MODE_SEL_23 (RW)
 *
 * Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Triple buffer is not used for this channel.
 * 1 - Triple buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_23      23
#define BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_23(v)   ((((reg32_t) v) << 23) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_23)
#else
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_23(v)   (((v) << 23) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_TRB_MODE_SEL_23 field to a new value.
#define BW_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_23(v)   BF_CS1(IPU_ALT_CH_TRB_MODE_SEL0, DMA_CH_TRB_MODE_SEL_23, v)
#endif


/* --- Register HW_IPU_ALT_CH_TRB_MODE_SEL0, field DMA_CH_TRB_MODE_SEL_27 (RW)
 *
 * Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Triple buffer is not used for this channel.
 * 1 - Triple buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_27      27
#define BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_27(v)   ((((reg32_t) v) << 27) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_27)
#else
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_27(v)   (((v) << 27) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_TRB_MODE_SEL_27 field to a new value.
#define BW_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_27(v)   BF_CS1(IPU_ALT_CH_TRB_MODE_SEL0, DMA_CH_TRB_MODE_SEL_27, v)
#endif


/* --- Register HW_IPU_ALT_CH_TRB_MODE_SEL0, field DMA_CH_TRB_MODE_SEL_28 (RW)
 *
 * Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Triple buffer is not used for this channel.
 * 1 - Triple buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_28      28
#define BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_28(v)   ((((reg32_t) v) << 28) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_28)
#else
#define BF_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_28(v)   (((v) << 28) & BM_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_TRB_MODE_SEL_28 field to a new value.
#define BW_IPU_ALT_CH_TRB_MODE_SEL0_DMA_CH_TRB_MODE_SEL_28(v)   BF_CS1(IPU_ALT_CH_TRB_MODE_SEL0, DMA_CH_TRB_MODE_SEL_28, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_ALT_CH_TRB_MODE_SEL1 - Alternate Channel Triple Buffer Mode Select 1 Register (RW)
 *
 * The register contains triple buffer mode select control information for 32 IPU's DMA channels.
 * When the channel is configured for triple buffer mode. The double buffer mode settings configured
 * on the corresponding DB_MODE_SEL bit are overridden.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMA_CH_TRB_MODE_SEL_N : 32; //!< Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_alt_ch_trb_mode_sel1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_ALT_CH_TRB_MODE_SEL1 register
 */
#define HW_IPU_ALT_CH_TRB_MODE_SEL1_ADDR(x)      (REGS_IPU_BASE(x) + 0x17c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_ALT_CH_TRB_MODE_SEL1(x)           (*(volatile hw_ipu_alt_ch_trb_mode_sel1_t *) HW_IPU_ALT_CH_TRB_MODE_SEL1_ADDR(x))
#define HW_IPU_ALT_CH_TRB_MODE_SEL1_RD(x)        (HW_IPU_ALT_CH_TRB_MODE_SEL1(x).U)
#define HW_IPU_ALT_CH_TRB_MODE_SEL1_WR(x, v)     (HW_IPU_ALT_CH_TRB_MODE_SEL1(x).U = (v))
#define HW_IPU_ALT_CH_TRB_MODE_SEL1_SET(x, v)    (HW_IPU_ALT_CH_TRB_MODE_SEL1_WR(x, HW_IPU_ALT_CH_TRB_MODE_SEL1_RD(x) |  (v)))
#define HW_IPU_ALT_CH_TRB_MODE_SEL1_CLR(x, v)    (HW_IPU_ALT_CH_TRB_MODE_SEL1_WR(x, HW_IPU_ALT_CH_TRB_MODE_SEL1_RD(x) & ~(v)))
#define HW_IPU_ALT_CH_TRB_MODE_SEL1_TOG(x, v)    (HW_IPU_ALT_CH_TRB_MODE_SEL1_WR(x, HW_IPU_ALT_CH_TRB_MODE_SEL1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_ALT_CH_TRB_MODE_SEL1 bitfields
 */

/* --- Register HW_IPU_ALT_CH_TRB_MODE_SEL1, field DMA_CH_TRB_MODE_SEL_N (ROZ)
 *
 * Triple Buffer Mode Select. This bit indicates if a triple buffer is used for this channel. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Triple buffer is not used for this channel.
 * 1 - Triple buffer is used for this channel.
 */

#define BP_IPU_ALT_CH_TRB_MODE_SEL1_DMA_CH_TRB_MODE_SEL_N      0
#define BM_IPU_ALT_CH_TRB_MODE_SEL1_DMA_CH_TRB_MODE_SEL_N      0xffffffff


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_1 - Interrupt Status Register 1 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. The status bits of EOF (end of frame) of DMA Channels
 * interrupts [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_EOF_0 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_1 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_2 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_3 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_EOF_5 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_EOF_8 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_9 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_10 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_11 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_12 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_13 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_14 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_15 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_EOF_17 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_18 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_19 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_20 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_21 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_22 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_23 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_24 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_25 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_26 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_27 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_28 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_29 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_EOF_31 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_int_stat_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_1 register
 */
#define HW_IPU_INT_STAT_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x200)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_1(x)           (*(volatile hw_ipu_int_stat_1_t *) HW_IPU_INT_STAT_1_ADDR(x))
#define HW_IPU_INT_STAT_1_RD(x)        (HW_IPU_INT_STAT_1(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_1 bitfields
 */

/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_0 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_0      0
#define BM_IPU_INT_STAT_1_IDMAC_EOF_0      0x00000001


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_1 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_1      1
#define BM_IPU_INT_STAT_1_IDMAC_EOF_1      0x00000002


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_2 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_2      2
#define BM_IPU_INT_STAT_1_IDMAC_EOF_2      0x00000004


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_3 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_3      3
#define BM_IPU_INT_STAT_1_IDMAC_EOF_3      0x00000008


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_5 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_5      5
#define BM_IPU_INT_STAT_1_IDMAC_EOF_5      0x00000020


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_8 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_8      8
#define BM_IPU_INT_STAT_1_IDMAC_EOF_8      0x00000100


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_9 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_9      9
#define BM_IPU_INT_STAT_1_IDMAC_EOF_9      0x00000200


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_10 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_10      10
#define BM_IPU_INT_STAT_1_IDMAC_EOF_10      0x00000400


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_11 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_11      11
#define BM_IPU_INT_STAT_1_IDMAC_EOF_11      0x00000800


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_12 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_12      12
#define BM_IPU_INT_STAT_1_IDMAC_EOF_12      0x00001000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_13 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_13      13
#define BM_IPU_INT_STAT_1_IDMAC_EOF_13      0x00002000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_14 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_14      14
#define BM_IPU_INT_STAT_1_IDMAC_EOF_14      0x00004000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_15 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_15      15
#define BM_IPU_INT_STAT_1_IDMAC_EOF_15      0x00008000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_17 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_17      17
#define BM_IPU_INT_STAT_1_IDMAC_EOF_17      0x00020000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_18 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_18      18
#define BM_IPU_INT_STAT_1_IDMAC_EOF_18      0x00040000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_19 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_19      19
#define BM_IPU_INT_STAT_1_IDMAC_EOF_19      0x00080000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_20 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_20      20
#define BM_IPU_INT_STAT_1_IDMAC_EOF_20      0x00100000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_21 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_21      21
#define BM_IPU_INT_STAT_1_IDMAC_EOF_21      0x00200000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_22 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_22      22
#define BM_IPU_INT_STAT_1_IDMAC_EOF_22      0x00400000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_23 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_23      23
#define BM_IPU_INT_STAT_1_IDMAC_EOF_23      0x00800000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_24 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_24      24
#define BM_IPU_INT_STAT_1_IDMAC_EOF_24      0x01000000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_25 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_25      25
#define BM_IPU_INT_STAT_1_IDMAC_EOF_25      0x02000000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_26 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_26      26
#define BM_IPU_INT_STAT_1_IDMAC_EOF_26      0x04000000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_27 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_27      27
#define BM_IPU_INT_STAT_1_IDMAC_EOF_27      0x08000000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_28 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_28      28
#define BM_IPU_INT_STAT_1_IDMAC_EOF_28      0x10000000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_29 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_29      29
#define BM_IPU_INT_STAT_1_IDMAC_EOF_29      0x20000000


/* --- Register HW_IPU_INT_STAT_1, field IDMAC_EOF_31 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_1_IDMAC_EOF_31      31
#define BM_IPU_INT_STAT_1_IDMAC_EOF_31      0x80000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_2 - Interrupt Status Register2 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. The status bits of EOF (end of frame) of DMA Channels
 * interrupts [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_EOF_33 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_EOF_40 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_41 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_42 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_43 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_44 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_45 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_46 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_47 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_48 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_49 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_50 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_51 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOF_52 : 1; //!< End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_int_stat_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_2 register
 */
#define HW_IPU_INT_STAT_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x204)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_2(x)           (*(volatile hw_ipu_int_stat_2_t *) HW_IPU_INT_STAT_2_ADDR(x))
#define HW_IPU_INT_STAT_2_RD(x)        (HW_IPU_INT_STAT_2(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_2 bitfields
 */

/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_33 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_33      1
#define BM_IPU_INT_STAT_2_IDMAC_EOF_33      0x00000002


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_40 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_40      8
#define BM_IPU_INT_STAT_2_IDMAC_EOF_40      0x00000100


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_41 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_41      9
#define BM_IPU_INT_STAT_2_IDMAC_EOF_41      0x00000200


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_42 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_42      10
#define BM_IPU_INT_STAT_2_IDMAC_EOF_42      0x00000400


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_43 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_43      11
#define BM_IPU_INT_STAT_2_IDMAC_EOF_43      0x00000800


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_44 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_44      12
#define BM_IPU_INT_STAT_2_IDMAC_EOF_44      0x00001000


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_45 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_45      13
#define BM_IPU_INT_STAT_2_IDMAC_EOF_45      0x00002000


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_46 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_46      14
#define BM_IPU_INT_STAT_2_IDMAC_EOF_46      0x00004000


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_47 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_47      15
#define BM_IPU_INT_STAT_2_IDMAC_EOF_47      0x00008000


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_48 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_48      16
#define BM_IPU_INT_STAT_2_IDMAC_EOF_48      0x00010000


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_49 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_49      17
#define BM_IPU_INT_STAT_2_IDMAC_EOF_49      0x00020000


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_50 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_50      18
#define BM_IPU_INT_STAT_2_IDMAC_EOF_50      0x00040000


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_51 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_51      19
#define BM_IPU_INT_STAT_2_IDMAC_EOF_51      0x00080000


/* --- Register HW_IPU_INT_STAT_2, field IDMAC_EOF_52 (W1C)
 *
 * End of Frame of Channel interrupt. This bit is the status bit of End Of Frame of Channel #n. n
 * Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_2_IDMAC_EOF_52      20
#define BM_IPU_INT_STAT_2_IDMAC_EOF_52      0x00100000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_3 - Interrupt Status Register 3 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. The status bits of NFACK (New Frame Ack) of DMA Channels
 * interrupts [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_NFACK_0 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_1 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_2 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_3 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_NFACK_5 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_NFACK_8 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_9 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_10 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_11 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_12 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_13 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_14 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_15 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_NFACK_17 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_18 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_19 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_20 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_21 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_22 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_23 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_24 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_25 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_26 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_27 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_28 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_29 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_NFACK_31 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_int_stat_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_3 register
 */
#define HW_IPU_INT_STAT_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x208)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_3(x)           (*(volatile hw_ipu_int_stat_3_t *) HW_IPU_INT_STAT_3_ADDR(x))
#define HW_IPU_INT_STAT_3_RD(x)        (HW_IPU_INT_STAT_3(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_3 bitfields
 */

/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_0 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_0      0
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_0      0x00000001


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_1 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_1      1
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_1      0x00000002


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_2 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_2      2
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_2      0x00000004


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_3 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_3      3
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_3      0x00000008


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_5 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_5      5
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_5      0x00000020


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_8 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_8      8
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_8      0x00000100


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_9 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_9      9
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_9      0x00000200


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_10 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_10      10
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_10      0x00000400


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_11 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_11      11
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_11      0x00000800


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_12 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_12      12
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_12      0x00001000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_13 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_13      13
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_13      0x00002000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_14 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_14      14
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_14      0x00004000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_15 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_15      15
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_15      0x00008000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_17 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_17      17
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_17      0x00020000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_18 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_18      18
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_18      0x00040000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_19 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_19      19
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_19      0x00080000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_20 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_20      20
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_20      0x00100000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_21 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_21      21
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_21      0x00200000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_22 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_22      22
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_22      0x00400000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_23 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_23      23
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_23      0x00800000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_24 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_24      24
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_24      0x01000000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_25 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_25      25
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_25      0x02000000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_26 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_26      26
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_26      0x04000000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_27 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_27      27
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_27      0x08000000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_28 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_28      28
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_28      0x10000000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_29 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_29      29
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_29      0x20000000


/* --- Register HW_IPU_INT_STAT_3, field IDMAC_NFACK_31 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_3_IDMAC_NFACK_31      31
#define BM_IPU_INT_STAT_3_IDMAC_NFACK_31      0x80000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_5 - Interrupt Status Register 5 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. The status bits of the New-frame before end-of-frame
 * indication (NFB4EOF_ERR) of DMA Channels interrupts [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_NFB4EOF_ERR_0 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_1 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_2 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_3 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_NFB4EOF_ERR_5 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_NFB4EOF_ERR_8 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_9 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_10 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_11 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_12 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_13 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_14 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_15 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_NFB4EOF_ERR_17 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_18 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_19 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_20 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_21 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_22 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_23 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_24 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_25 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_26 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_27 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_28 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_29 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_NFB4EOF_ERR_31 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_int_stat_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_5 register
 */
#define HW_IPU_INT_STAT_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x210)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_5(x)           (*(volatile hw_ipu_int_stat_5_t *) HW_IPU_INT_STAT_5_ADDR(x))
#define HW_IPU_INT_STAT_5_RD(x)        (HW_IPU_INT_STAT_5(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_5 bitfields
 */

/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_0 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_0      0
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_0      0x00000001


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_1 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_1      1
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_1      0x00000002


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_2 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_2      2
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_2      0x00000004


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_3 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_3      3
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_3      0x00000008


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_5 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_5      5
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_5      0x00000020


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_8 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_8      8
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_8      0x00000100


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_9 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_9      9
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_9      0x00000200


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_10 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_10      10
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_10      0x00000400


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_11 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_11      11
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_11      0x00000800


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_12 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_12      12
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_12      0x00001000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_13 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_13      13
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_13      0x00002000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_14 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_14      14
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_14      0x00004000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_15 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_15      15
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_15      0x00008000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_17 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_17      17
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_17      0x00020000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_18 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_18      18
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_18      0x00040000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_19 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_19      19
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_19      0x00080000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_20 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_20      20
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_20      0x00100000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_21 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_21      21
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_21      0x00200000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_22 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_22      22
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_22      0x00400000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_23 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_23      23
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_23      0x00800000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_24 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_24      24
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_24      0x01000000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_25 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_25      25
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_25      0x02000000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_26 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_26      26
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_26      0x04000000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_27 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_27      27
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_27      0x08000000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_28 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_28      28
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_28      0x10000000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_29 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_29      29
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_29      0x20000000


/* --- Register HW_IPU_INT_STAT_5, field IDMAC_NFB4EOF_ERR_31 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_31      31
#define BM_IPU_INT_STAT_5_IDMAC_NFB4EOF_ERR_31      0x80000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_6 - Interrupt Status Register 6 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. The status bits of the New-frame before end-of-frame
 * indication (NFB4EOF_ERR) of DMA Channels interrupts [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_NFB4EOF_ERR_33 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_NFB4EOF_ERR_40 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_41 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_42 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_43 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_44 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_45 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_46 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_47 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_48 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_49 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_50 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_51 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFB4EOF_ERR_52 : 1; //!< New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_int_stat_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_6 register
 */
#define HW_IPU_INT_STAT_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x214)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_6(x)           (*(volatile hw_ipu_int_stat_6_t *) HW_IPU_INT_STAT_6_ADDR(x))
#define HW_IPU_INT_STAT_6_RD(x)        (HW_IPU_INT_STAT_6(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_6 bitfields
 */

/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_33 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_33      1
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_33      0x00000002


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_40 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_40      8
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_40      0x00000100


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_41 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_41      9
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_41      0x00000200


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_42 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_42      10
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_42      0x00000400


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_43 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_43      11
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_43      0x00000800


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_44 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_44      12
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_44      0x00001000


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_45 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_45      13
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_45      0x00002000


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_46 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_46      14
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_46      0x00004000


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_47 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_47      15
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_47      0x00008000


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_48 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_48      16
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_48      0x00010000


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_49 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_49      17
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_49      0x00020000


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_50 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_50      18
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_50      0x00040000


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_51 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_51      19
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_51      0x00080000


/* --- Register HW_IPU_INT_STAT_6, field IDMAC_NFB4EOF_ERR_52 (W1C)
 *
 * New Frame before end-of-frame error indication of Channel interrupt. This bit is the status bit
 * of New Frame before end-of-frame error interrupt of Channel #n. n Indicates the corresponding DMA
 * channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_52      20
#define BM_IPU_INT_STAT_6_IDMAC_NFB4EOF_ERR_52      0x00100000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_7 - Interrupt Status Register7 1 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. The status bits of the End-of-Scroll indication (EOS) of DMA
 * Channels interrupts [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 19; //!< Reserved.
        unsigned IDMAC_EOS_EN_19 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 3; //!< Reserved.
        unsigned IDMAC_EOS_EN_23 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_24 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_25 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_26 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_27 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_28 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_29 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_EOS_EN_31 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_int_stat_7_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_7 register
 */
#define HW_IPU_INT_STAT_7_ADDR(x)      (REGS_IPU_BASE(x) + 0x218)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_7(x)           (*(volatile hw_ipu_int_stat_7_t *) HW_IPU_INT_STAT_7_ADDR(x))
#define HW_IPU_INT_STAT_7_RD(x)        (HW_IPU_INT_STAT_7(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_7 bitfields
 */

/* --- Register HW_IPU_INT_STAT_7, field IDMAC_EOS_EN_19 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_7_IDMAC_EOS_EN_19      19
#define BM_IPU_INT_STAT_7_IDMAC_EOS_EN_19      0x00080000


/* --- Register HW_IPU_INT_STAT_7, field IDMAC_EOS_EN_23 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_7_IDMAC_EOS_EN_23      23
#define BM_IPU_INT_STAT_7_IDMAC_EOS_EN_23      0x00800000


/* --- Register HW_IPU_INT_STAT_7, field IDMAC_EOS_EN_24 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_7_IDMAC_EOS_EN_24      24
#define BM_IPU_INT_STAT_7_IDMAC_EOS_EN_24      0x01000000


/* --- Register HW_IPU_INT_STAT_7, field IDMAC_EOS_EN_25 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_7_IDMAC_EOS_EN_25      25
#define BM_IPU_INT_STAT_7_IDMAC_EOS_EN_25      0x02000000


/* --- Register HW_IPU_INT_STAT_7, field IDMAC_EOS_EN_26 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_7_IDMAC_EOS_EN_26      26
#define BM_IPU_INT_STAT_7_IDMAC_EOS_EN_26      0x04000000


/* --- Register HW_IPU_INT_STAT_7, field IDMAC_EOS_EN_27 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_7_IDMAC_EOS_EN_27      27
#define BM_IPU_INT_STAT_7_IDMAC_EOS_EN_27      0x08000000


/* --- Register HW_IPU_INT_STAT_7, field IDMAC_EOS_EN_28 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_7_IDMAC_EOS_EN_28      28
#define BM_IPU_INT_STAT_7_IDMAC_EOS_EN_28      0x10000000


/* --- Register HW_IPU_INT_STAT_7, field IDMAC_EOS_EN_29 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_7_IDMAC_EOS_EN_29      29
#define BM_IPU_INT_STAT_7_IDMAC_EOS_EN_29      0x20000000


/* --- Register HW_IPU_INT_STAT_7, field IDMAC_EOS_EN_31 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_7_IDMAC_EOS_EN_31      31
#define BM_IPU_INT_STAT_7_IDMAC_EOS_EN_31      0x80000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_8 - Interrupt Status Register 8 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. All the status bits of the End of Scroll indication (EOS) of
 * DMA Channels interrupts [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_EOS_EN_33 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 7; //!< Reserved.
        unsigned IDMAC_EOS_EN_41 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_42 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_43 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_44 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 6; //!< Reserved.
        unsigned IDMAC_EOS_EN_51 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOS_EN_52 : 1; //!< End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 11; //!< Reserved.
    } B;
} hw_ipu_int_stat_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_8 register
 */
#define HW_IPU_INT_STAT_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x21c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_8(x)           (*(volatile hw_ipu_int_stat_8_t *) HW_IPU_INT_STAT_8_ADDR(x))
#define HW_IPU_INT_STAT_8_RD(x)        (HW_IPU_INT_STAT_8(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_8 bitfields
 */

/* --- Register HW_IPU_INT_STAT_8, field IDMAC_EOS_EN_33 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_8_IDMAC_EOS_EN_33      1
#define BM_IPU_INT_STAT_8_IDMAC_EOS_EN_33      0x00000002


/* --- Register HW_IPU_INT_STAT_8, field IDMAC_EOS_EN_41 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_8_IDMAC_EOS_EN_41      9
#define BM_IPU_INT_STAT_8_IDMAC_EOS_EN_41      0x00000200


/* --- Register HW_IPU_INT_STAT_8, field IDMAC_EOS_EN_42 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_8_IDMAC_EOS_EN_42      10
#define BM_IPU_INT_STAT_8_IDMAC_EOS_EN_42      0x00000400


/* --- Register HW_IPU_INT_STAT_8, field IDMAC_EOS_EN_43 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_8_IDMAC_EOS_EN_43      11
#define BM_IPU_INT_STAT_8_IDMAC_EOS_EN_43      0x00000800


/* --- Register HW_IPU_INT_STAT_8, field IDMAC_EOS_EN_44 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_8_IDMAC_EOS_EN_44      12
#define BM_IPU_INT_STAT_8_IDMAC_EOS_EN_44      0x00001000


/* --- Register HW_IPU_INT_STAT_8, field IDMAC_EOS_EN_51 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_8_IDMAC_EOS_EN_51      19
#define BM_IPU_INT_STAT_8_IDMAC_EOS_EN_51      0x00080000


/* --- Register HW_IPU_INT_STAT_8, field IDMAC_EOS_EN_52 (W1C)
 *
 * End of Scroll indication of Channel interrupt. This bit is the status bit of End of Scroll
 * interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_8_IDMAC_EOS_EN_52      20
#define BM_IPU_INT_STAT_8_IDMAC_EOS_EN_52      0x00100000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_9 - Interrupt Status Register 9 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. This register holds the error interrupt indications coming
 * from different modules within All the bits in this register are write one to clear.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned VDI_FIFO1_OVF : 1; //!< FIFO1 overflow Interrupt1 The VDI C generate FIFO1 overflow interrupt1 when write pointer of FIFO1 overrun read pointer.
        unsigned RESERVED0 : 25; //!< Reserved
        unsigned IC_BAYER_BUF_OVF : 1; //!< This bit indicates on an interrupt that is a result of the IC Buffer overflow for Bayer coming from the IC. The user needs to write 1 to this bit in order to clear it.
        unsigned IC_ENC_BUF_OVF : 1; //!< This bit indicates on an interrupt that is a result of the IC Buffer overflow for encoding coming from the IC. The user needs to write 1 to this bit in order to clear it.
        unsigned IC_VF_BUF_OVF : 1; //!< This bit indicates on an interrupt that is a result of the IC Buffer overflow for view finder coming from the IC. The user needs to write 1 to this bit in order to clear it.
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned CSI0_PUPE : 1; //!< CSI0_PUPE - CSI0 parameters update error interrupt. This bit indicates on an interrupt that is a result of an error generated by the CSI0. The error is generated in case where new frame arrived from the CSI0 before the completion of the CSI0's parameters update by the SRM
        unsigned CSI1_PUPE : 1; //!< CSI1_PUPE - CSI1 parameters update error interrupt. This bit indicates on an interrupt that is a result of an error generated by the CSI1. The error is generated in case where new frame arrived from the CSI1 before the completion of the CSI1's parameters update by the SRM
    } B;
} hw_ipu_int_stat_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_9 register
 */
#define HW_IPU_INT_STAT_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x220)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_9(x)           (*(volatile hw_ipu_int_stat_9_t *) HW_IPU_INT_STAT_9_ADDR(x))
#define HW_IPU_INT_STAT_9_RD(x)        (HW_IPU_INT_STAT_9(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_9 bitfields
 */

/* --- Register HW_IPU_INT_STAT_9, field VDI_FIFO1_OVF (W1C)
 *
 * FIFO1 overflow Interrupt1 The VDI C generate FIFO1 overflow interrupt1 when write pointer of
 * FIFO1 overrun read pointer.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_9_VDI_FIFO1_OVF      0
#define BM_IPU_INT_STAT_9_VDI_FIFO1_OVF      0x00000001


/* --- Register HW_IPU_INT_STAT_9, field IC_BAYER_BUF_OVF (W1C)
 *
 * This bit indicates on an interrupt that is a result of the IC Buffer overflow for Bayer coming
 * from the IC. The user needs to write 1 to this bit in order to clear it.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_9_IC_BAYER_BUF_OVF      26
#define BM_IPU_INT_STAT_9_IC_BAYER_BUF_OVF      0x04000000


/* --- Register HW_IPU_INT_STAT_9, field IC_ENC_BUF_OVF (W1C)
 *
 * This bit indicates on an interrupt that is a result of the IC Buffer overflow for encoding coming
 * from the IC. The user needs to write 1 to this bit in order to clear it.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_9_IC_ENC_BUF_OVF      27
#define BM_IPU_INT_STAT_9_IC_ENC_BUF_OVF      0x08000000


/* --- Register HW_IPU_INT_STAT_9, field IC_VF_BUF_OVF (W1C)
 *
 * This bit indicates on an interrupt that is a result of the IC Buffer overflow for view finder
 * coming from the IC. The user needs to write 1 to this bit in order to clear it.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_9_IC_VF_BUF_OVF      28
#define BM_IPU_INT_STAT_9_IC_VF_BUF_OVF      0x10000000


/* --- Register HW_IPU_INT_STAT_9, field CSI0_PUPE (W1C)
 *
 * CSI0_PUPE - CSI0 parameters update error interrupt. This bit indicates on an interrupt that is a
 * result of an error generated by the CSI0. The error is generated in case where new frame arrived
 * from the CSI0 before the completion of the CSI0's parameters update by the SRM
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_9_CSI0_PUPE      30
#define BM_IPU_INT_STAT_9_CSI0_PUPE      0x40000000


/* --- Register HW_IPU_INT_STAT_9, field CSI1_PUPE (W1C)
 *
 * CSI1_PUPE - CSI1 parameters update error interrupt. This bit indicates on an interrupt that is a
 * result of an error generated by the CSI1. The error is generated in case where new frame arrived
 * from the CSI1 before the completion of the CSI1's parameters update by the SRM
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_9_CSI1_PUPE      31
#define BM_IPU_INT_STAT_9_CSI1_PUPE      0x80000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_10 - Interrupt Status Register 10 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. This register holds error interrupt indications coming from
 * different modules within All the bits in this register are write one to clear.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SMFC0_FRM_LOST : 1; //!< Frame Lost of SMFC channel 0 interrupt. This bit indicates on an interrupt that is a result of a result of a Frame Lost of SMFC channel 0
        unsigned SMFC1_FRM_LOST : 1; //!< Frame Lost of SMFC channel 1 interrupt. This bit indicates on an interrupt that is a result of a result of a Frame Lost of SMFC channel 1
        unsigned SMFC2_FRM_LOST : 1; //!< Frame Lost of SMFC channel 2 interrupt. This bit indicates on an interrupt that is a result of a result of a Frame Lost of SMFC channel 2
        unsigned SMFC3_FRM_LOST : 1; //!< Frame Lost of SMFC channel 3 interrupt. This bit indicates on an interrupt that is a result of a result of a Frame Lost of SMFC channel 3
        unsigned RESERVED0 : 12; //!< Reserved
        unsigned DC_TEARING_ERR_1 : 1; //!< Tearing Error #1 interrupt This bit indicates on the interrupt that is a result of tearing error while the anti tearing mechanism is activated for DC channel 1
        unsigned DC_TEARING_ERR_2 : 1; //!< Tearing Error #2 interrupt This bit indicates on the interrupt that is a result of tearing error while the anti tearing mechanism is activated for DC channel 2
        unsigned DC_TEARING_ERR_6 : 1; //!< Tearing Error #6 interrupt This bit indicates on the interrupt that is a result of tearing error while the anti tearing mechanism is activated for DC channel 6
        unsigned DI0_SYNC_DISP_ERR : 1; //!< DI0 Synchronous display error interrupt This bit indicates on the interrupt that is a result of an error during access to a synchronous display via DI0
        unsigned DI1_SYNC_DISP_ERR : 1; //!< DI1 Synchronous display error interrupt This bit indicates on the interrupt that is a result of an error during access to a synchronous display via DI1
        unsigned DI0_TIME_OUT_ERR : 1; //!< DI0 time out error interrupt This bit indicates on the interrupt that is a result of a time out error during a read access via DI0
        unsigned DI1_TIME_OUT_ERR : 1; //!< DI1 time out error interrupt This bit indicates on the interrupt that is a result of a time out error during a read access via DI1
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned IC_VF_FRM_LOST_ERR : 1; //!< This bit indicates on an interrupt that is a result of IC's view finder frame lost.
        unsigned IC_ENC_FRM_LOST_ERR : 1; //!< This bit indicates on an interrupt that is a result of IC's encoding frame lost.
        unsigned IC_BAYER_FRM_LOST_ERR : 1; //!< This bit indicates on an interrupt that is a result of IC's Bayer frame lost.
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned NON_PRIVILEGED_ACC_ERR : 1; //!< Non Privileged Access Error interrupt. This bit indicates on an interrupt that is a result of access the CPMEM or the DP memory in user mode
        unsigned AXIW_ERR : 1; //!< This bit indicates on an interrupt that is a result of AXI write access resulted with error response. The user needs to write 1 to this bit in order to clear it.
        unsigned AXIR_ERR : 1; //!< This bit indicates on an interrupt that is a result of AXI read access resulted with error response. The user needs to write 1 to this bit in order to clear it.
        unsigned RESERVED3 : 1; //!< Reserved
    } B;
} hw_ipu_int_stat_10_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_10 register
 */
#define HW_IPU_INT_STAT_10_ADDR(x)      (REGS_IPU_BASE(x) + 0x224)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_10(x)           (*(volatile hw_ipu_int_stat_10_t *) HW_IPU_INT_STAT_10_ADDR(x))
#define HW_IPU_INT_STAT_10_RD(x)        (HW_IPU_INT_STAT_10(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_10 bitfields
 */

/* --- Register HW_IPU_INT_STAT_10, field SMFC0_FRM_LOST (W1C)
 *
 * Frame Lost of SMFC channel 0 interrupt. This bit indicates on an interrupt that is a result of a
 * result of a Frame Lost of SMFC channel 0
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_10_SMFC0_FRM_LOST      0
#define BM_IPU_INT_STAT_10_SMFC0_FRM_LOST      0x00000001


/* --- Register HW_IPU_INT_STAT_10, field SMFC1_FRM_LOST (W1C)
 *
 * Frame Lost of SMFC channel 1 interrupt. This bit indicates on an interrupt that is a result of a
 * result of a Frame Lost of SMFC channel 1
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_10_SMFC1_FRM_LOST      1
#define BM_IPU_INT_STAT_10_SMFC1_FRM_LOST      0x00000002


/* --- Register HW_IPU_INT_STAT_10, field SMFC2_FRM_LOST (W1C)
 *
 * Frame Lost of SMFC channel 2 interrupt. This bit indicates on an interrupt that is a result of a
 * result of a Frame Lost of SMFC channel 2
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_10_SMFC2_FRM_LOST      2
#define BM_IPU_INT_STAT_10_SMFC2_FRM_LOST      0x00000004


/* --- Register HW_IPU_INT_STAT_10, field SMFC3_FRM_LOST (W1C)
 *
 * Frame Lost of SMFC channel 3 interrupt. This bit indicates on an interrupt that is a result of a
 * result of a Frame Lost of SMFC channel 3
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_10_SMFC3_FRM_LOST      3
#define BM_IPU_INT_STAT_10_SMFC3_FRM_LOST      0x00000008


/* --- Register HW_IPU_INT_STAT_10, field DC_TEARING_ERR_1 (W1C)
 *
 * Tearing Error #1 interrupt This bit indicates on the interrupt that is a result of tearing error
 * while the anti tearing mechanism is activated for DC channel 1
 */

#define BP_IPU_INT_STAT_10_DC_TEARING_ERR_1      16
#define BM_IPU_INT_STAT_10_DC_TEARING_ERR_1      0x00010000

/* --- Register HW_IPU_INT_STAT_10, field DC_TEARING_ERR_2 (W1C)
 *
 * Tearing Error #2 interrupt This bit indicates on the interrupt that is a result of tearing error
 * while the anti tearing mechanism is activated for DC channel 2
 */

#define BP_IPU_INT_STAT_10_DC_TEARING_ERR_2      17
#define BM_IPU_INT_STAT_10_DC_TEARING_ERR_2      0x00020000

/* --- Register HW_IPU_INT_STAT_10, field DC_TEARING_ERR_6 (W1C)
 *
 * Tearing Error #6 interrupt This bit indicates on the interrupt that is a result of tearing error
 * while the anti tearing mechanism is activated for DC channel 6
 */

#define BP_IPU_INT_STAT_10_DC_TEARING_ERR_6      18
#define BM_IPU_INT_STAT_10_DC_TEARING_ERR_6      0x00040000

/* --- Register HW_IPU_INT_STAT_10, field DI0_SYNC_DISP_ERR (W1C)
 *
 * DI0 Synchronous display error interrupt This bit indicates on the interrupt that is a result of
 * an error during access to a synchronous display via DI0
 */

#define BP_IPU_INT_STAT_10_DI0_SYNC_DISP_ERR      19
#define BM_IPU_INT_STAT_10_DI0_SYNC_DISP_ERR      0x00080000

/* --- Register HW_IPU_INT_STAT_10, field DI1_SYNC_DISP_ERR (W1C)
 *
 * DI1 Synchronous display error interrupt This bit indicates on the interrupt that is a result of
 * an error during access to a synchronous display via DI1
 */

#define BP_IPU_INT_STAT_10_DI1_SYNC_DISP_ERR      20
#define BM_IPU_INT_STAT_10_DI1_SYNC_DISP_ERR      0x00100000

/* --- Register HW_IPU_INT_STAT_10, field DI0_TIME_OUT_ERR (W1C)
 *
 * DI0 time out error interrupt This bit indicates on the interrupt that is a result of a time out
 * error during a read access via DI0
 */

#define BP_IPU_INT_STAT_10_DI0_TIME_OUT_ERR      21
#define BM_IPU_INT_STAT_10_DI0_TIME_OUT_ERR      0x00200000

/* --- Register HW_IPU_INT_STAT_10, field DI1_TIME_OUT_ERR (W1C)
 *
 * DI1 time out error interrupt This bit indicates on the interrupt that is a result of a time out
 * error during a read access via DI1
 */

#define BP_IPU_INT_STAT_10_DI1_TIME_OUT_ERR      22
#define BM_IPU_INT_STAT_10_DI1_TIME_OUT_ERR      0x00400000

/* --- Register HW_IPU_INT_STAT_10, field IC_VF_FRM_LOST_ERR (W1C)
 *
 * This bit indicates on an interrupt that is a result of IC's view finder frame lost.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_STAT_10_IC_VF_FRM_LOST_ERR      24
#define BM_IPU_INT_STAT_10_IC_VF_FRM_LOST_ERR      0x01000000


/* --- Register HW_IPU_INT_STAT_10, field IC_ENC_FRM_LOST_ERR (W1C)
 *
 * This bit indicates on an interrupt that is a result of IC's encoding frame lost.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_STAT_10_IC_ENC_FRM_LOST_ERR      25
#define BM_IPU_INT_STAT_10_IC_ENC_FRM_LOST_ERR      0x02000000


/* --- Register HW_IPU_INT_STAT_10, field IC_BAYER_FRM_LOST_ERR (W1C)
 *
 * This bit indicates on an interrupt that is a result of IC's Bayer frame lost.
 *
 * Values:
 * 0 - Interrupt is disabled.
 * 1 - Interrupt is enabled.
 */

#define BP_IPU_INT_STAT_10_IC_BAYER_FRM_LOST_ERR      26
#define BM_IPU_INT_STAT_10_IC_BAYER_FRM_LOST_ERR      0x04000000


/* --- Register HW_IPU_INT_STAT_10, field NON_PRIVILEGED_ACC_ERR (W1C)
 *
 * Non Privileged Access Error interrupt. This bit indicates on an interrupt that is a result of
 * access the CPMEM or the DP memory in user mode
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_10_NON_PRIVILEGED_ACC_ERR      28
#define BM_IPU_INT_STAT_10_NON_PRIVILEGED_ACC_ERR      0x10000000


/* --- Register HW_IPU_INT_STAT_10, field AXIW_ERR (W1C)
 *
 * This bit indicates on an interrupt that is a result of AXI write access resulted with error
 * response. The user needs to write 1 to this bit in order to clear it.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_10_AXIW_ERR      29
#define BM_IPU_INT_STAT_10_AXIW_ERR      0x20000000


/* --- Register HW_IPU_INT_STAT_10, field AXIR_ERR (W1C)
 *
 * This bit indicates on an interrupt that is a result of AXI read access resulted with error
 * response. The user needs to write 1 to this bit in order to clear it.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_10_AXIR_ERR      30
#define BM_IPU_INT_STAT_10_AXIR_ERR      0x40000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_11 - Interrupt Status Register 11 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. The status bits of the end-of-band indication (EOBND) of DMA
 * Channels interrupts [31:0] can be found in this register.  Editor's Note: The conditional tag
 * settings should be   Hide VDOA_SYNC for all versions  Show VDOA_SYNC for IPUv3H version.  The
 * table below tagged with other settings (like IPU3M_only) should be hidden in IPUv3H version.
 * This requires some sophisticated conditional tag settings
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_EOBND_EN_0 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_1 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_2 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_3 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_EOBND_EN_5 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 5; //!< Reserved.
        unsigned IDMAC_EOBND_EN_11 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_12 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 7; //!< Reserved.
        unsigned IDMAC_EOBND_EN_20 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_21 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_22 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 2; //!< Reserved.
        unsigned IDMAC_EOBND_EN_25 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_26 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED4 : 5; //!< Reserved.
    } B;
} hw_ipu_int_stat_11_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_11 register
 */
#define HW_IPU_INT_STAT_11_ADDR(x)      (REGS_IPU_BASE(x) + 0x228)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_11(x)           (*(volatile hw_ipu_int_stat_11_t *) HW_IPU_INT_STAT_11_ADDR(x))
#define HW_IPU_INT_STAT_11_RD(x)        (HW_IPU_INT_STAT_11(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_11 bitfields
 */

/* --- Register HW_IPU_INT_STAT_11, field IDMAC_EOBND_EN_0 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_11_IDMAC_EOBND_EN_0      0
#define BM_IPU_INT_STAT_11_IDMAC_EOBND_EN_0      0x00000001


/* --- Register HW_IPU_INT_STAT_11, field IDMAC_EOBND_EN_1 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_11_IDMAC_EOBND_EN_1      1
#define BM_IPU_INT_STAT_11_IDMAC_EOBND_EN_1      0x00000002


/* --- Register HW_IPU_INT_STAT_11, field IDMAC_EOBND_EN_2 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_11_IDMAC_EOBND_EN_2      2
#define BM_IPU_INT_STAT_11_IDMAC_EOBND_EN_2      0x00000004


/* --- Register HW_IPU_INT_STAT_11, field IDMAC_EOBND_EN_3 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_11_IDMAC_EOBND_EN_3      3
#define BM_IPU_INT_STAT_11_IDMAC_EOBND_EN_3      0x00000008


/* --- Register HW_IPU_INT_STAT_11, field IDMAC_EOBND_EN_5 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_11_IDMAC_EOBND_EN_5      5
#define BM_IPU_INT_STAT_11_IDMAC_EOBND_EN_5      0x00000020


/* --- Register HW_IPU_INT_STAT_11, field IDMAC_EOBND_EN_11 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_11_IDMAC_EOBND_EN_11      11
#define BM_IPU_INT_STAT_11_IDMAC_EOBND_EN_11      0x00000800


/* --- Register HW_IPU_INT_STAT_11, field IDMAC_EOBND_EN_12 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_11_IDMAC_EOBND_EN_12      12
#define BM_IPU_INT_STAT_11_IDMAC_EOBND_EN_12      0x00001000


/* --- Register HW_IPU_INT_STAT_11, field IDMAC_EOBND_EN_20 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_11_IDMAC_EOBND_EN_20      20
#define BM_IPU_INT_STAT_11_IDMAC_EOBND_EN_20      0x00100000


/* --- Register HW_IPU_INT_STAT_11, field IDMAC_EOBND_EN_21 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_11_IDMAC_EOBND_EN_21      21
#define BM_IPU_INT_STAT_11_IDMAC_EOBND_EN_21      0x00200000


/* --- Register HW_IPU_INT_STAT_11, field IDMAC_EOBND_EN_22 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_11_IDMAC_EOBND_EN_22      22
#define BM_IPU_INT_STAT_11_IDMAC_EOBND_EN_22      0x00400000


/* --- Register HW_IPU_INT_STAT_11, field IDMAC_EOBND_EN_25 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_11_IDMAC_EOBND_EN_25      25
#define BM_IPU_INT_STAT_11_IDMAC_EOBND_EN_25      0x02000000


/* --- Register HW_IPU_INT_STAT_11, field IDMAC_EOBND_EN_26 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_11_IDMAC_EOBND_EN_26      26
#define BM_IPU_INT_STAT_11_IDMAC_EOBND_EN_26      0x04000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_12 - Interrupt Status Register 12 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. The status bits of the end-of-band indication (EOBND) of DMA
 * Channels interrupts [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 13; //!< Reserved.
        unsigned IDMAC_EOBND_EN_45 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_46 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_47 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_48 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_49 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_EOBND_EN_50 : 1; //!< end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 13; //!< Reserved.
    } B;
} hw_ipu_int_stat_12_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_12 register
 */
#define HW_IPU_INT_STAT_12_ADDR(x)      (REGS_IPU_BASE(x) + 0x22c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_12(x)           (*(volatile hw_ipu_int_stat_12_t *) HW_IPU_INT_STAT_12_ADDR(x))
#define HW_IPU_INT_STAT_12_RD(x)        (HW_IPU_INT_STAT_12(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_12 bitfields
 */

/* --- Register HW_IPU_INT_STAT_12, field IDMAC_EOBND_EN_45 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_12_IDMAC_EOBND_EN_45      13
#define BM_IPU_INT_STAT_12_IDMAC_EOBND_EN_45      0x00002000


/* --- Register HW_IPU_INT_STAT_12, field IDMAC_EOBND_EN_46 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_12_IDMAC_EOBND_EN_46      14
#define BM_IPU_INT_STAT_12_IDMAC_EOBND_EN_46      0x00004000


/* --- Register HW_IPU_INT_STAT_12, field IDMAC_EOBND_EN_47 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_12_IDMAC_EOBND_EN_47      15
#define BM_IPU_INT_STAT_12_IDMAC_EOBND_EN_47      0x00008000


/* --- Register HW_IPU_INT_STAT_12, field IDMAC_EOBND_EN_48 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_12_IDMAC_EOBND_EN_48      16
#define BM_IPU_INT_STAT_12_IDMAC_EOBND_EN_48      0x00010000


/* --- Register HW_IPU_INT_STAT_12, field IDMAC_EOBND_EN_49 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_12_IDMAC_EOBND_EN_49      17
#define BM_IPU_INT_STAT_12_IDMAC_EOBND_EN_49      0x00020000


/* --- Register HW_IPU_INT_STAT_12, field IDMAC_EOBND_EN_50 (W1C)
 *
 * end-of-band indication of Channel interrupt. This bit is the status bit of end-of-band interrupt
 * of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_12_IDMAC_EOBND_EN_50      18
#define BM_IPU_INT_STAT_12_IDMAC_EOBND_EN_50      0x00040000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_13 - Interrupt Status Register 13 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. The status bits of the Threshold crossing indication (TH) of
 * DMA Channels interrupts [31:0] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_TH_0 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_1 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_2 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_3 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_TH_5 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_TH_8 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_9 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_10 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_11 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_12 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_13 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_14 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_15 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_TH_17 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_18 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_19 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_20 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_21 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_22 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_23 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_24 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_25 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_26 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_27 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_28 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_29 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_TH_31 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_int_stat_13_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_13 register
 */
#define HW_IPU_INT_STAT_13_ADDR(x)      (REGS_IPU_BASE(x) + 0x230)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_13(x)           (*(volatile hw_ipu_int_stat_13_t *) HW_IPU_INT_STAT_13_ADDR(x))
#define HW_IPU_INT_STAT_13_RD(x)        (HW_IPU_INT_STAT_13(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_13 bitfields
 */

/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_0 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_0      0
#define BM_IPU_INT_STAT_13_IDMAC_TH_0      0x00000001


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_1 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_1      1
#define BM_IPU_INT_STAT_13_IDMAC_TH_1      0x00000002


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_2 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_2      2
#define BM_IPU_INT_STAT_13_IDMAC_TH_2      0x00000004


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_3 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_3      3
#define BM_IPU_INT_STAT_13_IDMAC_TH_3      0x00000008


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_5 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_5      5
#define BM_IPU_INT_STAT_13_IDMAC_TH_5      0x00000020


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_8 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_8      8
#define BM_IPU_INT_STAT_13_IDMAC_TH_8      0x00000100


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_9 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_9      9
#define BM_IPU_INT_STAT_13_IDMAC_TH_9      0x00000200


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_10 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_10      10
#define BM_IPU_INT_STAT_13_IDMAC_TH_10      0x00000400


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_11 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_11      11
#define BM_IPU_INT_STAT_13_IDMAC_TH_11      0x00000800


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_12 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_12      12
#define BM_IPU_INT_STAT_13_IDMAC_TH_12      0x00001000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_13 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_13      13
#define BM_IPU_INT_STAT_13_IDMAC_TH_13      0x00002000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_14 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_14      14
#define BM_IPU_INT_STAT_13_IDMAC_TH_14      0x00004000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_15 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_15      15
#define BM_IPU_INT_STAT_13_IDMAC_TH_15      0x00008000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_17 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_17      17
#define BM_IPU_INT_STAT_13_IDMAC_TH_17      0x00020000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_18 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_18      18
#define BM_IPU_INT_STAT_13_IDMAC_TH_18      0x00040000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_19 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_19      19
#define BM_IPU_INT_STAT_13_IDMAC_TH_19      0x00080000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_20 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_20      20
#define BM_IPU_INT_STAT_13_IDMAC_TH_20      0x00100000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_21 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_21      21
#define BM_IPU_INT_STAT_13_IDMAC_TH_21      0x00200000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_22 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_22      22
#define BM_IPU_INT_STAT_13_IDMAC_TH_22      0x00400000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_23 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_23      23
#define BM_IPU_INT_STAT_13_IDMAC_TH_23      0x00800000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_24 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_24      24
#define BM_IPU_INT_STAT_13_IDMAC_TH_24      0x01000000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_25 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_25      25
#define BM_IPU_INT_STAT_13_IDMAC_TH_25      0x02000000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_26 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_26      26
#define BM_IPU_INT_STAT_13_IDMAC_TH_26      0x04000000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_27 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_27      27
#define BM_IPU_INT_STAT_13_IDMAC_TH_27      0x08000000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_28 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_28      28
#define BM_IPU_INT_STAT_13_IDMAC_TH_28      0x10000000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_29 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_29      29
#define BM_IPU_INT_STAT_13_IDMAC_TH_29      0x20000000


/* --- Register HW_IPU_INT_STAT_13, field IDMAC_TH_31 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_13_IDMAC_TH_31      31
#define BM_IPU_INT_STAT_13_IDMAC_TH_31      0x80000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_14 - Interrupt Status Register 14 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. The status bits of the Threshold crossing indication (TH) of
 * DMA Channels interrupts [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_TH_33 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_TH_40 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_41 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_42 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_43 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_44 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_45 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_46 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_47 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_48 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_49 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_50 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_51 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_TH_52 : 1; //!< Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_int_stat_14_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_14 register
 */
#define HW_IPU_INT_STAT_14_ADDR(x)      (REGS_IPU_BASE(x) + 0x234)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_14(x)           (*(volatile hw_ipu_int_stat_14_t *) HW_IPU_INT_STAT_14_ADDR(x))
#define HW_IPU_INT_STAT_14_RD(x)        (HW_IPU_INT_STAT_14(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_14 bitfields
 */

/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_33 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_33      1
#define BM_IPU_INT_STAT_14_IDMAC_TH_33      0x00000002


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_40 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_40      8
#define BM_IPU_INT_STAT_14_IDMAC_TH_40      0x00000100


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_41 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_41      9
#define BM_IPU_INT_STAT_14_IDMAC_TH_41      0x00000200


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_42 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_42      10
#define BM_IPU_INT_STAT_14_IDMAC_TH_42      0x00000400


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_43 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_43      11
#define BM_IPU_INT_STAT_14_IDMAC_TH_43      0x00000800


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_44 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_44      12
#define BM_IPU_INT_STAT_14_IDMAC_TH_44      0x00001000


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_45 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_45      13
#define BM_IPU_INT_STAT_14_IDMAC_TH_45      0x00002000


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_46 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_46      14
#define BM_IPU_INT_STAT_14_IDMAC_TH_46      0x00004000


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_47 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_47      15
#define BM_IPU_INT_STAT_14_IDMAC_TH_47      0x00008000


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_48 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_48      16
#define BM_IPU_INT_STAT_14_IDMAC_TH_48      0x00010000


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_49 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_49      17
#define BM_IPU_INT_STAT_14_IDMAC_TH_49      0x00020000


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_50 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_50      18
#define BM_IPU_INT_STAT_14_IDMAC_TH_50      0x00040000


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_51 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_51      19
#define BM_IPU_INT_STAT_14_IDMAC_TH_51      0x00080000


/* --- Register HW_IPU_INT_STAT_14, field IDMAC_TH_52 (W1C)
 *
 * Threshold crossing indication of Channel interrupt. This bit is the status bit of Threshold
 * crossing interrupt of Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_14_IDMAC_TH_52      20
#define BM_IPU_INT_STAT_14_IDMAC_TH_52      0x00100000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_15 - Interrupt Status Register 15 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.IPU status registers are
 * not stored in the SRM during power gating mode.This register contains part of IPU interrupts
 * status bits. The status bits of general purpose interrupts can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SNOOPING1_INT : 1; //!< IPU snooping 1 event indication interrupt. This bit indicates on the interrupt that is a result of the detection of a snooping 1 signal assertion coming to the
        unsigned SNOOPING2_INT : 1; //!< IPU snooping 2 event indication interrupt. This bit indicates on the interrupt that is a result of the detection of a snooping 2 signal assertion coming to the IPU
        unsigned DP_SF_START : 1; //!< DP Sync Flow Start indication interrupt. This bit indicates on the interrupt that is a result of the Sync flow start at the DP
        unsigned DP_SF_END : 1; //!< DP Sync Flow End indication interrupt. This bit indicates on the interrupt that is a result of the Sync flow end at the DP
        unsigned DP_ASF_START : 1; //!< DP Async Flow Start indication interrupt. This bit indicates on the interrupt that is a result of the Async flow start at the DP
        unsigned DP_ASF_END : 1; //!< DP Async Flow End indication interrupt. This bit indicates on the interrupt that is a result of the Async flow end at the DP
        unsigned DP_SF_BRAKE : 1; //!< DP Sync Flow Brake indication interrupt. This bit indicates on the interrupt that is a result of the Sync flow brake at the DP
        unsigned DP_ASF_BRAKE : 1; //!< DP Async Flow Brake indication interrupt. This bit indicates on the interrupt that is a result of the async flow brake at the DP
        unsigned DC_FC_0 : 1; //!< DC Frame Complete on channel #0 interrupt indication
        unsigned DC_FC_1 : 1; //!< DC Frame Complete on channel #1 interrupt indication
        unsigned DC_FC_2 : 1; //!< DC Frame Complete on channel #2 interrupt indication
        unsigned DC_FC_3 : 1; //!< DC Frame Complete on channel #3 interrupt indication
        unsigned DC_FC_4 : 1; //!< DC Frame Complete on channel #4 interrupt indication
        unsigned DC_FC_6 : 1; //!< DC Frame Complete on channel #6 interrupt indication
        unsigned DI_VSYNC_PRE_0 : 1; //!< DI0 interrupt indicating of a VSYNC signal asserted 2 rows before the VSYNC sent to the display
        unsigned DI_VSYNC_PRE_1 : 1; //!< DI1 interrupt indicating of a VSYNC signal asserted 2 rows before the VSYNC sent to the display
        unsigned DC_DP_START : 1; //!< This bit indicates on an interrupt asserted anytime the DP start a new sync or async flow or when an async flow is interrupted by a sync flow
        unsigned DC_ASYNC_STOP : 1; //!< This bit indicates on an interrupt asserted anytime the DP stops an async flow and moves to a sync flow
        unsigned DI0_CNT_EN_PRE_0 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #0 of DI0
        unsigned DI0_CNT_EN_PRE_1 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #1 of DI0
        unsigned DI0_CNT_EN_PRE_2 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #2 of DI0
        unsigned DI0_CNT_EN_PRE_3 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #3 of DI0
        unsigned DI0_CNT_EN_PRE_4 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #4 of DI0
        unsigned DI0_CNT_EN_PRE_5 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #5 of DI0
        unsigned DI0_CNT_EN_PRE_6 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #6 of DI0
        unsigned DI0_CNT_EN_PRE_7 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #7 of DI0
        unsigned DI0_CNT_EN_PRE_8 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #8 of DI0
        unsigned DI0_CNT_EN_PRE_9 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #9 of DI0
        unsigned DI0_CNT_EN_PRE_10 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #10 of DI0
        unsigned DI1_DISP_CLK_EN_PRE : 1; //!< DI1_DISP_CLK_EN_PRE
        unsigned DI1_CNT_EN_PRE_3 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #3 of DI1
        unsigned DI1_CNT_EN_PRE_8 : 1; //!< This bit indicates on the interrupt that is a result of a trigger generated by counter #8 of DI1
    } B;
} hw_ipu_int_stat_15_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_15 register
 */
#define HW_IPU_INT_STAT_15_ADDR(x)      (REGS_IPU_BASE(x) + 0x238)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_15(x)           (*(volatile hw_ipu_int_stat_15_t *) HW_IPU_INT_STAT_15_ADDR(x))
#define HW_IPU_INT_STAT_15_RD(x)        (HW_IPU_INT_STAT_15(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_15 bitfields
 */

/* --- Register HW_IPU_INT_STAT_15, field SNOOPING1_INT (W1C)
 *
 * IPU snooping 1 event indication interrupt. This bit indicates on the interrupt that is a result
 * of the detection of a snooping 1 signal assertion coming to the
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_SNOOPING1_INT      0
#define BM_IPU_INT_STAT_15_SNOOPING1_INT      0x00000001


/* --- Register HW_IPU_INT_STAT_15, field SNOOPING2_INT (W1C)
 *
 * IPU snooping 2 event indication interrupt. This bit indicates on the interrupt that is a result
 * of the detection of a snooping 2 signal assertion coming to the IPU
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_SNOOPING2_INT      1
#define BM_IPU_INT_STAT_15_SNOOPING2_INT      0x00000002


/* --- Register HW_IPU_INT_STAT_15, field DP_SF_START (W1C)
 *
 * DP Sync Flow Start indication interrupt. This bit indicates on the interrupt that is a result of
 * the Sync flow start at the DP
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DP_SF_START      2
#define BM_IPU_INT_STAT_15_DP_SF_START      0x00000004


/* --- Register HW_IPU_INT_STAT_15, field DP_SF_END (W1C)
 *
 * DP Sync Flow End indication interrupt. This bit indicates on the interrupt that is a result of
 * the Sync flow end at the DP
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DP_SF_END      3
#define BM_IPU_INT_STAT_15_DP_SF_END      0x00000008


/* --- Register HW_IPU_INT_STAT_15, field DP_ASF_START (W1C)
 *
 * DP Async Flow Start indication interrupt. This bit indicates on the interrupt that is a result of
 * the Async flow start at the DP
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DP_ASF_START      4
#define BM_IPU_INT_STAT_15_DP_ASF_START      0x00000010


/* --- Register HW_IPU_INT_STAT_15, field DP_ASF_END (W1C)
 *
 * DP Async Flow End indication interrupt. This bit indicates on the interrupt that is a result of
 * the Async flow end at the DP
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DP_ASF_END      5
#define BM_IPU_INT_STAT_15_DP_ASF_END      0x00000020


/* --- Register HW_IPU_INT_STAT_15, field DP_SF_BRAKE (W1C)
 *
 * DP Sync Flow Brake indication interrupt. This bit indicates on the interrupt that is a result of
 * the Sync flow brake at the DP
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DP_SF_BRAKE      6
#define BM_IPU_INT_STAT_15_DP_SF_BRAKE      0x00000040


/* --- Register HW_IPU_INT_STAT_15, field DP_ASF_BRAKE (W1C)
 *
 * DP Async Flow Brake indication interrupt. This bit indicates on the interrupt that is a result of
 * the async flow brake at the DP
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DP_ASF_BRAKE      7
#define BM_IPU_INT_STAT_15_DP_ASF_BRAKE      0x00000080


/* --- Register HW_IPU_INT_STAT_15, field DC_FC_0 (W1C)
 *
 * DC Frame Complete on channel #0 interrupt indication
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DC_FC_0      8
#define BM_IPU_INT_STAT_15_DC_FC_0      0x00000100


/* --- Register HW_IPU_INT_STAT_15, field DC_FC_1 (W1C)
 *
 * DC Frame Complete on channel #1 interrupt indication
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DC_FC_1      9
#define BM_IPU_INT_STAT_15_DC_FC_1      0x00000200


/* --- Register HW_IPU_INT_STAT_15, field DC_FC_2 (W1C)
 *
 * DC Frame Complete on channel #2 interrupt indication
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DC_FC_2      10
#define BM_IPU_INT_STAT_15_DC_FC_2      0x00000400


/* --- Register HW_IPU_INT_STAT_15, field DC_FC_3 (W1C)
 *
 * DC Frame Complete on channel #3 interrupt indication
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DC_FC_3      11
#define BM_IPU_INT_STAT_15_DC_FC_3      0x00000800


/* --- Register HW_IPU_INT_STAT_15, field DC_FC_4 (W1C)
 *
 * DC Frame Complete on channel #4 interrupt indication
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DC_FC_4      12
#define BM_IPU_INT_STAT_15_DC_FC_4      0x00001000


/* --- Register HW_IPU_INT_STAT_15, field DC_FC_6 (W1C)
 *
 * DC Frame Complete on channel #6 interrupt indication
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DC_FC_6      13
#define BM_IPU_INT_STAT_15_DC_FC_6      0x00002000


/* --- Register HW_IPU_INT_STAT_15, field DI_VSYNC_PRE_0 (W1C)
 *
 * DI0 interrupt indicating of a VSYNC signal asserted 2 rows before the VSYNC sent to the display
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI_VSYNC_PRE_0      14
#define BM_IPU_INT_STAT_15_DI_VSYNC_PRE_0      0x00004000


/* --- Register HW_IPU_INT_STAT_15, field DI_VSYNC_PRE_1 (W1C)
 *
 * DI1 interrupt indicating of a VSYNC signal asserted 2 rows before the VSYNC sent to the display
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI_VSYNC_PRE_1      15
#define BM_IPU_INT_STAT_15_DI_VSYNC_PRE_1      0x00008000


/* --- Register HW_IPU_INT_STAT_15, field DC_DP_START (W1C)
 *
 * This bit indicates on an interrupt asserted anytime the DP start a new sync or async flow or when
 * an async flow is interrupted by a sync flow
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DC_DP_START      16
#define BM_IPU_INT_STAT_15_DC_DP_START      0x00010000


/* --- Register HW_IPU_INT_STAT_15, field DC_ASYNC_STOP (W1C)
 *
 * This bit indicates on an interrupt asserted anytime the DP stops an async flow and moves to a
 * sync flow
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DC_ASYNC_STOP      17
#define BM_IPU_INT_STAT_15_DC_ASYNC_STOP      0x00020000


/* --- Register HW_IPU_INT_STAT_15, field DI0_CNT_EN_PRE_0 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #0 of DI0
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI0_CNT_EN_PRE_0      18
#define BM_IPU_INT_STAT_15_DI0_CNT_EN_PRE_0      0x00040000


/* --- Register HW_IPU_INT_STAT_15, field DI0_CNT_EN_PRE_1 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #1 of DI0
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI0_CNT_EN_PRE_1      19
#define BM_IPU_INT_STAT_15_DI0_CNT_EN_PRE_1      0x00080000


/* --- Register HW_IPU_INT_STAT_15, field DI0_CNT_EN_PRE_2 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #2 of DI0
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI0_CNT_EN_PRE_2      20
#define BM_IPU_INT_STAT_15_DI0_CNT_EN_PRE_2      0x00100000


/* --- Register HW_IPU_INT_STAT_15, field DI0_CNT_EN_PRE_3 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #3 of DI0
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI0_CNT_EN_PRE_3      21
#define BM_IPU_INT_STAT_15_DI0_CNT_EN_PRE_3      0x00200000


/* --- Register HW_IPU_INT_STAT_15, field DI0_CNT_EN_PRE_4 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #4 of DI0
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI0_CNT_EN_PRE_4      22
#define BM_IPU_INT_STAT_15_DI0_CNT_EN_PRE_4      0x00400000


/* --- Register HW_IPU_INT_STAT_15, field DI0_CNT_EN_PRE_5 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #5 of DI0
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI0_CNT_EN_PRE_5      23
#define BM_IPU_INT_STAT_15_DI0_CNT_EN_PRE_5      0x00800000


/* --- Register HW_IPU_INT_STAT_15, field DI0_CNT_EN_PRE_6 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #6 of DI0
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI0_CNT_EN_PRE_6      24
#define BM_IPU_INT_STAT_15_DI0_CNT_EN_PRE_6      0x01000000


/* --- Register HW_IPU_INT_STAT_15, field DI0_CNT_EN_PRE_7 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #7 of DI0
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI0_CNT_EN_PRE_7      25
#define BM_IPU_INT_STAT_15_DI0_CNT_EN_PRE_7      0x02000000


/* --- Register HW_IPU_INT_STAT_15, field DI0_CNT_EN_PRE_8 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #8 of DI0
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI0_CNT_EN_PRE_8      26
#define BM_IPU_INT_STAT_15_DI0_CNT_EN_PRE_8      0x04000000


/* --- Register HW_IPU_INT_STAT_15, field DI0_CNT_EN_PRE_9 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #9 of DI0
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI0_CNT_EN_PRE_9      27
#define BM_IPU_INT_STAT_15_DI0_CNT_EN_PRE_9      0x08000000


/* --- Register HW_IPU_INT_STAT_15, field DI0_CNT_EN_PRE_10 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #10 of DI0
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI0_CNT_EN_PRE_10      28
#define BM_IPU_INT_STAT_15_DI0_CNT_EN_PRE_10      0x10000000


/* --- Register HW_IPU_INT_STAT_15, field DI1_DISP_CLK_EN_PRE (W1C)
 *
 * DI1_DISP_CLK_EN_PRE
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI1_DISP_CLK_EN_PRE      29
#define BM_IPU_INT_STAT_15_DI1_DISP_CLK_EN_PRE      0x20000000


/* --- Register HW_IPU_INT_STAT_15, field DI1_CNT_EN_PRE_3 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #3 of DI1
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI1_CNT_EN_PRE_3      30
#define BM_IPU_INT_STAT_15_DI1_CNT_EN_PRE_3      0x40000000


/* --- Register HW_IPU_INT_STAT_15, field DI1_CNT_EN_PRE_8 (W1C)
 *
 * This bit indicates on the interrupt that is a result of a trigger generated by counter #8 of DI1
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_15_DI1_CNT_EN_PRE_8      31
#define BM_IPU_INT_STAT_15_DI1_CNT_EN_PRE_8      0x80000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CUR_BUF_0 - Current Buffer Register 0 (RO)
 *
 * This register contains the current buffer status information bit for each DMA channel.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMA_CH_CUR_BUF_0 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_1 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_2 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_3 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DMA_CH_CUR_BUF_5 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned DMA_CH_CUR_BUF_8 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_9 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_10 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_11 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_12 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_13 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_14 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_15 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned DMA_CH_CUR_BUF_17 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_18 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_19 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_20 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_21 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_22 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_23 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_24 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_25 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_26 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_27 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_28 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_29 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned DMA_CH_CUR_BUF_31 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_cur_buf_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CUR_BUF_0 register
 */
#define HW_IPU_CUR_BUF_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x23c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CUR_BUF_0(x)           (*(volatile hw_ipu_cur_buf_0_t *) HW_IPU_CUR_BUF_0_ADDR(x))
#define HW_IPU_CUR_BUF_0_RD(x)        (HW_IPU_CUR_BUF_0(x).U)
#endif

/*
 * constants & macros for individual IPU_CUR_BUF_0 bitfields
 */

/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_0 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_0      0
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_0      0x00000001


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_1 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_1      1
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_1      0x00000002


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_2 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_2      2
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_2      0x00000004


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_3 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_3      3
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_3      0x00000008


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_5 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_5      5
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_5      0x00000020


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_8 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_8      8
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_8      0x00000100


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_9 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_9      9
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_9      0x00000200


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_10 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_10      10
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_10      0x00000400


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_11 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_11      11
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_11      0x00000800


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_12 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_12      12
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_12      0x00001000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_13 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_13      13
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_13      0x00002000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_14 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_14      14
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_14      0x00004000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_15 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_15      15
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_15      0x00008000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_17 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_17      17
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_17      0x00020000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_18 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_18      18
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_18      0x00040000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_19 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_19      19
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_19      0x00080000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_20 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_20      20
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_20      0x00100000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_21 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_21      21
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_21      0x00200000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_22 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_22      22
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_22      0x00400000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_23 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_23      23
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_23      0x00800000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_24 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_24      24
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_24      0x01000000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_25 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_25      25
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_25      0x02000000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_26 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_26      26
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_26      0x04000000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_27 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_27      27
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_27      0x08000000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_28 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_28      28
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_28      0x10000000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_29 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_29      29
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_29      0x20000000


/* --- Register HW_IPU_CUR_BUF_0, field DMA_CH_CUR_BUF_31 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_31      31
#define BM_IPU_CUR_BUF_0_DMA_CH_CUR_BUF_31      0x80000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CUR_BUF_1 - Current Buffer Register 1 (RO)
 *
 * This register contains the current buffer status information bit for each DMA channel.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DMA_CH_CUR_BUF_33 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned DMA_CH_CUR_BUF_40 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_41 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_42 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_43 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_44 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_45 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_46 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_47 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_48 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_49 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_50 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_51 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_CUR_BUF_52 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_cur_buf_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CUR_BUF_1 register
 */
#define HW_IPU_CUR_BUF_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x240)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CUR_BUF_1(x)           (*(volatile hw_ipu_cur_buf_1_t *) HW_IPU_CUR_BUF_1_ADDR(x))
#define HW_IPU_CUR_BUF_1_RD(x)        (HW_IPU_CUR_BUF_1(x).U)
#endif

/*
 * constants & macros for individual IPU_CUR_BUF_1 bitfields
 */

/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_33 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_33      1
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_33      0x00000002


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_40 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_40      8
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_40      0x00000100


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_41 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_41      9
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_41      0x00000200


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_42 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_42      10
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_42      0x00000400


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_43 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_43      11
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_43      0x00000800


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_44 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_44      12
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_44      0x00001000


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_45 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_45      13
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_45      0x00002000


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_46 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_46      14
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_46      0x00004000


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_47 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_47      15
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_47      0x00008000


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_48 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_48      16
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_48      0x00010000


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_49 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_49      17
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_49      0x00020000


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_50 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_50      18
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_50      0x00040000


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_51 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_51      19
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_51      0x00080000


/* --- Register HW_IPU_CUR_BUF_1, field DMA_CH_CUR_BUF_52 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_52      20
#define BM_IPU_CUR_BUF_1_DMA_CH_CUR_BUF_52      0x00100000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_ALT_CUR_0 - Alternate Current Buffer Register 0 (RO)
 *
 * This register contains the current buffer status information bit for each DMA channel.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 24; //!< Reserved.
        unsigned DMA_CH_ALT_CUR_BUF_24 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned DMA_CH_ALT_CUR_BUF_29 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 2; //!< Reserved.
    } B;
} hw_ipu_alt_cur_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_ALT_CUR_0 register
 */
#define HW_IPU_ALT_CUR_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x244)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_ALT_CUR_0(x)           (*(volatile hw_ipu_alt_cur_0_t *) HW_IPU_ALT_CUR_0_ADDR(x))
#define HW_IPU_ALT_CUR_0_RD(x)        (HW_IPU_ALT_CUR_0(x).U)
#endif

/*
 * constants & macros for individual IPU_ALT_CUR_0 bitfields
 */

/* --- Register HW_IPU_ALT_CUR_0, field DMA_CH_ALT_CUR_BUF_24 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_ALT_CUR_0_DMA_CH_ALT_CUR_BUF_24      24
#define BM_IPU_ALT_CUR_0_DMA_CH_ALT_CUR_BUF_24      0x01000000


/* --- Register HW_IPU_ALT_CUR_0, field DMA_CH_ALT_CUR_BUF_29 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_ALT_CUR_0_DMA_CH_ALT_CUR_BUF_29      29
#define BM_IPU_ALT_CUR_0_DMA_CH_ALT_CUR_BUF_29      0x20000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_ALT_CUR_1 - Alternate Current Buffer Register 1 (RO)
 *
 * This register contains the current buffer status information bit for each DMA channel. The
 * register is shown in VDI Plane Size Register 4 , and the register fields are described in VDI
 * Plane Size Register 4 .
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_ALT_CUR_BUF_N : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 7; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_ALT_CUR_BUF_N1 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 10; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned DMA_CH_ALT_CUR_BUF_52 : 1; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
        unsigned RESERVED3 : 11; //!< Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is selected. n Indicates the corresponding DMA channel number.
    } B;
} hw_ipu_alt_cur_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_ALT_CUR_1 register
 */
#define HW_IPU_ALT_CUR_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x248)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_ALT_CUR_1(x)           (*(volatile hw_ipu_alt_cur_1_t *) HW_IPU_ALT_CUR_1_ADDR(x))
#define HW_IPU_ALT_CUR_1_RD(x)        (HW_IPU_ALT_CUR_1(x).U)
#endif

/*
 * constants & macros for individual IPU_ALT_CUR_1 bitfields
 */

/* --- Register HW_IPU_ALT_CUR_1, field DMA_CH_ALT_CUR_BUF_N (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_ALT_CUR_1_DMA_CH_ALT_CUR_BUF_N      1
#define BM_IPU_ALT_CUR_1_DMA_CH_ALT_CUR_BUF_N      0x00000002


/* --- Register HW_IPU_ALT_CUR_1, field DMA_CH_ALT_CUR_BUF_N (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_ALT_CUR_1_DMA_CH_ALT_CUR_BUF_N      9
#define BM_IPU_ALT_CUR_1_DMA_CH_ALT_CUR_BUF_N      0x00000200


/* --- Register HW_IPU_ALT_CUR_1, field DMA_CH_ALT_CUR_BUF_52 (RO)
 *
 * Current Buffer. This bit indicates which buffer is in use by DMA when double buffer mode is
 * selected. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Current buffer used by DMA is buffer 0.
 * 1 - Current buffer used by DMA is buffer 1.
 */

#define BP_IPU_ALT_CUR_1_DMA_CH_ALT_CUR_BUF_52      20
#define BM_IPU_ALT_CUR_1_DMA_CH_ALT_CUR_BUF_52      0x00100000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SRM_STAT - Shadow Registers Memory Status Register (RO)
 *
 * The register contains status bits of SRM updates. There is a bit for each block. The bit is set
 * when the SRM is currently updating the module's registers. When the SRM completes updating the
 * registers of the block the bit is cleared. SW should not update the block's registers while it is
 * being updated by the SRM.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_S_SRM_STAT : 1; //!< DP SYNC FLOW SRM STAT This bit indicates that the SRM is currently updating the DP sync flow registers
        unsigned DP_A0_SRM_STAT : 1; //!< DP ASYNC0 FLOW SRM STAT This bit indicates that the SRM is currently updating the DP async flow 0 registers
        unsigned DP_A1_SRM_STAT : 1; //!< DP ASYNC1 FLOW SRM STAT This bit indicates that the SRM is currently updating the DP async flow 1 registers
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DC_2_SRM_STAT : 1; //!< DC group #2 SRM STAT This bit indicates that the SRM is currently updating the DC group #2 registers
        unsigned DC_6_SRM_STAT : 1; //!< DC group #6 SRM STAT This bit indicates that the SRM is currently updating the DC group #6 registers
        unsigned CSI0_SRM_STAT : 1; //!< CSI1_SRM_STAT
        unsigned CSI1_SRM_STAT : 1; //!< CSI1_SRM_STAT
        unsigned DI0_SRM_STAT : 1; //!< DI0 SRM STAT This bit indicates that the SRM is currently updating the DI0 registers
        unsigned DI1_SRM_STAT : 1; //!< DI1 SRM STAT This bit indicates that the SRM is currently updating the DI1 registers
        unsigned RESERVED1 : 22; //!< Reserved
    } B;
} hw_ipu_srm_stat_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SRM_STAT register
 */
#define HW_IPU_SRM_STAT_ADDR(x)      (REGS_IPU_BASE(x) + 0x24c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SRM_STAT(x)           (*(volatile hw_ipu_srm_stat_t *) HW_IPU_SRM_STAT_ADDR(x))
#define HW_IPU_SRM_STAT_RD(x)        (HW_IPU_SRM_STAT(x).U)
#endif

/*
 * constants & macros for individual IPU_SRM_STAT bitfields
 */

/* --- Register HW_IPU_SRM_STAT, field DP_S_SRM_STAT (RO)
 *
 * DP SYNC FLOW SRM STAT This bit indicates that the SRM is currently updating the DP sync flow
 * registers
 *
 * Values:
 * 1 - SRM is busy updating the DP sync flow registers
 * 0 - SRM is not updating the DP sync flow registers
 */

#define BP_IPU_SRM_STAT_DP_S_SRM_STAT      0
#define BM_IPU_SRM_STAT_DP_S_SRM_STAT      0x00000001


/* --- Register HW_IPU_SRM_STAT, field DP_A0_SRM_STAT (RO)
 *
 * DP ASYNC0 FLOW SRM STAT This bit indicates that the SRM is currently updating the DP async flow 0
 * registers
 *
 * Values:
 * 1 - SRM is busy updating the DP async flow 0 registers
 * 0 - SRM is not updating the DP async flow 0 registers
 */

#define BP_IPU_SRM_STAT_DP_A0_SRM_STAT      1
#define BM_IPU_SRM_STAT_DP_A0_SRM_STAT      0x00000002


/* --- Register HW_IPU_SRM_STAT, field DP_A1_SRM_STAT (RO)
 *
 * DP ASYNC1 FLOW SRM STAT This bit indicates that the SRM is currently updating the DP async flow 1
 * registers
 *
 * Values:
 * 1 - SRM is busy updating the DP sync flow registers
 * 0 - SRM is not updating the DP sync flow registers
 */

#define BP_IPU_SRM_STAT_DP_A1_SRM_STAT      2
#define BM_IPU_SRM_STAT_DP_A1_SRM_STAT      0x00000004


/* --- Register HW_IPU_SRM_STAT, field DC_2_SRM_STAT (RO)
 *
 * DC group #2 SRM STAT This bit indicates that the SRM is currently updating the DC group #2
 * registers
 *
 * Values:
 * 1 - SRM is busy updating the DC group #6 registers
 * 0 - SRM is not updating the DC group #2 registers
 */

#define BP_IPU_SRM_STAT_DC_2_SRM_STAT      4
#define BM_IPU_SRM_STAT_DC_2_SRM_STAT      0x00000010


/* --- Register HW_IPU_SRM_STAT, field DC_6_SRM_STAT (RO)
 *
 * DC group #6 SRM STAT This bit indicates that the SRM is currently updating the DC group #6
 * registers
 *
 * Values:
 * 1 - SRM is busy updating the DC registers
 * 0 - SRM is not updating the DC registers
 */

#define BP_IPU_SRM_STAT_DC_6_SRM_STAT      5
#define BM_IPU_SRM_STAT_DC_6_SRM_STAT      0x00000020


/* --- Register HW_IPU_SRM_STAT, field CSI0_SRM_STAT (RO)
 *
 * CSI1_SRM_STAT
 */

#define BP_IPU_SRM_STAT_CSI0_SRM_STAT      6
#define BM_IPU_SRM_STAT_CSI0_SRM_STAT      0x00000040

/* --- Register HW_IPU_SRM_STAT, field CSI1_SRM_STAT (RO)
 *
 * CSI1_SRM_STAT
 */

#define BP_IPU_SRM_STAT_CSI1_SRM_STAT      7
#define BM_IPU_SRM_STAT_CSI1_SRM_STAT      0x00000080

/* --- Register HW_IPU_SRM_STAT, field DI0_SRM_STAT (RO)
 *
 * DI0 SRM STAT This bit indicates that the SRM is currently updating the DI0 registers
 *
 * Values:
 * 1 - SRM is busy updating the DI0 registers
 * 0 - SRM is not updating the DI0 registers
 */

#define BP_IPU_SRM_STAT_DI0_SRM_STAT      8
#define BM_IPU_SRM_STAT_DI0_SRM_STAT      0x00000100


/* --- Register HW_IPU_SRM_STAT, field DI1_SRM_STAT (RO)
 *
 * DI1 SRM STAT This bit indicates that the SRM is currently updating the DI1 registers
 *
 * Values:
 * 1 - SRM is busy updating the DI1 registers
 * 0 - SRM is not updating the DI1 registers
 */

#define BP_IPU_SRM_STAT_DI1_SRM_STAT      9
#define BM_IPU_SRM_STAT_DI1_SRM_STAT      0x00000200


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_PROC_TASKS_STAT - Processing Status Tasks Register (RO)
 *
 * This register contains status bits for IPU's tasks.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned ENC_TSTAT : 2; //!< Status of the encoding task
        unsigned VF_TSTAT : 2; //!< Status of the viewfinder task
        unsigned PP_TSTAT : 2; //!< Status of the post processing task
        unsigned ENC_ROT_TSTAT : 2; //!< Status of the rotation for encoding task
        unsigned VF_ROT_TSTAT : 2; //!< Status of the rotation for viewfinder task
        unsigned PP_ROT_TSTAT : 2; //!< Status of the rotation for post processing task
        unsigned MEM2PRP_TSTAT : 3; //!< Status of the pre processing tasks (viewfinder and encoding) when the source is coming from the memory.
        unsigned RESERVED0 : 17; //!< Reserved
    } B;
} hw_ipu_proc_tasks_stat_t;
#endif

/*
 * constants & macros for entire multi-block IPU_PROC_TASKS_STAT register
 */
#define HW_IPU_PROC_TASKS_STAT_ADDR(x)      (REGS_IPU_BASE(x) + 0x250)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_PROC_TASKS_STAT(x)           (*(volatile hw_ipu_proc_tasks_stat_t *) HW_IPU_PROC_TASKS_STAT_ADDR(x))
#define HW_IPU_PROC_TASKS_STAT_RD(x)        (HW_IPU_PROC_TASKS_STAT(x).U)
#endif

/*
 * constants & macros for individual IPU_PROC_TASKS_STAT bitfields
 */

/* --- Register HW_IPU_PROC_TASKS_STAT, field ENC_TSTAT (RO)
 *
 * Status of the encoding task
 *
 * Values:
 * 00 - IDLE - The task is idle
 * 01 - ACTIVE - The primary flow of this task is currently active
 * 10 - WAIT_FOR_ READY - The task is waiting for a buffer to be ready
 */

#define BP_IPU_PROC_TASKS_STAT_ENC_TSTAT      0
#define BM_IPU_PROC_TASKS_STAT_ENC_TSTAT      0x00000003


/* --- Register HW_IPU_PROC_TASKS_STAT, field VF_TSTAT (RO)
 *
 * Status of the viewfinder task
 *
 * Values:
 * 00 - IDLE - The task is idle
 * 01 - ACTIVE - The primary flow of this task is currently active
 * 10 - WAIT_FOR_ READY - The task is waiting for a buffer to be ready
 */

#define BP_IPU_PROC_TASKS_STAT_VF_TSTAT      2
#define BM_IPU_PROC_TASKS_STAT_VF_TSTAT      0x0000000c


/* --- Register HW_IPU_PROC_TASKS_STAT, field PP_TSTAT (RO)
 *
 * Status of the post processing task
 *
 * Values:
 * 00 - IDLE - The task is idle
 * 01 - ACTIVE - The primary flow of this task is currently active
 * 10 - WAIT_FOR_ READY - The task is waiting for a buffer to be ready
 */

#define BP_IPU_PROC_TASKS_STAT_PP_TSTAT      4
#define BM_IPU_PROC_TASKS_STAT_PP_TSTAT      0x00000030


/* --- Register HW_IPU_PROC_TASKS_STAT, field ENC_ROT_TSTAT (RO)
 *
 * Status of the rotation for encoding task
 *
 * Values:
 * 00 - IDLE - The task is idle
 * 01 - ACTIVE - The primary flow of this task is currently active
 * 10 - WAIT_FOR_ READY - The task is waiting for a buffer to be ready
 */

#define BP_IPU_PROC_TASKS_STAT_ENC_ROT_TSTAT      6
#define BM_IPU_PROC_TASKS_STAT_ENC_ROT_TSTAT      0x000000c0


/* --- Register HW_IPU_PROC_TASKS_STAT, field VF_ROT_TSTAT (RO)
 *
 * Status of the rotation for viewfinder task
 *
 * Values:
 * 00 - IDLE - The task is idle
 * 01 - ACTIVE - The primary flow of this task is currently active
 * 10 - WAIT_FOR_ READY - The task is waiting for a buffer to be ready
 */

#define BP_IPU_PROC_TASKS_STAT_VF_ROT_TSTAT      8
#define BM_IPU_PROC_TASKS_STAT_VF_ROT_TSTAT      0x00000300


/* --- Register HW_IPU_PROC_TASKS_STAT, field PP_ROT_TSTAT (RO)
 *
 * Status of the rotation for post processing task
 *
 * Values:
 * 00 - IDLE - The task is idle
 * 01 - ACTIVE - The primary flow of this task is currently active
 * 10 - WAIT_FOR_ READY - The task is waiting for a buffer to be ready
 */

#define BP_IPU_PROC_TASKS_STAT_PP_ROT_TSTAT      10
#define BM_IPU_PROC_TASKS_STAT_PP_ROT_TSTAT      0x00000c00


/* --- Register HW_IPU_PROC_TASKS_STAT, field MEM2PRP_TSTAT (RO)
 *
 * Status of the pre processing tasks (viewfinder and encoding) when the source is coming from the
 * memory.
 *
 * Values:
 * 000 - IDLE - Both pre processing tasks are idle
 * 001 - BOTH_ACTIVE - Both pre processing tasks are idle
 * 010 - ENC_ACTIVE - Encoding task is active
 * 011 - VF_ACTIVE - View finder task is active
 * 100 - BOTH_PAUSE - both tasks are paused
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserve
 */

#define BP_IPU_PROC_TASKS_STAT_MEM2PRP_TSTAT      12
#define BM_IPU_PROC_TASKS_STAT_MEM2PRP_TSTAT      0x00007000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DISP_TASKS_STAT - Display Tasks Status Register (RO)
 *
 * This register contains status bits for IPU's tasks.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_ASYNC_STAT : 3; //!< Status of the Asynchronous flow through the DP
        unsigned DP_ASYNC_CUR_FLOW : 1; //!< Current asynchronous flow via the DP
        unsigned DC_ASYNC1_STAT : 2; //!< Status of the Asynchronous flow #1 through the DC (ch 28)
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DC_ASYNCH2_STAT : 3; //!< Status of the Asynchronous flow #2 through the DC
        unsigned DC_ASYNC2_CUR_FLOW : 1; //!< Current asynchronous #2 flow via the DC
        unsigned RESERVED1 : 20; //!< Reserved
    } B;
} hw_ipu_disp_tasks_stat_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DISP_TASKS_STAT register
 */
#define HW_IPU_DISP_TASKS_STAT_ADDR(x)      (REGS_IPU_BASE(x) + 0x254)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DISP_TASKS_STAT(x)           (*(volatile hw_ipu_disp_tasks_stat_t *) HW_IPU_DISP_TASKS_STAT_ADDR(x))
#define HW_IPU_DISP_TASKS_STAT_RD(x)        (HW_IPU_DISP_TASKS_STAT(x).U)
#endif

/*
 * constants & macros for individual IPU_DISP_TASKS_STAT bitfields
 */

/* --- Register HW_IPU_DISP_TASKS_STAT, field DP_ASYNC_STAT (RO)
 *
 * Status of the Asynchronous flow through the DP
 *
 * Values:
 * 000 - IDLE - the task is idle
 * 001 - PRIM_ACTIVE - The primary flow of this task is currently active
 * 010 - ALT_ACTIVE - The alternate flow of this task is currently active
 * 011 - UPDATE_PARAM - The FSU is busy updating parameters from the SRM
 * 100 - PAUSE - The task is paused
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DISP_TASKS_STAT_DP_ASYNC_STAT      0
#define BM_IPU_DISP_TASKS_STAT_DP_ASYNC_STAT      0x00000007


/* --- Register HW_IPU_DISP_TASKS_STAT, field DP_ASYNC_CUR_FLOW (RO)
 *
 * Current asynchronous flow via the DP
 *
 * Values:
 * 1 - alternate flow
 * 0 - main flow
 */

#define BP_IPU_DISP_TASKS_STAT_DP_ASYNC_CUR_FLOW      3
#define BM_IPU_DISP_TASKS_STAT_DP_ASYNC_CUR_FLOW      0x00000008


/* --- Register HW_IPU_DISP_TASKS_STAT, field DC_ASYNC1_STAT (RO)
 *
 * Status of the Asynchronous flow #1 through the DC (ch 28)
 *
 * Values:
 * 00 - IDLE - The task is idle
 * 01 - ACTIVE - This task is currently active
 * 10 - WAIT_FOR_ READY - The task is waiting for a buffer to be ready
 */

#define BP_IPU_DISP_TASKS_STAT_DC_ASYNC1_STAT      4
#define BM_IPU_DISP_TASKS_STAT_DC_ASYNC1_STAT      0x00000030


/* --- Register HW_IPU_DISP_TASKS_STAT, field DC_ASYNCH2_STAT (RO)
 *
 * Status of the Asynchronous flow #2 through the DC
 *
 * Values:
 * 000 - IDLE - the task is idle
 * 001 - PRIM_ACTIVE - The primary flow of this task is currently active
 * 010 - ALT_ACTIVE - The alternate flow of this task is currently active
 * 011 - UPDATE_PARAM - The FSU is busy updating parameters from the SRM
 * 100 - PAUSE - The task is paused
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DISP_TASKS_STAT_DC_ASYNCH2_STAT      8
#define BM_IPU_DISP_TASKS_STAT_DC_ASYNCH2_STAT      0x00000700


/* --- Register HW_IPU_DISP_TASKS_STAT, field DC_ASYNC2_CUR_FLOW (RO)
 *
 * Current asynchronous #2 flow via the DC
 *
 * Values:
 * 1 - alternate flow
 * 0 - main flow
 */

#define BP_IPU_DISP_TASKS_STAT_DC_ASYNC2_CUR_FLOW      11
#define BM_IPU_DISP_TASKS_STAT_DC_ASYNC2_CUR_FLOW      0x00000800


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_TRIPLE_CUR_BUF_0 - Triple Current Buffer Register 0 (RO)
 *
 * This register contains the current buffer status information for triple buffer mode for each DMA
 * channel.  Editor's Note: The conditional tag settings should be   Hide VPU_SUB_FRAME_SYNC for all
 * versions  Show VPU_SUB_FRAME_SYNC for IPUv3H version.  The table below tagged with other settings
 * (like IPU3M_only) should be hidden in IPUv3H version.  This requires some sophisticated
 * conditional tag settings
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 16; //!< Reserved.
        unsigned DMA_CH_TRIPLE_CUR_BUF_8 : 2; //!< Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
        unsigned DMA_CH_TRIPLE_CUR_BUF_9 : 2; //!< Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
        unsigned DMA_CH_TRIPLE_CUR_BUF_10 : 2; //!< Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned DMA_CH_TRIPLE_CUR_BUF_13 : 2; //!< Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
        unsigned RESERVED2 : 4; //!< Reserved.
    } B;
} hw_ipu_triple_cur_buf_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_TRIPLE_CUR_BUF_0 register
 */
#define HW_IPU_TRIPLE_CUR_BUF_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x258)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_TRIPLE_CUR_BUF_0(x)           (*(volatile hw_ipu_triple_cur_buf_0_t *) HW_IPU_TRIPLE_CUR_BUF_0_ADDR(x))
#define HW_IPU_TRIPLE_CUR_BUF_0_RD(x)        (HW_IPU_TRIPLE_CUR_BUF_0(x).U)
#endif

/*
 * constants & macros for individual IPU_TRIPLE_CUR_BUF_0 bitfields
 */

/* --- Register HW_IPU_TRIPLE_CUR_BUF_0, field DMA_CH_TRIPLE_CUR_BUF_8 (RO)
 *
 * Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when
 * triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits
 * [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
 *
 * Values:
 * 11 - NA
 * 00 - Current buffer used by DMA is buffer 0.
 * 01 - Current buffer used by DMA is buffer 1.
 * 10 - Current buffer used by DMA is buffer 2.
 */

#define BP_IPU_TRIPLE_CUR_BUF_0_DMA_CH_TRIPLE_CUR_BUF_8      16
#define BM_IPU_TRIPLE_CUR_BUF_0_DMA_CH_TRIPLE_CUR_BUF_8      0x00030000


/* --- Register HW_IPU_TRIPLE_CUR_BUF_0, field DMA_CH_TRIPLE_CUR_BUF_9 (RO)
 *
 * Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when
 * triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits
 * [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
 *
 * Values:
 * 11 - NA
 * 00 - Current buffer used by DMA is buffer 0.
 * 01 - Current buffer used by DMA is buffer 1.
 * 10 - Current buffer used by DMA is buffer 2.
 */

#define BP_IPU_TRIPLE_CUR_BUF_0_DMA_CH_TRIPLE_CUR_BUF_9      18
#define BM_IPU_TRIPLE_CUR_BUF_0_DMA_CH_TRIPLE_CUR_BUF_9      0x000c0000


/* --- Register HW_IPU_TRIPLE_CUR_BUF_0, field DMA_CH_TRIPLE_CUR_BUF_10 (RO)
 *
 * Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when
 * triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits
 * [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
 *
 * Values:
 * 11 - NA
 * 00 - Current buffer used by DMA is buffer 0.
 * 01 - Current buffer used by DMA is buffer 1.
 * 10 - Current buffer used by DMA is buffer 2.
 */

#define BP_IPU_TRIPLE_CUR_BUF_0_DMA_CH_TRIPLE_CUR_BUF_10      20
#define BM_IPU_TRIPLE_CUR_BUF_0_DMA_CH_TRIPLE_CUR_BUF_10      0x00300000


/* --- Register HW_IPU_TRIPLE_CUR_BUF_0, field DMA_CH_TRIPLE_CUR_BUF_13 (RO)
 *
 * Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when
 * triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits
 * [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
 *
 * Values:
 * 11 - NA
 * 00 - Current buffer used by DMA is buffer 0.
 * 01 - Current buffer used by DMA is buffer 1.
 * 10 - Current buffer used by DMA is buffer 2.
 */

#define BP_IPU_TRIPLE_CUR_BUF_0_DMA_CH_TRIPLE_CUR_BUF_13      26
#define BM_IPU_TRIPLE_CUR_BUF_0_DMA_CH_TRIPLE_CUR_BUF_13      0x0c000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_TRIPLE_CUR_BUF_1 - Triple Current Buffer Register 1 (RO)
 *
 * This register contains the current buffer status information for triple buffer mode for each DMA
 * channel.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 10; //!< Reserved.
        unsigned DMA_CH_TRIPLE_CUR_BUF_21 : 2; //!< Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned DMA_CH_TRIPLE_CUR_BUF_23 : 2; //!< Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
        unsigned RESERVED2 : 6; //!< Reserved.
        unsigned DMA_CH_TRIPLE_CUR_BUF_27 : 2; //!< Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
        unsigned DMA_CH_TRIPLE_CUR_BUF_28 : 2; //!< Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
        unsigned RESERVED3 : 6; //!< Reserved.
    } B;
} hw_ipu_triple_cur_buf_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_TRIPLE_CUR_BUF_1 register
 */
#define HW_IPU_TRIPLE_CUR_BUF_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x25c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_TRIPLE_CUR_BUF_1(x)           (*(volatile hw_ipu_triple_cur_buf_1_t *) HW_IPU_TRIPLE_CUR_BUF_1_ADDR(x))
#define HW_IPU_TRIPLE_CUR_BUF_1_RD(x)        (HW_IPU_TRIPLE_CUR_BUF_1(x).U)
#endif

/*
 * constants & macros for individual IPU_TRIPLE_CUR_BUF_1 bitfields
 */

/* --- Register HW_IPU_TRIPLE_CUR_BUF_1, field DMA_CH_TRIPLE_CUR_BUF_21 (RO)
 *
 * Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when
 * triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits
 * [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
 *
 * Values:
 * 11 - NA
 * 00 - Current buffer used by DMA is buffer 0.
 * 01 - Current buffer used by DMA is buffer 1.
 * 10 - Current buffer used by DMA is buffer 2.
 */

#define BP_IPU_TRIPLE_CUR_BUF_1_DMA_CH_TRIPLE_CUR_BUF_21      10
#define BM_IPU_TRIPLE_CUR_BUF_1_DMA_CH_TRIPLE_CUR_BUF_21      0x00000c00


/* --- Register HW_IPU_TRIPLE_CUR_BUF_1, field DMA_CH_TRIPLE_CUR_BUF_23 (RO)
 *
 * Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when
 * triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits
 * [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
 *
 * Values:
 * 11 - NA
 * 00 - Current buffer used by DMA is buffer 0.
 * 01 - Current buffer used by DMA is buffer 1.
 * 10 - Current buffer used by DMA is buffer 2.
 */

#define BP_IPU_TRIPLE_CUR_BUF_1_DMA_CH_TRIPLE_CUR_BUF_23      14
#define BM_IPU_TRIPLE_CUR_BUF_1_DMA_CH_TRIPLE_CUR_BUF_23      0x0000c000


/* --- Register HW_IPU_TRIPLE_CUR_BUF_1, field DMA_CH_TRIPLE_CUR_BUF_27 (RO)
 *
 * Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when
 * triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits
 * [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
 *
 * Values:
 * 11 - NA
 * 00 - Current buffer used by DMA is buffer 0.
 * 01 - Current buffer used by DMA is buffer 1.
 * 10 - Current buffer used by DMA is buffer 2.
 */

#define BP_IPU_TRIPLE_CUR_BUF_1_DMA_CH_TRIPLE_CUR_BUF_27      22
#define BM_IPU_TRIPLE_CUR_BUF_1_DMA_CH_TRIPLE_CUR_BUF_27      0x00c00000


/* --- Register HW_IPU_TRIPLE_CUR_BUF_1, field DMA_CH_TRIPLE_CUR_BUF_28 (RO)
 *
 * Current Buffer for triple buffer mode. This bits indicate which buffer is in use by the DMA when
 * triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits
 * [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
 *
 * Values:
 * 11 - NA
 * 00 - Current buffer used by DMA is buffer 0.
 * 01 - Current buffer used by DMA is buffer 1.
 * 10 - Current buffer used by DMA is buffer 2.
 */

#define BP_IPU_TRIPLE_CUR_BUF_1_DMA_CH_TRIPLE_CUR_BUF_28      24
#define BM_IPU_TRIPLE_CUR_BUF_1_DMA_CH_TRIPLE_CUR_BUF_28      0x03000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_TRIPLE_CUR_BUF_2 - Triple Current Buffer Register 2 (RO)
 *
 * This register contains the current buffer status information for triple buffer mode for each DMA
 * channel.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMA_CH_TRIPLE_CUR_BUF_N : 32; //!< Current Buffer for triple buffer mode. This bits indicate which buffer is in use by DMA when triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
    } B;
} hw_ipu_triple_cur_buf_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_TRIPLE_CUR_BUF_2 register
 */
#define HW_IPU_TRIPLE_CUR_BUF_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x260)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_TRIPLE_CUR_BUF_2(x)           (*(volatile hw_ipu_triple_cur_buf_2_t *) HW_IPU_TRIPLE_CUR_BUF_2_ADDR(x))
#define HW_IPU_TRIPLE_CUR_BUF_2_RD(x)        (HW_IPU_TRIPLE_CUR_BUF_2(x).U)
#endif

/*
 * constants & macros for individual IPU_TRIPLE_CUR_BUF_2 bitfields
 */

/* --- Register HW_IPU_TRIPLE_CUR_BUF_2, field DMA_CH_TRIPLE_CUR_BUF_N (ROZ)
 *
 * Current Buffer for triple buffer mode. This bits indicate which buffer is in use by DMA when
 * triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits
 * [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
 *
 * Values:
 * 00 - Current buffer used by DMA is buffer 0.
 * 01 - Current buffer used by DMA is buffer 1.
 * 10 - Current buffer used by DMA is buffer 2.
 */

#define BP_IPU_TRIPLE_CUR_BUF_2_DMA_CH_TRIPLE_CUR_BUF_N      0
#define BM_IPU_TRIPLE_CUR_BUF_2_DMA_CH_TRIPLE_CUR_BUF_N      0xffffffff


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_TRIPLE_CUR_BUF_3 - Triple Current Buffer Register 3 (RO)
 *
 * This register contains the current buffer status information for triple buffer mode for each DMA
 * channel.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMA_CH_TRIPLE_CUR_BUF_N : 32; //!< Current Buffer for triple buffer mode. This bits indicate which buffer is in use by DMA when triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
    } B;
} hw_ipu_triple_cur_buf_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_TRIPLE_CUR_BUF_3 register
 */
#define HW_IPU_TRIPLE_CUR_BUF_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x264)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_TRIPLE_CUR_BUF_3(x)           (*(volatile hw_ipu_triple_cur_buf_3_t *) HW_IPU_TRIPLE_CUR_BUF_3_ADDR(x))
#define HW_IPU_TRIPLE_CUR_BUF_3_RD(x)        (HW_IPU_TRIPLE_CUR_BUF_3(x).U)
#endif

/*
 * constants & macros for individual IPU_TRIPLE_CUR_BUF_3 bitfields
 */

/* --- Register HW_IPU_TRIPLE_CUR_BUF_3, field DMA_CH_TRIPLE_CUR_BUF_N (ROZ)
 *
 * Current Buffer for triple buffer mode. This bits indicate which buffer is in use by DMA when
 * triple buffer mode is selected. Each pair of bits indicate the corresponding DMA channel (bits
 * [1:0] correspond to ch #0; (bits [3:2] correspond to ch #1, etc.)
 *
 * Values:
 * 00 - Current buffer used by DMA is buffer 0.
 * 01 - Current buffer used by DMA is buffer 1.
 * 10 - Current buffer used by DMA is buffer 2.
 */

#define BP_IPU_TRIPLE_CUR_BUF_3_DMA_CH_TRIPLE_CUR_BUF_N      0
#define BM_IPU_TRIPLE_CUR_BUF_3_DMA_CH_TRIPLE_CUR_BUF_N      0xffffffff


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CH_BUF0_RDY0 - IPU Channels Buffer 0 Ready 0 Register (RW)
 *
 * The register contains buffer 0 ready control information for 32 IPU's DMA channels (31-0). This
 * register can be a write one to set or a write one to clear according to the IPU_CH_BUF0_RDY0_CLR
 * bit .  The register is shown in , and the register fields are described in .
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMA_CH_BUF0_RDY_0 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_1 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_2 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_3 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_4 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_5 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_6 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_7 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_8 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_9 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_10 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_11 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_12 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_13 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_14 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_15 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DMA_CH_BUF0_RDY_17 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_18 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED1 : 1; //!< Reserved.
        unsigned DMA_CH_BUF0_RDY_20 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_21 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_22 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_23 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_24 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED2 : 2; //!< Reserved.
        unsigned DMA_CH_BUF0_RDY_27 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_28 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_29 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned DMA_CH_BUF0_RDY_31 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
    } B;
} hw_ipu_ch_buf0_rdy0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CH_BUF0_RDY0 register
 */
#define HW_IPU_CH_BUF0_RDY0_ADDR(x)      (REGS_IPU_BASE(x) + 0x268)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CH_BUF0_RDY0(x)           (*(volatile hw_ipu_ch_buf0_rdy0_t *) HW_IPU_CH_BUF0_RDY0_ADDR(x))
#define HW_IPU_CH_BUF0_RDY0_RD(x)        (HW_IPU_CH_BUF0_RDY0(x).U)
#define HW_IPU_CH_BUF0_RDY0_WR(x, v)     (HW_IPU_CH_BUF0_RDY0(x).U = (v))
#define HW_IPU_CH_BUF0_RDY0_SET(x, v)    (HW_IPU_CH_BUF0_RDY0_WR(x, HW_IPU_CH_BUF0_RDY0_RD(x) |  (v)))
#define HW_IPU_CH_BUF0_RDY0_CLR(x, v)    (HW_IPU_CH_BUF0_RDY0_WR(x, HW_IPU_CH_BUF0_RDY0_RD(x) & ~(v)))
#define HW_IPU_CH_BUF0_RDY0_TOG(x, v)    (HW_IPU_CH_BUF0_RDY0_WR(x, HW_IPU_CH_BUF0_RDY0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CH_BUF0_RDY0 bitfields
 */

/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_0 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_0      0
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_0(v)   ((((reg32_t) v) << 0) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_0)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_0(v)   (((v) << 0) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_0 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_0(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_0, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_1 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_1      1
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_1(v)   ((((reg32_t) v) << 1) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_1)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_1(v)   (((v) << 1) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_1 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_1(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_1, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_2 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_2      2
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_2(v)   ((((reg32_t) v) << 2) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_2)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_2(v)   (((v) << 2) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_2 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_2(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_2, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_3 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_3      3
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_3(v)   ((((reg32_t) v) << 3) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_3)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_3(v)   (((v) << 3) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_3 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_3(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_3, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_4 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_4      4
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_4      0x00000010

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_4(v)   ((((reg32_t) v) << 4) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_4)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_4(v)   (((v) << 4) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_4 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_4(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_4, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_5 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_5      5
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_5(v)   ((((reg32_t) v) << 5) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_5)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_5(v)   (((v) << 5) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_5 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_5(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_5, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_6 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_6      6
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_6      0x00000040

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_6(v)   ((((reg32_t) v) << 6) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_6)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_6(v)   (((v) << 6) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_6 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_6(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_6, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_7 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_7      7
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_7      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_7(v)   ((((reg32_t) v) << 7) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_7)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_7(v)   (((v) << 7) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_7 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_7(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_7, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_8 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_8      8
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_8(v)   ((((reg32_t) v) << 8) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_8)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_8(v)   (((v) << 8) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_8 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_8(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_8, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_9 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_9      9
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_9(v)   ((((reg32_t) v) << 9) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_9)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_9(v)   (((v) << 9) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_9 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_9(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_9, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_10 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_10      10
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_10(v)   ((((reg32_t) v) << 10) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_10)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_10(v)   (((v) << 10) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_10 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_10(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_10, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_11 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_11      11
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_11(v)   ((((reg32_t) v) << 11) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_11)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_11(v)   (((v) << 11) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_11 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_11(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_11, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_12 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_12      12
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_12(v)   ((((reg32_t) v) << 12) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_12)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_12(v)   (((v) << 12) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_12 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_12(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_12, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_13 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_13      13
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_13(v)   ((((reg32_t) v) << 13) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_13)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_13(v)   (((v) << 13) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_13 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_13(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_13, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_14 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_14      14
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_14(v)   ((((reg32_t) v) << 14) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_14)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_14(v)   (((v) << 14) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_14 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_14(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_14, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_15 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_15      15
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_15(v)   ((((reg32_t) v) << 15) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_15)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_15(v)   (((v) << 15) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_15 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_15(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_15, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_17 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_17      17
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_17      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_17(v)   ((((reg32_t) v) << 17) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_17)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_17(v)   (((v) << 17) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_17 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_17(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_17, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_18 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_18      18
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_18      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_18(v)   ((((reg32_t) v) << 18) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_18)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_18(v)   (((v) << 18) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_18 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_18(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_18, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_20 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_20      20
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_20(v)   ((((reg32_t) v) << 20) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_20)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_20(v)   (((v) << 20) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_20 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_20(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_20, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_21 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_21      21
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_21(v)   ((((reg32_t) v) << 21) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_21)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_21(v)   (((v) << 21) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_21 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_21(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_21, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_22 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_22      22
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_22(v)   ((((reg32_t) v) << 22) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_22)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_22(v)   (((v) << 22) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_22 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_22(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_22, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_23 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_23      23
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_23(v)   ((((reg32_t) v) << 23) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_23)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_23(v)   (((v) << 23) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_23 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_23(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_23, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_24 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_24      24
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_24(v)   ((((reg32_t) v) << 24) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_24)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_24(v)   (((v) << 24) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_24 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_24(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_24, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_27 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_27      27
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_27(v)   ((((reg32_t) v) << 27) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_27)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_27(v)   (((v) << 27) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_27 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_27(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_27, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_28 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_28      28
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_28(v)   ((((reg32_t) v) << 28) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_28)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_28(v)   (((v) << 28) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_28 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_28(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_28, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_29 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_29      29
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_29(v)   ((((reg32_t) v) << 29) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_29)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_29(v)   (((v) << 29) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_29 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_29(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_29, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY0, field DMA_CH_BUF0_RDY_31 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_31      31
#define BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_31(v)   ((((reg32_t) v) << 31) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_31)
#else
#define BF_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_31(v)   (((v) << 31) & BM_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_31 field to a new value.
#define BW_IPU_CH_BUF0_RDY0_DMA_CH_BUF0_RDY_31(v)   BF_CS1(IPU_CH_BUF0_RDY0, DMA_CH_BUF0_RDY_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CH_BUF0_RDY1 - IPU Channels Buffer 0 Ready 1 Register (RW)
 *
 * The register contains buffer 0 ready control information for 32 IPU's DMA channels (63-32). This
 * register can be a write one to set or a write one to clear according to the IPU_CH_BUF0_RDY1_CLR
 * bit .
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DMA_CH_BUF0_RDY_33 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned DMA_CH_BUF0_RDY_40 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_41 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_42 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_43 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_44 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_45 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_46 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_47 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_48 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_49 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_50 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_51 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF0_RDY_52 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_ch_buf0_rdy1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CH_BUF0_RDY1 register
 */
#define HW_IPU_CH_BUF0_RDY1_ADDR(x)      (REGS_IPU_BASE(x) + 0x26c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CH_BUF0_RDY1(x)           (*(volatile hw_ipu_ch_buf0_rdy1_t *) HW_IPU_CH_BUF0_RDY1_ADDR(x))
#define HW_IPU_CH_BUF0_RDY1_RD(x)        (HW_IPU_CH_BUF0_RDY1(x).U)
#define HW_IPU_CH_BUF0_RDY1_WR(x, v)     (HW_IPU_CH_BUF0_RDY1(x).U = (v))
#define HW_IPU_CH_BUF0_RDY1_SET(x, v)    (HW_IPU_CH_BUF0_RDY1_WR(x, HW_IPU_CH_BUF0_RDY1_RD(x) |  (v)))
#define HW_IPU_CH_BUF0_RDY1_CLR(x, v)    (HW_IPU_CH_BUF0_RDY1_WR(x, HW_IPU_CH_BUF0_RDY1_RD(x) & ~(v)))
#define HW_IPU_CH_BUF0_RDY1_TOG(x, v)    (HW_IPU_CH_BUF0_RDY1_WR(x, HW_IPU_CH_BUF0_RDY1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CH_BUF0_RDY1 bitfields
 */

/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_33 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_33      1
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_33(v)   ((((reg32_t) v) << 1) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_33)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_33(v)   (((v) << 1) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_33 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_33(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_33, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_40 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_40      8
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_40      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_40(v)   ((((reg32_t) v) << 8) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_40)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_40(v)   (((v) << 8) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_40)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_40 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_40(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_40, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_41 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_41      9
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_41(v)   ((((reg32_t) v) << 9) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_41)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_41(v)   (((v) << 9) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_41 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_41(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_41, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_42 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_42      10
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_42(v)   ((((reg32_t) v) << 10) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_42)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_42(v)   (((v) << 10) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_42 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_42(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_42, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_43 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_43      11
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_43(v)   ((((reg32_t) v) << 11) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_43)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_43(v)   (((v) << 11) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_43 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_43(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_43, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_44 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_44      12
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_44(v)   ((((reg32_t) v) << 12) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_44)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_44(v)   (((v) << 12) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_44 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_44(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_44, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_45 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_45      13
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_45(v)   ((((reg32_t) v) << 13) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_45)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_45(v)   (((v) << 13) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_45 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_45(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_45, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_46 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_46      14
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_46(v)   ((((reg32_t) v) << 14) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_46)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_46(v)   (((v) << 14) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_46 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_46(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_46, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_47 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_47      15
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_47(v)   ((((reg32_t) v) << 15) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_47)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_47(v)   (((v) << 15) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_47 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_47(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_47, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_48 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_48      16
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_48(v)   ((((reg32_t) v) << 16) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_48)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_48(v)   (((v) << 16) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_48 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_48(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_48, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_49 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_49      17
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_49(v)   ((((reg32_t) v) << 17) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_49)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_49(v)   (((v) << 17) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_49 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_49(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_49, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_50 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_50      18
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_50(v)   ((((reg32_t) v) << 18) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_50)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_50(v)   (((v) << 18) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_50 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_50(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_50, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_51 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_51      19
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_51(v)   ((((reg32_t) v) << 19) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_51)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_51(v)   (((v) << 19) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_51 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_51(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_51, v)
#endif


/* --- Register HW_IPU_CH_BUF0_RDY1, field DMA_CH_BUF0_RDY_52 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_52      20
#define BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_52(v)   ((((reg32_t) v) << 20) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_52)
#else
#define BF_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_52(v)   (((v) << 20) & BM_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_52 field to a new value.
#define BW_IPU_CH_BUF0_RDY1_DMA_CH_BUF0_RDY_52(v)   BF_CS1(IPU_CH_BUF0_RDY1, DMA_CH_BUF0_RDY_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CH_BUF1_RDY0 - IPU Channels Buffer 1 Ready 0 Register (RW)
 *
 * The register contains buffer 1 ready control information for 32 IPU's DMA channels (31-0). This
 * register can be a write one to set or a write one to clear according to the IPU_CH_BUF1_RDY0_CLR
 * bit .
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMA_CH_BUF1_RDY_0 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_1 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_2 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_3 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DMA_CH_BUF1_RDY_5 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned DMA_CH_BUF1_RDY_8 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_9 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_10 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_ : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_12 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_13 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_14 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_15 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned DMA_CH_BUF1_RDY_17 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_18 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_19 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_20 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_21 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_22 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_23 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_24 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_25 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_26 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_27 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_28 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned DMA_CH_BUF1_RDY_29 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned DMA_CH_BUF1_RDY_31 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
    } B;
} hw_ipu_ch_buf1_rdy0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CH_BUF1_RDY0 register
 */
#define HW_IPU_CH_BUF1_RDY0_ADDR(x)      (REGS_IPU_BASE(x) + 0x270)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CH_BUF1_RDY0(x)           (*(volatile hw_ipu_ch_buf1_rdy0_t *) HW_IPU_CH_BUF1_RDY0_ADDR(x))
#define HW_IPU_CH_BUF1_RDY0_RD(x)        (HW_IPU_CH_BUF1_RDY0(x).U)
#define HW_IPU_CH_BUF1_RDY0_WR(x, v)     (HW_IPU_CH_BUF1_RDY0(x).U = (v))
#define HW_IPU_CH_BUF1_RDY0_SET(x, v)    (HW_IPU_CH_BUF1_RDY0_WR(x, HW_IPU_CH_BUF1_RDY0_RD(x) |  (v)))
#define HW_IPU_CH_BUF1_RDY0_CLR(x, v)    (HW_IPU_CH_BUF1_RDY0_WR(x, HW_IPU_CH_BUF1_RDY0_RD(x) & ~(v)))
#define HW_IPU_CH_BUF1_RDY0_TOG(x, v)    (HW_IPU_CH_BUF1_RDY0_WR(x, HW_IPU_CH_BUF1_RDY0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CH_BUF1_RDY0 bitfields
 */

/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_0 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_0      0
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_0(v)   ((((reg32_t) v) << 0) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_0)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_0(v)   (((v) << 0) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_0 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_0(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_0, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_1 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_1      1
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_1(v)   ((((reg32_t) v) << 1) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_1)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_1(v)   (((v) << 1) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_1 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_1(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_1, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_2 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_2      2
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_2(v)   ((((reg32_t) v) << 2) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_2)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_2(v)   (((v) << 2) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_2 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_2(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_2, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_3 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_3      3
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_3(v)   ((((reg32_t) v) << 3) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_3)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_3(v)   (((v) << 3) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_3 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_3(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_3, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_5 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_5      5
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_5(v)   ((((reg32_t) v) << 5) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_5)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_5(v)   (((v) << 5) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_5 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_5(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_5, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_8 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_8      8
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_8(v)   ((((reg32_t) v) << 8) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_8)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_8(v)   (((v) << 8) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_8 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_8(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_8, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_9 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_9      9
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_9(v)   ((((reg32_t) v) << 9) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_9)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_9(v)   (((v) << 9) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_9 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_9(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_9, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_10 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_10      10
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_10(v)   ((((reg32_t) v) << 10) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_10)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_10(v)   (((v) << 10) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_10 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_10(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_10, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_ (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_      11
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_(v)   ((((reg32_t) v) << 11) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_(v)   (((v) << 11) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_ field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_12 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_12      12
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_12(v)   ((((reg32_t) v) << 12) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_12)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_12(v)   (((v) << 12) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_12 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_12(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_12, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_13 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_13      13
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_13(v)   ((((reg32_t) v) << 13) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_13)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_13(v)   (((v) << 13) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_13 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_13(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_13, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_14 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_14      14
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_14(v)   ((((reg32_t) v) << 14) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_14)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_14(v)   (((v) << 14) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_14 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_14(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_14, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_15 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_15      15
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_15(v)   ((((reg32_t) v) << 15) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_15)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_15(v)   (((v) << 15) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_15 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_15(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_15, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_17 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_17      17
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_17      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_17(v)   ((((reg32_t) v) << 17) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_17)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_17(v)   (((v) << 17) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_17 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_17(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_17, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_18 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_18      18
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_18      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_18(v)   ((((reg32_t) v) << 18) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_18)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_18(v)   (((v) << 18) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_18 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_18(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_18, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_19 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_19      19
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_19      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_19(v)   ((((reg32_t) v) << 19) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_19)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_19(v)   (((v) << 19) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_19 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_19(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_19, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_20 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_20      20
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_20(v)   ((((reg32_t) v) << 20) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_20)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_20(v)   (((v) << 20) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_20 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_20(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_20, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_21 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_21      21
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_21(v)   ((((reg32_t) v) << 21) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_21)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_21(v)   (((v) << 21) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_21 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_21(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_21, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_22 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_22      22
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_22(v)   ((((reg32_t) v) << 22) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_22)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_22(v)   (((v) << 22) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_22 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_22(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_22, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_23 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_23      23
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_23(v)   ((((reg32_t) v) << 23) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_23)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_23(v)   (((v) << 23) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_23 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_23(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_23, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_24 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_24      24
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_24(v)   ((((reg32_t) v) << 24) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_24)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_24(v)   (((v) << 24) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_24 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_24(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_24, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_25 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_25      25
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_25(v)   ((((reg32_t) v) << 25) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_25)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_25(v)   (((v) << 25) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_25 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_25(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_25, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_26 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_26      26
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_26(v)   ((((reg32_t) v) << 26) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_26)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_26(v)   (((v) << 26) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_26 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_26(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_26, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_27 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_27      27
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_27(v)   ((((reg32_t) v) << 27) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_27)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_27(v)   (((v) << 27) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_27 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_27(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_27, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_28 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_28      28
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_28(v)   ((((reg32_t) v) << 28) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_28)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_28(v)   (((v) << 28) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_28 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_28(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_28, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_29 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_29      29
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_29(v)   ((((reg32_t) v) << 29) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_29)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_29(v)   (((v) << 29) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_29 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_29(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_29, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY0, field DMA_CH_BUF1_RDY_31 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_31      31
#define BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_31(v)   ((((reg32_t) v) << 31) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_31)
#else
#define BF_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_31(v)   (((v) << 31) & BM_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF1_RDY_31 field to a new value.
#define BW_IPU_CH_BUF1_RDY0_DMA_CH_BUF1_RDY_31(v)   BF_CS1(IPU_CH_BUF1_RDY0, DMA_CH_BUF1_RDY_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CH_BUF1_RDY1 - IPU Channels Buffer 1 Ready 1Register (RW)
 *
 * The register contains buffer 0 ready control information for 32 IPU's DMA channels (63-32). This
 * register can be a write one to set or a write one to clear according to the IPU_CH_BUF1_RDY1_CLR
 * bit .  The register is shown in , and the register fields are described in .
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DMA_CH_BUF0_RDY_33 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned DMA_CH_BUF0_RDY_40 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned DMA_CH_BUF0_RDY_41 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned DMA_CH_BUF0_RDY_42 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned DMA_CH_BUF0_RDY_43 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned DMA_CH_BUF0_RDY_44 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned DMA_CH_BUF0_RDY_45 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned DMA_CH_BUF0_RDY_46 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned DMA_CH_BUF0_RDY_47 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned DMA_CH_BUF0_RDY_48 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned DMA_CH_BUF0_RDY_49 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned DMA_CH_BUF0_RDY_50 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned DMA_CH_BUF0_RDY_51 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned DMA_CH_BUF0_RDY_52 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_ch_buf1_rdy1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CH_BUF1_RDY1 register
 */
#define HW_IPU_CH_BUF1_RDY1_ADDR(x)      (REGS_IPU_BASE(x) + 0x274)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CH_BUF1_RDY1(x)           (*(volatile hw_ipu_ch_buf1_rdy1_t *) HW_IPU_CH_BUF1_RDY1_ADDR(x))
#define HW_IPU_CH_BUF1_RDY1_RD(x)        (HW_IPU_CH_BUF1_RDY1(x).U)
#define HW_IPU_CH_BUF1_RDY1_WR(x, v)     (HW_IPU_CH_BUF1_RDY1(x).U = (v))
#define HW_IPU_CH_BUF1_RDY1_SET(x, v)    (HW_IPU_CH_BUF1_RDY1_WR(x, HW_IPU_CH_BUF1_RDY1_RD(x) |  (v)))
#define HW_IPU_CH_BUF1_RDY1_CLR(x, v)    (HW_IPU_CH_BUF1_RDY1_WR(x, HW_IPU_CH_BUF1_RDY1_RD(x) & ~(v)))
#define HW_IPU_CH_BUF1_RDY1_TOG(x, v)    (HW_IPU_CH_BUF1_RDY1_WR(x, HW_IPU_CH_BUF1_RDY1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CH_BUF1_RDY1 bitfields
 */

/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_33 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_33      1
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_33(v)   ((((reg32_t) v) << 1) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_33)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_33(v)   (((v) << 1) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_33 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_33(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_33, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_40 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_40      8
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_40      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_40(v)   ((((reg32_t) v) << 8) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_40)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_40(v)   (((v) << 8) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_40)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_40 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_40(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_40, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_41 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_41      9
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_41(v)   ((((reg32_t) v) << 9) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_41)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_41(v)   (((v) << 9) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_41 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_41(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_41, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_42 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_42      10
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_42(v)   ((((reg32_t) v) << 10) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_42)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_42(v)   (((v) << 10) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_42 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_42(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_42, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_43 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_43      11
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_43(v)   ((((reg32_t) v) << 11) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_43)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_43(v)   (((v) << 11) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_43 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_43(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_43, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_44 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_44      12
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_44(v)   ((((reg32_t) v) << 12) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_44)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_44(v)   (((v) << 12) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_44 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_44(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_44, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_45 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_45      13
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_45(v)   ((((reg32_t) v) << 13) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_45)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_45(v)   (((v) << 13) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_45 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_45(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_45, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_46 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_46      14
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_46(v)   ((((reg32_t) v) << 14) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_46)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_46(v)   (((v) << 14) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_46 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_46(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_46, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_47 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_47      15
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_47(v)   ((((reg32_t) v) << 15) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_47)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_47(v)   (((v) << 15) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_47 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_47(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_47, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_48 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_48      16
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_48(v)   ((((reg32_t) v) << 16) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_48)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_48(v)   (((v) << 16) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_48 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_48(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_48, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_49 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_49      17
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_49(v)   ((((reg32_t) v) << 17) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_49)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_49(v)   (((v) << 17) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_49 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_49(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_49, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_50 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_50      18
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_50(v)   ((((reg32_t) v) << 18) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_50)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_50(v)   (((v) << 18) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_50 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_50(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_50, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_51 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_51      19
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_51(v)   ((((reg32_t) v) << 19) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_51)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_51(v)   (((v) << 19) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_51 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_51(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_51, v)
#endif


/* --- Register HW_IPU_CH_BUF1_RDY1, field DMA_CH_BUF0_RDY_52 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - Buffer 1 is ready.
 */

#define BP_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_52      20
#define BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_52(v)   ((((reg32_t) v) << 20) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_52)
#else
#define BF_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_52(v)   (((v) << 20) & BM_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF0_RDY_52 field to a new value.
#define BW_IPU_CH_BUF1_RDY1_DMA_CH_BUF0_RDY_52(v)   BF_CS1(IPU_CH_BUF1_RDY1, DMA_CH_BUF0_RDY_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_ALT_CH_BUF0_RDY0 - IPU Alternate Channels Buffer 0 Ready 0 Register (RW)
 *
 * The register contains buffer 0 ready control information for 32 IPU's DMA channels (31-0).
 * Writing "1" to each field will set each bit. Writing "0" to each field simultaneously will clear
 * all the bits.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 24; //!< Reserved.
        unsigned DMA_CH_ALT_BUF0_RDY_24 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned DMA_CH_ALT_BUF0_RDY_29 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED2 : 2; //!< Reserved.
    } B;
} hw_ipu_alt_ch_buf0_rdy0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_ALT_CH_BUF0_RDY0 register
 */
#define HW_IPU_ALT_CH_BUF0_RDY0_ADDR(x)      (REGS_IPU_BASE(x) + 0x278)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_ALT_CH_BUF0_RDY0(x)           (*(volatile hw_ipu_alt_ch_buf0_rdy0_t *) HW_IPU_ALT_CH_BUF0_RDY0_ADDR(x))
#define HW_IPU_ALT_CH_BUF0_RDY0_RD(x)        (HW_IPU_ALT_CH_BUF0_RDY0(x).U)
#define HW_IPU_ALT_CH_BUF0_RDY0_WR(x, v)     (HW_IPU_ALT_CH_BUF0_RDY0(x).U = (v))
#define HW_IPU_ALT_CH_BUF0_RDY0_SET(x, v)    (HW_IPU_ALT_CH_BUF0_RDY0_WR(x, HW_IPU_ALT_CH_BUF0_RDY0_RD(x) |  (v)))
#define HW_IPU_ALT_CH_BUF0_RDY0_CLR(x, v)    (HW_IPU_ALT_CH_BUF0_RDY0_WR(x, HW_IPU_ALT_CH_BUF0_RDY0_RD(x) & ~(v)))
#define HW_IPU_ALT_CH_BUF0_RDY0_TOG(x, v)    (HW_IPU_ALT_CH_BUF0_RDY0_WR(x, HW_IPU_ALT_CH_BUF0_RDY0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_ALT_CH_BUF0_RDY0 bitfields
 */

/* --- Register HW_IPU_ALT_CH_BUF0_RDY0, field DMA_CH_ALT_BUF0_RDY_24 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_24      24
#define BM_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_24(v)   ((((reg32_t) v) << 24) & BM_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_24)
#else
#define BF_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_24(v)   (((v) << 24) & BM_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_BUF0_RDY_24 field to a new value.
#define BW_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_24(v)   BF_CS1(IPU_ALT_CH_BUF0_RDY0, DMA_CH_ALT_BUF0_RDY_24, v)
#endif


/* --- Register HW_IPU_ALT_CH_BUF0_RDY0, field DMA_CH_ALT_BUF0_RDY_29 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_29      29
#define BM_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_29(v)   ((((reg32_t) v) << 29) & BM_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_29)
#else
#define BF_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_29(v)   (((v) << 29) & BM_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_BUF0_RDY_29 field to a new value.
#define BW_IPU_ALT_CH_BUF0_RDY0_DMA_CH_ALT_BUF0_RDY_29(v)   BF_CS1(IPU_ALT_CH_BUF0_RDY0, DMA_CH_ALT_BUF0_RDY_29, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_ALT_CH_BUF0_RDY1 - IPU Alternate Channels Buffer 0 Ready 1 Register (RW)
 *
 * The register contains buffer 0 ready control information for 32 IPU's DMA channels (63-32).
 * Writing "1" to each field will set each bit. Writing "0" to each field simultaneously will clear
 * all the bits.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DMA_CH_ALT_BUF0_RDY_33 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED1 : 7; //!< Reserved.
        unsigned DMA_CH_ALT_BUF0_RDY_41 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED2 : 10; //!< Reserved.
        unsigned DMA_CH_ALT_BUF0_RDY_52 : 1; //!< Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in memory.
        unsigned RESERVED3 : 11; //!< Reserved.
    } B;
} hw_ipu_alt_ch_buf0_rdy1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_ALT_CH_BUF0_RDY1 register
 */
#define HW_IPU_ALT_CH_BUF0_RDY1_ADDR(x)      (REGS_IPU_BASE(x) + 0x27c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_ALT_CH_BUF0_RDY1(x)           (*(volatile hw_ipu_alt_ch_buf0_rdy1_t *) HW_IPU_ALT_CH_BUF0_RDY1_ADDR(x))
#define HW_IPU_ALT_CH_BUF0_RDY1_RD(x)        (HW_IPU_ALT_CH_BUF0_RDY1(x).U)
#define HW_IPU_ALT_CH_BUF0_RDY1_WR(x, v)     (HW_IPU_ALT_CH_BUF0_RDY1(x).U = (v))
#define HW_IPU_ALT_CH_BUF0_RDY1_SET(x, v)    (HW_IPU_ALT_CH_BUF0_RDY1_WR(x, HW_IPU_ALT_CH_BUF0_RDY1_RD(x) |  (v)))
#define HW_IPU_ALT_CH_BUF0_RDY1_CLR(x, v)    (HW_IPU_ALT_CH_BUF0_RDY1_WR(x, HW_IPU_ALT_CH_BUF0_RDY1_RD(x) & ~(v)))
#define HW_IPU_ALT_CH_BUF0_RDY1_TOG(x, v)    (HW_IPU_ALT_CH_BUF0_RDY1_WR(x, HW_IPU_ALT_CH_BUF0_RDY1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_ALT_CH_BUF0_RDY1 bitfields
 */

/* --- Register HW_IPU_ALT_CH_BUF0_RDY1, field DMA_CH_ALT_BUF0_RDY_33 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_33      1
#define BM_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_33(v)   ((((reg32_t) v) << 1) & BM_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_33)
#else
#define BF_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_33(v)   (((v) << 1) & BM_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_BUF0_RDY_33 field to a new value.
#define BW_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_33(v)   BF_CS1(IPU_ALT_CH_BUF0_RDY1, DMA_CH_ALT_BUF0_RDY_33, v)
#endif


/* --- Register HW_IPU_ALT_CH_BUF0_RDY1, field DMA_CH_ALT_BUF0_RDY_41 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_41      9
#define BM_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_41(v)   ((((reg32_t) v) << 9) & BM_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_41)
#else
#define BF_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_41(v)   (((v) << 9) & BM_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_BUF0_RDY_41 field to a new value.
#define BW_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_41(v)   BF_CS1(IPU_ALT_CH_BUF0_RDY1, DMA_CH_ALT_BUF0_RDY_41, v)
#endif


/* --- Register HW_IPU_ALT_CH_BUF0_RDY1, field DMA_CH_ALT_BUF0_RDY_52 (RW)
 *
 * Buffer 0 is ready. This bit indicates that ARM platform finished/writing reading buffer 0 in
 * memory.
 *
 * Values:
 * 0 - Buffer 0 is not ready.
 * 1 - Buffer 0 is ready.
 */

#define BP_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_52      20
#define BM_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_52(v)   ((((reg32_t) v) << 20) & BM_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_52)
#else
#define BF_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_52(v)   (((v) << 20) & BM_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_BUF0_RDY_52 field to a new value.
#define BW_IPU_ALT_CH_BUF0_RDY1_DMA_CH_ALT_BUF0_RDY_52(v)   BF_CS1(IPU_ALT_CH_BUF0_RDY1, DMA_CH_ALT_BUF0_RDY_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_ALT_CH_BUF1_RDY0 - IPU Alternate Channels Buffer1 Ready 0 Register (RW)
 *
 * The register contains buffer 1 ready control information for 32 IPU's DMA channels (31-0).
 * Writing "1" to each field will set each bit. Writing "0" to each field simultaneously will clear
 * all the bits.  The register is shown in , and the register fields are described in .
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 24; //!< Reserved.
        unsigned DMA_CH_ALT_BUF1_RDY_24 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned DMA_CH_ALT_BUF1_RDY_29 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned RESERVED2 : 2; //!< Reserved.
    } B;
} hw_ipu_alt_ch_buf1_rdy0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_ALT_CH_BUF1_RDY0 register
 */
#define HW_IPU_ALT_CH_BUF1_RDY0_ADDR(x)      (REGS_IPU_BASE(x) + 0x280)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_ALT_CH_BUF1_RDY0(x)           (*(volatile hw_ipu_alt_ch_buf1_rdy0_t *) HW_IPU_ALT_CH_BUF1_RDY0_ADDR(x))
#define HW_IPU_ALT_CH_BUF1_RDY0_RD(x)        (HW_IPU_ALT_CH_BUF1_RDY0(x).U)
#define HW_IPU_ALT_CH_BUF1_RDY0_WR(x, v)     (HW_IPU_ALT_CH_BUF1_RDY0(x).U = (v))
#define HW_IPU_ALT_CH_BUF1_RDY0_SET(x, v)    (HW_IPU_ALT_CH_BUF1_RDY0_WR(x, HW_IPU_ALT_CH_BUF1_RDY0_RD(x) |  (v)))
#define HW_IPU_ALT_CH_BUF1_RDY0_CLR(x, v)    (HW_IPU_ALT_CH_BUF1_RDY0_WR(x, HW_IPU_ALT_CH_BUF1_RDY0_RD(x) & ~(v)))
#define HW_IPU_ALT_CH_BUF1_RDY0_TOG(x, v)    (HW_IPU_ALT_CH_BUF1_RDY0_WR(x, HW_IPU_ALT_CH_BUF1_RDY0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_ALT_CH_BUF1_RDY0 bitfields
 */

/* --- Register HW_IPU_ALT_CH_BUF1_RDY0, field DMA_CH_ALT_BUF1_RDY_24 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - buffer 1 is ready.
 */

#define BP_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_24      24
#define BM_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_24(v)   ((((reg32_t) v) << 24) & BM_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_24)
#else
#define BF_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_24(v)   (((v) << 24) & BM_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_BUF1_RDY_24 field to a new value.
#define BW_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_24(v)   BF_CS1(IPU_ALT_CH_BUF1_RDY0, DMA_CH_ALT_BUF1_RDY_24, v)
#endif


/* --- Register HW_IPU_ALT_CH_BUF1_RDY0, field DMA_CH_ALT_BUF1_RDY_29 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - buffer 1 is ready.
 */

#define BP_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_29      29
#define BM_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_29(v)   ((((reg32_t) v) << 29) & BM_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_29)
#else
#define BF_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_29(v)   (((v) << 29) & BM_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_BUF1_RDY_29 field to a new value.
#define BW_IPU_ALT_CH_BUF1_RDY0_DMA_CH_ALT_BUF1_RDY_29(v)   BF_CS1(IPU_ALT_CH_BUF1_RDY0, DMA_CH_ALT_BUF1_RDY_29, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_ALT_CH_BUF1_RDY1 - IPU Alternate Channels Buffer 1 Ready 1 Register (RW)
 *
 * The register contains buffer 0 ready control information for 32 IPU's DMA channels (63-32).
 * Writing "1" to each field will set each bit. Writing "0" to each field simultaneously will clear
 * all the bits.  The register is shown in , and the register fields are described in .
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DMA_CH_ALT_BUF1_RDY_33 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned RESERVED1 : 7; //!< Reserved.
        unsigned DMA_CH_ALT_BUF1_RDY_41 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned RESERVED2 : 10; //!< Reserved.
        unsigned DMA_CH_ALT_BUF1_RDY_52 : 1; //!< Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in memory.
        unsigned RESERVED3 : 11; //!< Reserved.
    } B;
} hw_ipu_alt_ch_buf1_rdy1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_ALT_CH_BUF1_RDY1 register
 */
#define HW_IPU_ALT_CH_BUF1_RDY1_ADDR(x)      (REGS_IPU_BASE(x) + 0x284)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_ALT_CH_BUF1_RDY1(x)           (*(volatile hw_ipu_alt_ch_buf1_rdy1_t *) HW_IPU_ALT_CH_BUF1_RDY1_ADDR(x))
#define HW_IPU_ALT_CH_BUF1_RDY1_RD(x)        (HW_IPU_ALT_CH_BUF1_RDY1(x).U)
#define HW_IPU_ALT_CH_BUF1_RDY1_WR(x, v)     (HW_IPU_ALT_CH_BUF1_RDY1(x).U = (v))
#define HW_IPU_ALT_CH_BUF1_RDY1_SET(x, v)    (HW_IPU_ALT_CH_BUF1_RDY1_WR(x, HW_IPU_ALT_CH_BUF1_RDY1_RD(x) |  (v)))
#define HW_IPU_ALT_CH_BUF1_RDY1_CLR(x, v)    (HW_IPU_ALT_CH_BUF1_RDY1_WR(x, HW_IPU_ALT_CH_BUF1_RDY1_RD(x) & ~(v)))
#define HW_IPU_ALT_CH_BUF1_RDY1_TOG(x, v)    (HW_IPU_ALT_CH_BUF1_RDY1_WR(x, HW_IPU_ALT_CH_BUF1_RDY1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_ALT_CH_BUF1_RDY1 bitfields
 */

/* --- Register HW_IPU_ALT_CH_BUF1_RDY1, field DMA_CH_ALT_BUF1_RDY_33 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - buffer 1 is ready.
 */

#define BP_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_33      1
#define BM_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_33(v)   ((((reg32_t) v) << 1) & BM_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_33)
#else
#define BF_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_33(v)   (((v) << 1) & BM_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_BUF1_RDY_33 field to a new value.
#define BW_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_33(v)   BF_CS1(IPU_ALT_CH_BUF1_RDY1, DMA_CH_ALT_BUF1_RDY_33, v)
#endif


/* --- Register HW_IPU_ALT_CH_BUF1_RDY1, field DMA_CH_ALT_BUF1_RDY_41 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - buffer 1 is ready.
 */

#define BP_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_41      9
#define BM_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_41(v)   ((((reg32_t) v) << 9) & BM_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_41)
#else
#define BF_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_41(v)   (((v) << 9) & BM_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_BUF1_RDY_41 field to a new value.
#define BW_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_41(v)   BF_CS1(IPU_ALT_CH_BUF1_RDY1, DMA_CH_ALT_BUF1_RDY_41, v)
#endif


/* --- Register HW_IPU_ALT_CH_BUF1_RDY1, field DMA_CH_ALT_BUF1_RDY_52 (RW)
 *
 * Buffer 1 is ready. This bit indicates that ARM platform finished/writing reading buffer 1 in
 * memory.
 *
 * Values:
 * 0 - buffer 1 is not ready.
 * 1 - buffer 1 is ready.
 */

#define BP_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_52      20
#define BM_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_52(v)   ((((reg32_t) v) << 20) & BM_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_52)
#else
#define BF_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_52(v)   (((v) << 20) & BM_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_BUF1_RDY_52 field to a new value.
#define BW_IPU_ALT_CH_BUF1_RDY1_DMA_CH_ALT_BUF1_RDY_52(v)   BF_CS1(IPU_ALT_CH_BUF1_RDY1, DMA_CH_ALT_BUF1_RDY_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CH_BUF2_RDY0 - IPU Channels Buffer 2 Ready 0 Register (RW)
 *
 * The register contains buffer 2 ready control information for 32 IPU's DMA channels (31-0). This
 * register can be a write one to set or a write one to clear according to the IPU_CH_BUF2_RDY0_CLR
 * bit .  The register is shown in , and the register fields are described in .
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMA_CH_BUF2_RDY_0 : 1; //!< Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in memory.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DMA_CH_BUF2_RDY_2 : 1; //!< Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in memory.
        unsigned RESERVED1 : 5; //!< Reserved.
        unsigned DMA_CH_BUF2_RDY_8 : 1; //!< Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in memory.
        unsigned DMA_CH_BUF2_RDY_9 : 1; //!< Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in memory.
        unsigned DMA_CH_BUF2_RDY_10 : 1; //!< Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in memory.
        unsigned RESERVED2 : 2; //!< Reserved.
        unsigned DMA_CH_BUF2_RDY_13 : 1; //!< Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in memory.
        unsigned RESERVED3 : 7; //!< Reserved.
        unsigned DMA_CH_BUF2_RDY_21 : 1; //!< Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in memory.
        unsigned RESERVED4 : 1; //!< Reserved.
        unsigned DMA_CH_BUF2_RDY_23 : 1; //!< Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in memory.
        unsigned RESERVED5 : 3; //!< Reserved.
        unsigned DMA_CH_ALT_BUF1_RDY_27 : 1; //!< buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in memory.
        unsigned DMA_CH_BUF2_RDY_28 : 1; //!< Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in memory.
        unsigned RESERVED6 : 3; //!< Reserved.
    } B;
} hw_ipu_ch_buf2_rdy0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CH_BUF2_RDY0 register
 */
#define HW_IPU_CH_BUF2_RDY0_ADDR(x)      (REGS_IPU_BASE(x) + 0x288)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CH_BUF2_RDY0(x)           (*(volatile hw_ipu_ch_buf2_rdy0_t *) HW_IPU_CH_BUF2_RDY0_ADDR(x))
#define HW_IPU_CH_BUF2_RDY0_RD(x)        (HW_IPU_CH_BUF2_RDY0(x).U)
#define HW_IPU_CH_BUF2_RDY0_WR(x, v)     (HW_IPU_CH_BUF2_RDY0(x).U = (v))
#define HW_IPU_CH_BUF2_RDY0_SET(x, v)    (HW_IPU_CH_BUF2_RDY0_WR(x, HW_IPU_CH_BUF2_RDY0_RD(x) |  (v)))
#define HW_IPU_CH_BUF2_RDY0_CLR(x, v)    (HW_IPU_CH_BUF2_RDY0_WR(x, HW_IPU_CH_BUF2_RDY0_RD(x) & ~(v)))
#define HW_IPU_CH_BUF2_RDY0_TOG(x, v)    (HW_IPU_CH_BUF2_RDY0_WR(x, HW_IPU_CH_BUF2_RDY0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CH_BUF2_RDY0 bitfields
 */

/* --- Register HW_IPU_CH_BUF2_RDY0, field DMA_CH_BUF2_RDY_0 (RW)
 *
 * Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in
 * memory.
 *
 * Values:
 * 0 - Buffer 2 is not ready.
 * 1 - Buffer 2 is ready.
 */

#define BP_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_0      0
#define BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_0(v)   ((((reg32_t) v) << 0) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_0)
#else
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_0(v)   (((v) << 0) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF2_RDY_0 field to a new value.
#define BW_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_0(v)   BF_CS1(IPU_CH_BUF2_RDY0, DMA_CH_BUF2_RDY_0, v)
#endif


/* --- Register HW_IPU_CH_BUF2_RDY0, field DMA_CH_BUF2_RDY_2 (RW)
 *
 * Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in
 * memory.
 *
 * Values:
 * 0 - Buffer 2 is not ready.
 * 1 - Buffer 2 is ready.
 */

#define BP_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_2      2
#define BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_2(v)   ((((reg32_t) v) << 2) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_2)
#else
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_2(v)   (((v) << 2) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF2_RDY_2 field to a new value.
#define BW_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_2(v)   BF_CS1(IPU_CH_BUF2_RDY0, DMA_CH_BUF2_RDY_2, v)
#endif


/* --- Register HW_IPU_CH_BUF2_RDY0, field DMA_CH_BUF2_RDY_8 (RW)
 *
 * Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in
 * memory.
 *
 * Values:
 * 0 - Buffer 2 is not ready.
 * 1 - Buffer 2 is ready.
 */

#define BP_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_8      8
#define BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_8(v)   ((((reg32_t) v) << 8) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_8)
#else
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_8(v)   (((v) << 8) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF2_RDY_8 field to a new value.
#define BW_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_8(v)   BF_CS1(IPU_CH_BUF2_RDY0, DMA_CH_BUF2_RDY_8, v)
#endif


/* --- Register HW_IPU_CH_BUF2_RDY0, field DMA_CH_BUF2_RDY_9 (RW)
 *
 * Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in
 * memory.
 *
 * Values:
 * 0 - Buffer 2 is not ready.
 * 1 - Buffer 2 is ready.
 */

#define BP_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_9      9
#define BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_9(v)   ((((reg32_t) v) << 9) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_9)
#else
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_9(v)   (((v) << 9) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF2_RDY_9 field to a new value.
#define BW_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_9(v)   BF_CS1(IPU_CH_BUF2_RDY0, DMA_CH_BUF2_RDY_9, v)
#endif


/* --- Register HW_IPU_CH_BUF2_RDY0, field DMA_CH_BUF2_RDY_10 (RW)
 *
 * Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in
 * memory.
 *
 * Values:
 * 0 - Buffer 2 is not ready.
 * 1 - Buffer 2 is ready.
 */

#define BP_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_10      10
#define BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_10(v)   ((((reg32_t) v) << 10) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_10)
#else
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_10(v)   (((v) << 10) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF2_RDY_10 field to a new value.
#define BW_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_10(v)   BF_CS1(IPU_CH_BUF2_RDY0, DMA_CH_BUF2_RDY_10, v)
#endif


/* --- Register HW_IPU_CH_BUF2_RDY0, field DMA_CH_BUF2_RDY_13 (RW)
 *
 * Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in
 * memory.
 *
 * Values:
 * 0 - Buffer 2 is not ready.
 * 1 - Buffer 2 is ready.
 */

#define BP_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_13      13
#define BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_13(v)   ((((reg32_t) v) << 13) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_13)
#else
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_13(v)   (((v) << 13) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF2_RDY_13 field to a new value.
#define BW_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_13(v)   BF_CS1(IPU_CH_BUF2_RDY0, DMA_CH_BUF2_RDY_13, v)
#endif


/* --- Register HW_IPU_CH_BUF2_RDY0, field DMA_CH_BUF2_RDY_21 (RW)
 *
 * Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in
 * memory.
 *
 * Values:
 * 0 - Buffer 2 is not ready.
 * 1 - Buffer 2 is ready.
 */

#define BP_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_21      21
#define BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_21(v)   ((((reg32_t) v) << 21) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_21)
#else
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_21(v)   (((v) << 21) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF2_RDY_21 field to a new value.
#define BW_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_21(v)   BF_CS1(IPU_CH_BUF2_RDY0, DMA_CH_BUF2_RDY_21, v)
#endif


/* --- Register HW_IPU_CH_BUF2_RDY0, field DMA_CH_BUF2_RDY_23 (RW)
 *
 * Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in
 * memory.
 *
 * Values:
 * 0 - Buffer 2 is not ready.
 * 1 - Buffer 2 is ready.
 */

#define BP_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_23      23
#define BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_23(v)   ((((reg32_t) v) << 23) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_23)
#else
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_23(v)   (((v) << 23) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF2_RDY_23 field to a new value.
#define BW_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_23(v)   BF_CS1(IPU_CH_BUF2_RDY0, DMA_CH_BUF2_RDY_23, v)
#endif


/* --- Register HW_IPU_CH_BUF2_RDY0, field DMA_CH_ALT_BUF1_RDY_27 (RW)
 *
 * buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in
 * memory.
 *
 * Values:
 * 0 - buffer 2 is not ready.
 * 1 - buffer 2 is ready.
 */

#define BP_IPU_CH_BUF2_RDY0_DMA_CH_ALT_BUF1_RDY_27      27
#define BM_IPU_CH_BUF2_RDY0_DMA_CH_ALT_BUF1_RDY_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_ALT_BUF1_RDY_27(v)   ((((reg32_t) v) << 27) & BM_IPU_CH_BUF2_RDY0_DMA_CH_ALT_BUF1_RDY_27)
#else
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_ALT_BUF1_RDY_27(v)   (((v) << 27) & BM_IPU_CH_BUF2_RDY0_DMA_CH_ALT_BUF1_RDY_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_ALT_BUF1_RDY_27 field to a new value.
#define BW_IPU_CH_BUF2_RDY0_DMA_CH_ALT_BUF1_RDY_27(v)   BF_CS1(IPU_CH_BUF2_RDY0, DMA_CH_ALT_BUF1_RDY_27, v)
#endif


/* --- Register HW_IPU_CH_BUF2_RDY0, field DMA_CH_BUF2_RDY_28 (RW)
 *
 * Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in
 * memory.
 *
 * Values:
 * 0 - Buffer 2 is not ready.
 * 1 - Buffer 2 is ready.
 */

#define BP_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_28      28
#define BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_28(v)   ((((reg32_t) v) << 28) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_28)
#else
#define BF_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_28(v)   (((v) << 28) & BM_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF2_RDY_28 field to a new value.
#define BW_IPU_CH_BUF2_RDY0_DMA_CH_BUF2_RDY_28(v)   BF_CS1(IPU_CH_BUF2_RDY0, DMA_CH_BUF2_RDY_28, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CH_BUF2_RDY1 - IPU Channels Buffer 2 Ready 1 Register (RW)
 *
 * The register contains buffer 2 ready control information for 32 IPU's DMA channels (63-32). This
 * register can be a write one to set or a write one to clear according to the IPU_CH_BUF2_RDY1_CLR
 * bit.  The register is shown in , and the register fields are described in .
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMA_CH_BUF2_RDY_ : 32; //!< Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in memory.
    } B;
} hw_ipu_ch_buf2_rdy1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CH_BUF2_RDY1 register
 */
#define HW_IPU_CH_BUF2_RDY1_ADDR(x)      (REGS_IPU_BASE(x) + 0x28c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CH_BUF2_RDY1(x)           (*(volatile hw_ipu_ch_buf2_rdy1_t *) HW_IPU_CH_BUF2_RDY1_ADDR(x))
#define HW_IPU_CH_BUF2_RDY1_RD(x)        (HW_IPU_CH_BUF2_RDY1(x).U)
#define HW_IPU_CH_BUF2_RDY1_WR(x, v)     (HW_IPU_CH_BUF2_RDY1(x).U = (v))
#define HW_IPU_CH_BUF2_RDY1_SET(x, v)    (HW_IPU_CH_BUF2_RDY1_WR(x, HW_IPU_CH_BUF2_RDY1_RD(x) |  (v)))
#define HW_IPU_CH_BUF2_RDY1_CLR(x, v)    (HW_IPU_CH_BUF2_RDY1_WR(x, HW_IPU_CH_BUF2_RDY1_RD(x) & ~(v)))
#define HW_IPU_CH_BUF2_RDY1_TOG(x, v)    (HW_IPU_CH_BUF2_RDY1_WR(x, HW_IPU_CH_BUF2_RDY1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CH_BUF2_RDY1 bitfields
 */

/* --- Register HW_IPU_CH_BUF2_RDY1, field DMA_CH_BUF2_RDY_ (RW)
 *
 * Buffer 2 is ready. This bit indicates that ARM platform finished/writing reading buffer 2 in
 * memory.
 *
 * Values:
 * 0 - Buffer 2 is not ready.
 * 1 - Buffer 2 is ready.
 */

#define BP_IPU_CH_BUF2_RDY1_DMA_CH_BUF2_RDY_      0
#define BM_IPU_CH_BUF2_RDY1_DMA_CH_BUF2_RDY_      0xffffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CH_BUF2_RDY1_DMA_CH_BUF2_RDY_(v)   ((((reg32_t) v) << 0) & BM_IPU_CH_BUF2_RDY1_DMA_CH_BUF2_RDY_)
#else
#define BF_IPU_CH_BUF2_RDY1_DMA_CH_BUF2_RDY_(v)   (((v) << 0) & BM_IPU_CH_BUF2_RDY1_DMA_CH_BUF2_RDY_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMA_CH_BUF2_RDY_ field to a new value.
#define BW_IPU_CH_BUF2_RDY1_DMA_CH_BUF2_RDY_(v)   BF_CS1(IPU_CH_BUF2_RDY1, DMA_CH_BUF2_RDY_, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_INT_STAT_4 - Interrupt Status Register 4 (W1C)
 *
 * IPU status registers are not stored in the SRM during power gating mode.This register contains
 * part of IPU interrupts status bits. The status bits of NFACK (New Frame Ack) of DMA Channels
 * interrupts [63:32] can be found in this register.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_NFACK_33 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_NFACK_40 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_41 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_42 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_43 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_44 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_45 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_46 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_47 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_48 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_49 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_50 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_51 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned IDMAC_NFACK_52 : 1; //!< Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of Channel #n. n Indicates the corresponding DMA channel number.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_int_stat_4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_INT_STAT_4 register
 */
#define HW_IPU_INT_STAT_4_ADDR(x)      (REGS_IPU_BASE(x) + 0x2c0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_INT_STAT_4(x)           (*(volatile hw_ipu_int_stat_4_t *) HW_IPU_INT_STAT_4_ADDR(x))
#define HW_IPU_INT_STAT_4_RD(x)        (HW_IPU_INT_STAT_4(x).U)
#endif

/*
 * constants & macros for individual IPU_INT_STAT_4 bitfields
 */

/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_33 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_33      1
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_33      0x00000002


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_40 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_40      8
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_40      0x00000100


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_41 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_41      9
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_41      0x00000200


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_42 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_42      10
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_42      0x00000400


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_43 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_43      11
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_43      0x00000800


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_44 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_44      12
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_44      0x00001000


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_45 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_45      13
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_45      0x00002000


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_46 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_46      14
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_46      0x00004000


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_47 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_47      15
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_47      0x00008000


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_48 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_48      16
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_48      0x00010000


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_49 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_49      17
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_49      0x00020000


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_50 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_50      18
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_50      0x00040000


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_51 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_51      19
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_51      0x00080000


/* --- Register HW_IPU_INT_STAT_4, field IDMAC_NFACK_52 (W1C)
 *
 * Enable New Frame Ack of Channel interrupt. This bit is the status bits of New Frame Ack of
 * Channel #n. n Indicates the corresponding DMA channel number.
 *
 * Values:
 * 0 - Interrupt is cleared.
 * 1 - Interrupt is requested.
 */

#define BP_IPU_INT_STAT_4_IDMAC_NFACK_52      20
#define BM_IPU_INT_STAT_4_IDMAC_NFACK_52      0x00100000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_CONF - IDMAC Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAX_REQ_READ : 3; //!< Maximum Read Requests. This fields sets the maximum pending requests allowed in the AXI Read requests queue.
        unsigned WIDPT : 2; //!< Write Interleaving Depth These 2 bits define the Write Interleaving Depth of the AXI port. This bits should be configured by the user according to the AXI slave's Write Interleaving Depth. WIDPT defines the maximal number of active bursts (yet to be responded) with different IDs. IDMAC will block data phase if the next data's ID is new (no such ID active) and the number of active IDs is equal to WIDPT. 00 Write Interleaving Depth of 1 01 Write Interleaving Depth of 2 10 Write Interleaving Depth of 3 11 Write Interleaving Depth of 4
        unsigned RDI : 1; //!< Read Data Interleaving. This bit must match the slave read data interleaving support. If the AXI slave connected to the IPU supports read data interleaving then this bit must be set. If the AXI slave does not support read data interleaving then the IDMAC can utilize this and issue more address phases on read. In that case it is recommended to have this bit cleared. 0 The AXI slave does not support read data interleaving 1 The AXI slave supports read data interleaving
        unsigned RESERVED0 : 10; //!< Reserved, should be cleared.
        unsigned P_ENDIAN : 1; //!< Pixel Endianness. The pixel Endianness must not be changed while any of the IDMAC channels is enabled. 0 little endian 1 Big endian
        unsigned USED_BUFS_MAX_W : 3; //!< Limit the number of pending non real time write requests. The value can be between 0 to 6. This field has no affect if USED_BUFS_EN_W is cleared
        unsigned USED_BUFS_EN_W : 1; //!< Enables the limit on the number of pending non real time write requests.
        unsigned USED_BUFS_MAX_R : 4; //!< Limit the number of pending non real time read requests. The value can be between 0 to 8. This field has no affect if USED_BUFS_EN_R is cleared
        unsigned USED_BUFS_EN_R : 1; //!< Enables the limit on the number of pending non real time read requests.
        unsigned RESERVED1 : 6; //!< Reserved, should be cleared.
    } B;
} hw_ipu_idmac_conf_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_CONF register
 */
#define HW_IPU_IDMAC_CONF_ADDR(x)      (REGS_IPU_BASE(x) + 0x1f40)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_CONF(x)           (*(volatile hw_ipu_idmac_conf_t *) HW_IPU_IDMAC_CONF_ADDR(x))
#define HW_IPU_IDMAC_CONF_RD(x)        (HW_IPU_IDMAC_CONF(x).U)
#define HW_IPU_IDMAC_CONF_WR(x, v)     (HW_IPU_IDMAC_CONF(x).U = (v))
#define HW_IPU_IDMAC_CONF_SET(x, v)    (HW_IPU_IDMAC_CONF_WR(x, HW_IPU_IDMAC_CONF_RD(x) |  (v)))
#define HW_IPU_IDMAC_CONF_CLR(x, v)    (HW_IPU_IDMAC_CONF_WR(x, HW_IPU_IDMAC_CONF_RD(x) & ~(v)))
#define HW_IPU_IDMAC_CONF_TOG(x, v)    (HW_IPU_IDMAC_CONF_WR(x, HW_IPU_IDMAC_CONF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_CONF bitfields
 */

/* --- Register HW_IPU_IDMAC_CONF, field MAX_REQ_READ (RW)
 *
 * Maximum Read Requests. This fields sets the maximum pending requests allowed in the AXI Read
 * requests queue.
 */

#define BP_IPU_IDMAC_CONF_MAX_REQ_READ      0
#define BM_IPU_IDMAC_CONF_MAX_REQ_READ      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CONF_MAX_REQ_READ(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_CONF_MAX_REQ_READ)
#else
#define BF_IPU_IDMAC_CONF_MAX_REQ_READ(v)   (((v) << 0) & BM_IPU_IDMAC_CONF_MAX_REQ_READ)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAX_REQ_READ field to a new value.
#define BW_IPU_IDMAC_CONF_MAX_REQ_READ(v)   BF_CS1(IPU_IDMAC_CONF, MAX_REQ_READ, v)
#endif

/* --- Register HW_IPU_IDMAC_CONF, field WIDPT (RW)
 *
 * Write Interleaving Depth These 2 bits define the Write Interleaving Depth of the AXI port. This
 * bits should be configured by the user according to the AXI slave's Write Interleaving Depth.
 * WIDPT defines the maximal number of active bursts (yet to be responded) with different IDs. IDMAC
 * will block data phase if the next data's ID is new (no such ID active) and the number of active
 * IDs is equal to WIDPT. 00 Write Interleaving Depth of 1 01 Write Interleaving Depth of 2 10 Write
 * Interleaving Depth of 3 11 Write Interleaving Depth of 4
 */

#define BP_IPU_IDMAC_CONF_WIDPT      3
#define BM_IPU_IDMAC_CONF_WIDPT      0x00000018

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CONF_WIDPT(v)   ((((reg32_t) v) << 3) & BM_IPU_IDMAC_CONF_WIDPT)
#else
#define BF_IPU_IDMAC_CONF_WIDPT(v)   (((v) << 3) & BM_IPU_IDMAC_CONF_WIDPT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WIDPT field to a new value.
#define BW_IPU_IDMAC_CONF_WIDPT(v)   BF_CS1(IPU_IDMAC_CONF, WIDPT, v)
#endif

/* --- Register HW_IPU_IDMAC_CONF, field RDI (RW)
 *
 * Read Data Interleaving. This bit must match the slave read data interleaving support. If the AXI
 * slave connected to the IPU supports read data interleaving then this bit must be set. If the AXI
 * slave does not support read data interleaving then the IDMAC can utilize this and issue more
 * address phases on read. In that case it is recommended to have this bit cleared. 0 The AXI slave
 * does not support read data interleaving 1 The AXI slave supports read data interleaving
 */

#define BP_IPU_IDMAC_CONF_RDI      5
#define BM_IPU_IDMAC_CONF_RDI      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CONF_RDI(v)   ((((reg32_t) v) << 5) & BM_IPU_IDMAC_CONF_RDI)
#else
#define BF_IPU_IDMAC_CONF_RDI(v)   (((v) << 5) & BM_IPU_IDMAC_CONF_RDI)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the RDI field to a new value.
#define BW_IPU_IDMAC_CONF_RDI(v)   BF_CS1(IPU_IDMAC_CONF, RDI, v)
#endif

/* --- Register HW_IPU_IDMAC_CONF, field P_ENDIAN (RW)
 *
 * Pixel Endianness. The pixel Endianness must not be changed while any of the IDMAC channels is
 * enabled. 0 little endian 1 Big endian
 */

#define BP_IPU_IDMAC_CONF_P_ENDIAN      16
#define BM_IPU_IDMAC_CONF_P_ENDIAN      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CONF_P_ENDIAN(v)   ((((reg32_t) v) << 16) & BM_IPU_IDMAC_CONF_P_ENDIAN)
#else
#define BF_IPU_IDMAC_CONF_P_ENDIAN(v)   (((v) << 16) & BM_IPU_IDMAC_CONF_P_ENDIAN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the P_ENDIAN field to a new value.
#define BW_IPU_IDMAC_CONF_P_ENDIAN(v)   BF_CS1(IPU_IDMAC_CONF, P_ENDIAN, v)
#endif

/* --- Register HW_IPU_IDMAC_CONF, field USED_BUFS_MAX_W (RW)
 *
 * Limit the number of pending non real time write requests. The value can be between 0 to 6. This
 * field has no affect if USED_BUFS_EN_W is cleared
 */

#define BP_IPU_IDMAC_CONF_USED_BUFS_MAX_W      17
#define BM_IPU_IDMAC_CONF_USED_BUFS_MAX_W      0x000e0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CONF_USED_BUFS_MAX_W(v)   ((((reg32_t) v) << 17) & BM_IPU_IDMAC_CONF_USED_BUFS_MAX_W)
#else
#define BF_IPU_IDMAC_CONF_USED_BUFS_MAX_W(v)   (((v) << 17) & BM_IPU_IDMAC_CONF_USED_BUFS_MAX_W)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the USED_BUFS_MAX_W field to a new value.
#define BW_IPU_IDMAC_CONF_USED_BUFS_MAX_W(v)   BF_CS1(IPU_IDMAC_CONF, USED_BUFS_MAX_W, v)
#endif

/* --- Register HW_IPU_IDMAC_CONF, field USED_BUFS_EN_W (RW)
 *
 * Enables the limit on the number of pending non real time write requests.
 */

#define BP_IPU_IDMAC_CONF_USED_BUFS_EN_W      20
#define BM_IPU_IDMAC_CONF_USED_BUFS_EN_W      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CONF_USED_BUFS_EN_W(v)   ((((reg32_t) v) << 20) & BM_IPU_IDMAC_CONF_USED_BUFS_EN_W)
#else
#define BF_IPU_IDMAC_CONF_USED_BUFS_EN_W(v)   (((v) << 20) & BM_IPU_IDMAC_CONF_USED_BUFS_EN_W)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the USED_BUFS_EN_W field to a new value.
#define BW_IPU_IDMAC_CONF_USED_BUFS_EN_W(v)   BF_CS1(IPU_IDMAC_CONF, USED_BUFS_EN_W, v)
#endif

/* --- Register HW_IPU_IDMAC_CONF, field USED_BUFS_MAX_R (RW)
 *
 * Limit the number of pending non real time read requests. The value can be between 0 to 8. This
 * field has no affect if USED_BUFS_EN_R is cleared
 */

#define BP_IPU_IDMAC_CONF_USED_BUFS_MAX_R      21
#define BM_IPU_IDMAC_CONF_USED_BUFS_MAX_R      0x01e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CONF_USED_BUFS_MAX_R(v)   ((((reg32_t) v) << 21) & BM_IPU_IDMAC_CONF_USED_BUFS_MAX_R)
#else
#define BF_IPU_IDMAC_CONF_USED_BUFS_MAX_R(v)   (((v) << 21) & BM_IPU_IDMAC_CONF_USED_BUFS_MAX_R)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the USED_BUFS_MAX_R field to a new value.
#define BW_IPU_IDMAC_CONF_USED_BUFS_MAX_R(v)   BF_CS1(IPU_IDMAC_CONF, USED_BUFS_MAX_R, v)
#endif

/* --- Register HW_IPU_IDMAC_CONF, field USED_BUFS_EN_R (RW)
 *
 * Enables the limit on the number of pending non real time read requests.
 */

#define BP_IPU_IDMAC_CONF_USED_BUFS_EN_R      25
#define BM_IPU_IDMAC_CONF_USED_BUFS_EN_R      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CONF_USED_BUFS_EN_R(v)   ((((reg32_t) v) << 25) & BM_IPU_IDMAC_CONF_USED_BUFS_EN_R)
#else
#define BF_IPU_IDMAC_CONF_USED_BUFS_EN_R(v)   (((v) << 25) & BM_IPU_IDMAC_CONF_USED_BUFS_EN_R)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the USED_BUFS_EN_R field to a new value.
#define BW_IPU_IDMAC_CONF_USED_BUFS_EN_R(v)   BF_CS1(IPU_IDMAC_CONF, USED_BUFS_EN_R, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_CH_EN_1 - IDMAC Channel Enable 1 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_CH_EN_0 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_1 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_2 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_3 : 1; //!< IDMAC Channel enable bit [i]
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_CH_EN_5 : 1; //!< IDMAC Channel enable bit [i]
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_CH_EN_8 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_9 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_10 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_11 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_12 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_13 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_14 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_15 : 1; //!< IDMAC Channel enable bit [i]
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_CH_EN_17 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_18 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_19 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_20 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_21 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_22 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_23 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_24 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_25 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_26 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_27 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_28 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_29 : 1; //!< IDMAC Channel enable bit [i]
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_CH_EN_31 : 1; //!< IDMAC Channel enable bit [i]
    } B;
} hw_ipu_idmac_ch_en_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_CH_EN_1 register
 */
#define HW_IPU_IDMAC_CH_EN_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x1f44)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_CH_EN_1(x)           (*(volatile hw_ipu_idmac_ch_en_1_t *) HW_IPU_IDMAC_CH_EN_1_ADDR(x))
#define HW_IPU_IDMAC_CH_EN_1_RD(x)        (HW_IPU_IDMAC_CH_EN_1(x).U)
#define HW_IPU_IDMAC_CH_EN_1_WR(x, v)     (HW_IPU_IDMAC_CH_EN_1(x).U = (v))
#define HW_IPU_IDMAC_CH_EN_1_SET(x, v)    (HW_IPU_IDMAC_CH_EN_1_WR(x, HW_IPU_IDMAC_CH_EN_1_RD(x) |  (v)))
#define HW_IPU_IDMAC_CH_EN_1_CLR(x, v)    (HW_IPU_IDMAC_CH_EN_1_WR(x, HW_IPU_IDMAC_CH_EN_1_RD(x) & ~(v)))
#define HW_IPU_IDMAC_CH_EN_1_TOG(x, v)    (HW_IPU_IDMAC_CH_EN_1_WR(x, HW_IPU_IDMAC_CH_EN_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_CH_EN_1 bitfields
 */

/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_0 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_0      0
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_0)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_0(v)   (((v) << 0) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_0 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_0(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_0, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_1 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_1      1
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_1(v)   ((((reg32_t) v) << 1) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_1)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_1(v)   (((v) << 1) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_1 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_1(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_1, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_2 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_2      2
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_2(v)   ((((reg32_t) v) << 2) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_2)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_2(v)   (((v) << 2) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_2 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_2(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_2, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_3 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_3      3
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_3(v)   ((((reg32_t) v) << 3) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_3)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_3(v)   (((v) << 3) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_3 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_3(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_3, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_5 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_5      5
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_5(v)   ((((reg32_t) v) << 5) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_5)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_5(v)   (((v) << 5) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_5 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_5(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_5, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_8 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_8      8
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_8(v)   ((((reg32_t) v) << 8) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_8)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_8(v)   (((v) << 8) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_8 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_8(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_8, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_9 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_9      9
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_9(v)   ((((reg32_t) v) << 9) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_9)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_9(v)   (((v) << 9) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_9 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_9(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_9, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_10 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_10      10
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_10(v)   ((((reg32_t) v) << 10) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_10)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_10(v)   (((v) << 10) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_10 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_10(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_10, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_11 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_11      11
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_11(v)   ((((reg32_t) v) << 11) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_11)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_11(v)   (((v) << 11) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_11 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_11(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_11, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_12 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_12      12
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_12(v)   ((((reg32_t) v) << 12) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_12)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_12(v)   (((v) << 12) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_12 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_12(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_12, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_13 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_13      13
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_13(v)   ((((reg32_t) v) << 13) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_13)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_13(v)   (((v) << 13) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_13 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_13(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_13, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_14 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_14      14
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_14(v)   ((((reg32_t) v) << 14) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_14)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_14(v)   (((v) << 14) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_14 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_14(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_14, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_15 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_15      15
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_15(v)   ((((reg32_t) v) << 15) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_15)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_15(v)   (((v) << 15) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_15 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_15(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_15, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_17 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_17      17
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_17      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_17(v)   ((((reg32_t) v) << 17) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_17)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_17(v)   (((v) << 17) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_17 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_17(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_17, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_18 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_18      18
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_18      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_18(v)   ((((reg32_t) v) << 18) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_18)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_18(v)   (((v) << 18) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_18 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_18(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_18, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_19 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_19      19
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_19      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_19(v)   ((((reg32_t) v) << 19) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_19)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_19(v)   (((v) << 19) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_19 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_19(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_19, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_20 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_20      20
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_20(v)   ((((reg32_t) v) << 20) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_20)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_20(v)   (((v) << 20) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_20 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_20(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_20, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_21 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_21      21
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_21(v)   ((((reg32_t) v) << 21) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_21)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_21(v)   (((v) << 21) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_21 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_21(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_21, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_22 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_22      22
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_22(v)   ((((reg32_t) v) << 22) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_22)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_22(v)   (((v) << 22) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_22 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_22(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_22, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_23 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_23      23
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_23(v)   ((((reg32_t) v) << 23) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_23)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_23(v)   (((v) << 23) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_23 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_23(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_23, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_24 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_24      24
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_24(v)   ((((reg32_t) v) << 24) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_24)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_24(v)   (((v) << 24) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_24 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_24(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_24, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_25 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_25      25
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_25)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_25(v)   (((v) << 25) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_25 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_25(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_25, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_26 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_26      26
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_26)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_26(v)   (((v) << 26) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_26 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_26(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_26, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_27 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_27      27
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_27(v)   ((((reg32_t) v) << 27) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_27)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_27(v)   (((v) << 27) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_27 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_27(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_27, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_28 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_28      28
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_28(v)   ((((reg32_t) v) << 28) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_28)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_28(v)   (((v) << 28) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_28 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_28(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_28, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_29 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_29      29
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_29(v)   ((((reg32_t) v) << 29) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_29)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_29(v)   (((v) << 29) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_29 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_29(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_29, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_1, field IDMAC_CH_EN_31 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_31      31
#define BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_31      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_31(v)   ((((reg32_t) v) << 31) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_31)
#else
#define BF_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_31(v)   (((v) << 31) & BM_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_31)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_31 field to a new value.
#define BW_IPU_IDMAC_CH_EN_1_IDMAC_CH_EN_31(v)   BF_CS1(IPU_IDMAC_CH_EN_1, IDMAC_CH_EN_31, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_ALT_SEP_ALPHA - IDMAC Alternate Separate Alpha Indication Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 23; //!< Reserved.
        unsigned IDMAC_ALT_SEP_AL_23 : 1; //!< IDMAC Alternate Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case where the alpha should be read from a separate buffer, the user should set the channels corresponding. For channels that may have alternate flow and may use separate alpha. This bit indicates the mode of the alpha for the alternate flow
        unsigned IDMAC_ALT_SEP_AL_24 : 1; //!< IDMAC Alternate Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case where the alpha should be read from a separate buffer, the user should set the channels corresponding. For channels that may have alternate flow and may use separate alpha. This bit indicates the mode of the alpha for the alternate flow
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned IDMAC_ALT_SEP_AL_29 : 1; //!< IDMAC Alternate Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case where the alpha should be read from a separate buffer, the user should set the channels corresponding. For channels that may have alternate flow and may use separate alpha. This bit indicates the mode of the alpha for the alternate flow
        unsigned RESERVED2 : 2; //!< Reserved.
    } B;
} hw_ipu_idmac_alt_sep_alpha_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_ALT_SEP_ALPHA register
 */
#define HW_IPU_IDMAC_ALT_SEP_ALPHA_ADDR(x)      (REGS_IPU_BASE(x) + 0x1f4a)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_ALT_SEP_ALPHA(x)           (*(volatile hw_ipu_idmac_alt_sep_alpha_t *) HW_IPU_IDMAC_ALT_SEP_ALPHA_ADDR(x))
#define HW_IPU_IDMAC_ALT_SEP_ALPHA_RD(x)        (HW_IPU_IDMAC_ALT_SEP_ALPHA(x).U)
#define HW_IPU_IDMAC_ALT_SEP_ALPHA_WR(x, v)     (HW_IPU_IDMAC_ALT_SEP_ALPHA(x).U = (v))
#define HW_IPU_IDMAC_ALT_SEP_ALPHA_SET(x, v)    (HW_IPU_IDMAC_ALT_SEP_ALPHA_WR(x, HW_IPU_IDMAC_ALT_SEP_ALPHA_RD(x) |  (v)))
#define HW_IPU_IDMAC_ALT_SEP_ALPHA_CLR(x, v)    (HW_IPU_IDMAC_ALT_SEP_ALPHA_WR(x, HW_IPU_IDMAC_ALT_SEP_ALPHA_RD(x) & ~(v)))
#define HW_IPU_IDMAC_ALT_SEP_ALPHA_TOG(x, v)    (HW_IPU_IDMAC_ALT_SEP_ALPHA_WR(x, HW_IPU_IDMAC_ALT_SEP_ALPHA_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_ALT_SEP_ALPHA bitfields
 */

/* --- Register HW_IPU_IDMAC_ALT_SEP_ALPHA, field IDMAC_ALT_SEP_AL_23 (RW)
 *
 * IDMAC Alternate Separate alpha indication bit [i] A sub block may need to read data from the
 * system's memory where the pixel data and the alpha transparency data are located in separate
 * buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case
 * where the alpha should be read from a separate buffer, the user should set the channels
 * corresponding. For channels that may have alternate flow and may use separate alpha. This bit
 * indicates the mode of the alpha for the alternate flow
 *
 * Values:
 * 0 - Channel [i] does not read Alpha transparency data from a separate buffer.
 * 1 - Channel [i] reads Alpha transparency data from a separate buffer.
 */

#define BP_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_23      23
#define BM_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_23(v)   ((((reg32_t) v) << 23) & BM_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_23)
#else
#define BF_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_23(v)   (((v) << 23) & BM_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_ALT_SEP_AL_23 field to a new value.
#define BW_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_23(v)   BF_CS1(IPU_IDMAC_ALT_SEP_ALPHA, IDMAC_ALT_SEP_AL_23, v)
#endif


/* --- Register HW_IPU_IDMAC_ALT_SEP_ALPHA, field IDMAC_ALT_SEP_AL_24 (RW)
 *
 * IDMAC Alternate Separate alpha indication bit [i] A sub block may need to read data from the
 * system's memory where the pixel data and the alpha transparency data are located in separate
 * buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case
 * where the alpha should be read from a separate buffer, the user should set the channels
 * corresponding. For channels that may have alternate flow and may use separate alpha. This bit
 * indicates the mode of the alpha for the alternate flow
 *
 * Values:
 * 0 - Channel [i] does not read Alpha transparency data from a separate buffer.
 * 1 - Channel [i] reads Alpha transparency data from a separate buffer.
 */

#define BP_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_24      24
#define BM_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_24(v)   ((((reg32_t) v) << 24) & BM_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_24)
#else
#define BF_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_24(v)   (((v) << 24) & BM_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_ALT_SEP_AL_24 field to a new value.
#define BW_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_24(v)   BF_CS1(IPU_IDMAC_ALT_SEP_ALPHA, IDMAC_ALT_SEP_AL_24, v)
#endif


/* --- Register HW_IPU_IDMAC_ALT_SEP_ALPHA, field IDMAC_ALT_SEP_AL_29 (RW)
 *
 * IDMAC Alternate Separate alpha indication bit [i] A sub block may need to read data from the
 * system's memory where the pixel data and the alpha transparency data are located in separate
 * buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case
 * where the alpha should be read from a separate buffer, the user should set the channels
 * corresponding. For channels that may have alternate flow and may use separate alpha. This bit
 * indicates the mode of the alpha for the alternate flow
 *
 * Values:
 * 0 - Channel [i] does not read Alpha transparency data from a separate buffer.
 * 1 - Channel [i] reads Alpha transparency data from a separate buffer.
 */

#define BP_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_29      29
#define BM_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_29(v)   ((((reg32_t) v) << 29) & BM_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_29)
#else
#define BF_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_29(v)   (((v) << 29) & BM_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_ALT_SEP_AL_29 field to a new value.
#define BW_IPU_IDMAC_ALT_SEP_ALPHA_IDMAC_ALT_SEP_AL_29(v)   BF_CS1(IPU_IDMAC_ALT_SEP_ALPHA, IDMAC_ALT_SEP_AL_29, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_CH_PRI_1 - IDMAC Channel Priority 1 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_CH_PRI_0 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_1 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_2 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_3 : 1; //!< IDMAC Channel enable bit [i]
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_CH_PRI_5 : 1; //!< IDMAC Channel enable bit [i]
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_CH_PRI_8 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_9 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_10 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_11 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_12 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_13 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_14 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_15 : 1; //!< IDMAC Channel enable bit [i]
        unsigned RESERVED2 : 4; //!< Reserved.
        unsigned IDMAC_CH_PRI_20 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_21 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_22 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_23 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_24 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_25 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_26 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_27 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_28 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_29 : 1; //!< IDMAC Channel enable bit [i]
        unsigned RESERVED3 : 2; //!< Reserved.
    } B;
} hw_ipu_idmac_ch_pri_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_CH_PRI_1 register
 */
#define HW_IPU_IDMAC_CH_PRI_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x1f4e)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_CH_PRI_1(x)           (*(volatile hw_ipu_idmac_ch_pri_1_t *) HW_IPU_IDMAC_CH_PRI_1_ADDR(x))
#define HW_IPU_IDMAC_CH_PRI_1_RD(x)        (HW_IPU_IDMAC_CH_PRI_1(x).U)
#define HW_IPU_IDMAC_CH_PRI_1_WR(x, v)     (HW_IPU_IDMAC_CH_PRI_1(x).U = (v))
#define HW_IPU_IDMAC_CH_PRI_1_SET(x, v)    (HW_IPU_IDMAC_CH_PRI_1_WR(x, HW_IPU_IDMAC_CH_PRI_1_RD(x) |  (v)))
#define HW_IPU_IDMAC_CH_PRI_1_CLR(x, v)    (HW_IPU_IDMAC_CH_PRI_1_WR(x, HW_IPU_IDMAC_CH_PRI_1_RD(x) & ~(v)))
#define HW_IPU_IDMAC_CH_PRI_1_TOG(x, v)    (HW_IPU_IDMAC_CH_PRI_1_WR(x, HW_IPU_IDMAC_CH_PRI_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_CH_PRI_1 bitfields
 */

/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_0 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_0      0
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_0(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_0)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_0(v)   (((v) << 0) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_0 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_0(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_0, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_1 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_1      1
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_1(v)   ((((reg32_t) v) << 1) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_1)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_1(v)   (((v) << 1) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_1 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_1(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_1, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_2 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_2      2
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_2(v)   ((((reg32_t) v) << 2) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_2)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_2(v)   (((v) << 2) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_2 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_2(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_2, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_3 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_3      3
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_3(v)   ((((reg32_t) v) << 3) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_3)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_3(v)   (((v) << 3) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_3 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_3(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_3, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_5 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_5      5
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_5(v)   ((((reg32_t) v) << 5) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_5)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_5(v)   (((v) << 5) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_5 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_5(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_5, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_8 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_8      8
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_8(v)   ((((reg32_t) v) << 8) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_8)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_8(v)   (((v) << 8) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_8 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_8(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_8, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_9 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_9      9
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_9(v)   ((((reg32_t) v) << 9) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_9)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_9(v)   (((v) << 9) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_9 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_9(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_9, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_10 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_10      10
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_10(v)   ((((reg32_t) v) << 10) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_10)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_10(v)   (((v) << 10) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_10 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_10(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_10, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_11 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_11      11
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_11(v)   ((((reg32_t) v) << 11) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_11)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_11(v)   (((v) << 11) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_11 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_11(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_11, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_12 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_12      12
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_12(v)   ((((reg32_t) v) << 12) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_12)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_12(v)   (((v) << 12) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_12 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_12(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_12, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_13 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_13      13
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_13(v)   ((((reg32_t) v) << 13) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_13)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_13(v)   (((v) << 13) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_13 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_13(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_13, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_14 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_14      14
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_14(v)   ((((reg32_t) v) << 14) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_14)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_14(v)   (((v) << 14) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_14 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_14(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_14, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_15 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_15      15
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_15(v)   ((((reg32_t) v) << 15) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_15)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_15(v)   (((v) << 15) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_15 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_15(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_15, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_20 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_20      20
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_20(v)   ((((reg32_t) v) << 20) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_20)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_20(v)   (((v) << 20) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_20 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_20(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_20, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_21 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_21      21
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_21(v)   ((((reg32_t) v) << 21) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_21)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_21(v)   (((v) << 21) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_21 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_21(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_21, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_22 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_22      22
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_22(v)   ((((reg32_t) v) << 22) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_22)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_22(v)   (((v) << 22) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_22 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_22(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_22, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_23 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_23      23
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_23(v)   ((((reg32_t) v) << 23) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_23)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_23(v)   (((v) << 23) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_23 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_23(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_23, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_24 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_24      24
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_24(v)   ((((reg32_t) v) << 24) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_24)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_24(v)   (((v) << 24) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_24 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_24(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_24, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_25 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_25      25
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_25(v)   ((((reg32_t) v) << 25) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_25)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_25(v)   (((v) << 25) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_25 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_25(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_25, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_26 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_26      26
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_26(v)   ((((reg32_t) v) << 26) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_26)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_26(v)   (((v) << 26) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_26 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_26(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_26, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_27 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_27      27
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_27(v)   ((((reg32_t) v) << 27) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_27)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_27(v)   (((v) << 27) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_27 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_27(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_27, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_28 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_28      28
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_28(v)   ((((reg32_t) v) << 28) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_28)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_28(v)   (((v) << 28) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_28 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_28(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_28, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_1, field IDMAC_CH_PRI_29 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_29      29
#define BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_29(v)   ((((reg32_t) v) << 29) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_29)
#else
#define BF_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_29(v)   (((v) << 29) & BM_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_29 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_1_IDMAC_CH_PRI_29(v)   BF_CS1(IPU_IDMAC_CH_PRI_1, IDMAC_CH_PRI_29, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_CH_PRI_2 - IDMAC Channel Priority 2 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 8; //!< Reserved.
        unsigned IDMAC_CH_PRI_8 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_9 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_10 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_11 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_12 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_13 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_14 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_15 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_16 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_17 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_PRI_18 : 1; //!< IDMAC Channel enable bit [i]
        unsigned RESERVED1 : 13; //!< Reserved.
    } B;
} hw_ipu_idmac_ch_pri_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_CH_PRI_2 register
 */
#define HW_IPU_IDMAC_CH_PRI_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x1f52)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_CH_PRI_2(x)           (*(volatile hw_ipu_idmac_ch_pri_2_t *) HW_IPU_IDMAC_CH_PRI_2_ADDR(x))
#define HW_IPU_IDMAC_CH_PRI_2_RD(x)        (HW_IPU_IDMAC_CH_PRI_2(x).U)
#define HW_IPU_IDMAC_CH_PRI_2_WR(x, v)     (HW_IPU_IDMAC_CH_PRI_2(x).U = (v))
#define HW_IPU_IDMAC_CH_PRI_2_SET(x, v)    (HW_IPU_IDMAC_CH_PRI_2_WR(x, HW_IPU_IDMAC_CH_PRI_2_RD(x) |  (v)))
#define HW_IPU_IDMAC_CH_PRI_2_CLR(x, v)    (HW_IPU_IDMAC_CH_PRI_2_WR(x, HW_IPU_IDMAC_CH_PRI_2_RD(x) & ~(v)))
#define HW_IPU_IDMAC_CH_PRI_2_TOG(x, v)    (HW_IPU_IDMAC_CH_PRI_2_WR(x, HW_IPU_IDMAC_CH_PRI_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_CH_PRI_2 bitfields
 */

/* --- Register HW_IPU_IDMAC_CH_PRI_2, field IDMAC_CH_PRI_8 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_8      8
#define BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_8(v)   ((((reg32_t) v) << 8) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_8)
#else
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_8(v)   (((v) << 8) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_8 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_8(v)   BF_CS1(IPU_IDMAC_CH_PRI_2, IDMAC_CH_PRI_8, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_2, field IDMAC_CH_PRI_9 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_9      9
#define BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_9(v)   ((((reg32_t) v) << 9) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_9)
#else
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_9(v)   (((v) << 9) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_9 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_9(v)   BF_CS1(IPU_IDMAC_CH_PRI_2, IDMAC_CH_PRI_9, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_2, field IDMAC_CH_PRI_10 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_10      10
#define BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_10(v)   ((((reg32_t) v) << 10) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_10)
#else
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_10(v)   (((v) << 10) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_10 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_10(v)   BF_CS1(IPU_IDMAC_CH_PRI_2, IDMAC_CH_PRI_10, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_2, field IDMAC_CH_PRI_11 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_11      11
#define BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_11(v)   ((((reg32_t) v) << 11) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_11)
#else
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_11(v)   (((v) << 11) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_11 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_11(v)   BF_CS1(IPU_IDMAC_CH_PRI_2, IDMAC_CH_PRI_11, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_2, field IDMAC_CH_PRI_12 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_12      12
#define BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_12(v)   ((((reg32_t) v) << 12) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_12)
#else
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_12(v)   (((v) << 12) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_12 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_12(v)   BF_CS1(IPU_IDMAC_CH_PRI_2, IDMAC_CH_PRI_12, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_2, field IDMAC_CH_PRI_13 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_13      13
#define BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_13(v)   ((((reg32_t) v) << 13) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_13)
#else
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_13(v)   (((v) << 13) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_13 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_13(v)   BF_CS1(IPU_IDMAC_CH_PRI_2, IDMAC_CH_PRI_13, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_2, field IDMAC_CH_PRI_14 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_14      14
#define BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_14(v)   ((((reg32_t) v) << 14) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_14)
#else
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_14(v)   (((v) << 14) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_14 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_14(v)   BF_CS1(IPU_IDMAC_CH_PRI_2, IDMAC_CH_PRI_14, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_2, field IDMAC_CH_PRI_15 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_15      15
#define BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_15(v)   ((((reg32_t) v) << 15) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_15)
#else
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_15(v)   (((v) << 15) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_15 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_15(v)   BF_CS1(IPU_IDMAC_CH_PRI_2, IDMAC_CH_PRI_15, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_2, field IDMAC_CH_PRI_16 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_16      16
#define BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_16      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_16(v)   ((((reg32_t) v) << 16) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_16)
#else
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_16(v)   (((v) << 16) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_16 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_16(v)   BF_CS1(IPU_IDMAC_CH_PRI_2, IDMAC_CH_PRI_16, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_2, field IDMAC_CH_PRI_17 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_17      17
#define BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_17      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_17(v)   ((((reg32_t) v) << 17) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_17)
#else
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_17(v)   (((v) << 17) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_17 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_17(v)   BF_CS1(IPU_IDMAC_CH_PRI_2, IDMAC_CH_PRI_17, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_PRI_2, field IDMAC_CH_PRI_18 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] is in low priority
 * 1 - IDMAC channel [i] is in high priority
 */

#define BP_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_18      18
#define BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_18      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_18(v)   ((((reg32_t) v) << 18) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_18)
#else
#define BF_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_18(v)   (((v) << 18) & BM_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_PRI_18 field to a new value.
#define BW_IPU_IDMAC_CH_PRI_2_IDMAC_CH_PRI_18(v)   BF_CS1(IPU_IDMAC_CH_PRI_2, IDMAC_CH_PRI_18, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_WM_EN_2 - IDMAC Channel Watermark Enable 2 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 8; //!< Reserved.
        unsigned IDMAC_WM_EN__40 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__41 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__42 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__43 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__44 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned RESERVED1 : 19; //!< Reserved.
    } B;
} hw_ipu_idmac_wm_en_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_WM_EN_2 register
 */
#define HW_IPU_IDMAC_WM_EN_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x1f54)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_WM_EN_2(x)           (*(volatile hw_ipu_idmac_wm_en_2_t *) HW_IPU_IDMAC_WM_EN_2_ADDR(x))
#define HW_IPU_IDMAC_WM_EN_2_RD(x)        (HW_IPU_IDMAC_WM_EN_2(x).U)
#define HW_IPU_IDMAC_WM_EN_2_WR(x, v)     (HW_IPU_IDMAC_WM_EN_2(x).U = (v))
#define HW_IPU_IDMAC_WM_EN_2_SET(x, v)    (HW_IPU_IDMAC_WM_EN_2_WR(x, HW_IPU_IDMAC_WM_EN_2_RD(x) |  (v)))
#define HW_IPU_IDMAC_WM_EN_2_CLR(x, v)    (HW_IPU_IDMAC_WM_EN_2_WR(x, HW_IPU_IDMAC_WM_EN_2_RD(x) & ~(v)))
#define HW_IPU_IDMAC_WM_EN_2_TOG(x, v)    (HW_IPU_IDMAC_WM_EN_2_WR(x, HW_IPU_IDMAC_WM_EN_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_WM_EN_2 bitfields
 */

/* --- Register HW_IPU_IDMAC_WM_EN_2, field IDMAC_WM_EN__40 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__40      8
#define BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__40      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__40(v)   ((((reg32_t) v) << 8) & BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__40)
#else
#define BF_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__40(v)   (((v) << 8) & BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__40)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__40 field to a new value.
#define BW_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__40(v)   BF_CS1(IPU_IDMAC_WM_EN_2, IDMAC_WM_EN__40, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_2, field IDMAC_WM_EN__41 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__41      9
#define BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__41(v)   ((((reg32_t) v) << 9) & BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__41)
#else
#define BF_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__41(v)   (((v) << 9) & BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__41 field to a new value.
#define BW_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__41(v)   BF_CS1(IPU_IDMAC_WM_EN_2, IDMAC_WM_EN__41, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_2, field IDMAC_WM_EN__42 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__42      10
#define BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__42(v)   ((((reg32_t) v) << 10) & BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__42)
#else
#define BF_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__42(v)   (((v) << 10) & BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__42 field to a new value.
#define BW_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__42(v)   BF_CS1(IPU_IDMAC_WM_EN_2, IDMAC_WM_EN__42, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_2, field IDMAC_WM_EN__43 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__43      11
#define BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__43(v)   ((((reg32_t) v) << 11) & BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__43)
#else
#define BF_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__43(v)   (((v) << 11) & BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__43 field to a new value.
#define BW_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__43(v)   BF_CS1(IPU_IDMAC_WM_EN_2, IDMAC_WM_EN__43, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_2, field IDMAC_WM_EN__44 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__44      12
#define BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__44(v)   ((((reg32_t) v) << 12) & BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__44)
#else
#define BF_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__44(v)   (((v) << 12) & BM_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__44 field to a new value.
#define BW_IPU_IDMAC_WM_EN_2_IDMAC_WM_EN__44(v)   BF_CS1(IPU_IDMAC_WM_EN_2, IDMAC_WM_EN__44, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_LOCK_EN_1 - IDMAC Channel Lock Enable 1Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_LOCK_EN_5 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_EN_11 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_EN_12 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_EN_14 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_EN_15 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_EN_20 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_EN_21 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_EN_22 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_EN_23 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_EN_27 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_EN_28 : 2; //!< IDMAC lock bits for channel [i]
        unsigned RESERVED0 : 10; //!< Reserved.
    } B;
} hw_ipu_idmac_lock_en_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_LOCK_EN_1 register
 */
#define HW_IPU_IDMAC_LOCK_EN_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x1f58)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_LOCK_EN_1(x)           (*(volatile hw_ipu_idmac_lock_en_1_t *) HW_IPU_IDMAC_LOCK_EN_1_ADDR(x))
#define HW_IPU_IDMAC_LOCK_EN_1_RD(x)        (HW_IPU_IDMAC_LOCK_EN_1(x).U)
#define HW_IPU_IDMAC_LOCK_EN_1_WR(x, v)     (HW_IPU_IDMAC_LOCK_EN_1(x).U = (v))
#define HW_IPU_IDMAC_LOCK_EN_1_SET(x, v)    (HW_IPU_IDMAC_LOCK_EN_1_WR(x, HW_IPU_IDMAC_LOCK_EN_1_RD(x) |  (v)))
#define HW_IPU_IDMAC_LOCK_EN_1_CLR(x, v)    (HW_IPU_IDMAC_LOCK_EN_1_WR(x, HW_IPU_IDMAC_LOCK_EN_1_RD(x) & ~(v)))
#define HW_IPU_IDMAC_LOCK_EN_1_TOG(x, v)    (HW_IPU_IDMAC_LOCK_EN_1_WR(x, HW_IPU_IDMAC_LOCK_EN_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_LOCK_EN_1 bitfields
 */

/* --- Register HW_IPU_IDMAC_LOCK_EN_1, field IDMAC_LOCK_EN_5 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_5      0
#define BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_5      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_5(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_5)
#else
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_5(v)   (((v) << 0) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_EN_5 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_5(v)   BF_CS1(IPU_IDMAC_LOCK_EN_1, IDMAC_LOCK_EN_5, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_1, field IDMAC_LOCK_EN_11 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_11      2
#define BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_11      0x0000000c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_11(v)   ((((reg32_t) v) << 2) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_11)
#else
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_11(v)   (((v) << 2) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_EN_11 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_11(v)   BF_CS1(IPU_IDMAC_LOCK_EN_1, IDMAC_LOCK_EN_11, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_1, field IDMAC_LOCK_EN_12 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_12      4
#define BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_12      0x00000030

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_12(v)   ((((reg32_t) v) << 4) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_12)
#else
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_12(v)   (((v) << 4) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_EN_12 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_12(v)   BF_CS1(IPU_IDMAC_LOCK_EN_1, IDMAC_LOCK_EN_12, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_1, field IDMAC_LOCK_EN_14 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_14      6
#define BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_14      0x000000c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_14(v)   ((((reg32_t) v) << 6) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_14)
#else
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_14(v)   (((v) << 6) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_EN_14 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_14(v)   BF_CS1(IPU_IDMAC_LOCK_EN_1, IDMAC_LOCK_EN_14, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_1, field IDMAC_LOCK_EN_15 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_15      8
#define BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_15      0x00000300

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_15(v)   ((((reg32_t) v) << 8) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_15)
#else
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_15(v)   (((v) << 8) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_EN_15 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_15(v)   BF_CS1(IPU_IDMAC_LOCK_EN_1, IDMAC_LOCK_EN_15, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_1, field IDMAC_LOCK_EN_20 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_20      10
#define BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_20      0x00000c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_20(v)   ((((reg32_t) v) << 10) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_20)
#else
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_20(v)   (((v) << 10) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_EN_20 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_20(v)   BF_CS1(IPU_IDMAC_LOCK_EN_1, IDMAC_LOCK_EN_20, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_1, field IDMAC_LOCK_EN_21 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_21      12
#define BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_21      0x00003000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_21(v)   ((((reg32_t) v) << 12) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_21)
#else
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_21(v)   (((v) << 12) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_EN_21 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_21(v)   BF_CS1(IPU_IDMAC_LOCK_EN_1, IDMAC_LOCK_EN_21, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_1, field IDMAC_LOCK_EN_22 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_22      14
#define BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_22      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_22(v)   ((((reg32_t) v) << 14) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_22)
#else
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_22(v)   (((v) << 14) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_EN_22 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_22(v)   BF_CS1(IPU_IDMAC_LOCK_EN_1, IDMAC_LOCK_EN_22, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_1, field IDMAC_LOCK_EN_23 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_23      16
#define BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_23      0x00030000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_23(v)   ((((reg32_t) v) << 16) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_23)
#else
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_23(v)   (((v) << 16) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_EN_23 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_23(v)   BF_CS1(IPU_IDMAC_LOCK_EN_1, IDMAC_LOCK_EN_23, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_1, field IDMAC_LOCK_EN_27 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_27      18
#define BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_27      0x000c0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_27(v)   ((((reg32_t) v) << 18) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_27)
#else
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_27(v)   (((v) << 18) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_EN_27 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_27(v)   BF_CS1(IPU_IDMAC_LOCK_EN_1, IDMAC_LOCK_EN_27, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_1, field IDMAC_LOCK_EN_28 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_28      20
#define BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_28      0x00300000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_28(v)   ((((reg32_t) v) << 20) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_28)
#else
#define BF_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_28(v)   (((v) << 20) & BM_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_EN_28 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_1_IDMAC_LOCK_EN_28(v)   BF_CS1(IPU_IDMAC_LOCK_EN_1, IDMAC_LOCK_EN_28, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_CH_BUSY_1 - IDMAC Channel Busy 1 Register (RO)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_CH_BUSY_0 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_1 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_2 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_3 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_CH_BUSY_5 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned RESERVED1 : 2; //!< Reserved.
        unsigned IDMAC_CH_BUSY_8 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_9 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_10 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_11 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_12 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_13 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_14 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_15 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_CH_BUSY_17 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_18 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_CH_BUSY_20 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_21 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_22 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_23 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_24 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_25 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_26 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_27 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_28 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_29 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned RESERVED4 : 1; //!< Reserved.
        unsigned IDMAC_CH_BUSY_ : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
    } B;
} hw_ipu_idmac_ch_busy_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_CH_BUSY_1 register
 */
#define HW_IPU_IDMAC_CH_BUSY_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x1fa4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_CH_BUSY_1(x)           (*(volatile hw_ipu_idmac_ch_busy_1_t *) HW_IPU_IDMAC_CH_BUSY_1_ADDR(x))
#define HW_IPU_IDMAC_CH_BUSY_1_RD(x)        (HW_IPU_IDMAC_CH_BUSY_1(x).U)
#endif

/*
 * constants & macros for individual IPU_IDMAC_CH_BUSY_1 bitfields
 */

/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_0 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_0      0
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_0      0x00000001


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_1 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_1      1
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_1      0x00000002


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_2 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_2      2
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_2      0x00000004


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_3 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_3      3
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_3      0x00000008


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_5 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_5      5
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_5      0x00000020


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_8 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_8      8
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_8      0x00000100


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_9 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_9      9
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_9      0x00000200


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_10 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_10      10
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_10      0x00000400


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_11 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_11      11
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_11      0x00000800


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_12 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_12      12
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_12      0x00001000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_13 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_13      13
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_13      0x00002000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_14 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_14      14
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_14      0x00004000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_15 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_15      15
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_15      0x00008000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_17 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_17      17
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_17      0x00020000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_18 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_18      18
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_18      0x00040000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_20 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_20      20
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_20      0x00100000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_21 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_21      21
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_21      0x00200000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_22 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_22      22
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_22      0x00400000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_23 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_23      23
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_23      0x00800000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_24 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_24      24
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_24      0x01000000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_25 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_25      25
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_25      0x02000000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_26 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_26      26
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_26      0x04000000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_27 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_27      27
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_27      0x08000000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_28 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_28      28
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_28      0x10000000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_29 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_29      29
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_29      0x20000000


/* --- Register HW_IPU_IDMAC_CH_BUSY_1, field IDMAC_CH_BUSY_ (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_      31
#define BM_IPU_IDMAC_CH_BUSY_1_IDMAC_CH_BUSY_      0x80000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_CH_BUSY_2 - IDMAC Channel Busy 2 Register (RO)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_CH_BUSY_33 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_CH_BUSY_40 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_41 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_42 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_43 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_44 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_45 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_46 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_47 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_48 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_49 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_50 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_51 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned IDMAC_CH_BUSY_52 : 1; //!< IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC. This bit is self cleared by the IDMAC.
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_idmac_ch_busy_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_CH_BUSY_2 register
 */
#define HW_IPU_IDMAC_CH_BUSY_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x1fa8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_CH_BUSY_2(x)           (*(volatile hw_ipu_idmac_ch_busy_2_t *) HW_IPU_IDMAC_CH_BUSY_2_ADDR(x))
#define HW_IPU_IDMAC_CH_BUSY_2_RD(x)        (HW_IPU_IDMAC_CH_BUSY_2(x).U)
#endif

/*
 * constants & macros for individual IPU_IDMAC_CH_BUSY_2 bitfields
 */

/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_33 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_33      1
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_33      0x00000002


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_40 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_40      8
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_40      0x00000100


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_41 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_41      9
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_41      0x00000200


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_42 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_42      10
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_42      0x00000400


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_43 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_43      11
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_43      0x00000800


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_44 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_44      12
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_44      0x00001000


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_45 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_45      13
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_45      0x00002000


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_46 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_46      14
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_46      0x00004000


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_47 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_47      15
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_47      0x00008000


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_48 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_48      16
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_48      0x00010000


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_49 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_49      17
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_49      0x00020000


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_50 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_50      18
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_50      0x00040000


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_51 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_51      19
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_51      0x00080000


/* --- Register HW_IPU_IDMAC_CH_BUSY_2, field IDMAC_CH_BUSY_52 (RO)
 *
 * IDMAC Channel busy bit [i] This bit indicates if the channel is currently served by the IDMAC.
 * This bit is self cleared by the IDMAC.
 *
 * Values:
 * 0 - IDMAC channel [i] is not busy
 * 1 - IDMAC channel [i] is busy
 */

#define BP_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_52      20
#define BM_IPU_IDMAC_CH_BUSY_2_IDMAC_CH_BUSY_52      0x00100000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_SEP_ALPHA - IDMAC Separate Alpha Indication Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 14; //!< Reserved.
        unsigned IDMAC_SEP_AL_14 : 1; //!< IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case where the alpha should be read from a separate buffer, the user should set the channels corresponding.
        unsigned IDMAC_SEP_AL_15 : 1; //!< IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case where the alpha should be read from a separate buffer, the user should set the channels corresponding.
        unsigned RESERVED1 : 7; //!< Reserved.
        unsigned IDMAC_SEP_AL_23 : 1; //!< IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case where the alpha should be read from a separate buffer, the user should set the channels corresponding.
        unsigned IDMAC_SEP_AL_24 : 1; //!< IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case where the alpha should be read from a separate buffer, the user should set the channels corresponding.
        unsigned IDMAC_SEP_AL_25 : 1; //!< IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case where the alpha should be read from a separate buffer, the user should set the channels corresponding.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_SEP_AL_27 : 1; //!< IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case where the alpha should be read from a separate buffer, the user should set the channels corresponding.
        unsigned RESERVED3 : 1; //!< Reserved.
        unsigned IDMAC_SEP_AL_29 : 1; //!< IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's memory where the pixel data and the alpha transparency data are located in separate buffers. In that case the Alpha transparency data is read by the special Alpha channel. In a case where the alpha should be read from a separate buffer, the user should set the channels corresponding.
        unsigned RESERVED4 : 2; //!< Reserved.
    } B;
} hw_ipu_idmac_sep_alpha_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_SEP_ALPHA register
 */
#define HW_IPU_IDMAC_SEP_ALPHA_ADDR(x)      (REGS_IPU_BASE(x) + 0x800c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_SEP_ALPHA(x)           (*(volatile hw_ipu_idmac_sep_alpha_t *) HW_IPU_IDMAC_SEP_ALPHA_ADDR(x))
#define HW_IPU_IDMAC_SEP_ALPHA_RD(x)        (HW_IPU_IDMAC_SEP_ALPHA(x).U)
#define HW_IPU_IDMAC_SEP_ALPHA_WR(x, v)     (HW_IPU_IDMAC_SEP_ALPHA(x).U = (v))
#define HW_IPU_IDMAC_SEP_ALPHA_SET(x, v)    (HW_IPU_IDMAC_SEP_ALPHA_WR(x, HW_IPU_IDMAC_SEP_ALPHA_RD(x) |  (v)))
#define HW_IPU_IDMAC_SEP_ALPHA_CLR(x, v)    (HW_IPU_IDMAC_SEP_ALPHA_WR(x, HW_IPU_IDMAC_SEP_ALPHA_RD(x) & ~(v)))
#define HW_IPU_IDMAC_SEP_ALPHA_TOG(x, v)    (HW_IPU_IDMAC_SEP_ALPHA_WR(x, HW_IPU_IDMAC_SEP_ALPHA_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_SEP_ALPHA bitfields
 */

/* --- Register HW_IPU_IDMAC_SEP_ALPHA, field IDMAC_SEP_AL_14 (RW)
 *
 * IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's
 * memory where the pixel data and the alpha transparency data are located in separate buffers. In
 * that case the Alpha transparency data is read by the special Alpha channel. In a case where the
 * alpha should be read from a separate buffer, the user should set the channels corresponding.
 *
 * Values:
 * 0 - Channel [i] does not read Alpha transparency data from a separate buffer.
 * 1 - Channel [i] reads Alpha transparency data from a separate buffer.
 */

#define BP_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_14      14
#define BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_14(v)   ((((reg32_t) v) << 14) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_14)
#else
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_14(v)   (((v) << 14) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SEP_AL_14 field to a new value.
#define BW_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_14(v)   BF_CS1(IPU_IDMAC_SEP_ALPHA, IDMAC_SEP_AL_14, v)
#endif


/* --- Register HW_IPU_IDMAC_SEP_ALPHA, field IDMAC_SEP_AL_15 (RW)
 *
 * IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's
 * memory where the pixel data and the alpha transparency data are located in separate buffers. In
 * that case the Alpha transparency data is read by the special Alpha channel. In a case where the
 * alpha should be read from a separate buffer, the user should set the channels corresponding.
 *
 * Values:
 * 0 - Channel [i] does not read Alpha transparency data from a separate buffer.
 * 1 - Channel [i] reads Alpha transparency data from a separate buffer.
 */

#define BP_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_15      15
#define BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_15      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_15(v)   ((((reg32_t) v) << 15) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_15)
#else
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_15(v)   (((v) << 15) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SEP_AL_15 field to a new value.
#define BW_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_15(v)   BF_CS1(IPU_IDMAC_SEP_ALPHA, IDMAC_SEP_AL_15, v)
#endif


/* --- Register HW_IPU_IDMAC_SEP_ALPHA, field IDMAC_SEP_AL_23 (RW)
 *
 * IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's
 * memory where the pixel data and the alpha transparency data are located in separate buffers. In
 * that case the Alpha transparency data is read by the special Alpha channel. In a case where the
 * alpha should be read from a separate buffer, the user should set the channels corresponding.
 *
 * Values:
 * 0 - Channel [i] does not read Alpha transparency data from a separate buffer.
 * 1 - Channel [i] reads Alpha transparency data from a separate buffer.
 */

#define BP_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_23      23
#define BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_23(v)   ((((reg32_t) v) << 23) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_23)
#else
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_23(v)   (((v) << 23) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SEP_AL_23 field to a new value.
#define BW_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_23(v)   BF_CS1(IPU_IDMAC_SEP_ALPHA, IDMAC_SEP_AL_23, v)
#endif


/* --- Register HW_IPU_IDMAC_SEP_ALPHA, field IDMAC_SEP_AL_24 (RW)
 *
 * IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's
 * memory where the pixel data and the alpha transparency data are located in separate buffers. In
 * that case the Alpha transparency data is read by the special Alpha channel. In a case where the
 * alpha should be read from a separate buffer, the user should set the channels corresponding.
 *
 * Values:
 * 0 - Channel [i] does not read Alpha transparency data from a separate buffer.
 * 1 - Channel [i] reads Alpha transparency data from a separate buffer.
 */

#define BP_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_24      24
#define BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_24(v)   ((((reg32_t) v) << 24) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_24)
#else
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_24(v)   (((v) << 24) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SEP_AL_24 field to a new value.
#define BW_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_24(v)   BF_CS1(IPU_IDMAC_SEP_ALPHA, IDMAC_SEP_AL_24, v)
#endif


/* --- Register HW_IPU_IDMAC_SEP_ALPHA, field IDMAC_SEP_AL_25 (RW)
 *
 * IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's
 * memory where the pixel data and the alpha transparency data are located in separate buffers. In
 * that case the Alpha transparency data is read by the special Alpha channel. In a case where the
 * alpha should be read from a separate buffer, the user should set the channels corresponding.
 *
 * Values:
 * 0 - Channel [i] does not read Alpha transparency data from a separate buffer.
 * 1 - Channel [i] reads Alpha transparency data from a separate buffer.
 */

#define BP_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_25      25
#define BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_25(v)   ((((reg32_t) v) << 25) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_25)
#else
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_25(v)   (((v) << 25) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SEP_AL_25 field to a new value.
#define BW_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_25(v)   BF_CS1(IPU_IDMAC_SEP_ALPHA, IDMAC_SEP_AL_25, v)
#endif


/* --- Register HW_IPU_IDMAC_SEP_ALPHA, field IDMAC_SEP_AL_27 (RW)
 *
 * IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's
 * memory where the pixel data and the alpha transparency data are located in separate buffers. In
 * that case the Alpha transparency data is read by the special Alpha channel. In a case where the
 * alpha should be read from a separate buffer, the user should set the channels corresponding.
 *
 * Values:
 * 0 - Channel [i] does not read Alpha transparency data from a separate buffer.
 * 1 - Channel [i] reads Alpha transparency data from a separate buffer.
 */

#define BP_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_27      27
#define BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_27(v)   ((((reg32_t) v) << 27) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_27)
#else
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_27(v)   (((v) << 27) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SEP_AL_27 field to a new value.
#define BW_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_27(v)   BF_CS1(IPU_IDMAC_SEP_ALPHA, IDMAC_SEP_AL_27, v)
#endif


/* --- Register HW_IPU_IDMAC_SEP_ALPHA, field IDMAC_SEP_AL_29 (RW)
 *
 * IDMAC Separate alpha indication bit [i] A sub block may need to read data from the system's
 * memory where the pixel data and the alpha transparency data are located in separate buffers. In
 * that case the Alpha transparency data is read by the special Alpha channel. In a case where the
 * alpha should be read from a separate buffer, the user should set the channels corresponding.
 *
 * Values:
 * 0 - Channel [i] does not read Alpha transparency data from a separate buffer.
 * 1 - Channel [i] reads Alpha transparency data from a separate buffer.
 */

#define BP_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_29      29
#define BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_29(v)   ((((reg32_t) v) << 29) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_29)
#else
#define BF_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_29(v)   (((v) << 29) & BM_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SEP_AL_29 field to a new value.
#define BW_IPU_IDMAC_SEP_ALPHA_IDMAC_SEP_AL_29(v)   BF_CS1(IPU_IDMAC_SEP_ALPHA, IDMAC_SEP_AL_29, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_WM_EN_1 - IDMAC Channel Watermark Enable 1 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_WM_EN__0 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__1 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__2 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__3 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned IDMAC_WM_EN__8 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned RESERVED1 : 1; //!< Reserved.
        unsigned IDMAC_WM_EN__10 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_WM_EN__12 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__13 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__14 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned RESERVED3 : 8; //!< Reserved.
        unsigned IDMAC_WM_EN__23 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__24 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__25 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__26 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__27 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__28 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned IDMAC_WM_EN__29 : 1; //!< IDMAC Watermark enable bit [i]
        unsigned RESERVED4 : 2; //!< Reserved.
    } B;
} hw_ipu_idmac_wm_en_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_WM_EN_1 register
 */
#define HW_IPU_IDMAC_WM_EN_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x801c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_WM_EN_1(x)           (*(volatile hw_ipu_idmac_wm_en_1_t *) HW_IPU_IDMAC_WM_EN_1_ADDR(x))
#define HW_IPU_IDMAC_WM_EN_1_RD(x)        (HW_IPU_IDMAC_WM_EN_1(x).U)
#define HW_IPU_IDMAC_WM_EN_1_WR(x, v)     (HW_IPU_IDMAC_WM_EN_1(x).U = (v))
#define HW_IPU_IDMAC_WM_EN_1_SET(x, v)    (HW_IPU_IDMAC_WM_EN_1_WR(x, HW_IPU_IDMAC_WM_EN_1_RD(x) |  (v)))
#define HW_IPU_IDMAC_WM_EN_1_CLR(x, v)    (HW_IPU_IDMAC_WM_EN_1_WR(x, HW_IPU_IDMAC_WM_EN_1_RD(x) & ~(v)))
#define HW_IPU_IDMAC_WM_EN_1_TOG(x, v)    (HW_IPU_IDMAC_WM_EN_1_WR(x, HW_IPU_IDMAC_WM_EN_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_WM_EN_1 bitfields
 */

/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__0 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__0      0
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__0(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__0)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__0(v)   (((v) << 0) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__0 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__0(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__0, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__1 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__1      1
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__1(v)   ((((reg32_t) v) << 1) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__1)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__1(v)   (((v) << 1) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__1 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__1(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__1, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__2 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__2      2
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__2(v)   ((((reg32_t) v) << 2) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__2)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__2(v)   (((v) << 2) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__2 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__2(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__2, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__3 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__3      3
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__3(v)   ((((reg32_t) v) << 3) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__3)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__3(v)   (((v) << 3) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__3 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__3(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__3, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__8 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__8      8
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__8      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__8(v)   ((((reg32_t) v) << 8) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__8)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__8(v)   (((v) << 8) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__8 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__8(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__8, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__10 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__10      10
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__10      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__10(v)   ((((reg32_t) v) << 10) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__10)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__10(v)   (((v) << 10) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__10 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__10(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__10, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__12 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__12      12
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__12(v)   ((((reg32_t) v) << 12) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__12)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__12(v)   (((v) << 12) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__12 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__12(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__12, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__13 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__13      13
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__13      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__13(v)   ((((reg32_t) v) << 13) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__13)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__13(v)   (((v) << 13) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__13 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__13(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__13, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__14 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__14      14
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__14      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__14(v)   ((((reg32_t) v) << 14) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__14)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__14(v)   (((v) << 14) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__14 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__14(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__14, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__23 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__23      23
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__23      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__23(v)   ((((reg32_t) v) << 23) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__23)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__23(v)   (((v) << 23) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__23 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__23(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__23, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__24 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__24      24
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__24      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__24(v)   ((((reg32_t) v) << 24) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__24)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__24(v)   (((v) << 24) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__24 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__24(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__24, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__25 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__25      25
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__25(v)   ((((reg32_t) v) << 25) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__25)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__25(v)   (((v) << 25) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__25 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__25(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__25, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__26 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__26      26
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__26(v)   ((((reg32_t) v) << 26) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__26)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__26(v)   (((v) << 26) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__26 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__26(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__26, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__27 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__27      27
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__27      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__27(v)   ((((reg32_t) v) << 27) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__27)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__27(v)   (((v) << 27) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__27 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__27(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__27, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__28 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__28      28
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__28      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__28(v)   ((((reg32_t) v) << 28) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__28)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__28(v)   (((v) << 28) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__28 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__28(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__28, v)
#endif


/* --- Register HW_IPU_IDMAC_WM_EN_1, field IDMAC_WM_EN__29 (RW)
 *
 * IDMAC Watermark enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel [i] watermark feature is disabled
 * 1 - IDMAC channel [i] watermark feature is enabled
 */

#define BP_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__29      29
#define BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__29      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__29(v)   ((((reg32_t) v) << 29) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__29)
#else
#define BF_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__29(v)   (((v) << 29) & BM_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_WM_EN__29 field to a new value.
#define BW_IPU_IDMAC_WM_EN_1_IDMAC_WM_EN__29(v)   BF_CS1(IPU_IDMAC_WM_EN_1, IDMAC_WM_EN__29, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_SC_CORD_1 - IDMAC Scroll Coordinations Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SY1 : 11; //!< Scroll Y coordination (2nd set) This field indicates the Y coordinate of the scroll. This parameter has an affect on continuos scroll mode only. Units are pixels. When the alpha buffer resides in a separate buffer and the alpha is different than 8 BPP this field should be 0.
        unsigned RESERVED0 : 5; //!< Reserved, should be cleared.
        unsigned SX1 : 12; //!< Scroll X coordination (2nd set) This field indicates the X coordinate of the scroll. This parameter has an affect on continuos scroll mode only. Units are pixels. When the alpha buffer resides in a separate buffer and the alpha is different than 8 BPP this field should be 0.
        unsigned RESERVED1 : 4; //!< Reserved, should be cleared.
    } B;
} hw_ipu_idmac_sc_cord_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_SC_CORD_1 register
 */
#define HW_IPU_IDMAC_SC_CORD_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x804c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_SC_CORD_1(x)           (*(volatile hw_ipu_idmac_sc_cord_1_t *) HW_IPU_IDMAC_SC_CORD_1_ADDR(x))
#define HW_IPU_IDMAC_SC_CORD_1_RD(x)        (HW_IPU_IDMAC_SC_CORD_1(x).U)
#define HW_IPU_IDMAC_SC_CORD_1_WR(x, v)     (HW_IPU_IDMAC_SC_CORD_1(x).U = (v))
#define HW_IPU_IDMAC_SC_CORD_1_SET(x, v)    (HW_IPU_IDMAC_SC_CORD_1_WR(x, HW_IPU_IDMAC_SC_CORD_1_RD(x) |  (v)))
#define HW_IPU_IDMAC_SC_CORD_1_CLR(x, v)    (HW_IPU_IDMAC_SC_CORD_1_WR(x, HW_IPU_IDMAC_SC_CORD_1_RD(x) & ~(v)))
#define HW_IPU_IDMAC_SC_CORD_1_TOG(x, v)    (HW_IPU_IDMAC_SC_CORD_1_WR(x, HW_IPU_IDMAC_SC_CORD_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_SC_CORD_1 bitfields
 */

/* --- Register HW_IPU_IDMAC_SC_CORD_1, field SY1 (RW)
 *
 * Scroll Y coordination (2nd set) This field indicates the Y coordinate of the scroll. This
 * parameter has an affect on continuos scroll mode only. Units are pixels. When the alpha buffer
 * resides in a separate buffer and the alpha is different than 8 BPP this field should be 0.
 */

#define BP_IPU_IDMAC_SC_CORD_1_SY1      0
#define BM_IPU_IDMAC_SC_CORD_1_SY1      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SC_CORD_1_SY1(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_SC_CORD_1_SY1)
#else
#define BF_IPU_IDMAC_SC_CORD_1_SY1(v)   (((v) << 0) & BM_IPU_IDMAC_SC_CORD_1_SY1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SY1 field to a new value.
#define BW_IPU_IDMAC_SC_CORD_1_SY1(v)   BF_CS1(IPU_IDMAC_SC_CORD_1, SY1, v)
#endif

/* --- Register HW_IPU_IDMAC_SC_CORD_1, field SX1 (RW)
 *
 * Scroll X coordination (2nd set) This field indicates the X coordinate of the scroll. This
 * parameter has an affect on continuos scroll mode only. Units are pixels. When the alpha buffer
 * resides in a separate buffer and the alpha is different than 8 BPP this field should be 0.
 */

#define BP_IPU_IDMAC_SC_CORD_1_SX1      16
#define BM_IPU_IDMAC_SC_CORD_1_SX1      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SC_CORD_1_SX1(v)   ((((reg32_t) v) << 16) & BM_IPU_IDMAC_SC_CORD_1_SX1)
#else
#define BF_IPU_IDMAC_SC_CORD_1_SX1(v)   (((v) << 16) & BM_IPU_IDMAC_SC_CORD_1_SX1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SX1 field to a new value.
#define BW_IPU_IDMAC_SC_CORD_1_SX1(v)   BF_CS1(IPU_IDMAC_SC_CORD_1, SX1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_CH_EN_2 - IDMAC Channel Enable 2 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_CH_EN_33 : 1; //!< IDMAC Channel enable bit [i]
        unsigned RESERVED1 : 6; //!< Reserved.
        unsigned IDMAC_CH_EN_40 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_41 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_42 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_43 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_44 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_45 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_46 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_47 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_48 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_49 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_50 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_51 : 1; //!< IDMAC Channel enable bit [i]
        unsigned IDMAC_CH_EN_52 : 1; //!< IDMAC Channel enable bit [i]
        unsigned RESERVED2 : 11; //!< Reserved.
    } B;
} hw_ipu_idmac_ch_en_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_CH_EN_2 register
 */
#define HW_IPU_IDMAC_CH_EN_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x13888)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_CH_EN_2(x)           (*(volatile hw_ipu_idmac_ch_en_2_t *) HW_IPU_IDMAC_CH_EN_2_ADDR(x))
#define HW_IPU_IDMAC_CH_EN_2_RD(x)        (HW_IPU_IDMAC_CH_EN_2(x).U)
#define HW_IPU_IDMAC_CH_EN_2_WR(x, v)     (HW_IPU_IDMAC_CH_EN_2(x).U = (v))
#define HW_IPU_IDMAC_CH_EN_2_SET(x, v)    (HW_IPU_IDMAC_CH_EN_2_WR(x, HW_IPU_IDMAC_CH_EN_2_RD(x) |  (v)))
#define HW_IPU_IDMAC_CH_EN_2_CLR(x, v)    (HW_IPU_IDMAC_CH_EN_2_WR(x, HW_IPU_IDMAC_CH_EN_2_RD(x) & ~(v)))
#define HW_IPU_IDMAC_CH_EN_2_TOG(x, v)    (HW_IPU_IDMAC_CH_EN_2_WR(x, HW_IPU_IDMAC_CH_EN_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_CH_EN_2 bitfields
 */

/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_33 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_33      1
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_33      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_33(v)   ((((reg32_t) v) << 1) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_33)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_33(v)   (((v) << 1) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_33)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_33 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_33(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_33, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_40 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_40      8
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_40      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_40(v)   ((((reg32_t) v) << 8) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_40)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_40(v)   (((v) << 8) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_40)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_40 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_40(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_40, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_41 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_41      9
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_41      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_41(v)   ((((reg32_t) v) << 9) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_41)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_41(v)   (((v) << 9) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_41 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_41(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_41, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_42 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_42      10
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_42      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_42(v)   ((((reg32_t) v) << 10) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_42)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_42(v)   (((v) << 10) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_42)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_42 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_42(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_42, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_43 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_43      11
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_43      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_43(v)   ((((reg32_t) v) << 11) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_43)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_43(v)   (((v) << 11) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_43)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_43 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_43(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_43, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_44 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_44      12
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_44      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_44(v)   ((((reg32_t) v) << 12) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_44)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_44(v)   (((v) << 12) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_44)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_44 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_44(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_44, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_45 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_45      13
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_45(v)   ((((reg32_t) v) << 13) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_45)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_45(v)   (((v) << 13) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_45 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_45(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_45, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_46 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_46      14
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_46(v)   ((((reg32_t) v) << 14) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_46)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_46(v)   (((v) << 14) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_46 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_46(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_46, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_47 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_47      15
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_47(v)   ((((reg32_t) v) << 15) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_47)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_47(v)   (((v) << 15) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_47 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_47(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_47, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_48 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_48      16
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_48(v)   ((((reg32_t) v) << 16) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_48)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_48(v)   (((v) << 16) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_48 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_48(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_48, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_49 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_49      17
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_49(v)   ((((reg32_t) v) << 17) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_49)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_49(v)   (((v) << 17) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_49 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_49(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_49, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_50 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_50      18
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_50(v)   ((((reg32_t) v) << 18) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_50)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_50(v)   (((v) << 18) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_50 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_50(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_50, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_51 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_51      19
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_51      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_51(v)   ((((reg32_t) v) << 19) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_51)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_51(v)   (((v) << 19) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_51 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_51(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_51, v)
#endif


/* --- Register HW_IPU_IDMAC_CH_EN_2, field IDMAC_CH_EN_52 (RW)
 *
 * IDMAC Channel enable bit [i]
 *
 * Values:
 * 0 - IDMAC channel is disabled
 * 1 - IDMAC channel is enabled
 */

#define BP_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_52      20
#define BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_52      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_52(v)   ((((reg32_t) v) << 20) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_52)
#else
#define BF_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_52(v)   (((v) << 20) & BM_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_CH_EN_52 field to a new value.
#define BW_IPU_IDMAC_CH_EN_2_IDMAC_CH_EN_52(v)   BF_CS1(IPU_IDMAC_CH_EN_2, IDMAC_CH_EN_52, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_LOCK_EN_2 - IDMAC Channel Lock Enable 2Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_LOCK_45 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_46 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_47 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_48 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_49 : 2; //!< IDMAC lock bits for channel [i]
        unsigned IDMAC_LOCK_50 : 2; //!< IDMAC lock bits for channel [i]
        unsigned RESERVED0 : 20; //!< Reserved
    } B;
} hw_ipu_idmac_lock_en_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_LOCK_EN_2 register
 */
#define HW_IPU_IDMAC_LOCK_EN_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x13978)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_LOCK_EN_2(x)           (*(volatile hw_ipu_idmac_lock_en_2_t *) HW_IPU_IDMAC_LOCK_EN_2_ADDR(x))
#define HW_IPU_IDMAC_LOCK_EN_2_RD(x)        (HW_IPU_IDMAC_LOCK_EN_2(x).U)
#define HW_IPU_IDMAC_LOCK_EN_2_WR(x, v)     (HW_IPU_IDMAC_LOCK_EN_2(x).U = (v))
#define HW_IPU_IDMAC_LOCK_EN_2_SET(x, v)    (HW_IPU_IDMAC_LOCK_EN_2_WR(x, HW_IPU_IDMAC_LOCK_EN_2_RD(x) |  (v)))
#define HW_IPU_IDMAC_LOCK_EN_2_CLR(x, v)    (HW_IPU_IDMAC_LOCK_EN_2_WR(x, HW_IPU_IDMAC_LOCK_EN_2_RD(x) & ~(v)))
#define HW_IPU_IDMAC_LOCK_EN_2_TOG(x, v)    (HW_IPU_IDMAC_LOCK_EN_2_WR(x, HW_IPU_IDMAC_LOCK_EN_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_LOCK_EN_2 bitfields
 */

/* --- Register HW_IPU_IDMAC_LOCK_EN_2, field IDMAC_LOCK_45 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_45      0
#define BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_45      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_45(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_45)
#else
#define BF_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_45(v)   (((v) << 0) & BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_45 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_45(v)   BF_CS1(IPU_IDMAC_LOCK_EN_2, IDMAC_LOCK_45, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_2, field IDMAC_LOCK_46 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_46      2
#define BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_46      0x0000000c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_46(v)   ((((reg32_t) v) << 2) & BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_46)
#else
#define BF_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_46(v)   (((v) << 2) & BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_46 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_46(v)   BF_CS1(IPU_IDMAC_LOCK_EN_2, IDMAC_LOCK_46, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_2, field IDMAC_LOCK_47 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_47      4
#define BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_47      0x00000030

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_47(v)   ((((reg32_t) v) << 4) & BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_47)
#else
#define BF_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_47(v)   (((v) << 4) & BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_47 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_47(v)   BF_CS1(IPU_IDMAC_LOCK_EN_2, IDMAC_LOCK_47, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_2, field IDMAC_LOCK_48 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_48      6
#define BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_48      0x000000c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_48(v)   ((((reg32_t) v) << 6) & BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_48)
#else
#define BF_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_48(v)   (((v) << 6) & BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_48 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_48(v)   BF_CS1(IPU_IDMAC_LOCK_EN_2, IDMAC_LOCK_48, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_2, field IDMAC_LOCK_49 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_49      8
#define BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_49      0x00000300

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_49(v)   ((((reg32_t) v) << 8) & BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_49)
#else
#define BF_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_49(v)   (((v) << 8) & BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_49 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_49(v)   BF_CS1(IPU_IDMAC_LOCK_EN_2, IDMAC_LOCK_49, v)
#endif


/* --- Register HW_IPU_IDMAC_LOCK_EN_2, field IDMAC_LOCK_50 (RW)
 *
 * IDMAC lock bits for channel [i]
 *
 * Values:
 * 00 - The lock feature is disabled. The IDMAC will generate one AXI burst upon the assertion of the DMA
 *     request.
 * 01 - The IDMAC will generate two AXI bursts upon the assertion of the DMA request.
 * 10 - The IDMAC will generate four AXI bursts upon the assertion of the DMA request.
 * 11 - The IDMAC will generate eight AXI bursts upon the assertion of the DMA request.
 */

#define BP_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_50      10
#define BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_50      0x00000c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_50(v)   ((((reg32_t) v) << 10) & BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_50)
#else
#define BF_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_50(v)   (((v) << 10) & BM_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_LOCK_50 field to a new value.
#define BW_IPU_IDMAC_LOCK_EN_2_IDMAC_LOCK_50(v)   BF_CS1(IPU_IDMAC_LOCK_EN_2, IDMAC_LOCK_50, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_SUB_ADDR_2 - IDMAC Channel Alternate Address 2 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_SUB_ADDR_41 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_SUB_ADDR_51 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED1 : 1; //!< Reserved.
        unsigned IDMAC_SUB_ADDR_52 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED2 : 9; //!< Reserved.
    } B;
} hw_ipu_idmac_sub_addr_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_SUB_ADDR_2 register
 */
#define HW_IPU_IDMAC_SUB_ADDR_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x139b0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_SUB_ADDR_2(x)           (*(volatile hw_ipu_idmac_sub_addr_2_t *) HW_IPU_IDMAC_SUB_ADDR_2_ADDR(x))
#define HW_IPU_IDMAC_SUB_ADDR_2_RD(x)        (HW_IPU_IDMAC_SUB_ADDR_2(x).U)
#define HW_IPU_IDMAC_SUB_ADDR_2_WR(x, v)     (HW_IPU_IDMAC_SUB_ADDR_2(x).U = (v))
#define HW_IPU_IDMAC_SUB_ADDR_2_SET(x, v)    (HW_IPU_IDMAC_SUB_ADDR_2_WR(x, HW_IPU_IDMAC_SUB_ADDR_2_RD(x) |  (v)))
#define HW_IPU_IDMAC_SUB_ADDR_2_CLR(x, v)    (HW_IPU_IDMAC_SUB_ADDR_2_WR(x, HW_IPU_IDMAC_SUB_ADDR_2_RD(x) & ~(v)))
#define HW_IPU_IDMAC_SUB_ADDR_2_TOG(x, v)    (HW_IPU_IDMAC_SUB_ADDR_2_WR(x, HW_IPU_IDMAC_SUB_ADDR_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_SUB_ADDR_2 bitfields
 */

/* --- Register HW_IPU_IDMAC_SUB_ADDR_2, field IDMAC_SUB_ADDR_41 (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_41      0
#define BM_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_41      0x0000007f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_41(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_41)
#else
#define BF_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_41(v)   (((v) << 0) & BM_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_41)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR_41 field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_41(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_2, IDMAC_SUB_ADDR_41, v)
#endif

/* --- Register HW_IPU_IDMAC_SUB_ADDR_2, field IDMAC_SUB_ADDR_51 (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_51      8
#define BM_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_51      0x00007f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_51(v)   ((((reg32_t) v) << 8) & BM_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_51)
#else
#define BF_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_51(v)   (((v) << 8) & BM_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_51)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR_51 field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_51(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_2, IDMAC_SUB_ADDR_51, v)
#endif

/* --- Register HW_IPU_IDMAC_SUB_ADDR_2, field IDMAC_SUB_ADDR_52 (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_52      16
#define BM_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_52      0x007f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_52(v)   ((((reg32_t) v) << 16) & BM_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_52)
#else
#define BF_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_52(v)   (((v) << 16) & BM_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_52)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR_52 field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_2_IDMAC_SUB_ADDR_52(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_2, IDMAC_SUB_ADDR_52, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_SUB_ADDR_3 - IDMAC Channel Alternate Address 3 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_SUB_ADDR_9 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_SUB_ADDR_10 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED1 : 1; //!< Reserved.
        unsigned IDMAC_SUB_ADDR_13 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_SUB_ADDR_27 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED3 : 1; //!< Reserved.
    } B;
} hw_ipu_idmac_sub_addr_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_SUB_ADDR_3 register
 */
#define HW_IPU_IDMAC_SUB_ADDR_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x139b4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_SUB_ADDR_3(x)           (*(volatile hw_ipu_idmac_sub_addr_3_t *) HW_IPU_IDMAC_SUB_ADDR_3_ADDR(x))
#define HW_IPU_IDMAC_SUB_ADDR_3_RD(x)        (HW_IPU_IDMAC_SUB_ADDR_3(x).U)
#define HW_IPU_IDMAC_SUB_ADDR_3_WR(x, v)     (HW_IPU_IDMAC_SUB_ADDR_3(x).U = (v))
#define HW_IPU_IDMAC_SUB_ADDR_3_SET(x, v)    (HW_IPU_IDMAC_SUB_ADDR_3_WR(x, HW_IPU_IDMAC_SUB_ADDR_3_RD(x) |  (v)))
#define HW_IPU_IDMAC_SUB_ADDR_3_CLR(x, v)    (HW_IPU_IDMAC_SUB_ADDR_3_WR(x, HW_IPU_IDMAC_SUB_ADDR_3_RD(x) & ~(v)))
#define HW_IPU_IDMAC_SUB_ADDR_3_TOG(x, v)    (HW_IPU_IDMAC_SUB_ADDR_3_WR(x, HW_IPU_IDMAC_SUB_ADDR_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_SUB_ADDR_3 bitfields
 */

/* --- Register HW_IPU_IDMAC_SUB_ADDR_3, field IDMAC_SUB_ADDR_9 (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_9      0
#define BM_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_9      0x0000007f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_9(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_9)
#else
#define BF_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_9(v)   (((v) << 0) & BM_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR_9 field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_9(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_3, IDMAC_SUB_ADDR_9, v)
#endif

/* --- Register HW_IPU_IDMAC_SUB_ADDR_3, field IDMAC_SUB_ADDR_10 (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_10      8
#define BM_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_10      0x00007f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_10(v)   ((((reg32_t) v) << 8) & BM_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_10)
#else
#define BF_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_10(v)   (((v) << 8) & BM_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR_10 field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_10(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_3, IDMAC_SUB_ADDR_10, v)
#endif

/* --- Register HW_IPU_IDMAC_SUB_ADDR_3, field IDMAC_SUB_ADDR_13 (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_13      16
#define BM_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_13      0x007f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_13(v)   ((((reg32_t) v) << 16) & BM_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_13)
#else
#define BF_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_13(v)   (((v) << 16) & BM_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR_13 field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_13(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_3, IDMAC_SUB_ADDR_13, v)
#endif

/* --- Register HW_IPU_IDMAC_SUB_ADDR_3, field IDMAC_SUB_ADDR_27 (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_27      24
#define BM_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_27      0x7f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_27(v)   ((((reg32_t) v) << 24) & BM_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_27)
#else
#define BF_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_27(v)   (((v) << 24) & BM_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR_27 field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_3_IDMAC_SUB_ADDR_27(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_3, IDMAC_SUB_ADDR_27, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_BNDM_EN_1 - IDMAC Band Mode Enable 1 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_BNDM_EN_0 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned IDMAC_BNDM_EN_1 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned IDMAC_BNDM_EN_2 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned IDMAC_BNDM_EN_3 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_BNDM_EN_5 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned RESERVED1 : 5; //!< Reserved.
        unsigned IDMAC_BNDM_EN_11 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned IDMAC_BNDM_EN_12 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned RESERVED2 : 7; //!< Reserved.
        unsigned IDMAC_BNDM_EN_20 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned IDMAC_BNDM_EN_21 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned IDMAC_BNDM_EN_22 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned RESERVED3 : 2; //!< Reserved.
        unsigned IDMAC_BNDM_EN_25 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned IDMAC_BNDM_EN_26 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned RESERVED4 : 5; //!< Reserved.
    } B;
} hw_ipu_idmac_bndm_en_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_BNDM_EN_1 register
 */
#define HW_IPU_IDMAC_BNDM_EN_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x13a38)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_BNDM_EN_1(x)           (*(volatile hw_ipu_idmac_bndm_en_1_t *) HW_IPU_IDMAC_BNDM_EN_1_ADDR(x))
#define HW_IPU_IDMAC_BNDM_EN_1_RD(x)        (HW_IPU_IDMAC_BNDM_EN_1(x).U)
#define HW_IPU_IDMAC_BNDM_EN_1_WR(x, v)     (HW_IPU_IDMAC_BNDM_EN_1(x).U = (v))
#define HW_IPU_IDMAC_BNDM_EN_1_SET(x, v)    (HW_IPU_IDMAC_BNDM_EN_1_WR(x, HW_IPU_IDMAC_BNDM_EN_1_RD(x) |  (v)))
#define HW_IPU_IDMAC_BNDM_EN_1_CLR(x, v)    (HW_IPU_IDMAC_BNDM_EN_1_WR(x, HW_IPU_IDMAC_BNDM_EN_1_RD(x) & ~(v)))
#define HW_IPU_IDMAC_BNDM_EN_1_TOG(x, v)    (HW_IPU_IDMAC_BNDM_EN_1_WR(x, HW_IPU_IDMAC_BNDM_EN_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_BNDM_EN_1 bitfields
 */

/* --- Register HW_IPU_IDMAC_BNDM_EN_1, field IDMAC_BNDM_EN_0 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_0      0
#define BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_0)
#else
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_0(v)   (((v) << 0) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_0 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_0(v)   BF_CS1(IPU_IDMAC_BNDM_EN_1, IDMAC_BNDM_EN_0, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_1, field IDMAC_BNDM_EN_1 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_1      1
#define BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_1(v)   ((((reg32_t) v) << 1) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_1)
#else
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_1(v)   (((v) << 1) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_1 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_1(v)   BF_CS1(IPU_IDMAC_BNDM_EN_1, IDMAC_BNDM_EN_1, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_1, field IDMAC_BNDM_EN_2 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_2      2
#define BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_2(v)   ((((reg32_t) v) << 2) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_2)
#else
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_2(v)   (((v) << 2) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_2 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_2(v)   BF_CS1(IPU_IDMAC_BNDM_EN_1, IDMAC_BNDM_EN_2, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_1, field IDMAC_BNDM_EN_3 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_3      3
#define BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_3      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_3(v)   ((((reg32_t) v) << 3) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_3)
#else
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_3(v)   (((v) << 3) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_3 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_3(v)   BF_CS1(IPU_IDMAC_BNDM_EN_1, IDMAC_BNDM_EN_3, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_1, field IDMAC_BNDM_EN_5 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_5      5
#define BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_5(v)   ((((reg32_t) v) << 5) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_5)
#else
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_5(v)   (((v) << 5) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_5 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_5(v)   BF_CS1(IPU_IDMAC_BNDM_EN_1, IDMAC_BNDM_EN_5, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_1, field IDMAC_BNDM_EN_11 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_11      11
#define BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_11      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_11(v)   ((((reg32_t) v) << 11) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_11)
#else
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_11(v)   (((v) << 11) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_11 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_11(v)   BF_CS1(IPU_IDMAC_BNDM_EN_1, IDMAC_BNDM_EN_11, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_1, field IDMAC_BNDM_EN_12 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_12      12
#define BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_12      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_12(v)   ((((reg32_t) v) << 12) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_12)
#else
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_12(v)   (((v) << 12) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_12 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_12(v)   BF_CS1(IPU_IDMAC_BNDM_EN_1, IDMAC_BNDM_EN_12, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_1, field IDMAC_BNDM_EN_20 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_20      20
#define BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_20      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_20(v)   ((((reg32_t) v) << 20) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_20)
#else
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_20(v)   (((v) << 20) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_20 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_20(v)   BF_CS1(IPU_IDMAC_BNDM_EN_1, IDMAC_BNDM_EN_20, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_1, field IDMAC_BNDM_EN_21 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_21      21
#define BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_21      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_21(v)   ((((reg32_t) v) << 21) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_21)
#else
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_21(v)   (((v) << 21) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_21 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_21(v)   BF_CS1(IPU_IDMAC_BNDM_EN_1, IDMAC_BNDM_EN_21, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_1, field IDMAC_BNDM_EN_22 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_22      22
#define BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_22      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_22(v)   ((((reg32_t) v) << 22) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_22)
#else
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_22(v)   (((v) << 22) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_22 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_22(v)   BF_CS1(IPU_IDMAC_BNDM_EN_1, IDMAC_BNDM_EN_22, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_1, field IDMAC_BNDM_EN_25 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_25      25
#define BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_25      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_25(v)   ((((reg32_t) v) << 25) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_25)
#else
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_25(v)   (((v) << 25) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_25 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_25(v)   BF_CS1(IPU_IDMAC_BNDM_EN_1, IDMAC_BNDM_EN_25, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_1, field IDMAC_BNDM_EN_26 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_26      26
#define BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_26      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_26(v)   ((((reg32_t) v) << 26) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_26)
#else
#define BF_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_26(v)   (((v) << 26) & BM_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_26 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_1_IDMAC_BNDM_EN_26(v)   BF_CS1(IPU_IDMAC_BNDM_EN_1, IDMAC_BNDM_EN_26, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_DEBUG_CNT - DP Debug Control Register (RW)
 *
 * This is the debug unit control register. This register is not stored in the SRM.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned BRAKE_STATUS_EN_0 : 1; //!< This bit enables the break/status unit #0
        unsigned BRAKE_CNT_0 : 3; //!< The async flow can be broken multiple times. It possible to control which breaking event will cause the interrupt. This field counts the breaking events for unit #0
        unsigned BRAKE_STATUS_EN_1 : 1; //!< This bit enables the break/status unit #1
        unsigned BRAKE_CNT_1 : 3; //!< The async flow can be broken multiple times. It possible to control which breaking event will cause the interrupt. This field counts the breaking events for unit #1
        unsigned RESERVED0 : 24; //!< Reserved
    } B;
} hw_ipu_dp_debug_cnt_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_DEBUG_CNT register
 */
#define HW_IPU_DP_DEBUG_CNT_ADDR(x)      (REGS_IPU_BASE(x) + 0x180bc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_DEBUG_CNT(x)           (*(volatile hw_ipu_dp_debug_cnt_t *) HW_IPU_DP_DEBUG_CNT_ADDR(x))
#define HW_IPU_DP_DEBUG_CNT_RD(x)        (HW_IPU_DP_DEBUG_CNT(x).U)
#define HW_IPU_DP_DEBUG_CNT_WR(x, v)     (HW_IPU_DP_DEBUG_CNT(x).U = (v))
#define HW_IPU_DP_DEBUG_CNT_SET(x, v)    (HW_IPU_DP_DEBUG_CNT_WR(x, HW_IPU_DP_DEBUG_CNT_RD(x) |  (v)))
#define HW_IPU_DP_DEBUG_CNT_CLR(x, v)    (HW_IPU_DP_DEBUG_CNT_WR(x, HW_IPU_DP_DEBUG_CNT_RD(x) & ~(v)))
#define HW_IPU_DP_DEBUG_CNT_TOG(x, v)    (HW_IPU_DP_DEBUG_CNT_WR(x, HW_IPU_DP_DEBUG_CNT_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_DEBUG_CNT bitfields
 */

/* --- Register HW_IPU_DP_DEBUG_CNT, field BRAKE_STATUS_EN_0 (RW)
 *
 * This bit enables the break/status unit #0
 */

#define BP_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_0      0
#define BM_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_0      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_0)
#else
#define BF_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_0(v)   (((v) << 0) & BM_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the BRAKE_STATUS_EN_0 field to a new value.
#define BW_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_0(v)   BF_CS1(IPU_DP_DEBUG_CNT, BRAKE_STATUS_EN_0, v)
#endif

/* --- Register HW_IPU_DP_DEBUG_CNT, field BRAKE_CNT_0 (RW)
 *
 * The async flow can be broken multiple times. It possible to control which breaking event will
 * cause the interrupt. This field counts the breaking events for unit #0
 */

#define BP_IPU_DP_DEBUG_CNT_BRAKE_CNT_0      1
#define BM_IPU_DP_DEBUG_CNT_BRAKE_CNT_0      0x0000000e

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_DEBUG_CNT_BRAKE_CNT_0(v)   ((((reg32_t) v) << 1) & BM_IPU_DP_DEBUG_CNT_BRAKE_CNT_0)
#else
#define BF_IPU_DP_DEBUG_CNT_BRAKE_CNT_0(v)   (((v) << 1) & BM_IPU_DP_DEBUG_CNT_BRAKE_CNT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the BRAKE_CNT_0 field to a new value.
#define BW_IPU_DP_DEBUG_CNT_BRAKE_CNT_0(v)   BF_CS1(IPU_DP_DEBUG_CNT, BRAKE_CNT_0, v)
#endif

/* --- Register HW_IPU_DP_DEBUG_CNT, field BRAKE_STATUS_EN_1 (RW)
 *
 * This bit enables the break/status unit #1
 */

#define BP_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_1      4
#define BM_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_1      0x00000010

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_1(v)   ((((reg32_t) v) << 4) & BM_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_1)
#else
#define BF_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_1(v)   (((v) << 4) & BM_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the BRAKE_STATUS_EN_1 field to a new value.
#define BW_IPU_DP_DEBUG_CNT_BRAKE_STATUS_EN_1(v)   BF_CS1(IPU_DP_DEBUG_CNT, BRAKE_STATUS_EN_1, v)
#endif

/* --- Register HW_IPU_DP_DEBUG_CNT, field BRAKE_CNT_1 (RW)
 *
 * The async flow can be broken multiple times. It possible to control which breaking event will
 * cause the interrupt. This field counts the breaking events for unit #1
 */

#define BP_IPU_DP_DEBUG_CNT_BRAKE_CNT_1      5
#define BM_IPU_DP_DEBUG_CNT_BRAKE_CNT_1      0x000000e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_DEBUG_CNT_BRAKE_CNT_1(v)   ((((reg32_t) v) << 5) & BM_IPU_DP_DEBUG_CNT_BRAKE_CNT_1)
#else
#define BF_IPU_DP_DEBUG_CNT_BRAKE_CNT_1(v)   (((v) << 5) & BM_IPU_DP_DEBUG_CNT_BRAKE_CNT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the BRAKE_CNT_1 field to a new value.
#define BW_IPU_DP_DEBUG_CNT_BRAKE_CNT_1(v)   BF_CS1(IPU_DP_DEBUG_CNT, BRAKE_CNT_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_DEBUG_STAT - DP Debug Status Register (RO)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned V_CNT_OLD_0 : 11; //!< The exact row where the async flow has been broken (This filed is relevant for debug unit #0)
        unsigned FG_ACTIVE_0 : 1; //!< Displaying the partial frame has been started for async flow (This filed is relevant for debug unit #0)
        unsigned COMBYP_EN_OLD_0 : 1; //!< the async flow has been broken in the middle of combining (This filed is relevant for debug unit #0)
        unsigned CYP_EN_OLD_0 : 1; //!< The async flow has been broken in the middle of a cursor (This filed is relevant for debug unit #0)
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned V_CNT_OLD_1 : 11; //!< The exact row where the async flow has been broken (This filed is relevant for debug unit #0)
        unsigned FG_ACTIVE_1 : 1; //!< Displaying the partial frame has been started (This filed is relevant for debug unit #1)
        unsigned COMBYP_EN_OLD_1 : 1; //!< the async1 flow has been broken in the middle of combining (This filed is relevant for debug unit #1)
        unsigned CYP_EN_OLD_1 : 1; //!< The async flow has been broken in the middle of a cursor (This filed is relevant for debug unit #1)
        unsigned RESERVED1 : 2; //!< Reserved
    } B;
} hw_ipu_dp_debug_stat_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_DEBUG_STAT register
 */
#define HW_IPU_DP_DEBUG_STAT_ADDR(x)      (REGS_IPU_BASE(x) + 0x180c0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_DEBUG_STAT(x)           (*(volatile hw_ipu_dp_debug_stat_t *) HW_IPU_DP_DEBUG_STAT_ADDR(x))
#define HW_IPU_DP_DEBUG_STAT_RD(x)        (HW_IPU_DP_DEBUG_STAT(x).U)
#endif

/*
 * constants & macros for individual IPU_DP_DEBUG_STAT bitfields
 */

/* --- Register HW_IPU_DP_DEBUG_STAT, field V_CNT_OLD_0 (RO)
 *
 * The exact row where the async flow has been broken (This filed is relevant for debug unit #0)
 */

#define BP_IPU_DP_DEBUG_STAT_V_CNT_OLD_0      0
#define BM_IPU_DP_DEBUG_STAT_V_CNT_OLD_0      0x000007ff

/* --- Register HW_IPU_DP_DEBUG_STAT, field FG_ACTIVE_0 (RO)
 *
 * Displaying the partial frame has been started for async flow (This filed is relevant for debug
 * unit #0)
 */

#define BP_IPU_DP_DEBUG_STAT_FG_ACTIVE_0      11
#define BM_IPU_DP_DEBUG_STAT_FG_ACTIVE_0      0x00000800

/* --- Register HW_IPU_DP_DEBUG_STAT, field COMBYP_EN_OLD_0 (RO)
 *
 * the async flow has been broken in the middle of combining (This filed is relevant for debug unit
 * #0)
 */

#define BP_IPU_DP_DEBUG_STAT_COMBYP_EN_OLD_0      12
#define BM_IPU_DP_DEBUG_STAT_COMBYP_EN_OLD_0      0x00001000

/* --- Register HW_IPU_DP_DEBUG_STAT, field CYP_EN_OLD_0 (RO)
 *
 * The async flow has been broken in the middle of a cursor (This filed is relevant for debug unit
 * #0)
 */

#define BP_IPU_DP_DEBUG_STAT_CYP_EN_OLD_0      13
#define BM_IPU_DP_DEBUG_STAT_CYP_EN_OLD_0      0x00002000

/* --- Register HW_IPU_DP_DEBUG_STAT, field V_CNT_OLD_1 (RO)
 *
 * The exact row where the async flow has been broken (This filed is relevant for debug unit #0)
 */

#define BP_IPU_DP_DEBUG_STAT_V_CNT_OLD_1      16
#define BM_IPU_DP_DEBUG_STAT_V_CNT_OLD_1      0x07ff0000

/* --- Register HW_IPU_DP_DEBUG_STAT, field FG_ACTIVE_1 (RO)
 *
 * Displaying the partial frame has been started (This filed is relevant for debug unit #1)
 */

#define BP_IPU_DP_DEBUG_STAT_FG_ACTIVE_1      27
#define BM_IPU_DP_DEBUG_STAT_FG_ACTIVE_1      0x08000000

/* --- Register HW_IPU_DP_DEBUG_STAT, field COMBYP_EN_OLD_1 (RO)
 *
 * the async1 flow has been broken in the middle of combining (This filed is relevant for debug unit
 * #1)
 */

#define BP_IPU_DP_DEBUG_STAT_COMBYP_EN_OLD_1      28
#define BM_IPU_DP_DEBUG_STAT_COMBYP_EN_OLD_1      0x10000000

/* --- Register HW_IPU_DP_DEBUG_STAT, field CYP_EN_OLD_1 (RO)
 *
 * The async flow has been broken in the middle of a cursor (This filed is relevant for debug unit
 * #1)
 */

#define BP_IPU_DP_DEBUG_STAT_CYP_EN_OLD_1      29
#define BM_IPU_DP_DEBUG_STAT_CYP_EN_OLD_1      0x20000000

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IC_CONF - IC Configuration Register (RW)
 *
 * This register contains control parameter for IC 3 tasks (pre-processing for encoding, pre-
 * processing for view-finder and post processing).
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned PRPENC_EN : 1; //!< Preprocessing Task for encoding enable. This bit enables the encoding task.
        unsigned PRPENC_CSC1 : 1; //!< Preprocessing Task for encoding color conversion enable. This bit enables color conversion.
        unsigned PRPENC_ROT_EN : 1; //!< Preprocessing Rotation Task for encoding enable. This bit enable Preprocessing Rotation Task for encoding.
        unsigned RESERVED0 : 5; //!< Reserved
        unsigned PRPVF_EN : 1; //!< Preprocessing Task for View-Finder enable. This bit enables the View-Finder task.
        unsigned PRPVF_CSC1 : 1; //!< Pre-processing task for view-finder first color conversion enable. This bit enables first color conversion.
        unsigned PRPVF_CSC2 : 1; //!< Pre-processing task for view-finder second color conversion enable. This bit enables second color conversion. Reserved
        unsigned PRPVF_CMB : 1; //!< Preprocessing Task for View-Finder combining enable. This bit enables combining.
        unsigned PRPVF_ROT_EN : 1; //!< Preprocessing Rotation Task for viewfinder enable. This bit enable Preprocessing Rotation Task for viewfinder.
        unsigned RESERVED1 : 3; //!< Reserved
        unsigned PP_EN : 1; //!< Post-Processing Task enable. This bit enables the Post-Processing task.
        unsigned PP_CSC1 : 1; //!< Post-Processing Task color conversion YUV-->RGB enable. This bit enables YUV-->RGB.
        unsigned PP_CSC2 : 1; //!< Post-Processing Task color conversion RGB-->YUV enable. This bit enables YUV-->RGB. Reserved
        unsigned PP_CMB : 1; //!< Post-Processing Task combining enable. This bit enables combining.
        unsigned PP_ROT_EN : 1; //!< Post-Processing Rotation Task enable. This bit enable Post-Processing Rotation Task.
        unsigned RESERVED2 : 7; //!< Reserved
        unsigned IC_GLB_LOC_A : 1; //!< Global Alpha. This bit select the source of Alpha parameter.
        unsigned IC_KEY_COLOR_EN : 1; //!< Key Color enable. This bit enables the key color feature.
        unsigned RWS_EN : 1; //!< Raw sensor enable. This bit indicate if a Raw sensor is attached (Bayer format). This bit is used together with the CSI_MEM_WR_EN bit as follows: CSI_MEM_WR_EN=0, RWS_EN=0 - data is fed from the CSI to the IC for processing; CSI_MEM_WR_EN=1, RWS_EN=0 - data is fed from the CSI to the IC for processing and also for writing to the system memory; CSI_MEM_WR_EN=0, RWS_EN=1 - data is fed from the CSI to the system memory (via the IC) and from the system memory to the IC for processing; CSI_MEM_WR_EN=1, RWS_EN=1 - non-valid configuration. On IPUv3D this bit should be always set (1)
        unsigned CSI_MEM_WR_EN : 1; //!< CSI direct memory write enable. This bit enables writing data from sensor directly to memory even when a raw sensor is not attached. On IPUv3D this bit should be always clear (0)
    } B;
} hw_ipu_ic_conf_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IC_CONF register
 */
#define HW_IPU_IC_CONF_ADDR(x)      (REGS_IPU_BASE(x) + 0x20000)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IC_CONF(x)           (*(volatile hw_ipu_ic_conf_t *) HW_IPU_IC_CONF_ADDR(x))
#define HW_IPU_IC_CONF_RD(x)        (HW_IPU_IC_CONF(x).U)
#define HW_IPU_IC_CONF_WR(x, v)     (HW_IPU_IC_CONF(x).U = (v))
#define HW_IPU_IC_CONF_SET(x, v)    (HW_IPU_IC_CONF_WR(x, HW_IPU_IC_CONF_RD(x) |  (v)))
#define HW_IPU_IC_CONF_CLR(x, v)    (HW_IPU_IC_CONF_WR(x, HW_IPU_IC_CONF_RD(x) & ~(v)))
#define HW_IPU_IC_CONF_TOG(x, v)    (HW_IPU_IC_CONF_WR(x, HW_IPU_IC_CONF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IC_CONF bitfields
 */

/* --- Register HW_IPU_IC_CONF, field PRPENC_EN (RW)
 *
 * Preprocessing Task for encoding enable. This bit enables the encoding task.
 *
 * Values:
 * 0 - Task is disabled.
 * 1 - Task is enabled.
 */

#define BP_IPU_IC_CONF_PRPENC_EN      0
#define BM_IPU_IC_CONF_PRPENC_EN      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PRPENC_EN(v)   ((((reg32_t) v) << 0) & BM_IPU_IC_CONF_PRPENC_EN)
#else
#define BF_IPU_IC_CONF_PRPENC_EN(v)   (((v) << 0) & BM_IPU_IC_CONF_PRPENC_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPENC_EN field to a new value.
#define BW_IPU_IC_CONF_PRPENC_EN(v)   BF_CS1(IPU_IC_CONF, PRPENC_EN, v)
#endif


/* --- Register HW_IPU_IC_CONF, field PRPENC_CSC1 (RW)
 *
 * Preprocessing Task for encoding color conversion enable. This bit enables color conversion.
 *
 * Values:
 * 0 - Color conversion is disabled.
 * 1 - Color conversion is enabled.
 */

#define BP_IPU_IC_CONF_PRPENC_CSC1      1
#define BM_IPU_IC_CONF_PRPENC_CSC1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PRPENC_CSC1(v)   ((((reg32_t) v) << 1) & BM_IPU_IC_CONF_PRPENC_CSC1)
#else
#define BF_IPU_IC_CONF_PRPENC_CSC1(v)   (((v) << 1) & BM_IPU_IC_CONF_PRPENC_CSC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPENC_CSC1 field to a new value.
#define BW_IPU_IC_CONF_PRPENC_CSC1(v)   BF_CS1(IPU_IC_CONF, PRPENC_CSC1, v)
#endif


/* --- Register HW_IPU_IC_CONF, field PRPENC_ROT_EN (RW)
 *
 * Preprocessing Rotation Task for encoding enable. This bit enable Preprocessing Rotation Task for
 * encoding.
 *
 * Values:
 * 0 - Rotation is disabled.
 * 1 - Rotation is enabled.
 */

#define BP_IPU_IC_CONF_PRPENC_ROT_EN      2
#define BM_IPU_IC_CONF_PRPENC_ROT_EN      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PRPENC_ROT_EN(v)   ((((reg32_t) v) << 2) & BM_IPU_IC_CONF_PRPENC_ROT_EN)
#else
#define BF_IPU_IC_CONF_PRPENC_ROT_EN(v)   (((v) << 2) & BM_IPU_IC_CONF_PRPENC_ROT_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPENC_ROT_EN field to a new value.
#define BW_IPU_IC_CONF_PRPENC_ROT_EN(v)   BF_CS1(IPU_IC_CONF, PRPENC_ROT_EN, v)
#endif


/* --- Register HW_IPU_IC_CONF, field PRPVF_EN (RW)
 *
 * Preprocessing Task for View-Finder enable. This bit enables the View-Finder task.
 *
 * Values:
 * 0 - Task is disabled.
 * 1 - Task is enabled.
 */

#define BP_IPU_IC_CONF_PRPVF_EN      8
#define BM_IPU_IC_CONF_PRPVF_EN      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PRPVF_EN(v)   ((((reg32_t) v) << 8) & BM_IPU_IC_CONF_PRPVF_EN)
#else
#define BF_IPU_IC_CONF_PRPVF_EN(v)   (((v) << 8) & BM_IPU_IC_CONF_PRPVF_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPVF_EN field to a new value.
#define BW_IPU_IC_CONF_PRPVF_EN(v)   BF_CS1(IPU_IC_CONF, PRPVF_EN, v)
#endif


/* --- Register HW_IPU_IC_CONF, field PRPVF_CSC1 (RW)
 *
 * Pre-processing task for view-finder first color conversion enable. This bit enables first color
 * conversion.
 *
 * Values:
 * 0 - First color conversion is disabled.
 * 1 - First color conversion is enabled.
 */

#define BP_IPU_IC_CONF_PRPVF_CSC1      9
#define BM_IPU_IC_CONF_PRPVF_CSC1      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PRPVF_CSC1(v)   ((((reg32_t) v) << 9) & BM_IPU_IC_CONF_PRPVF_CSC1)
#else
#define BF_IPU_IC_CONF_PRPVF_CSC1(v)   (((v) << 9) & BM_IPU_IC_CONF_PRPVF_CSC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPVF_CSC1 field to a new value.
#define BW_IPU_IC_CONF_PRPVF_CSC1(v)   BF_CS1(IPU_IC_CONF, PRPVF_CSC1, v)
#endif


/* --- Register HW_IPU_IC_CONF, field PRPVF_CSC2 (RW)
 *
 * Pre-processing task for view-finder second color conversion enable. This bit enables second color
 * conversion. Reserved
 */

#define BP_IPU_IC_CONF_PRPVF_CSC2      10
#define BM_IPU_IC_CONF_PRPVF_CSC2      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PRPVF_CSC2(v)   ((((reg32_t) v) << 10) & BM_IPU_IC_CONF_PRPVF_CSC2)
#else
#define BF_IPU_IC_CONF_PRPVF_CSC2(v)   (((v) << 10) & BM_IPU_IC_CONF_PRPVF_CSC2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPVF_CSC2 field to a new value.
#define BW_IPU_IC_CONF_PRPVF_CSC2(v)   BF_CS1(IPU_IC_CONF, PRPVF_CSC2, v)
#endif

/* --- Register HW_IPU_IC_CONF, field PRPVF_CMB (RW)
 *
 * Preprocessing Task for View-Finder combining enable. This bit enables combining.
 *
 * Values:
 * 0 - Combining is disabled.
 * 1 - Combining is enabled.
 */

#define BP_IPU_IC_CONF_PRPVF_CMB      11
#define BM_IPU_IC_CONF_PRPVF_CMB      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PRPVF_CMB(v)   ((((reg32_t) v) << 11) & BM_IPU_IC_CONF_PRPVF_CMB)
#else
#define BF_IPU_IC_CONF_PRPVF_CMB(v)   (((v) << 11) & BM_IPU_IC_CONF_PRPVF_CMB)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPVF_CMB field to a new value.
#define BW_IPU_IC_CONF_PRPVF_CMB(v)   BF_CS1(IPU_IC_CONF, PRPVF_CMB, v)
#endif


/* --- Register HW_IPU_IC_CONF, field PRPVF_ROT_EN (RW)
 *
 * Preprocessing Rotation Task for viewfinder enable. This bit enable Preprocessing Rotation Task
 * for viewfinder.
 *
 * Values:
 * 0 - Rotation is disabled.
 * 1 - Rotation is enabled.
 */

#define BP_IPU_IC_CONF_PRPVF_ROT_EN      12
#define BM_IPU_IC_CONF_PRPVF_ROT_EN      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PRPVF_ROT_EN(v)   ((((reg32_t) v) << 12) & BM_IPU_IC_CONF_PRPVF_ROT_EN)
#else
#define BF_IPU_IC_CONF_PRPVF_ROT_EN(v)   (((v) << 12) & BM_IPU_IC_CONF_PRPVF_ROT_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPVF_ROT_EN field to a new value.
#define BW_IPU_IC_CONF_PRPVF_ROT_EN(v)   BF_CS1(IPU_IC_CONF, PRPVF_ROT_EN, v)
#endif


/* --- Register HW_IPU_IC_CONF, field PP_EN (RW)
 *
 * Post-Processing Task enable. This bit enables the Post-Processing task.
 *
 * Values:
 * 0 - Task is disabled.
 * 1 - Task is enabled.
 */

#define BP_IPU_IC_CONF_PP_EN      16
#define BM_IPU_IC_CONF_PP_EN      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PP_EN(v)   ((((reg32_t) v) << 16) & BM_IPU_IC_CONF_PP_EN)
#else
#define BF_IPU_IC_CONF_PP_EN(v)   (((v) << 16) & BM_IPU_IC_CONF_PP_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_EN field to a new value.
#define BW_IPU_IC_CONF_PP_EN(v)   BF_CS1(IPU_IC_CONF, PP_EN, v)
#endif


/* --- Register HW_IPU_IC_CONF, field PP_CSC1 (RW)
 *
 * Post-Processing Task color conversion YUV-->RGB enable. This bit enables YUV-->RGB.
 *
 * Values:
 * 0 - YUV-->RGB is disabled.
 * 1 - YUV-->RGB is enabled.
 */

#define BP_IPU_IC_CONF_PP_CSC1      17
#define BM_IPU_IC_CONF_PP_CSC1      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PP_CSC1(v)   ((((reg32_t) v) << 17) & BM_IPU_IC_CONF_PP_CSC1)
#else
#define BF_IPU_IC_CONF_PP_CSC1(v)   (((v) << 17) & BM_IPU_IC_CONF_PP_CSC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_CSC1 field to a new value.
#define BW_IPU_IC_CONF_PP_CSC1(v)   BF_CS1(IPU_IC_CONF, PP_CSC1, v)
#endif


/* --- Register HW_IPU_IC_CONF, field PP_CSC2 (RW)
 *
 * Post-Processing Task color conversion RGB-->YUV enable. This bit enables YUV-->RGB. Reserved
 *
 * Values:
 * 0 - RGB-->YUV is disabled.
 * 1 - RGB-->YUV is enabled.
 */

#define BP_IPU_IC_CONF_PP_CSC2      18
#define BM_IPU_IC_CONF_PP_CSC2      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PP_CSC2(v)   ((((reg32_t) v) << 18) & BM_IPU_IC_CONF_PP_CSC2)
#else
#define BF_IPU_IC_CONF_PP_CSC2(v)   (((v) << 18) & BM_IPU_IC_CONF_PP_CSC2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_CSC2 field to a new value.
#define BW_IPU_IC_CONF_PP_CSC2(v)   BF_CS1(IPU_IC_CONF, PP_CSC2, v)
#endif


/* --- Register HW_IPU_IC_CONF, field PP_CMB (RW)
 *
 * Post-Processing Task combining enable. This bit enables combining.
 *
 * Values:
 * 0 - Combining is disabled.
 * 1 - Combining is enabled.
 */

#define BP_IPU_IC_CONF_PP_CMB      19
#define BM_IPU_IC_CONF_PP_CMB      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PP_CMB(v)   ((((reg32_t) v) << 19) & BM_IPU_IC_CONF_PP_CMB)
#else
#define BF_IPU_IC_CONF_PP_CMB(v)   (((v) << 19) & BM_IPU_IC_CONF_PP_CMB)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_CMB field to a new value.
#define BW_IPU_IC_CONF_PP_CMB(v)   BF_CS1(IPU_IC_CONF, PP_CMB, v)
#endif


/* --- Register HW_IPU_IC_CONF, field PP_ROT_EN (RW)
 *
 * Post-Processing Rotation Task enable. This bit enable Post-Processing Rotation Task.
 *
 * Values:
 * 0 - Rotation is disabled.
 * 1 - Rotation is enabled.
 */

#define BP_IPU_IC_CONF_PP_ROT_EN      20
#define BM_IPU_IC_CONF_PP_ROT_EN      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_PP_ROT_EN(v)   ((((reg32_t) v) << 20) & BM_IPU_IC_CONF_PP_ROT_EN)
#else
#define BF_IPU_IC_CONF_PP_ROT_EN(v)   (((v) << 20) & BM_IPU_IC_CONF_PP_ROT_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_ROT_EN field to a new value.
#define BW_IPU_IC_CONF_PP_ROT_EN(v)   BF_CS1(IPU_IC_CONF, PP_ROT_EN, v)
#endif


/* --- Register HW_IPU_IC_CONF, field IC_GLB_LOC_A (RW)
 *
 * Global Alpha. This bit select the source of Alpha parameter.
 *
 * Values:
 * 0 - Alpha parameter is local.
 * 1 - Alpha parameter is global.
 */

#define BP_IPU_IC_CONF_IC_GLB_LOC_A      28
#define BM_IPU_IC_CONF_IC_GLB_LOC_A      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_IC_GLB_LOC_A(v)   ((((reg32_t) v) << 28) & BM_IPU_IC_CONF_IC_GLB_LOC_A)
#else
#define BF_IPU_IC_CONF_IC_GLB_LOC_A(v)   (((v) << 28) & BM_IPU_IC_CONF_IC_GLB_LOC_A)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_GLB_LOC_A field to a new value.
#define BW_IPU_IC_CONF_IC_GLB_LOC_A(v)   BF_CS1(IPU_IC_CONF, IC_GLB_LOC_A, v)
#endif


/* --- Register HW_IPU_IC_CONF, field IC_KEY_COLOR_EN (RW)
 *
 * Key Color enable. This bit enables the key color feature.
 *
 * Values:
 * 0 - Key color is disabled.
 * 1 - Key color is enabled.
 */

#define BP_IPU_IC_CONF_IC_KEY_COLOR_EN      29
#define BM_IPU_IC_CONF_IC_KEY_COLOR_EN      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_IC_KEY_COLOR_EN(v)   ((((reg32_t) v) << 29) & BM_IPU_IC_CONF_IC_KEY_COLOR_EN)
#else
#define BF_IPU_IC_CONF_IC_KEY_COLOR_EN(v)   (((v) << 29) & BM_IPU_IC_CONF_IC_KEY_COLOR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_KEY_COLOR_EN field to a new value.
#define BW_IPU_IC_CONF_IC_KEY_COLOR_EN(v)   BF_CS1(IPU_IC_CONF, IC_KEY_COLOR_EN, v)
#endif


/* --- Register HW_IPU_IC_CONF, field RWS_EN (RW)
 *
 * Raw sensor enable. This bit indicate if a Raw sensor is attached (Bayer format). This bit is used
 * together with the CSI_MEM_WR_EN bit as follows: CSI_MEM_WR_EN=0, RWS_EN=0 - data is fed from the
 * CSI to the IC for processing; CSI_MEM_WR_EN=1, RWS_EN=0 - data is fed from the CSI to the IC for
 * processing and also for writing to the system memory; CSI_MEM_WR_EN=0, RWS_EN=1 - data is fed
 * from the CSI to the system memory (via the IC) and from the system memory to the IC for
 * processing; CSI_MEM_WR_EN=1, RWS_EN=1 - non-valid configuration. On IPUv3D this bit should be
 * always set (1)
 *
 * Values:
 * 0 - Raw sensor is not attached.
 * 1 - Raw sensor is attached.
 */

#define BP_IPU_IC_CONF_RWS_EN      30
#define BM_IPU_IC_CONF_RWS_EN      0x40000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_RWS_EN(v)   ((((reg32_t) v) << 30) & BM_IPU_IC_CONF_RWS_EN)
#else
#define BF_IPU_IC_CONF_RWS_EN(v)   (((v) << 30) & BM_IPU_IC_CONF_RWS_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the RWS_EN field to a new value.
#define BW_IPU_IC_CONF_RWS_EN(v)   BF_CS1(IPU_IC_CONF, RWS_EN, v)
#endif


/* --- Register HW_IPU_IC_CONF, field CSI_MEM_WR_EN (RW)
 *
 * CSI direct memory write enable. This bit enables writing data from sensor directly to memory even
 * when a raw sensor is not attached. On IPUv3D this bit should be always clear (0)
 *
 * Values:
 * 0 - CSI direct writing to memory is disabled.
 * 1 - CSI direct writing to memory is enabled.
 */

#define BP_IPU_IC_CONF_CSI_MEM_WR_EN      31
#define BM_IPU_IC_CONF_CSI_MEM_WR_EN      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CONF_CSI_MEM_WR_EN(v)   ((((reg32_t) v) << 31) & BM_IPU_IC_CONF_CSI_MEM_WR_EN)
#else
#define BF_IPU_IC_CONF_CSI_MEM_WR_EN(v)   (((v) << 31) & BM_IPU_IC_CONF_CSI_MEM_WR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI_MEM_WR_EN field to a new value.
#define BW_IPU_IC_CONF_CSI_MEM_WR_EN(v)   BF_CS1(IPU_IC_CONF, CSI_MEM_WR_EN, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IC_PRP_ENC_RSC - IC Preprocessing Encoder Resizing Coefficients Register (RW)
 *
 * This register contains the resizing and downsizing parameters for Preprocessing task for
 * encoding.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned PRPENC_RS_R_H : 14; //!< Preprocessing task for encoding Resizing horizontal Ratio. This field contains the resizing horizontal coefficient of Preprocessing for Encoding. Resizing Ratio is equal to PRPENC_RS_R_H: M Where M = 2^13; SI - input size; SO - output size PRPENC_RS_R_H = floor(M*(SI-1)/(SO-1));
        unsigned PRPENC_DS_R_H : 2; //!< Preprocessing task for encoding Downsizing horizontal Ratio. This field contains the downsizing horizontal coefficient of Preprocessing for Encoding. Values:
        unsigned PRPENC_RS_R_V : 14; //!< Preprocessing task for encoding Resizing vertical Ratio. This field contains the resizing vertical coefficient of Preprocessing for Encoding. Resizing Ratio is equal to PRPENC_RS_R_V: M Where M = 2^13; SI - input size; SO - output size PRPENC_RS_R_V = floor(M*(SI-1)/(SO-1));
        unsigned PRPENC_DS_R_V : 2; //!< Preprocessing task for encoding Downsizing vertical Ratio. This field contains the downsizing vertical coefficient of Preprocessing for Encoding.
    } B;
} hw_ipu_ic_prp_enc_rsc_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IC_PRP_ENC_RSC register
 */
#define HW_IPU_IC_PRP_ENC_RSC_ADDR(x)      (REGS_IPU_BASE(x) + 0x20004)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IC_PRP_ENC_RSC(x)           (*(volatile hw_ipu_ic_prp_enc_rsc_t *) HW_IPU_IC_PRP_ENC_RSC_ADDR(x))
#define HW_IPU_IC_PRP_ENC_RSC_RD(x)        (HW_IPU_IC_PRP_ENC_RSC(x).U)
#define HW_IPU_IC_PRP_ENC_RSC_WR(x, v)     (HW_IPU_IC_PRP_ENC_RSC(x).U = (v))
#define HW_IPU_IC_PRP_ENC_RSC_SET(x, v)    (HW_IPU_IC_PRP_ENC_RSC_WR(x, HW_IPU_IC_PRP_ENC_RSC_RD(x) |  (v)))
#define HW_IPU_IC_PRP_ENC_RSC_CLR(x, v)    (HW_IPU_IC_PRP_ENC_RSC_WR(x, HW_IPU_IC_PRP_ENC_RSC_RD(x) & ~(v)))
#define HW_IPU_IC_PRP_ENC_RSC_TOG(x, v)    (HW_IPU_IC_PRP_ENC_RSC_WR(x, HW_IPU_IC_PRP_ENC_RSC_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IC_PRP_ENC_RSC bitfields
 */

/* --- Register HW_IPU_IC_PRP_ENC_RSC, field PRPENC_RS_R_H (RW)
 *
 * Preprocessing task for encoding Resizing horizontal Ratio. This field contains the resizing
 * horizontal coefficient of Preprocessing for Encoding. Resizing Ratio is equal to PRPENC_RS_R_H: M
 * Where M = 2^13; SI - input size; SO - output size PRPENC_RS_R_H = floor(M*(SI-1)/(SO-1));
 */

#define BP_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_H      0
#define BM_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_H      0x00003fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_H(v)   ((((reg32_t) v) << 0) & BM_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_H)
#else
#define BF_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_H(v)   (((v) << 0) & BM_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_H)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPENC_RS_R_H field to a new value.
#define BW_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_H(v)   BF_CS1(IPU_IC_PRP_ENC_RSC, PRPENC_RS_R_H, v)
#endif

/* --- Register HW_IPU_IC_PRP_ENC_RSC, field PRPENC_DS_R_H (RW)
 *
 * Preprocessing task for encoding Downsizing horizontal Ratio. This field contains the downsizing
 * horizontal coefficient of Preprocessing for Encoding. Values:
 *
 * Values:
 * 00 - 1
 * 01 - 2
 * 10 - 4
 * 11 - RSV
 */

#define BP_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_H      14
#define BM_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_H      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_H(v)   ((((reg32_t) v) << 14) & BM_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_H)
#else
#define BF_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_H(v)   (((v) << 14) & BM_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_H)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPENC_DS_R_H field to a new value.
#define BW_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_H(v)   BF_CS1(IPU_IC_PRP_ENC_RSC, PRPENC_DS_R_H, v)
#endif


/* --- Register HW_IPU_IC_PRP_ENC_RSC, field PRPENC_RS_R_V (RW)
 *
 * Preprocessing task for encoding Resizing vertical Ratio. This field contains the resizing
 * vertical coefficient of Preprocessing for Encoding. Resizing Ratio is equal to PRPENC_RS_R_V: M
 * Where M = 2^13; SI - input size; SO - output size PRPENC_RS_R_V = floor(M*(SI-1)/(SO-1));
 */

#define BP_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_V      16
#define BM_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_V      0x3fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_V(v)   ((((reg32_t) v) << 16) & BM_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_V)
#else
#define BF_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_V(v)   (((v) << 16) & BM_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_V)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPENC_RS_R_V field to a new value.
#define BW_IPU_IC_PRP_ENC_RSC_PRPENC_RS_R_V(v)   BF_CS1(IPU_IC_PRP_ENC_RSC, PRPENC_RS_R_V, v)
#endif

/* --- Register HW_IPU_IC_PRP_ENC_RSC, field PRPENC_DS_R_V (RW)
 *
 * Preprocessing task for encoding Downsizing vertical Ratio. This field contains the downsizing
 * vertical coefficient of Preprocessing for Encoding.
 */

#define BP_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_V      30
#define BM_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_V      0xc0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_V(v)   ((((reg32_t) v) << 30) & BM_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_V)
#else
#define BF_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_V(v)   (((v) << 30) & BM_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_V)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPENC_DS_R_V field to a new value.
#define BW_IPU_IC_PRP_ENC_RSC_PRPENC_DS_R_V(v)   BF_CS1(IPU_IC_PRP_ENC_RSC, PRPENC_DS_R_V, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IC_PRP_VF_RSC - IC Preprocessing View-Finder Resizing Coefficients Register (RW)
 *
 * This register contains the resizing and downsizing parameters for preprocessing task for display.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned PRPVF_RS_R_H : 14; //!< Preprocessing task for view-finding resizing horizontal ratio. This field contains the resizing horizontal coefficient of preprocessing Task For View-finder. Resizing Ratio is equal to PRPVF_RS_R_H: M Where M = 2^13; SI - input size; SO - output size PRPVF_RS_R_H = floor(M*(SI-1)/(SO-1));
        unsigned PRPVF_DS_R_H : 2; //!< Preprocessing task for encoding Downsizing horizontal Ratio. This field contains the downsizing horizontal coefficient of Preprocessing for View-Finder. Values:
        unsigned PRPVF_RS_R_V : 14; //!< Preprocessing task for encoding Resizing vertical Ratio. This field contains the resizing vertical coefficient of Preprocessing for View-Finder. Resizing Ratio is equal to PRPVF_RS_R_V: M Where M = 2^13; SI - input size; SO - output size PRPVF_RS_R_V = floor(M*(SI-1)/(SO-1));
        unsigned PRPVF_DS_R_V : 2; //!< Preprocessing task for encoding Downsizing vertical Ratio. This field contains the downsizing vertical coefficient of Preprocessing for View-Finder.
    } B;
} hw_ipu_ic_prp_vf_rsc_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IC_PRP_VF_RSC register
 */
#define HW_IPU_IC_PRP_VF_RSC_ADDR(x)      (REGS_IPU_BASE(x) + 0x20008)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IC_PRP_VF_RSC(x)           (*(volatile hw_ipu_ic_prp_vf_rsc_t *) HW_IPU_IC_PRP_VF_RSC_ADDR(x))
#define HW_IPU_IC_PRP_VF_RSC_RD(x)        (HW_IPU_IC_PRP_VF_RSC(x).U)
#define HW_IPU_IC_PRP_VF_RSC_WR(x, v)     (HW_IPU_IC_PRP_VF_RSC(x).U = (v))
#define HW_IPU_IC_PRP_VF_RSC_SET(x, v)    (HW_IPU_IC_PRP_VF_RSC_WR(x, HW_IPU_IC_PRP_VF_RSC_RD(x) |  (v)))
#define HW_IPU_IC_PRP_VF_RSC_CLR(x, v)    (HW_IPU_IC_PRP_VF_RSC_WR(x, HW_IPU_IC_PRP_VF_RSC_RD(x) & ~(v)))
#define HW_IPU_IC_PRP_VF_RSC_TOG(x, v)    (HW_IPU_IC_PRP_VF_RSC_WR(x, HW_IPU_IC_PRP_VF_RSC_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IC_PRP_VF_RSC bitfields
 */

/* --- Register HW_IPU_IC_PRP_VF_RSC, field PRPVF_RS_R_H (RW)
 *
 * Preprocessing task for view-finding resizing horizontal ratio. This field contains the resizing
 * horizontal coefficient of preprocessing Task For View-finder. Resizing Ratio is equal to
 * PRPVF_RS_R_H: M Where M = 2^13; SI - input size; SO - output size PRPVF_RS_R_H =
 * floor(M*(SI-1)/(SO-1));
 */

#define BP_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_H      0
#define BM_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_H      0x00003fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_H(v)   ((((reg32_t) v) << 0) & BM_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_H)
#else
#define BF_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_H(v)   (((v) << 0) & BM_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_H)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPVF_RS_R_H field to a new value.
#define BW_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_H(v)   BF_CS1(IPU_IC_PRP_VF_RSC, PRPVF_RS_R_H, v)
#endif

/* --- Register HW_IPU_IC_PRP_VF_RSC, field PRPVF_DS_R_H (RW)
 *
 * Preprocessing task for encoding Downsizing horizontal Ratio. This field contains the downsizing
 * horizontal coefficient of Preprocessing for View-Finder. Values:
 *
 * Values:
 * 00 - 1
 * 01 - 2
 * 10 - 4
 * 11 - RSV
 */

#define BP_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_H      14
#define BM_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_H      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_H(v)   ((((reg32_t) v) << 14) & BM_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_H)
#else
#define BF_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_H(v)   (((v) << 14) & BM_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_H)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPVF_DS_R_H field to a new value.
#define BW_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_H(v)   BF_CS1(IPU_IC_PRP_VF_RSC, PRPVF_DS_R_H, v)
#endif


/* --- Register HW_IPU_IC_PRP_VF_RSC, field PRPVF_RS_R_V (RW)
 *
 * Preprocessing task for encoding Resizing vertical Ratio. This field contains the resizing
 * vertical coefficient of Preprocessing for View-Finder. Resizing Ratio is equal to PRPVF_RS_R_V: M
 * Where M = 2^13; SI - input size; SO - output size PRPVF_RS_R_V = floor(M*(SI-1)/(SO-1));
 */

#define BP_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_V      16
#define BM_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_V      0x3fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_V(v)   ((((reg32_t) v) << 16) & BM_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_V)
#else
#define BF_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_V(v)   (((v) << 16) & BM_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_V)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPVF_RS_R_V field to a new value.
#define BW_IPU_IC_PRP_VF_RSC_PRPVF_RS_R_V(v)   BF_CS1(IPU_IC_PRP_VF_RSC, PRPVF_RS_R_V, v)
#endif

/* --- Register HW_IPU_IC_PRP_VF_RSC, field PRPVF_DS_R_V (RW)
 *
 * Preprocessing task for encoding Downsizing vertical Ratio. This field contains the downsizing
 * vertical coefficient of Preprocessing for View-Finder.
 */

#define BP_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_V      30
#define BM_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_V      0xc0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_V(v)   ((((reg32_t) v) << 30) & BM_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_V)
#else
#define BF_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_V(v)   (((v) << 30) & BM_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_V)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PRPVF_DS_R_V field to a new value.
#define BW_IPU_IC_PRP_VF_RSC_PRPVF_DS_R_V(v)   BF_CS1(IPU_IC_PRP_VF_RSC, PRPVF_DS_R_V, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IC_PP_RSC - IC Postprocessing Encoder Resizing Coefficients Register (RW)
 *
 * This register contains the resizing and downsizing parameters for Post-Processing task for
 * display.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned PP_RS_R_H : 14; //!< Post-Processing task Resizing horizontal Ratio. This field contains the resizing horizontal coefficient of Post-Processing. Resizing Ratio is equal to PP_RS_R_H: M Where M = 2^13; SI - input size; SO - output size PP_RS_R_H = floor(M*(SI-1)/(SO-1));
        unsigned PP_DS_R_H : 2; //!< Post-Processing task Downsizing horizontal Ratio. This field contains the downsizing horizontal coefficient of Post-Processing.
        unsigned PP_RS_R_V : 14; //!< Post-Processing task Resizing vertical Ratio. This field contains the resizing vertical coefficient of Post-Processing. Resizing Ratio is equal to PP_RS_R_V: M Where M = 2^13; SI - input size; SO - output size PP_RS_R_V = floor(M*(SI-1)/(SO-1));
        unsigned PP_DS_R_V : 2; //!< Post-Processing task Downsizing vertical Ratio. This field contains the downsizing vertical coefficient of Post-Processing.
    } B;
} hw_ipu_ic_pp_rsc_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IC_PP_RSC register
 */
#define HW_IPU_IC_PP_RSC_ADDR(x)      (REGS_IPU_BASE(x) + 0x2000c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IC_PP_RSC(x)           (*(volatile hw_ipu_ic_pp_rsc_t *) HW_IPU_IC_PP_RSC_ADDR(x))
#define HW_IPU_IC_PP_RSC_RD(x)        (HW_IPU_IC_PP_RSC(x).U)
#define HW_IPU_IC_PP_RSC_WR(x, v)     (HW_IPU_IC_PP_RSC(x).U = (v))
#define HW_IPU_IC_PP_RSC_SET(x, v)    (HW_IPU_IC_PP_RSC_WR(x, HW_IPU_IC_PP_RSC_RD(x) |  (v)))
#define HW_IPU_IC_PP_RSC_CLR(x, v)    (HW_IPU_IC_PP_RSC_WR(x, HW_IPU_IC_PP_RSC_RD(x) & ~(v)))
#define HW_IPU_IC_PP_RSC_TOG(x, v)    (HW_IPU_IC_PP_RSC_WR(x, HW_IPU_IC_PP_RSC_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IC_PP_RSC bitfields
 */

/* --- Register HW_IPU_IC_PP_RSC, field PP_RS_R_H (RW)
 *
 * Post-Processing task Resizing horizontal Ratio. This field contains the resizing horizontal
 * coefficient of Post-Processing. Resizing Ratio is equal to PP_RS_R_H: M Where M = 2^13; SI -
 * input size; SO - output size PP_RS_R_H = floor(M*(SI-1)/(SO-1));
 */

#define BP_IPU_IC_PP_RSC_PP_RS_R_H      0
#define BM_IPU_IC_PP_RSC_PP_RS_R_H      0x00003fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_PP_RSC_PP_RS_R_H(v)   ((((reg32_t) v) << 0) & BM_IPU_IC_PP_RSC_PP_RS_R_H)
#else
#define BF_IPU_IC_PP_RSC_PP_RS_R_H(v)   (((v) << 0) & BM_IPU_IC_PP_RSC_PP_RS_R_H)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_RS_R_H field to a new value.
#define BW_IPU_IC_PP_RSC_PP_RS_R_H(v)   BF_CS1(IPU_IC_PP_RSC, PP_RS_R_H, v)
#endif

/* --- Register HW_IPU_IC_PP_RSC, field PP_DS_R_H (RW)
 *
 * Post-Processing task Downsizing horizontal Ratio. This field contains the downsizing horizontal
 * coefficient of Post-Processing.
 *
 * Values:
 * 00 - 1
 * 01 - 2
 * 10 - 4
 * 11 - RSV
 */

#define BP_IPU_IC_PP_RSC_PP_DS_R_H      14
#define BM_IPU_IC_PP_RSC_PP_DS_R_H      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_PP_RSC_PP_DS_R_H(v)   ((((reg32_t) v) << 14) & BM_IPU_IC_PP_RSC_PP_DS_R_H)
#else
#define BF_IPU_IC_PP_RSC_PP_DS_R_H(v)   (((v) << 14) & BM_IPU_IC_PP_RSC_PP_DS_R_H)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_DS_R_H field to a new value.
#define BW_IPU_IC_PP_RSC_PP_DS_R_H(v)   BF_CS1(IPU_IC_PP_RSC, PP_DS_R_H, v)
#endif


/* --- Register HW_IPU_IC_PP_RSC, field PP_RS_R_V (RW)
 *
 * Post-Processing task Resizing vertical Ratio. This field contains the resizing vertical
 * coefficient of Post-Processing. Resizing Ratio is equal to PP_RS_R_V: M Where M = 2^13; SI -
 * input size; SO - output size PP_RS_R_V = floor(M*(SI-1)/(SO-1));
 */

#define BP_IPU_IC_PP_RSC_PP_RS_R_V      16
#define BM_IPU_IC_PP_RSC_PP_RS_R_V      0x3fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_PP_RSC_PP_RS_R_V(v)   ((((reg32_t) v) << 16) & BM_IPU_IC_PP_RSC_PP_RS_R_V)
#else
#define BF_IPU_IC_PP_RSC_PP_RS_R_V(v)   (((v) << 16) & BM_IPU_IC_PP_RSC_PP_RS_R_V)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_RS_R_V field to a new value.
#define BW_IPU_IC_PP_RSC_PP_RS_R_V(v)   BF_CS1(IPU_IC_PP_RSC, PP_RS_R_V, v)
#endif

/* --- Register HW_IPU_IC_PP_RSC, field PP_DS_R_V (RW)
 *
 * Post-Processing task Downsizing vertical Ratio. This field contains the downsizing vertical
 * coefficient of Post-Processing.
 */

#define BP_IPU_IC_PP_RSC_PP_DS_R_V      30
#define BM_IPU_IC_PP_RSC_PP_DS_R_V      0xc0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_PP_RSC_PP_DS_R_V(v)   ((((reg32_t) v) << 30) & BM_IPU_IC_PP_RSC_PP_DS_R_V)
#else
#define BF_IPU_IC_PP_RSC_PP_DS_R_V(v)   (((v) << 30) & BM_IPU_IC_PP_RSC_PP_DS_R_V)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PP_DS_R_V field to a new value.
#define BW_IPU_IC_PP_RSC_PP_DS_R_V(v)   BF_CS1(IPU_IC_PP_RSC, PP_DS_R_V, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IC_CMBP_1 - IC Combining Parameters Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IC_PRPVF_ALPHA_V : 8; //!< Preprocessing task for viewfinder Global Alpha. This field contains the Global Alpha value of Preprocessing for viewfinder.
        unsigned IC_PP_ALPHA_V : 8; //!< Post-Processing task Global Alpha. This field contains the Global Alpha value of Post-Processing.
        unsigned RESERVED0 : 16; //!< Reserved.
    } B;
} hw_ipu_ic_cmbp_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IC_CMBP_1 register
 */
#define HW_IPU_IC_CMBP_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x20010)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IC_CMBP_1(x)           (*(volatile hw_ipu_ic_cmbp_1_t *) HW_IPU_IC_CMBP_1_ADDR(x))
#define HW_IPU_IC_CMBP_1_RD(x)        (HW_IPU_IC_CMBP_1(x).U)
#define HW_IPU_IC_CMBP_1_WR(x, v)     (HW_IPU_IC_CMBP_1(x).U = (v))
#define HW_IPU_IC_CMBP_1_SET(x, v)    (HW_IPU_IC_CMBP_1_WR(x, HW_IPU_IC_CMBP_1_RD(x) |  (v)))
#define HW_IPU_IC_CMBP_1_CLR(x, v)    (HW_IPU_IC_CMBP_1_WR(x, HW_IPU_IC_CMBP_1_RD(x) & ~(v)))
#define HW_IPU_IC_CMBP_1_TOG(x, v)    (HW_IPU_IC_CMBP_1_WR(x, HW_IPU_IC_CMBP_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IC_CMBP_1 bitfields
 */

/* --- Register HW_IPU_IC_CMBP_1, field IC_PRPVF_ALPHA_V (RW)
 *
 * Preprocessing task for viewfinder Global Alpha. This field contains the Global Alpha value of
 * Preprocessing for viewfinder.
 */

#define BP_IPU_IC_CMBP_1_IC_PRPVF_ALPHA_V      0
#define BM_IPU_IC_CMBP_1_IC_PRPVF_ALPHA_V      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CMBP_1_IC_PRPVF_ALPHA_V(v)   ((((reg32_t) v) << 0) & BM_IPU_IC_CMBP_1_IC_PRPVF_ALPHA_V)
#else
#define BF_IPU_IC_CMBP_1_IC_PRPVF_ALPHA_V(v)   (((v) << 0) & BM_IPU_IC_CMBP_1_IC_PRPVF_ALPHA_V)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_PRPVF_ALPHA_V field to a new value.
#define BW_IPU_IC_CMBP_1_IC_PRPVF_ALPHA_V(v)   BF_CS1(IPU_IC_CMBP_1, IC_PRPVF_ALPHA_V, v)
#endif

/* --- Register HW_IPU_IC_CMBP_1, field IC_PP_ALPHA_V (RW)
 *
 * Post-Processing task Global Alpha. This field contains the Global Alpha value of Post-Processing.
 */

#define BP_IPU_IC_CMBP_1_IC_PP_ALPHA_V      8
#define BM_IPU_IC_CMBP_1_IC_PP_ALPHA_V      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CMBP_1_IC_PP_ALPHA_V(v)   ((((reg32_t) v) << 8) & BM_IPU_IC_CMBP_1_IC_PP_ALPHA_V)
#else
#define BF_IPU_IC_CMBP_1_IC_PP_ALPHA_V(v)   (((v) << 8) & BM_IPU_IC_CMBP_1_IC_PP_ALPHA_V)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_PP_ALPHA_V field to a new value.
#define BW_IPU_IC_CMBP_1_IC_PP_ALPHA_V(v)   BF_CS1(IPU_IC_CMBP_1, IC_PP_ALPHA_V, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IC_CMBP_2 - IC Combining Parameters Register 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IC_KEY_COLOR_B : 8; //!< Key Color Blue.
        unsigned IC_KEY_COLOR_G : 8; //!< Key Color Green.
        unsigned IC_KEY_COLOR_R : 8; //!< Key Color Red.
        unsigned RESERVED0 : 8; //!< Reserved.
    } B;
} hw_ipu_ic_cmbp_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IC_CMBP_2 register
 */
#define HW_IPU_IC_CMBP_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x20014)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IC_CMBP_2(x)           (*(volatile hw_ipu_ic_cmbp_2_t *) HW_IPU_IC_CMBP_2_ADDR(x))
#define HW_IPU_IC_CMBP_2_RD(x)        (HW_IPU_IC_CMBP_2(x).U)
#define HW_IPU_IC_CMBP_2_WR(x, v)     (HW_IPU_IC_CMBP_2(x).U = (v))
#define HW_IPU_IC_CMBP_2_SET(x, v)    (HW_IPU_IC_CMBP_2_WR(x, HW_IPU_IC_CMBP_2_RD(x) |  (v)))
#define HW_IPU_IC_CMBP_2_CLR(x, v)    (HW_IPU_IC_CMBP_2_WR(x, HW_IPU_IC_CMBP_2_RD(x) & ~(v)))
#define HW_IPU_IC_CMBP_2_TOG(x, v)    (HW_IPU_IC_CMBP_2_WR(x, HW_IPU_IC_CMBP_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IC_CMBP_2 bitfields
 */

/* --- Register HW_IPU_IC_CMBP_2, field IC_KEY_COLOR_B (RW)
 *
 * Key Color Blue.
 */

#define BP_IPU_IC_CMBP_2_IC_KEY_COLOR_B      0
#define BM_IPU_IC_CMBP_2_IC_KEY_COLOR_B      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CMBP_2_IC_KEY_COLOR_B(v)   ((((reg32_t) v) << 0) & BM_IPU_IC_CMBP_2_IC_KEY_COLOR_B)
#else
#define BF_IPU_IC_CMBP_2_IC_KEY_COLOR_B(v)   (((v) << 0) & BM_IPU_IC_CMBP_2_IC_KEY_COLOR_B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_KEY_COLOR_B field to a new value.
#define BW_IPU_IC_CMBP_2_IC_KEY_COLOR_B(v)   BF_CS1(IPU_IC_CMBP_2, IC_KEY_COLOR_B, v)
#endif

/* --- Register HW_IPU_IC_CMBP_2, field IC_KEY_COLOR_G (RW)
 *
 * Key Color Green.
 */

#define BP_IPU_IC_CMBP_2_IC_KEY_COLOR_G      8
#define BM_IPU_IC_CMBP_2_IC_KEY_COLOR_G      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CMBP_2_IC_KEY_COLOR_G(v)   ((((reg32_t) v) << 8) & BM_IPU_IC_CMBP_2_IC_KEY_COLOR_G)
#else
#define BF_IPU_IC_CMBP_2_IC_KEY_COLOR_G(v)   (((v) << 8) & BM_IPU_IC_CMBP_2_IC_KEY_COLOR_G)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_KEY_COLOR_G field to a new value.
#define BW_IPU_IC_CMBP_2_IC_KEY_COLOR_G(v)   BF_CS1(IPU_IC_CMBP_2, IC_KEY_COLOR_G, v)
#endif

/* --- Register HW_IPU_IC_CMBP_2, field IC_KEY_COLOR_R (RW)
 *
 * Key Color Red.
 */

#define BP_IPU_IC_CMBP_2_IC_KEY_COLOR_R      16
#define BM_IPU_IC_CMBP_2_IC_KEY_COLOR_R      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_CMBP_2_IC_KEY_COLOR_R(v)   ((((reg32_t) v) << 16) & BM_IPU_IC_CMBP_2_IC_KEY_COLOR_R)
#else
#define BF_IPU_IC_CMBP_2_IC_KEY_COLOR_R(v)   (((v) << 16) & BM_IPU_IC_CMBP_2_IC_KEY_COLOR_R)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IC_KEY_COLOR_R field to a new value.
#define BW_IPU_IC_CMBP_2_IC_KEY_COLOR_R(v)   BF_CS1(IPU_IC_CMBP_2, IC_KEY_COLOR_R, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IC_IDMAC_1 - IC IDMAC Parameters 1 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CB0_BURST_16 : 1; //!< This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB0 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM
        unsigned CB1_BURST_16 : 1; //!< This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB1 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM
        unsigned CB2_BURST_16 : 1; //!< This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB2 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM
        unsigned CB3_BURST_16 : 1; //!< This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB3 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM
        unsigned CB4_BURST_16 : 1; //!< This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB4 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM
        unsigned CB5_BURST_16 : 1; //!< This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB5 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM
        unsigned CB6_BURST_16 : 1; //!< This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB6 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM
        unsigned CB7_BURST_16 : 1; //!< This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB7 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM
        unsigned RESERVED0 : 3; //!< Reserved
        unsigned T1_ROT : 1; //!< Rotation for Encoding (ENC) task The value of this field must be identical to the corresponding channel's ROT parameters in the IDMAC's CPMEM
        unsigned T1_FLIP_LR : 1; //!< LEFT/RIGHT flip for Encoding (ENC) task; this bit affect the flipping done on the rotation unit The value of this field must be identical to the corresponding channel's HF parameter in the IDMAC's CPMEM
        unsigned T1_FLIP_UD : 1; //!< UP/DOWN flip for Encoding (ENC) task The value of this field must be identical to the corresponding channel's VF parameters in the IDMAC's CPMEM
        unsigned T2_ROT : 1; //!< Rotation for View Finder (VF) task The value of this field must be identical to the corresponding channel's ROT parameters in the IDMAC's CPMEM
        unsigned T2_FLIP_LR : 1; //!< LEFT/RIGHT flip for View Finder (VF) task; this bit affect the flipping done on the rotation unit The value of this field must be identical to the corresponding channel's HF parameter in the IDMAC's CPMEM
        unsigned T2_FLIP_UD : 1; //!< UP/DOWN flip for View Finder (VF) task The value of this field must be identical to the corresponding channel's VF parameters in the IDMAC's CPMEM
        unsigned T3_ROT : 1; //!< Rotation for Post Processing (PP) task The value of this field must be identical to the corresponding channel's ROT parameters in the IDMAC's CPMEM
        unsigned T3_FLIP_LR : 1; //!< LEFT/RIGHT flip for Post Processing (PP) task; this bit affect the flipping done on the rotation unit The value of this field must be identical to the corresponding channel's HF parameter in the IDMAC's CPMEM
        unsigned T3_FLIP_UD : 1; //!< UP/DOWN flip for Post Processing (PP) task The value of this field must be identical to the corresponding channel's VF parameters in the IDMAC's CPMEM
        unsigned T1_FLIP_RS : 1; //!< LEFT/RIGHT flip for Encoding (ENC) task; this bit affect the flipping done on the resizing unit. The value of this field must be identical to the corresponding channel's HF parameter in the IDMAC's CPMEM This bit is reserved on IPUv3D as this feature is not supported on IPUv3D
        unsigned T2_FLIP_RS : 1; //!< LEFT/RIGHT flip for View Finder (VF) task; this bit affect the flipping done on the resizing unit. The value of this field must be identical to the corresponding channel's HF parameter in the IDMAC's CPMEM This bit is reserved on IPUv3D as this feature is not supported on IPUv3D
        unsigned T3_FLIP_RS : 1; //!< LEFT/RIGHT flip for Post Processing (PP) task; his bit affect the flipping done on the resizing unit. The value of this field must be identical to the corresponding channel's HF parameter in the IDMAC's CPMEM This bit is reserved on IPUv3D as this feature is not supported on IPUv3D
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned ALT_CB6_BURST_16 : 1; //!< This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC for IC's CB6 when used in alternate mode. For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM Reserved
        unsigned ALT_CB7_BURST_16 : 1; //!< This bit defines the number of pixels within a burst (burst size) coming from the IDMAC for IC's CB7 when used in alternate mode. For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's CPMEM Reserved
        unsigned RESERVED2 : 6; //!< Reserved
    } B;
} hw_ipu_ic_idmac_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IC_IDMAC_1 register
 */
#define HW_IPU_IC_IDMAC_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x20018)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IC_IDMAC_1(x)           (*(volatile hw_ipu_ic_idmac_1_t *) HW_IPU_IC_IDMAC_1_ADDR(x))
#define HW_IPU_IC_IDMAC_1_RD(x)        (HW_IPU_IC_IDMAC_1(x).U)
#define HW_IPU_IC_IDMAC_1_WR(x, v)     (HW_IPU_IC_IDMAC_1(x).U = (v))
#define HW_IPU_IC_IDMAC_1_SET(x, v)    (HW_IPU_IC_IDMAC_1_WR(x, HW_IPU_IC_IDMAC_1_RD(x) |  (v)))
#define HW_IPU_IC_IDMAC_1_CLR(x, v)    (HW_IPU_IC_IDMAC_1_WR(x, HW_IPU_IC_IDMAC_1_RD(x) & ~(v)))
#define HW_IPU_IC_IDMAC_1_TOG(x, v)    (HW_IPU_IC_IDMAC_1_WR(x, HW_IPU_IC_IDMAC_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IC_IDMAC_1 bitfields
 */

/* --- Register HW_IPU_IC_IDMAC_1, field CB0_BURST_16 (RW)
 *
 * This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC
 * for IC's CB0 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's
 * CPMEM
 *
 * Values:
 * 0 - Burst size is 8 pixels; The Matching NPB[6:2] should be 00111
 * 1 - Burst size is 16 pixels; The Matching NPB[6:2] should be 01111
 */

#define BP_IPU_IC_IDMAC_1_CB0_BURST_16      0
#define BM_IPU_IC_IDMAC_1_CB0_BURST_16      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_CB0_BURST_16(v)   ((((reg32_t) v) << 0) & BM_IPU_IC_IDMAC_1_CB0_BURST_16)
#else
#define BF_IPU_IC_IDMAC_1_CB0_BURST_16(v)   (((v) << 0) & BM_IPU_IC_IDMAC_1_CB0_BURST_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CB0_BURST_16 field to a new value.
#define BW_IPU_IC_IDMAC_1_CB0_BURST_16(v)   BF_CS1(IPU_IC_IDMAC_1, CB0_BURST_16, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field CB1_BURST_16 (RW)
 *
 * This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC
 * for IC's CB1 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's
 * CPMEM
 *
 * Values:
 * 0 - Burst size is 8 pixels; The Matching NPB[6:2] should be 00111
 * 1 - Burst size is 16 pixels; The Matching NPB[6:2] should be 01111
 */

#define BP_IPU_IC_IDMAC_1_CB1_BURST_16      1
#define BM_IPU_IC_IDMAC_1_CB1_BURST_16      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_CB1_BURST_16(v)   ((((reg32_t) v) << 1) & BM_IPU_IC_IDMAC_1_CB1_BURST_16)
#else
#define BF_IPU_IC_IDMAC_1_CB1_BURST_16(v)   (((v) << 1) & BM_IPU_IC_IDMAC_1_CB1_BURST_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CB1_BURST_16 field to a new value.
#define BW_IPU_IC_IDMAC_1_CB1_BURST_16(v)   BF_CS1(IPU_IC_IDMAC_1, CB1_BURST_16, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field CB2_BURST_16 (RW)
 *
 * This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC
 * for IC's CB2 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's
 * CPMEM
 *
 * Values:
 * 0 - Burst size is 8 pixels; The Matching NPB[6:2] should be 00111
 * 1 - Burst size is 16 pixels; The Matching NPB[6:2] should be 01111
 */

#define BP_IPU_IC_IDMAC_1_CB2_BURST_16      2
#define BM_IPU_IC_IDMAC_1_CB2_BURST_16      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_CB2_BURST_16(v)   ((((reg32_t) v) << 2) & BM_IPU_IC_IDMAC_1_CB2_BURST_16)
#else
#define BF_IPU_IC_IDMAC_1_CB2_BURST_16(v)   (((v) << 2) & BM_IPU_IC_IDMAC_1_CB2_BURST_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CB2_BURST_16 field to a new value.
#define BW_IPU_IC_IDMAC_1_CB2_BURST_16(v)   BF_CS1(IPU_IC_IDMAC_1, CB2_BURST_16, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field CB3_BURST_16 (RW)
 *
 * This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC
 * for IC's CB3 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's
 * CPMEM
 *
 * Values:
 * 0 - Burst size is 8 pixels; The Matching NPB[6:2] should be 00111
 * 1 - Burst size is 16 pixels; The Matching NPB[6:2] should be 01111
 */

#define BP_IPU_IC_IDMAC_1_CB3_BURST_16      3
#define BM_IPU_IC_IDMAC_1_CB3_BURST_16      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_CB3_BURST_16(v)   ((((reg32_t) v) << 3) & BM_IPU_IC_IDMAC_1_CB3_BURST_16)
#else
#define BF_IPU_IC_IDMAC_1_CB3_BURST_16(v)   (((v) << 3) & BM_IPU_IC_IDMAC_1_CB3_BURST_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CB3_BURST_16 field to a new value.
#define BW_IPU_IC_IDMAC_1_CB3_BURST_16(v)   BF_CS1(IPU_IC_IDMAC_1, CB3_BURST_16, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field CB4_BURST_16 (RW)
 *
 * This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC
 * for IC's CB4 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's
 * CPMEM
 *
 * Values:
 * 0 - Burst size is 8 pixels; The Matching NPB[6:2] should be 00111
 * 1 - Burst size is 16 pixels; The Matching NPB[6:2] should be 01111
 */

#define BP_IPU_IC_IDMAC_1_CB4_BURST_16      4
#define BM_IPU_IC_IDMAC_1_CB4_BURST_16      0x00000010

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_CB4_BURST_16(v)   ((((reg32_t) v) << 4) & BM_IPU_IC_IDMAC_1_CB4_BURST_16)
#else
#define BF_IPU_IC_IDMAC_1_CB4_BURST_16(v)   (((v) << 4) & BM_IPU_IC_IDMAC_1_CB4_BURST_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CB4_BURST_16 field to a new value.
#define BW_IPU_IC_IDMAC_1_CB4_BURST_16(v)   BF_CS1(IPU_IC_IDMAC_1, CB4_BURST_16, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field CB5_BURST_16 (RW)
 *
 * This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC
 * for IC's CB5 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's
 * CPMEM
 *
 * Values:
 * 0 - Burst size is 8 pixels; The Matching NPB[6:2] should be 00111
 * 1 - Burst size is 16 pixels; The Matching NPB[6:2] should be 01111
 */

#define BP_IPU_IC_IDMAC_1_CB5_BURST_16      5
#define BM_IPU_IC_IDMAC_1_CB5_BURST_16      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_CB5_BURST_16(v)   ((((reg32_t) v) << 5) & BM_IPU_IC_IDMAC_1_CB5_BURST_16)
#else
#define BF_IPU_IC_IDMAC_1_CB5_BURST_16(v)   (((v) << 5) & BM_IPU_IC_IDMAC_1_CB5_BURST_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CB5_BURST_16 field to a new value.
#define BW_IPU_IC_IDMAC_1_CB5_BURST_16(v)   BF_CS1(IPU_IC_IDMAC_1, CB5_BURST_16, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field CB6_BURST_16 (RW)
 *
 * This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC
 * for IC's CB6 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's
 * CPMEM
 *
 * Values:
 * 0 - Burst size is 8 pixels; The Matching NPB[6:2] should be 00111
 * 1 - Burst size is 16 pixels; The Matching NPB[6:2] should be 01111
 */

#define BP_IPU_IC_IDMAC_1_CB6_BURST_16      6
#define BM_IPU_IC_IDMAC_1_CB6_BURST_16      0x00000040

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_CB6_BURST_16(v)   ((((reg32_t) v) << 6) & BM_IPU_IC_IDMAC_1_CB6_BURST_16)
#else
#define BF_IPU_IC_IDMAC_1_CB6_BURST_16(v)   (((v) << 6) & BM_IPU_IC_IDMAC_1_CB6_BURST_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CB6_BURST_16 field to a new value.
#define BW_IPU_IC_IDMAC_1_CB6_BURST_16(v)   BF_CS1(IPU_IC_IDMAC_1, CB6_BURST_16, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field CB7_BURST_16 (RW)
 *
 * This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC
 * for IC's CB7 For pixel data the number of pixels should match the NPB[6:2] value on the IDMAC's
 * CPMEM
 *
 * Values:
 * 0 - Burst size is 8 pixels; The Matching NPB[6:2] should be 00111
 * 1 - Burst size is 16 pixels; The Matching NPB[6:2] should be 01111
 */

#define BP_IPU_IC_IDMAC_1_CB7_BURST_16      7
#define BM_IPU_IC_IDMAC_1_CB7_BURST_16      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_CB7_BURST_16(v)   ((((reg32_t) v) << 7) & BM_IPU_IC_IDMAC_1_CB7_BURST_16)
#else
#define BF_IPU_IC_IDMAC_1_CB7_BURST_16(v)   (((v) << 7) & BM_IPU_IC_IDMAC_1_CB7_BURST_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CB7_BURST_16 field to a new value.
#define BW_IPU_IC_IDMAC_1_CB7_BURST_16(v)   BF_CS1(IPU_IC_IDMAC_1, CB7_BURST_16, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field T1_ROT (RW)
 *
 * Rotation for Encoding (ENC) task The value of this field must be identical to the corresponding
 * channel's ROT parameters in the IDMAC's CPMEM
 *
 * Values:
 * 1 - 90 degree rotation clockwise
 * 0 - no rotation
 */

#define BP_IPU_IC_IDMAC_1_T1_ROT      11
#define BM_IPU_IC_IDMAC_1_T1_ROT      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_T1_ROT(v)   ((((reg32_t) v) << 11) & BM_IPU_IC_IDMAC_1_T1_ROT)
#else
#define BF_IPU_IC_IDMAC_1_T1_ROT(v)   (((v) << 11) & BM_IPU_IC_IDMAC_1_T1_ROT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T1_ROT field to a new value.
#define BW_IPU_IC_IDMAC_1_T1_ROT(v)   BF_CS1(IPU_IC_IDMAC_1, T1_ROT, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field T1_FLIP_LR (RW)
 *
 * LEFT/RIGHT flip for Encoding (ENC) task; this bit affect the flipping done on the rotation unit
 * The value of this field must be identical to the corresponding channel's HF parameter in the
 * IDMAC's CPMEM
 *
 * Values:
 * 1 - horizontal flip enabled
 * 0 - no flip
 */

#define BP_IPU_IC_IDMAC_1_T1_FLIP_LR      12
#define BM_IPU_IC_IDMAC_1_T1_FLIP_LR      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_T1_FLIP_LR(v)   ((((reg32_t) v) << 12) & BM_IPU_IC_IDMAC_1_T1_FLIP_LR)
#else
#define BF_IPU_IC_IDMAC_1_T1_FLIP_LR(v)   (((v) << 12) & BM_IPU_IC_IDMAC_1_T1_FLIP_LR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T1_FLIP_LR field to a new value.
#define BW_IPU_IC_IDMAC_1_T1_FLIP_LR(v)   BF_CS1(IPU_IC_IDMAC_1, T1_FLIP_LR, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field T1_FLIP_UD (RW)
 *
 * UP/DOWN flip for Encoding (ENC) task The value of this field must be identical to the
 * corresponding channel's VF parameters in the IDMAC's CPMEM
 *
 * Values:
 * 1 - Vertical flip enable
 * 0 - no flip
 */

#define BP_IPU_IC_IDMAC_1_T1_FLIP_UD      13
#define BM_IPU_IC_IDMAC_1_T1_FLIP_UD      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_T1_FLIP_UD(v)   ((((reg32_t) v) << 13) & BM_IPU_IC_IDMAC_1_T1_FLIP_UD)
#else
#define BF_IPU_IC_IDMAC_1_T1_FLIP_UD(v)   (((v) << 13) & BM_IPU_IC_IDMAC_1_T1_FLIP_UD)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T1_FLIP_UD field to a new value.
#define BW_IPU_IC_IDMAC_1_T1_FLIP_UD(v)   BF_CS1(IPU_IC_IDMAC_1, T1_FLIP_UD, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field T2_ROT (RW)
 *
 * Rotation for View Finder (VF) task The value of this field must be identical to the corresponding
 * channel's ROT parameters in the IDMAC's CPMEM
 *
 * Values:
 * 1 - 90 degree rotation clockwise
 * 0 - no rotation
 */

#define BP_IPU_IC_IDMAC_1_T2_ROT      14
#define BM_IPU_IC_IDMAC_1_T2_ROT      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_T2_ROT(v)   ((((reg32_t) v) << 14) & BM_IPU_IC_IDMAC_1_T2_ROT)
#else
#define BF_IPU_IC_IDMAC_1_T2_ROT(v)   (((v) << 14) & BM_IPU_IC_IDMAC_1_T2_ROT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T2_ROT field to a new value.
#define BW_IPU_IC_IDMAC_1_T2_ROT(v)   BF_CS1(IPU_IC_IDMAC_1, T2_ROT, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field T2_FLIP_LR (RW)
 *
 * LEFT/RIGHT flip for View Finder (VF) task; this bit affect the flipping done on the rotation unit
 * The value of this field must be identical to the corresponding channel's HF parameter in the
 * IDMAC's CPMEM
 *
 * Values:
 * 1 - horizontal flip enabled
 * 0 - no flip
 */

#define BP_IPU_IC_IDMAC_1_T2_FLIP_LR      15
#define BM_IPU_IC_IDMAC_1_T2_FLIP_LR      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_T2_FLIP_LR(v)   ((((reg32_t) v) << 15) & BM_IPU_IC_IDMAC_1_T2_FLIP_LR)
#else
#define BF_IPU_IC_IDMAC_1_T2_FLIP_LR(v)   (((v) << 15) & BM_IPU_IC_IDMAC_1_T2_FLIP_LR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T2_FLIP_LR field to a new value.
#define BW_IPU_IC_IDMAC_1_T2_FLIP_LR(v)   BF_CS1(IPU_IC_IDMAC_1, T2_FLIP_LR, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field T2_FLIP_UD (RW)
 *
 * UP/DOWN flip for View Finder (VF) task The value of this field must be identical to the
 * corresponding channel's VF parameters in the IDMAC's CPMEM
 *
 * Values:
 * 1 - Vertical flip enable
 * 0 - no flip
 */

#define BP_IPU_IC_IDMAC_1_T2_FLIP_UD      16
#define BM_IPU_IC_IDMAC_1_T2_FLIP_UD      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_T2_FLIP_UD(v)   ((((reg32_t) v) << 16) & BM_IPU_IC_IDMAC_1_T2_FLIP_UD)
#else
#define BF_IPU_IC_IDMAC_1_T2_FLIP_UD(v)   (((v) << 16) & BM_IPU_IC_IDMAC_1_T2_FLIP_UD)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T2_FLIP_UD field to a new value.
#define BW_IPU_IC_IDMAC_1_T2_FLIP_UD(v)   BF_CS1(IPU_IC_IDMAC_1, T2_FLIP_UD, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field T3_ROT (RW)
 *
 * Rotation for Post Processing (PP) task The value of this field must be identical to the
 * corresponding channel's ROT parameters in the IDMAC's CPMEM
 *
 * Values:
 * 1 - 90 degree rotation clockwise
 * 0 - no rotation
 */

#define BP_IPU_IC_IDMAC_1_T3_ROT      17
#define BM_IPU_IC_IDMAC_1_T3_ROT      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_T3_ROT(v)   ((((reg32_t) v) << 17) & BM_IPU_IC_IDMAC_1_T3_ROT)
#else
#define BF_IPU_IC_IDMAC_1_T3_ROT(v)   (((v) << 17) & BM_IPU_IC_IDMAC_1_T3_ROT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T3_ROT field to a new value.
#define BW_IPU_IC_IDMAC_1_T3_ROT(v)   BF_CS1(IPU_IC_IDMAC_1, T3_ROT, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field T3_FLIP_LR (RW)
 *
 * LEFT/RIGHT flip for Post Processing (PP) task; this bit affect the flipping done on the rotation
 * unit The value of this field must be identical to the corresponding channel's HF parameter in the
 * IDMAC's CPMEM
 *
 * Values:
 * 1 - horizontal flip enabled
 * 0 - no flip
 */

#define BP_IPU_IC_IDMAC_1_T3_FLIP_LR      18
#define BM_IPU_IC_IDMAC_1_T3_FLIP_LR      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_T3_FLIP_LR(v)   ((((reg32_t) v) << 18) & BM_IPU_IC_IDMAC_1_T3_FLIP_LR)
#else
#define BF_IPU_IC_IDMAC_1_T3_FLIP_LR(v)   (((v) << 18) & BM_IPU_IC_IDMAC_1_T3_FLIP_LR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T3_FLIP_LR field to a new value.
#define BW_IPU_IC_IDMAC_1_T3_FLIP_LR(v)   BF_CS1(IPU_IC_IDMAC_1, T3_FLIP_LR, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field T3_FLIP_UD (RW)
 *
 * UP/DOWN flip for Post Processing (PP) task The value of this field must be identical to the
 * corresponding channel's VF parameters in the IDMAC's CPMEM
 *
 * Values:
 * 1 - Vertical flip enable
 * 0 - no flip
 */

#define BP_IPU_IC_IDMAC_1_T3_FLIP_UD      19
#define BM_IPU_IC_IDMAC_1_T3_FLIP_UD      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_T3_FLIP_UD(v)   ((((reg32_t) v) << 19) & BM_IPU_IC_IDMAC_1_T3_FLIP_UD)
#else
#define BF_IPU_IC_IDMAC_1_T3_FLIP_UD(v)   (((v) << 19) & BM_IPU_IC_IDMAC_1_T3_FLIP_UD)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T3_FLIP_UD field to a new value.
#define BW_IPU_IC_IDMAC_1_T3_FLIP_UD(v)   BF_CS1(IPU_IC_IDMAC_1, T3_FLIP_UD, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field T1_FLIP_RS (RW)
 *
 * LEFT/RIGHT flip for Encoding (ENC) task; this bit affect the flipping done on the resizing unit.
 * The value of this field must be identical to the corresponding channel's HF parameter in the
 * IDMAC's CPMEM This bit is reserved on IPUv3D as this feature is not supported on IPUv3D
 *
 * Values:
 * 1 - horizontal flip enabled
 * 0 - no flip
 */

#define BP_IPU_IC_IDMAC_1_T1_FLIP_RS      20
#define BM_IPU_IC_IDMAC_1_T1_FLIP_RS      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_T1_FLIP_RS(v)   ((((reg32_t) v) << 20) & BM_IPU_IC_IDMAC_1_T1_FLIP_RS)
#else
#define BF_IPU_IC_IDMAC_1_T1_FLIP_RS(v)   (((v) << 20) & BM_IPU_IC_IDMAC_1_T1_FLIP_RS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T1_FLIP_RS field to a new value.
#define BW_IPU_IC_IDMAC_1_T1_FLIP_RS(v)   BF_CS1(IPU_IC_IDMAC_1, T1_FLIP_RS, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field T2_FLIP_RS (RW)
 *
 * LEFT/RIGHT flip for View Finder (VF) task; this bit affect the flipping done on the resizing
 * unit. The value of this field must be identical to the corresponding channel's HF parameter in
 * the IDMAC's CPMEM This bit is reserved on IPUv3D as this feature is not supported on IPUv3D
 *
 * Values:
 * 1 - horizontal flip enabled
 * 0 - no flip
 */

#define BP_IPU_IC_IDMAC_1_T2_FLIP_RS      21
#define BM_IPU_IC_IDMAC_1_T2_FLIP_RS      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_T2_FLIP_RS(v)   ((((reg32_t) v) << 21) & BM_IPU_IC_IDMAC_1_T2_FLIP_RS)
#else
#define BF_IPU_IC_IDMAC_1_T2_FLIP_RS(v)   (((v) << 21) & BM_IPU_IC_IDMAC_1_T2_FLIP_RS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T2_FLIP_RS field to a new value.
#define BW_IPU_IC_IDMAC_1_T2_FLIP_RS(v)   BF_CS1(IPU_IC_IDMAC_1, T2_FLIP_RS, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field T3_FLIP_RS (RW)
 *
 * LEFT/RIGHT flip for Post Processing (PP) task; his bit affect the flipping done on the resizing
 * unit. The value of this field must be identical to the corresponding channel's HF parameter in
 * the IDMAC's CPMEM This bit is reserved on IPUv3D as this feature is not supported on IPUv3D
 *
 * Values:
 * 1 - horizontal flip enabled
 * 0 - no flip
 */

#define BP_IPU_IC_IDMAC_1_T3_FLIP_RS      22
#define BM_IPU_IC_IDMAC_1_T3_FLIP_RS      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_T3_FLIP_RS(v)   ((((reg32_t) v) << 22) & BM_IPU_IC_IDMAC_1_T3_FLIP_RS)
#else
#define BF_IPU_IC_IDMAC_1_T3_FLIP_RS(v)   (((v) << 22) & BM_IPU_IC_IDMAC_1_T3_FLIP_RS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T3_FLIP_RS field to a new value.
#define BW_IPU_IC_IDMAC_1_T3_FLIP_RS(v)   BF_CS1(IPU_IC_IDMAC_1, T3_FLIP_RS, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_1, field ALT_CB6_BURST_16 (RW)
 *
 * This bit defines the number of active cycles within a burst (burst size) coming from the IDMAC
 * for IC's CB6 when used in alternate mode. For pixel data the number of pixels should match the
 * NPB[6:2] value on the IDMAC's CPMEM Reserved
 */

#define BP_IPU_IC_IDMAC_1_ALT_CB6_BURST_16      24
#define BM_IPU_IC_IDMAC_1_ALT_CB6_BURST_16      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_ALT_CB6_BURST_16(v)   ((((reg32_t) v) << 24) & BM_IPU_IC_IDMAC_1_ALT_CB6_BURST_16)
#else
#define BF_IPU_IC_IDMAC_1_ALT_CB6_BURST_16(v)   (((v) << 24) & BM_IPU_IC_IDMAC_1_ALT_CB6_BURST_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ALT_CB6_BURST_16 field to a new value.
#define BW_IPU_IC_IDMAC_1_ALT_CB6_BURST_16(v)   BF_CS1(IPU_IC_IDMAC_1, ALT_CB6_BURST_16, v)
#endif

/* --- Register HW_IPU_IC_IDMAC_1, field ALT_CB7_BURST_16 (RW)
 *
 * This bit defines the number of pixels within a burst (burst size) coming from the IDMAC for IC's
 * CB7 when used in alternate mode. For pixel data the number of pixels should match the NPB[6:2]
 * value on the IDMAC's CPMEM Reserved
 */

#define BP_IPU_IC_IDMAC_1_ALT_CB7_BURST_16      25
#define BM_IPU_IC_IDMAC_1_ALT_CB7_BURST_16      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_1_ALT_CB7_BURST_16(v)   ((((reg32_t) v) << 25) & BM_IPU_IC_IDMAC_1_ALT_CB7_BURST_16)
#else
#define BF_IPU_IC_IDMAC_1_ALT_CB7_BURST_16(v)   (((v) << 25) & BM_IPU_IC_IDMAC_1_ALT_CB7_BURST_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ALT_CB7_BURST_16 field to a new value.
#define BW_IPU_IC_IDMAC_1_ALT_CB7_BURST_16(v)   BF_CS1(IPU_IC_IDMAC_1, ALT_CB7_BURST_16, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IC_IDMAC_2 - IC IDMAC Parameters 2 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned T1_FR_HEIGHT : 10; //!< Frame Height for Encoding (ENC) task The value of this field must be identical to corresponding FH channel's parameters in the IDMAC's CPMEM. This parameter refers to the output's size -1
        unsigned T2_FR_HEIGHT : 10; //!< Frame Height for View Finder (VF) task The value of this field must be identical to the corresponding FH channel's parameters in the IDMAC's CPMEM. This parameter refers to the output's size -1
        unsigned T3_FR_HEIGHT : 10; //!< Frame Height for Post Processing (PP) task The value of this field must be identical to the corresponding FH channel's parameters in the IDMAC's CPMEM. This parameter refers to the output's size -1
        unsigned RESERVED0 : 2; //!< Reserved
    } B;
} hw_ipu_ic_idmac_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IC_IDMAC_2 register
 */
#define HW_IPU_IC_IDMAC_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x2001c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IC_IDMAC_2(x)           (*(volatile hw_ipu_ic_idmac_2_t *) HW_IPU_IC_IDMAC_2_ADDR(x))
#define HW_IPU_IC_IDMAC_2_RD(x)        (HW_IPU_IC_IDMAC_2(x).U)
#define HW_IPU_IC_IDMAC_2_WR(x, v)     (HW_IPU_IC_IDMAC_2(x).U = (v))
#define HW_IPU_IC_IDMAC_2_SET(x, v)    (HW_IPU_IC_IDMAC_2_WR(x, HW_IPU_IC_IDMAC_2_RD(x) |  (v)))
#define HW_IPU_IC_IDMAC_2_CLR(x, v)    (HW_IPU_IC_IDMAC_2_WR(x, HW_IPU_IC_IDMAC_2_RD(x) & ~(v)))
#define HW_IPU_IC_IDMAC_2_TOG(x, v)    (HW_IPU_IC_IDMAC_2_WR(x, HW_IPU_IC_IDMAC_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IC_IDMAC_2 bitfields
 */

/* --- Register HW_IPU_IC_IDMAC_2, field T1_FR_HEIGHT (RW)
 *
 * Frame Height for Encoding (ENC) task The value of this field must be identical to corresponding
 * FH channel's parameters in the IDMAC's CPMEM. This parameter refers to the output's size -1
 */

#define BP_IPU_IC_IDMAC_2_T1_FR_HEIGHT      0
#define BM_IPU_IC_IDMAC_2_T1_FR_HEIGHT      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_2_T1_FR_HEIGHT(v)   ((((reg32_t) v) << 0) & BM_IPU_IC_IDMAC_2_T1_FR_HEIGHT)
#else
#define BF_IPU_IC_IDMAC_2_T1_FR_HEIGHT(v)   (((v) << 0) & BM_IPU_IC_IDMAC_2_T1_FR_HEIGHT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T1_FR_HEIGHT field to a new value.
#define BW_IPU_IC_IDMAC_2_T1_FR_HEIGHT(v)   BF_CS1(IPU_IC_IDMAC_2, T1_FR_HEIGHT, v)
#endif

/* --- Register HW_IPU_IC_IDMAC_2, field T2_FR_HEIGHT (RW)
 *
 * Frame Height for View Finder (VF) task The value of this field must be identical to the
 * corresponding FH channel's parameters in the IDMAC's CPMEM. This parameter refers to the output's
 * size -1
 */

#define BP_IPU_IC_IDMAC_2_T2_FR_HEIGHT      10
#define BM_IPU_IC_IDMAC_2_T2_FR_HEIGHT      0x000ffc00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_2_T2_FR_HEIGHT(v)   ((((reg32_t) v) << 10) & BM_IPU_IC_IDMAC_2_T2_FR_HEIGHT)
#else
#define BF_IPU_IC_IDMAC_2_T2_FR_HEIGHT(v)   (((v) << 10) & BM_IPU_IC_IDMAC_2_T2_FR_HEIGHT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T2_FR_HEIGHT field to a new value.
#define BW_IPU_IC_IDMAC_2_T2_FR_HEIGHT(v)   BF_CS1(IPU_IC_IDMAC_2, T2_FR_HEIGHT, v)
#endif

/* --- Register HW_IPU_IC_IDMAC_2, field T3_FR_HEIGHT (RW)
 *
 * Frame Height for Post Processing (PP) task The value of this field must be identical to the
 * corresponding FH channel's parameters in the IDMAC's CPMEM. This parameter refers to the output's
 * size -1
 */

#define BP_IPU_IC_IDMAC_2_T3_FR_HEIGHT      20
#define BM_IPU_IC_IDMAC_2_T3_FR_HEIGHT      0x3ff00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_2_T3_FR_HEIGHT(v)   ((((reg32_t) v) << 20) & BM_IPU_IC_IDMAC_2_T3_FR_HEIGHT)
#else
#define BF_IPU_IC_IDMAC_2_T3_FR_HEIGHT(v)   (((v) << 20) & BM_IPU_IC_IDMAC_2_T3_FR_HEIGHT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T3_FR_HEIGHT field to a new value.
#define BW_IPU_IC_IDMAC_2_T3_FR_HEIGHT(v)   BF_CS1(IPU_IC_IDMAC_2, T3_FR_HEIGHT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IC_IDMAC_3 - IC IDMAC Parameters 3Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned T1_FR_WIDTH : 10; //!< Frame Width for Encoding (ENC) task The value of this field must be identical to corresponding FW channel's parameters in the IDMAC's CPMEM. This parameter refers to the output's size -1
        unsigned T2_FR_WIDTH : 10; //!< Frame Width for View Finder (VF) task The value of this field must be identical to the corresponding FW channel's parameters in the IDMAC's CPMEM. This parameter refers to the output's size -1
        unsigned T3_FR_WIDTH : 10; //!< Frame Width for Post Processing (PP) task The value of this field must be identical to the corresponding FW channel's parameters in the IDMAC's CPMEM. This parameter refers to the output's size -1
        unsigned RESERVED0 : 2; //!< Reserved
    } B;
} hw_ipu_ic_idmac_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IC_IDMAC_3 register
 */
#define HW_IPU_IC_IDMAC_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x20020)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IC_IDMAC_3(x)           (*(volatile hw_ipu_ic_idmac_3_t *) HW_IPU_IC_IDMAC_3_ADDR(x))
#define HW_IPU_IC_IDMAC_3_RD(x)        (HW_IPU_IC_IDMAC_3(x).U)
#define HW_IPU_IC_IDMAC_3_WR(x, v)     (HW_IPU_IC_IDMAC_3(x).U = (v))
#define HW_IPU_IC_IDMAC_3_SET(x, v)    (HW_IPU_IC_IDMAC_3_WR(x, HW_IPU_IC_IDMAC_3_RD(x) |  (v)))
#define HW_IPU_IC_IDMAC_3_CLR(x, v)    (HW_IPU_IC_IDMAC_3_WR(x, HW_IPU_IC_IDMAC_3_RD(x) & ~(v)))
#define HW_IPU_IC_IDMAC_3_TOG(x, v)    (HW_IPU_IC_IDMAC_3_WR(x, HW_IPU_IC_IDMAC_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IC_IDMAC_3 bitfields
 */

/* --- Register HW_IPU_IC_IDMAC_3, field T1_FR_WIDTH (RW)
 *
 * Frame Width for Encoding (ENC) task The value of this field must be identical to corresponding FW
 * channel's parameters in the IDMAC's CPMEM. This parameter refers to the output's size -1
 */

#define BP_IPU_IC_IDMAC_3_T1_FR_WIDTH      0
#define BM_IPU_IC_IDMAC_3_T1_FR_WIDTH      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_3_T1_FR_WIDTH(v)   ((((reg32_t) v) << 0) & BM_IPU_IC_IDMAC_3_T1_FR_WIDTH)
#else
#define BF_IPU_IC_IDMAC_3_T1_FR_WIDTH(v)   (((v) << 0) & BM_IPU_IC_IDMAC_3_T1_FR_WIDTH)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T1_FR_WIDTH field to a new value.
#define BW_IPU_IC_IDMAC_3_T1_FR_WIDTH(v)   BF_CS1(IPU_IC_IDMAC_3, T1_FR_WIDTH, v)
#endif

/* --- Register HW_IPU_IC_IDMAC_3, field T2_FR_WIDTH (RW)
 *
 * Frame Width for View Finder (VF) task The value of this field must be identical to the
 * corresponding FW channel's parameters in the IDMAC's CPMEM. This parameter refers to the output's
 * size -1
 */

#define BP_IPU_IC_IDMAC_3_T2_FR_WIDTH      10
#define BM_IPU_IC_IDMAC_3_T2_FR_WIDTH      0x000ffc00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_3_T2_FR_WIDTH(v)   ((((reg32_t) v) << 10) & BM_IPU_IC_IDMAC_3_T2_FR_WIDTH)
#else
#define BF_IPU_IC_IDMAC_3_T2_FR_WIDTH(v)   (((v) << 10) & BM_IPU_IC_IDMAC_3_T2_FR_WIDTH)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T2_FR_WIDTH field to a new value.
#define BW_IPU_IC_IDMAC_3_T2_FR_WIDTH(v)   BF_CS1(IPU_IC_IDMAC_3, T2_FR_WIDTH, v)
#endif

/* --- Register HW_IPU_IC_IDMAC_3, field T3_FR_WIDTH (RW)
 *
 * Frame Width for Post Processing (PP) task The value of this field must be identical to the
 * corresponding FW channel's parameters in the IDMAC's CPMEM. This parameter refers to the output's
 * size -1
 */

#define BP_IPU_IC_IDMAC_3_T3_FR_WIDTH      20
#define BM_IPU_IC_IDMAC_3_T3_FR_WIDTH      0x3ff00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_3_T3_FR_WIDTH(v)   ((((reg32_t) v) << 20) & BM_IPU_IC_IDMAC_3_T3_FR_WIDTH)
#else
#define BF_IPU_IC_IDMAC_3_T3_FR_WIDTH(v)   (((v) << 20) & BM_IPU_IC_IDMAC_3_T3_FR_WIDTH)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the T3_FR_WIDTH field to a new value.
#define BW_IPU_IC_IDMAC_3_T3_FR_WIDTH(v)   BF_CS1(IPU_IC_IDMAC_3, T3_FR_WIDTH, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IC_IDMAC_4 - IC IDMAC Parameters 4 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MPM_RW_BRDG_MAX_RQ : 4; //!< MPM memory Bridge Max Requests between MPM's read and writes
        unsigned MPM_DMFC_BRDG_MAX_RQ : 4; //!< MPM memory Bridge Max Requests for the IC DMFC interface
        unsigned IBM_BRDG_MAX_RQ : 4; //!< IBM memory Bridge Max Requests
        unsigned RM_BRDG_MAX_RQ : 4; //!< RM memory Bridge Max Requests
        unsigned RESERVED0 : 16; //!< Reserved
    } B;
} hw_ipu_ic_idmac_4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IC_IDMAC_4 register
 */
#define HW_IPU_IC_IDMAC_4_ADDR(x)      (REGS_IPU_BASE(x) + 0x20024)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IC_IDMAC_4(x)           (*(volatile hw_ipu_ic_idmac_4_t *) HW_IPU_IC_IDMAC_4_ADDR(x))
#define HW_IPU_IC_IDMAC_4_RD(x)        (HW_IPU_IC_IDMAC_4(x).U)
#define HW_IPU_IC_IDMAC_4_WR(x, v)     (HW_IPU_IC_IDMAC_4(x).U = (v))
#define HW_IPU_IC_IDMAC_4_SET(x, v)    (HW_IPU_IC_IDMAC_4_WR(x, HW_IPU_IC_IDMAC_4_RD(x) |  (v)))
#define HW_IPU_IC_IDMAC_4_CLR(x, v)    (HW_IPU_IC_IDMAC_4_WR(x, HW_IPU_IC_IDMAC_4_RD(x) & ~(v)))
#define HW_IPU_IC_IDMAC_4_TOG(x, v)    (HW_IPU_IC_IDMAC_4_WR(x, HW_IPU_IC_IDMAC_4_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IC_IDMAC_4 bitfields
 */

/* --- Register HW_IPU_IC_IDMAC_4, field MPM_RW_BRDG_MAX_RQ (RW)
 *
 * MPM memory Bridge Max Requests between MPM's read and writes
 *
 * Values:
 * 0000 - Feature is disabled
 * 0001 - Max request is 1
 * 1111 - Max request are15
 */

#define BP_IPU_IC_IDMAC_4_MPM_RW_BRDG_MAX_RQ      0
#define BM_IPU_IC_IDMAC_4_MPM_RW_BRDG_MAX_RQ      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_4_MPM_RW_BRDG_MAX_RQ(v)   ((((reg32_t) v) << 0) & BM_IPU_IC_IDMAC_4_MPM_RW_BRDG_MAX_RQ)
#else
#define BF_IPU_IC_IDMAC_4_MPM_RW_BRDG_MAX_RQ(v)   (((v) << 0) & BM_IPU_IC_IDMAC_4_MPM_RW_BRDG_MAX_RQ)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MPM_RW_BRDG_MAX_RQ field to a new value.
#define BW_IPU_IC_IDMAC_4_MPM_RW_BRDG_MAX_RQ(v)   BF_CS1(IPU_IC_IDMAC_4, MPM_RW_BRDG_MAX_RQ, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_4, field MPM_DMFC_BRDG_MAX_RQ (RW)
 *
 * MPM memory Bridge Max Requests for the IC DMFC interface
 *
 * Values:
 * 0000 - Feature is disabled
 * 0001 - Max request is 1
 * 1111 - Max request are15
 */

#define BP_IPU_IC_IDMAC_4_MPM_DMFC_BRDG_MAX_RQ      4
#define BM_IPU_IC_IDMAC_4_MPM_DMFC_BRDG_MAX_RQ      0x000000f0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_4_MPM_DMFC_BRDG_MAX_RQ(v)   ((((reg32_t) v) << 4) & BM_IPU_IC_IDMAC_4_MPM_DMFC_BRDG_MAX_RQ)
#else
#define BF_IPU_IC_IDMAC_4_MPM_DMFC_BRDG_MAX_RQ(v)   (((v) << 4) & BM_IPU_IC_IDMAC_4_MPM_DMFC_BRDG_MAX_RQ)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MPM_DMFC_BRDG_MAX_RQ field to a new value.
#define BW_IPU_IC_IDMAC_4_MPM_DMFC_BRDG_MAX_RQ(v)   BF_CS1(IPU_IC_IDMAC_4, MPM_DMFC_BRDG_MAX_RQ, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_4, field IBM_BRDG_MAX_RQ (RW)
 *
 * IBM memory Bridge Max Requests
 *
 * Values:
 * 0000 - Feature is disabled
 * 0001 - Max request is 1
 * 1111 - Max request are15
 */

#define BP_IPU_IC_IDMAC_4_IBM_BRDG_MAX_RQ      8
#define BM_IPU_IC_IDMAC_4_IBM_BRDG_MAX_RQ      0x00000f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_4_IBM_BRDG_MAX_RQ(v)   ((((reg32_t) v) << 8) & BM_IPU_IC_IDMAC_4_IBM_BRDG_MAX_RQ)
#else
#define BF_IPU_IC_IDMAC_4_IBM_BRDG_MAX_RQ(v)   (((v) << 8) & BM_IPU_IC_IDMAC_4_IBM_BRDG_MAX_RQ)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IBM_BRDG_MAX_RQ field to a new value.
#define BW_IPU_IC_IDMAC_4_IBM_BRDG_MAX_RQ(v)   BF_CS1(IPU_IC_IDMAC_4, IBM_BRDG_MAX_RQ, v)
#endif


/* --- Register HW_IPU_IC_IDMAC_4, field RM_BRDG_MAX_RQ (RW)
 *
 * RM memory Bridge Max Requests
 *
 * Values:
 * 0000 - Feature is disabled
 * 0001 - Max request is 1
 * 1111 - Max request are15
 */

#define BP_IPU_IC_IDMAC_4_RM_BRDG_MAX_RQ      12
#define BM_IPU_IC_IDMAC_4_RM_BRDG_MAX_RQ      0x0000f000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IC_IDMAC_4_RM_BRDG_MAX_RQ(v)   ((((reg32_t) v) << 12) & BM_IPU_IC_IDMAC_4_RM_BRDG_MAX_RQ)
#else
#define BF_IPU_IC_IDMAC_4_RM_BRDG_MAX_RQ(v)   (((v) << 12) & BM_IPU_IC_IDMAC_4_RM_BRDG_MAX_RQ)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the RM_BRDG_MAX_RQ field to a new value.
#define BW_IPU_IC_IDMAC_4_RM_BRDG_MAX_RQ(v)   BF_CS1(IPU_IC_IDMAC_4, RM_BRDG_MAX_RQ, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI0_SENS_CONF - CSI0 Sensor Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_VSYNC_POL : 1; //!< Invert IPP_IND_SENSB_VSYNC input. This bit selects the polarity of IPP_IND_SENSB_VSYNC signal.
        unsigned CSI0_HSYNC_POL : 1; //!< Invert IPP_IND_SENSB_HSYNC input. This bit selects the polarity of IPP_IND_SENSB_HSYNC signal.
        unsigned CSI0_DATA_POL : 1; //!< Invert data input. This bit selects the polarity of data input.
        unsigned CSI0_SENS_PIX_CLK_POL : 1; //!< Invert Pixel clock input. This bit selects the polarity of pixel clock.
        unsigned CSI0_SENS_PRTCL : 3; //!< Sensor Protocol. This bit defines the Sensor timing/data mode protocol. Values:
        unsigned CSI0_PACK_TIGHT : 1; //!< CSI0 Pack Tight When the data format is YUV or RGB and the component's width is 9-16 bits, it can be sent to the memory in 2 different ways.
        unsigned CSI0_SENS_DATA_FORMAT : 3; //!< Data format from the sensor. This field defines the data format for the input of the CSI sensor. Values:
        unsigned CSI0_DATA_WIDTH : 4; //!< Data width. This field defines the number of bits per color. Values:
        unsigned CSI0_EXT_VSYNC : 1; //!< External VSYNC enable. This bits select between external and internal VSYNC.
        unsigned CSI0_DIV_RATIO : 8; //!< DIV Ratio Clock division ratio minus 1. This field defines the division ratio of HSP_CLK into SENSB_MCLK: SENSB_MCLK rate = HSP_CLK rate /(DIV_RATIO+1)
        unsigned CSI0_DATA_DEST : 3; //!< These bits enable the destination of the data coming from the CSI. CSI0_DATA_DEST[0] - destination is ISP (including statistics) Reserved CSI0_DATA_DEST[1] - destination is IC CSI0_DATA_DEST[2] - destination is IDMAC via SMFC
        unsigned CSI0_JPEG8_EN : 1; //!< JPEG8 enable bit
        unsigned CSI0_JPEG_MODE : 1; //!< JPEG Mode - this bit defines the mode of the control signals when working in JPEG mode
        unsigned CSI0_FORCE_EOF : 1; //!< Force End of frame This is a self clear bit allowing the user to force an End-of-frame event; This bit can be used in cases where the frame sent by the sensor was not completed.
        unsigned RESERVED0 : 1; //!< Reserved, should be cleared.
        unsigned CSI0_DATA_EN_POL : 1; //!< Invert IPP_IND_SENSB_DATA_EN input. This bit selects the polarity of IPP_IND_SENSB_DATA_EN signal.
    } B;
} hw_ipu_csi0_sens_conf_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI0_SENS_CONF register
 */
#define HW_IPU_CSI0_SENS_CONF_ADDR(x)      (REGS_IPU_BASE(x) + 0x30000)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI0_SENS_CONF(x)           (*(volatile hw_ipu_csi0_sens_conf_t *) HW_IPU_CSI0_SENS_CONF_ADDR(x))
#define HW_IPU_CSI0_SENS_CONF_RD(x)        (HW_IPU_CSI0_SENS_CONF(x).U)
#define HW_IPU_CSI0_SENS_CONF_WR(x, v)     (HW_IPU_CSI0_SENS_CONF(x).U = (v))
#define HW_IPU_CSI0_SENS_CONF_SET(x, v)    (HW_IPU_CSI0_SENS_CONF_WR(x, HW_IPU_CSI0_SENS_CONF_RD(x) |  (v)))
#define HW_IPU_CSI0_SENS_CONF_CLR(x, v)    (HW_IPU_CSI0_SENS_CONF_WR(x, HW_IPU_CSI0_SENS_CONF_RD(x) & ~(v)))
#define HW_IPU_CSI0_SENS_CONF_TOG(x, v)    (HW_IPU_CSI0_SENS_CONF_WR(x, HW_IPU_CSI0_SENS_CONF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI0_SENS_CONF bitfields
 */

/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_VSYNC_POL (RW)
 *
 * Invert IPP_IND_SENSB_VSYNC input. This bit selects the polarity of IPP_IND_SENSB_VSYNC signal.
 *
 * Values:
 * 0 - IPP_IND_SENSB_VSYNC is not inverted before applied to internal circuitry.
 * 1 - IPP_IND_SENSB_VSYNC is inverted before applied to internal circuitry.
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_VSYNC_POL      0
#define BM_IPU_CSI0_SENS_CONF_CSI0_VSYNC_POL      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_VSYNC_POL(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI0_SENS_CONF_CSI0_VSYNC_POL)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_VSYNC_POL(v)   (((v) << 0) & BM_IPU_CSI0_SENS_CONF_CSI0_VSYNC_POL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_VSYNC_POL field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_VSYNC_POL(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_VSYNC_POL, v)
#endif


/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_HSYNC_POL (RW)
 *
 * Invert IPP_IND_SENSB_HSYNC input. This bit selects the polarity of IPP_IND_SENSB_HSYNC signal.
 *
 * Values:
 * 0 - IPP_IND_SENSB_HSYNC is directly applied to internal circuitry.
 * 1 - IPP_IND_SENSB_HSYNC is inverted before applied to internal circuitry.
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_HSYNC_POL      1
#define BM_IPU_CSI0_SENS_CONF_CSI0_HSYNC_POL      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_HSYNC_POL(v)   ((((reg32_t) v) << 1) & BM_IPU_CSI0_SENS_CONF_CSI0_HSYNC_POL)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_HSYNC_POL(v)   (((v) << 1) & BM_IPU_CSI0_SENS_CONF_CSI0_HSYNC_POL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_HSYNC_POL field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_HSYNC_POL(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_HSYNC_POL, v)
#endif


/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_DATA_POL (RW)
 *
 * Invert data input. This bit selects the polarity of data input.
 *
 * Values:
 * 0 - data lines are directly applied to internal circuitry.
 * 1 - data lines are inverted before applied to internal circuitry.
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_DATA_POL      2
#define BM_IPU_CSI0_SENS_CONF_CSI0_DATA_POL      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_DATA_POL(v)   ((((reg32_t) v) << 2) & BM_IPU_CSI0_SENS_CONF_CSI0_DATA_POL)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_DATA_POL(v)   (((v) << 2) & BM_IPU_CSI0_SENS_CONF_CSI0_DATA_POL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_DATA_POL field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_DATA_POL(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_DATA_POL, v)
#endif


/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_SENS_PIX_CLK_POL (RW)
 *
 * Invert Pixel clock input. This bit selects the polarity of pixel clock.
 *
 * Values:
 * 0 - pixel clock is directly applied to internal circuitry.
 * 1 - pixel clock is inverted before applied to internal circuitry.
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_SENS_PIX_CLK_POL      3
#define BM_IPU_CSI0_SENS_CONF_CSI0_SENS_PIX_CLK_POL      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_SENS_PIX_CLK_POL(v)   ((((reg32_t) v) << 3) & BM_IPU_CSI0_SENS_CONF_CSI0_SENS_PIX_CLK_POL)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_SENS_PIX_CLK_POL(v)   (((v) << 3) & BM_IPU_CSI0_SENS_CONF_CSI0_SENS_PIX_CLK_POL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_SENS_PIX_CLK_POL field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_SENS_PIX_CLK_POL(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_SENS_PIX_CLK_POL, v)
#endif


/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_SENS_PRTCL (RW)
 *
 * Sensor Protocol. This bit defines the Sensor timing/data mode protocol. Values:
 *
 * Values:
 * 000 - Gated clock mode
 * 001 - Non-gated clock mode
 * 010 - CCIR progressive mode (BT.656)
 * 011 - CCIR interlaced mode (BT.656)
 * 100 - CCIR progressive (BT.1120 DDR mode: data arrives on every edge of the clock)
 * 101 - CCIR progressive (BT.1120 SDR mode: data arrives only on the positive edge of the clock)
 * 110 - CCIR interlaced mode (BT.1120 DDR mode: data arrives on every edge of the clock)
 * 111 - CCIR interlaced mode (BT.1120 SDR mode: data arrives only on the positive edge of the clock)
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_SENS_PRTCL      4
#define BM_IPU_CSI0_SENS_CONF_CSI0_SENS_PRTCL      0x00000070

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_SENS_PRTCL(v)   ((((reg32_t) v) << 4) & BM_IPU_CSI0_SENS_CONF_CSI0_SENS_PRTCL)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_SENS_PRTCL(v)   (((v) << 4) & BM_IPU_CSI0_SENS_CONF_CSI0_SENS_PRTCL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_SENS_PRTCL field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_SENS_PRTCL(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_SENS_PRTCL, v)
#endif


/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_PACK_TIGHT (RW)
 *
 * CSI0 Pack Tight When the data format is YUV or RGB and the component's width is 9-16 bits, it can
 * be sent to the memory in 2 different ways.
 *
 * Values:
 * 1 - Three 10 bits components are packed into a 32 bit word. Color extension/reduction is performed
 * 0 - Each component is written as a 16 bit word where the MSB is written to bit #15, color extension is
 *     done for the remaining least significant bits.
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_PACK_TIGHT      7
#define BM_IPU_CSI0_SENS_CONF_CSI0_PACK_TIGHT      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_PACK_TIGHT(v)   ((((reg32_t) v) << 7) & BM_IPU_CSI0_SENS_CONF_CSI0_PACK_TIGHT)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_PACK_TIGHT(v)   (((v) << 7) & BM_IPU_CSI0_SENS_CONF_CSI0_PACK_TIGHT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_PACK_TIGHT field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_PACK_TIGHT(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_PACK_TIGHT, v)
#endif


/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_SENS_DATA_FORMAT (RW)
 *
 * Data format from the sensor. This field defines the data format for the input of the CSI sensor.
 * Values:
 *
 * Values:
 * 000 - full RGB or YUV444
 * 001 - YUV422 (YUYV...)
 * 010 - YUV422 (UYVY...)
 * 011 - Bayer or Generic data
 * 100 - RGB565
 * 101 - RGB555
 * 110 - RGB444
 * 111 - JPEG
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_SENS_DATA_FORMAT      8
#define BM_IPU_CSI0_SENS_CONF_CSI0_SENS_DATA_FORMAT      0x00000700

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_SENS_DATA_FORMAT(v)   ((((reg32_t) v) << 8) & BM_IPU_CSI0_SENS_CONF_CSI0_SENS_DATA_FORMAT)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_SENS_DATA_FORMAT(v)   (((v) << 8) & BM_IPU_CSI0_SENS_CONF_CSI0_SENS_DATA_FORMAT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_SENS_DATA_FORMAT field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_SENS_DATA_FORMAT(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_SENS_DATA_FORMAT, v)
#endif


/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_DATA_WIDTH (RW)
 *
 * Data width. This field defines the number of bits per color. Values:
 *
 * Values:
 * 0000 - 4 bits per color
 * 0000 - Reserved
 * 0001 - 8 bits per color
 * 0010 - 9 bits per color
 * 0010 - Reserved
 * 0011 - 10 bits per color
 * 0100 - 11 bits per color
 * 0100 - Reserved
 * 0101 - 12 bits per color
 * 0101 - Reserved
 * 0110 - 13 bits per color
 * 0110 - Reserved
 * 0111 - 14 bits per color
 * 0111 - Reserved
 * 1000 - 15 bits per color
 * 1000 - Reserved
 * 1001 - 16 bits per color
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_DATA_WIDTH      11
#define BM_IPU_CSI0_SENS_CONF_CSI0_DATA_WIDTH      0x00007800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_DATA_WIDTH(v)   ((((reg32_t) v) << 11) & BM_IPU_CSI0_SENS_CONF_CSI0_DATA_WIDTH)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_DATA_WIDTH(v)   (((v) << 11) & BM_IPU_CSI0_SENS_CONF_CSI0_DATA_WIDTH)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_DATA_WIDTH field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_DATA_WIDTH(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_DATA_WIDTH, v)
#endif


/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_EXT_VSYNC (RW)
 *
 * External VSYNC enable. This bits select between external and internal VSYNC.
 *
 * Values:
 * 0 - Internal VSYNC mode.
 * 1 - External VSYNC mode.
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_EXT_VSYNC      15
#define BM_IPU_CSI0_SENS_CONF_CSI0_EXT_VSYNC      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_EXT_VSYNC(v)   ((((reg32_t) v) << 15) & BM_IPU_CSI0_SENS_CONF_CSI0_EXT_VSYNC)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_EXT_VSYNC(v)   (((v) << 15) & BM_IPU_CSI0_SENS_CONF_CSI0_EXT_VSYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_EXT_VSYNC field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_EXT_VSYNC(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_EXT_VSYNC, v)
#endif


/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_DIV_RATIO (RW)
 *
 * DIV Ratio Clock division ratio minus 1. This field defines the division ratio of HSP_CLK into
 * SENSB_MCLK: SENSB_MCLK rate = HSP_CLK rate /(DIV_RATIO+1)
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_DIV_RATIO      16
#define BM_IPU_CSI0_SENS_CONF_CSI0_DIV_RATIO      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_DIV_RATIO(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI0_SENS_CONF_CSI0_DIV_RATIO)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_DIV_RATIO(v)   (((v) << 16) & BM_IPU_CSI0_SENS_CONF_CSI0_DIV_RATIO)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_DIV_RATIO field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_DIV_RATIO(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_DIV_RATIO, v)
#endif

/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_DATA_DEST (RW)
 *
 * These bits enable the destination of the data coming from the CSI. CSI0_DATA_DEST[0] -
 * destination is ISP (including statistics) Reserved CSI0_DATA_DEST[1] - destination is IC
 * CSI0_DATA_DEST[2] - destination is IDMAC via SMFC
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_DATA_DEST      24
#define BM_IPU_CSI0_SENS_CONF_CSI0_DATA_DEST      0x07000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_DATA_DEST(v)   ((((reg32_t) v) << 24) & BM_IPU_CSI0_SENS_CONF_CSI0_DATA_DEST)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_DATA_DEST(v)   (((v) << 24) & BM_IPU_CSI0_SENS_CONF_CSI0_DATA_DEST)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_DATA_DEST field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_DATA_DEST(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_DATA_DEST, v)
#endif

/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_JPEG8_EN (RW)
 *
 * JPEG8 enable bit
 *
 * Values:
 * 1 - JPEG8 detection is enabled
 * 0 - JPEG8 is disabled
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_JPEG8_EN      27
#define BM_IPU_CSI0_SENS_CONF_CSI0_JPEG8_EN      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_JPEG8_EN(v)   ((((reg32_t) v) << 27) & BM_IPU_CSI0_SENS_CONF_CSI0_JPEG8_EN)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_JPEG8_EN(v)   (((v) << 27) & BM_IPU_CSI0_SENS_CONF_CSI0_JPEG8_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_JPEG8_EN field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_JPEG8_EN(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_JPEG8_EN, v)
#endif


/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_JPEG_MODE (RW)
 *
 * JPEG Mode - this bit defines the mode of the control signals when working in JPEG mode
 *
 * Values:
 * 1 - The data is valid as long as HSYNC and VSYNC signals are active; HSYNC is valid for single frame
 * 0 - The frame starts withe the assertion of VSYNC. The frame ends on the next VSYNC or by setting the
 *     CSI0_FORCE_EOF bit.
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_JPEG_MODE      28
#define BM_IPU_CSI0_SENS_CONF_CSI0_JPEG_MODE      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_JPEG_MODE(v)   ((((reg32_t) v) << 28) & BM_IPU_CSI0_SENS_CONF_CSI0_JPEG_MODE)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_JPEG_MODE(v)   (((v) << 28) & BM_IPU_CSI0_SENS_CONF_CSI0_JPEG_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_JPEG_MODE field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_JPEG_MODE(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_JPEG_MODE, v)
#endif


/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_FORCE_EOF (RW)
 *
 * Force End of frame This is a self clear bit allowing the user to force an End-of-frame event;
 * This bit can be used in cases where the frame sent by the sensor was not completed.
 *
 * Values:
 * 1 - force end of frame
 * 0 - no action
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_FORCE_EOF      29
#define BM_IPU_CSI0_SENS_CONF_CSI0_FORCE_EOF      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_FORCE_EOF(v)   ((((reg32_t) v) << 29) & BM_IPU_CSI0_SENS_CONF_CSI0_FORCE_EOF)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_FORCE_EOF(v)   (((v) << 29) & BM_IPU_CSI0_SENS_CONF_CSI0_FORCE_EOF)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_FORCE_EOF field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_FORCE_EOF(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_FORCE_EOF, v)
#endif


/* --- Register HW_IPU_CSI0_SENS_CONF, field CSI0_DATA_EN_POL (RW)
 *
 * Invert IPP_IND_SENSB_DATA_EN input. This bit selects the polarity of IPP_IND_SENSB_DATA_EN
 * signal.
 *
 * Values:
 * 0 - IPP_IND_SENSB_DATA_EN is directly applied to internal circuitry.
 * 1 - IPP_IND_SENSB_DATA_EN is inverted before applied to internal circuitry.
 */

#define BP_IPU_CSI0_SENS_CONF_CSI0_DATA_EN_POL      31
#define BM_IPU_CSI0_SENS_CONF_CSI0_DATA_EN_POL      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_CONF_CSI0_DATA_EN_POL(v)   ((((reg32_t) v) << 31) & BM_IPU_CSI0_SENS_CONF_CSI0_DATA_EN_POL)
#else
#define BF_IPU_CSI0_SENS_CONF_CSI0_DATA_EN_POL(v)   (((v) << 31) & BM_IPU_CSI0_SENS_CONF_CSI0_DATA_EN_POL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_DATA_EN_POL field to a new value.
#define BW_IPU_CSI0_SENS_CONF_CSI0_DATA_EN_POL(v)   BF_CS1(IPU_CSI0_SENS_CONF, CSI0_DATA_EN_POL, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI0_SENS_FRM_SIZE - CSI0 Sense Frame Size Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_SENS_FRM_WIDTH : 13; //!< Sensor frame width minus 1. This field defines the sensor frame column number minus 1.
        unsigned RESERVED0 : 3; //!< Reserved, should be cleared.
        unsigned CSI0_SENS_FRM_HEIGHT : 12; //!< Sensor frame height minus 1. This field defines the sensor frame rows number minus 1.
        unsigned RESERVED1 : 4; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi0_sens_frm_size_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI0_SENS_FRM_SIZE register
 */
#define HW_IPU_CSI0_SENS_FRM_SIZE_ADDR(x)      (REGS_IPU_BASE(x) + 0x30004)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI0_SENS_FRM_SIZE(x)           (*(volatile hw_ipu_csi0_sens_frm_size_t *) HW_IPU_CSI0_SENS_FRM_SIZE_ADDR(x))
#define HW_IPU_CSI0_SENS_FRM_SIZE_RD(x)        (HW_IPU_CSI0_SENS_FRM_SIZE(x).U)
#define HW_IPU_CSI0_SENS_FRM_SIZE_WR(x, v)     (HW_IPU_CSI0_SENS_FRM_SIZE(x).U = (v))
#define HW_IPU_CSI0_SENS_FRM_SIZE_SET(x, v)    (HW_IPU_CSI0_SENS_FRM_SIZE_WR(x, HW_IPU_CSI0_SENS_FRM_SIZE_RD(x) |  (v)))
#define HW_IPU_CSI0_SENS_FRM_SIZE_CLR(x, v)    (HW_IPU_CSI0_SENS_FRM_SIZE_WR(x, HW_IPU_CSI0_SENS_FRM_SIZE_RD(x) & ~(v)))
#define HW_IPU_CSI0_SENS_FRM_SIZE_TOG(x, v)    (HW_IPU_CSI0_SENS_FRM_SIZE_WR(x, HW_IPU_CSI0_SENS_FRM_SIZE_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI0_SENS_FRM_SIZE bitfields
 */

/* --- Register HW_IPU_CSI0_SENS_FRM_SIZE, field CSI0_SENS_FRM_WIDTH (RW)
 *
 * Sensor frame width minus 1. This field defines the sensor frame column number minus 1.
 */

#define BP_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_WIDTH      0
#define BM_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_WIDTH      0x00001fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_WIDTH(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_WIDTH)
#else
#define BF_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_WIDTH(v)   (((v) << 0) & BM_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_WIDTH)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_SENS_FRM_WIDTH field to a new value.
#define BW_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_WIDTH(v)   BF_CS1(IPU_CSI0_SENS_FRM_SIZE, CSI0_SENS_FRM_WIDTH, v)
#endif

/* --- Register HW_IPU_CSI0_SENS_FRM_SIZE, field CSI0_SENS_FRM_HEIGHT (RW)
 *
 * Sensor frame height minus 1. This field defines the sensor frame rows number minus 1.
 */

#define BP_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_HEIGHT      16
#define BM_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_HEIGHT      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_HEIGHT(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_HEIGHT)
#else
#define BF_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_HEIGHT(v)   (((v) << 16) & BM_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_HEIGHT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_SENS_FRM_HEIGHT field to a new value.
#define BW_IPU_CSI0_SENS_FRM_SIZE_CSI0_SENS_FRM_HEIGHT(v)   BF_CS1(IPU_CSI0_SENS_FRM_SIZE, CSI0_SENS_FRM_HEIGHT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI0_ACT_FRM_SIZE - CSI0 Actual Frame Size Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_ACT_FRM_WIDTH : 13; //!< Actual frame width minus 1. This field defines the CSI output frame columns number minus 1.
        unsigned RESERVED0 : 3; //!< Reserved, should be cleared.
        unsigned CSI0_ACT_FRM_HEIGHT : 12; //!< Actual frame height minus 1. This field defines the CSI output frame rows number minus 1.
        unsigned RESERVED1 : 4; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi0_act_frm_size_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI0_ACT_FRM_SIZE register
 */
#define HW_IPU_CSI0_ACT_FRM_SIZE_ADDR(x)      (REGS_IPU_BASE(x) + 0x30008)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI0_ACT_FRM_SIZE(x)           (*(volatile hw_ipu_csi0_act_frm_size_t *) HW_IPU_CSI0_ACT_FRM_SIZE_ADDR(x))
#define HW_IPU_CSI0_ACT_FRM_SIZE_RD(x)        (HW_IPU_CSI0_ACT_FRM_SIZE(x).U)
#define HW_IPU_CSI0_ACT_FRM_SIZE_WR(x, v)     (HW_IPU_CSI0_ACT_FRM_SIZE(x).U = (v))
#define HW_IPU_CSI0_ACT_FRM_SIZE_SET(x, v)    (HW_IPU_CSI0_ACT_FRM_SIZE_WR(x, HW_IPU_CSI0_ACT_FRM_SIZE_RD(x) |  (v)))
#define HW_IPU_CSI0_ACT_FRM_SIZE_CLR(x, v)    (HW_IPU_CSI0_ACT_FRM_SIZE_WR(x, HW_IPU_CSI0_ACT_FRM_SIZE_RD(x) & ~(v)))
#define HW_IPU_CSI0_ACT_FRM_SIZE_TOG(x, v)    (HW_IPU_CSI0_ACT_FRM_SIZE_WR(x, HW_IPU_CSI0_ACT_FRM_SIZE_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI0_ACT_FRM_SIZE bitfields
 */

/* --- Register HW_IPU_CSI0_ACT_FRM_SIZE, field CSI0_ACT_FRM_WIDTH (RW)
 *
 * Actual frame width minus 1. This field defines the CSI output frame columns number minus 1.
 */

#define BP_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_WIDTH      0
#define BM_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_WIDTH      0x00001fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_WIDTH(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_WIDTH)
#else
#define BF_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_WIDTH(v)   (((v) << 0) & BM_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_WIDTH)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_ACT_FRM_WIDTH field to a new value.
#define BW_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_WIDTH(v)   BF_CS1(IPU_CSI0_ACT_FRM_SIZE, CSI0_ACT_FRM_WIDTH, v)
#endif

/* --- Register HW_IPU_CSI0_ACT_FRM_SIZE, field CSI0_ACT_FRM_HEIGHT (RW)
 *
 * Actual frame height minus 1. This field defines the CSI output frame rows number minus 1.
 */

#define BP_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_HEIGHT      16
#define BM_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_HEIGHT      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_HEIGHT(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_HEIGHT)
#else
#define BF_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_HEIGHT(v)   (((v) << 16) & BM_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_HEIGHT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_ACT_FRM_HEIGHT field to a new value.
#define BW_IPU_CSI0_ACT_FRM_SIZE_CSI0_ACT_FRM_HEIGHT(v)   BF_CS1(IPU_CSI0_ACT_FRM_SIZE, CSI0_ACT_FRM_HEIGHT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI0_OUT_FRM_CTRL - CSI0 Output Control Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_VSC : 12; //!< Vertical skip. This field defines the number of rows to skip.
        unsigned RESERVED0 : 4; //!< Reserved, should be cleared.
        unsigned CSI0_HSC : 13; //!< Horizontal skip. This field defines the number of columns to skip. In Interlaced mode this number refers to the number of lines per field.
        unsigned RESERVED1 : 1; //!< Reserved, should be cleared.
        unsigned CSI0_VERT_DWNS : 1; //!< Enable vertical downsizing (decimation) by 2.
        unsigned CSI0_HORZ_DWNS : 1; //!< Enable horizontal downsizing (decimation) by 2.
    } B;
} hw_ipu_csi0_out_frm_ctrl_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI0_OUT_FRM_CTRL register
 */
#define HW_IPU_CSI0_OUT_FRM_CTRL_ADDR(x)      (REGS_IPU_BASE(x) + 0x3000c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI0_OUT_FRM_CTRL(x)           (*(volatile hw_ipu_csi0_out_frm_ctrl_t *) HW_IPU_CSI0_OUT_FRM_CTRL_ADDR(x))
#define HW_IPU_CSI0_OUT_FRM_CTRL_RD(x)        (HW_IPU_CSI0_OUT_FRM_CTRL(x).U)
#define HW_IPU_CSI0_OUT_FRM_CTRL_WR(x, v)     (HW_IPU_CSI0_OUT_FRM_CTRL(x).U = (v))
#define HW_IPU_CSI0_OUT_FRM_CTRL_SET(x, v)    (HW_IPU_CSI0_OUT_FRM_CTRL_WR(x, HW_IPU_CSI0_OUT_FRM_CTRL_RD(x) |  (v)))
#define HW_IPU_CSI0_OUT_FRM_CTRL_CLR(x, v)    (HW_IPU_CSI0_OUT_FRM_CTRL_WR(x, HW_IPU_CSI0_OUT_FRM_CTRL_RD(x) & ~(v)))
#define HW_IPU_CSI0_OUT_FRM_CTRL_TOG(x, v)    (HW_IPU_CSI0_OUT_FRM_CTRL_WR(x, HW_IPU_CSI0_OUT_FRM_CTRL_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI0_OUT_FRM_CTRL bitfields
 */

/* --- Register HW_IPU_CSI0_OUT_FRM_CTRL, field CSI0_VSC (RW)
 *
 * Vertical skip. This field defines the number of rows to skip.
 */

#define BP_IPU_CSI0_OUT_FRM_CTRL_CSI0_VSC      0
#define BM_IPU_CSI0_OUT_FRM_CTRL_CSI0_VSC      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_OUT_FRM_CTRL_CSI0_VSC(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI0_OUT_FRM_CTRL_CSI0_VSC)
#else
#define BF_IPU_CSI0_OUT_FRM_CTRL_CSI0_VSC(v)   (((v) << 0) & BM_IPU_CSI0_OUT_FRM_CTRL_CSI0_VSC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_VSC field to a new value.
#define BW_IPU_CSI0_OUT_FRM_CTRL_CSI0_VSC(v)   BF_CS1(IPU_CSI0_OUT_FRM_CTRL, CSI0_VSC, v)
#endif

/* --- Register HW_IPU_CSI0_OUT_FRM_CTRL, field CSI0_HSC (RW)
 *
 * Horizontal skip. This field defines the number of columns to skip. In Interlaced mode this number
 * refers to the number of lines per field.
 */

#define BP_IPU_CSI0_OUT_FRM_CTRL_CSI0_HSC      16
#define BM_IPU_CSI0_OUT_FRM_CTRL_CSI0_HSC      0x1fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_OUT_FRM_CTRL_CSI0_HSC(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI0_OUT_FRM_CTRL_CSI0_HSC)
#else
#define BF_IPU_CSI0_OUT_FRM_CTRL_CSI0_HSC(v)   (((v) << 16) & BM_IPU_CSI0_OUT_FRM_CTRL_CSI0_HSC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_HSC field to a new value.
#define BW_IPU_CSI0_OUT_FRM_CTRL_CSI0_HSC(v)   BF_CS1(IPU_CSI0_OUT_FRM_CTRL, CSI0_HSC, v)
#endif

/* --- Register HW_IPU_CSI0_OUT_FRM_CTRL, field CSI0_VERT_DWNS (RW)
 *
 * Enable vertical downsizing (decimation) by 2.
 *
 * Values:
 * 0 - Downsizing disabled
 * 1 - Downsizing enabled
 */

#define BP_IPU_CSI0_OUT_FRM_CTRL_CSI0_VERT_DWNS      30
#define BM_IPU_CSI0_OUT_FRM_CTRL_CSI0_VERT_DWNS      0x40000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_OUT_FRM_CTRL_CSI0_VERT_DWNS(v)   ((((reg32_t) v) << 30) & BM_IPU_CSI0_OUT_FRM_CTRL_CSI0_VERT_DWNS)
#else
#define BF_IPU_CSI0_OUT_FRM_CTRL_CSI0_VERT_DWNS(v)   (((v) << 30) & BM_IPU_CSI0_OUT_FRM_CTRL_CSI0_VERT_DWNS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_VERT_DWNS field to a new value.
#define BW_IPU_CSI0_OUT_FRM_CTRL_CSI0_VERT_DWNS(v)   BF_CS1(IPU_CSI0_OUT_FRM_CTRL, CSI0_VERT_DWNS, v)
#endif


/* --- Register HW_IPU_CSI0_OUT_FRM_CTRL, field CSI0_HORZ_DWNS (RW)
 *
 * Enable horizontal downsizing (decimation) by 2.
 *
 * Values:
 * 0 - Downsizing disabled 1 Downsizing enabled
 */

#define BP_IPU_CSI0_OUT_FRM_CTRL_CSI0_HORZ_DWNS      31
#define BM_IPU_CSI0_OUT_FRM_CTRL_CSI0_HORZ_DWNS      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_OUT_FRM_CTRL_CSI0_HORZ_DWNS(v)   ((((reg32_t) v) << 31) & BM_IPU_CSI0_OUT_FRM_CTRL_CSI0_HORZ_DWNS)
#else
#define BF_IPU_CSI0_OUT_FRM_CTRL_CSI0_HORZ_DWNS(v)   (((v) << 31) & BM_IPU_CSI0_OUT_FRM_CTRL_CSI0_HORZ_DWNS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_HORZ_DWNS field to a new value.
#define BW_IPU_CSI0_OUT_FRM_CTRL_CSI0_HORZ_DWNS(v)   BF_CS1(IPU_CSI0_OUT_FRM_CTRL, CSI0_HORZ_DWNS, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI0_TST_CTRL - CSIO Test Control Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned PG_R_VALUE : 8; //!< Pattern generator R value. This field selects the R value for the generated pattern of even pixel.
        unsigned PG_G_VALUE : 8; //!< Pattern generator G value. This field selects the G value for the generated pattern of even pixel.
        unsigned PG_B_VALUE : 8; //!< Pattern generator B value. This field selects the B value for the generated pattern of even pixel.
        unsigned TEST_GEN_MODE : 1; //!< Test generator mode. This bit activates the signal generation.
        unsigned RESERVED0 : 7; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi0_tst_ctrl_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI0_TST_CTRL register
 */
#define HW_IPU_CSI0_TST_CTRL_ADDR(x)      (REGS_IPU_BASE(x) + 0x30010)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI0_TST_CTRL(x)           (*(volatile hw_ipu_csi0_tst_ctrl_t *) HW_IPU_CSI0_TST_CTRL_ADDR(x))
#define HW_IPU_CSI0_TST_CTRL_RD(x)        (HW_IPU_CSI0_TST_CTRL(x).U)
#define HW_IPU_CSI0_TST_CTRL_WR(x, v)     (HW_IPU_CSI0_TST_CTRL(x).U = (v))
#define HW_IPU_CSI0_TST_CTRL_SET(x, v)    (HW_IPU_CSI0_TST_CTRL_WR(x, HW_IPU_CSI0_TST_CTRL_RD(x) |  (v)))
#define HW_IPU_CSI0_TST_CTRL_CLR(x, v)    (HW_IPU_CSI0_TST_CTRL_WR(x, HW_IPU_CSI0_TST_CTRL_RD(x) & ~(v)))
#define HW_IPU_CSI0_TST_CTRL_TOG(x, v)    (HW_IPU_CSI0_TST_CTRL_WR(x, HW_IPU_CSI0_TST_CTRL_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI0_TST_CTRL bitfields
 */

/* --- Register HW_IPU_CSI0_TST_CTRL, field PG_R_VALUE (RW)
 *
 * Pattern generator R value. This field selects the R value for the generated pattern of even
 * pixel.
 */

#define BP_IPU_CSI0_TST_CTRL_PG_R_VALUE      0
#define BM_IPU_CSI0_TST_CTRL_PG_R_VALUE      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_TST_CTRL_PG_R_VALUE(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI0_TST_CTRL_PG_R_VALUE)
#else
#define BF_IPU_CSI0_TST_CTRL_PG_R_VALUE(v)   (((v) << 0) & BM_IPU_CSI0_TST_CTRL_PG_R_VALUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PG_R_VALUE field to a new value.
#define BW_IPU_CSI0_TST_CTRL_PG_R_VALUE(v)   BF_CS1(IPU_CSI0_TST_CTRL, PG_R_VALUE, v)
#endif

/* --- Register HW_IPU_CSI0_TST_CTRL, field PG_G_VALUE (RW)
 *
 * Pattern generator G value. This field selects the G value for the generated pattern of even
 * pixel.
 */

#define BP_IPU_CSI0_TST_CTRL_PG_G_VALUE      8
#define BM_IPU_CSI0_TST_CTRL_PG_G_VALUE      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_TST_CTRL_PG_G_VALUE(v)   ((((reg32_t) v) << 8) & BM_IPU_CSI0_TST_CTRL_PG_G_VALUE)
#else
#define BF_IPU_CSI0_TST_CTRL_PG_G_VALUE(v)   (((v) << 8) & BM_IPU_CSI0_TST_CTRL_PG_G_VALUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PG_G_VALUE field to a new value.
#define BW_IPU_CSI0_TST_CTRL_PG_G_VALUE(v)   BF_CS1(IPU_CSI0_TST_CTRL, PG_G_VALUE, v)
#endif

/* --- Register HW_IPU_CSI0_TST_CTRL, field PG_B_VALUE (RW)
 *
 * Pattern generator B value. This field selects the B value for the generated pattern of even
 * pixel.
 */

#define BP_IPU_CSI0_TST_CTRL_PG_B_VALUE      16
#define BM_IPU_CSI0_TST_CTRL_PG_B_VALUE      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_TST_CTRL_PG_B_VALUE(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI0_TST_CTRL_PG_B_VALUE)
#else
#define BF_IPU_CSI0_TST_CTRL_PG_B_VALUE(v)   (((v) << 16) & BM_IPU_CSI0_TST_CTRL_PG_B_VALUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PG_B_VALUE field to a new value.
#define BW_IPU_CSI0_TST_CTRL_PG_B_VALUE(v)   BF_CS1(IPU_CSI0_TST_CTRL, PG_B_VALUE, v)
#endif

/* --- Register HW_IPU_CSI0_TST_CTRL, field TEST_GEN_MODE (RW)
 *
 * Test generator mode. This bit activates the signal generation.
 *
 * Values:
 * 0 - Test signal generator is inactive.
 * 1 - Test signal generator is active.
 */

#define BP_IPU_CSI0_TST_CTRL_TEST_GEN_MODE      24
#define BM_IPU_CSI0_TST_CTRL_TEST_GEN_MODE      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_TST_CTRL_TEST_GEN_MODE(v)   ((((reg32_t) v) << 24) & BM_IPU_CSI0_TST_CTRL_TEST_GEN_MODE)
#else
#define BF_IPU_CSI0_TST_CTRL_TEST_GEN_MODE(v)   (((v) << 24) & BM_IPU_CSI0_TST_CTRL_TEST_GEN_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the TEST_GEN_MODE field to a new value.
#define BW_IPU_CSI0_TST_CTRL_TEST_GEN_MODE(v)   BF_CS1(IPU_CSI0_TST_CTRL, TEST_GEN_MODE, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI0_CCIR_CODE_1 - CSIO CCIR Code Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_END_FLD0_BLNK_1ST : 3; //!< End of field 0 first blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned CSI0_STRT_FLD0_BLNK_1ST : 3; //!< Start of field 0 first blanking line command (interlaces mode). (In progressive mode this field indicates start of blanking line command).
        unsigned CSI0_END_FLD0_BLNK_2ND : 3; //!< End of field 0 second blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned CSI0_STRT_FLD0_BLNK_2ND : 3; //!< Start of field 0 second blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned RESERVED0 : 4; //!< Reserved, should be cleared.
        unsigned CSI0_END_FLD0_ACTV : 3; //!< End of field 0 active line command (interlaces mode). (In progressive mode, end of active line command mode).
        unsigned CSI0_STRT_FLD0_ACTV : 3; //!< Start of field 0 active line command (interlaces mode). (In progressive mode, start of active line command mode).
        unsigned RESERVED1 : 2; //!< Reserved, should be cleared.
        unsigned CSI0_CCIR_ERR_DET_EN : 1; //!< Enable error detection and correction for CCIR interlaced mode with protection bit.
        unsigned RESERVED2 : 7; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi0_ccir_code_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI0_CCIR_CODE_1 register
 */
#define HW_IPU_CSI0_CCIR_CODE_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x30014)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI0_CCIR_CODE_1(x)           (*(volatile hw_ipu_csi0_ccir_code_1_t *) HW_IPU_CSI0_CCIR_CODE_1_ADDR(x))
#define HW_IPU_CSI0_CCIR_CODE_1_RD(x)        (HW_IPU_CSI0_CCIR_CODE_1(x).U)
#define HW_IPU_CSI0_CCIR_CODE_1_WR(x, v)     (HW_IPU_CSI0_CCIR_CODE_1(x).U = (v))
#define HW_IPU_CSI0_CCIR_CODE_1_SET(x, v)    (HW_IPU_CSI0_CCIR_CODE_1_WR(x, HW_IPU_CSI0_CCIR_CODE_1_RD(x) |  (v)))
#define HW_IPU_CSI0_CCIR_CODE_1_CLR(x, v)    (HW_IPU_CSI0_CCIR_CODE_1_WR(x, HW_IPU_CSI0_CCIR_CODE_1_RD(x) & ~(v)))
#define HW_IPU_CSI0_CCIR_CODE_1_TOG(x, v)    (HW_IPU_CSI0_CCIR_CODE_1_WR(x, HW_IPU_CSI0_CCIR_CODE_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI0_CCIR_CODE_1 bitfields
 */

/* --- Register HW_IPU_CSI0_CCIR_CODE_1, field CSI0_END_FLD0_BLNK_1ST (RW)
 *
 * End of field 0 first blanking line command (interlaces mode). (In progressive mode this field is
 * ignored).
 */

#define BP_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_1ST      0
#define BM_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_1ST      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_1ST(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_1ST)
#else
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_1ST(v)   (((v) << 0) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_1ST)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_END_FLD0_BLNK_1ST field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_1ST(v)   BF_CS1(IPU_CSI0_CCIR_CODE_1, CSI0_END_FLD0_BLNK_1ST, v)
#endif

/* --- Register HW_IPU_CSI0_CCIR_CODE_1, field CSI0_STRT_FLD0_BLNK_1ST (RW)
 *
 * Start of field 0 first blanking line command (interlaces mode). (In progressive mode this field
 * indicates start of blanking line command).
 */

#define BP_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_1ST      3
#define BM_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_1ST      0x00000038

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_1ST(v)   ((((reg32_t) v) << 3) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_1ST)
#else
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_1ST(v)   (((v) << 3) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_1ST)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_STRT_FLD0_BLNK_1ST field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_1ST(v)   BF_CS1(IPU_CSI0_CCIR_CODE_1, CSI0_STRT_FLD0_BLNK_1ST, v)
#endif

/* --- Register HW_IPU_CSI0_CCIR_CODE_1, field CSI0_END_FLD0_BLNK_2ND (RW)
 *
 * End of field 0 second blanking line command (interlaces mode). (In progressive mode this field is
 * ignored).
 */

#define BP_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_2ND      6
#define BM_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_2ND      0x000001c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_2ND(v)   ((((reg32_t) v) << 6) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_2ND)
#else
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_2ND(v)   (((v) << 6) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_2ND)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_END_FLD0_BLNK_2ND field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_BLNK_2ND(v)   BF_CS1(IPU_CSI0_CCIR_CODE_1, CSI0_END_FLD0_BLNK_2ND, v)
#endif

/* --- Register HW_IPU_CSI0_CCIR_CODE_1, field CSI0_STRT_FLD0_BLNK_2ND (RW)
 *
 * Start of field 0 second blanking line command (interlaces mode). (In progressive mode this field
 * is ignored).
 */

#define BP_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_2ND      9
#define BM_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_2ND      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_2ND(v)   ((((reg32_t) v) << 9) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_2ND)
#else
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_2ND(v)   (((v) << 9) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_2ND)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_STRT_FLD0_BLNK_2ND field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_BLNK_2ND(v)   BF_CS1(IPU_CSI0_CCIR_CODE_1, CSI0_STRT_FLD0_BLNK_2ND, v)
#endif

/* --- Register HW_IPU_CSI0_CCIR_CODE_1, field CSI0_END_FLD0_ACTV (RW)
 *
 * End of field 0 active line command (interlaces mode). (In progressive mode, end of active line
 * command mode).
 */

#define BP_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_ACTV      16
#define BM_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_ACTV      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_ACTV(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_ACTV)
#else
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_ACTV(v)   (((v) << 16) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_ACTV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_END_FLD0_ACTV field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_1_CSI0_END_FLD0_ACTV(v)   BF_CS1(IPU_CSI0_CCIR_CODE_1, CSI0_END_FLD0_ACTV, v)
#endif

/* --- Register HW_IPU_CSI0_CCIR_CODE_1, field CSI0_STRT_FLD0_ACTV (RW)
 *
 * Start of field 0 active line command (interlaces mode). (In progressive mode, start of active
 * line command mode).
 */

#define BP_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_ACTV      19
#define BM_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_ACTV      0x00380000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_ACTV(v)   ((((reg32_t) v) << 19) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_ACTV)
#else
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_ACTV(v)   (((v) << 19) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_ACTV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_STRT_FLD0_ACTV field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_1_CSI0_STRT_FLD0_ACTV(v)   BF_CS1(IPU_CSI0_CCIR_CODE_1, CSI0_STRT_FLD0_ACTV, v)
#endif

/* --- Register HW_IPU_CSI0_CCIR_CODE_1, field CSI0_CCIR_ERR_DET_EN (RW)
 *
 * Enable error detection and correction for CCIR interlaced mode with protection bit.
 *
 * Values:
 * 0 - Error detection and correction is disabled.
 * 1 - Error detection and correction is enabled.
 */

#define BP_IPU_CSI0_CCIR_CODE_1_CSI0_CCIR_ERR_DET_EN      24
#define BM_IPU_CSI0_CCIR_CODE_1_CSI0_CCIR_ERR_DET_EN      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_CCIR_ERR_DET_EN(v)   ((((reg32_t) v) << 24) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_CCIR_ERR_DET_EN)
#else
#define BF_IPU_CSI0_CCIR_CODE_1_CSI0_CCIR_ERR_DET_EN(v)   (((v) << 24) & BM_IPU_CSI0_CCIR_CODE_1_CSI0_CCIR_ERR_DET_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CCIR_ERR_DET_EN field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_1_CSI0_CCIR_ERR_DET_EN(v)   BF_CS1(IPU_CSI0_CCIR_CODE_1, CSI0_CCIR_ERR_DET_EN, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI0_CCIR_CODE_2 - CSIO CCIR Code Register 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_END_FLD1_BLNK_1ST : 3; //!< End of field 1 first blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned CSI0_STRT_FLD1_BLNK_1ST : 3; //!< Start of field 1 first blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned CSI0_END_FLD1_BLNK_2ND : 3; //!< End of field 1 second blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned CSI0_STRT_FLD1_BLNK_2ND : 3; //!< Start of field 1 second blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned RESERVED0 : 4; //!< Reserved, should be cleared.
        unsigned CSI0_END_FLD1_ACTV : 3; //!< End of field 1 active line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned CSI0_STRT_FLD1_ACTV : 3; //!< Start of field 1 active line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned RESERVED1 : 10; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi0_ccir_code_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI0_CCIR_CODE_2 register
 */
#define HW_IPU_CSI0_CCIR_CODE_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x30018)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI0_CCIR_CODE_2(x)           (*(volatile hw_ipu_csi0_ccir_code_2_t *) HW_IPU_CSI0_CCIR_CODE_2_ADDR(x))
#define HW_IPU_CSI0_CCIR_CODE_2_RD(x)        (HW_IPU_CSI0_CCIR_CODE_2(x).U)
#define HW_IPU_CSI0_CCIR_CODE_2_WR(x, v)     (HW_IPU_CSI0_CCIR_CODE_2(x).U = (v))
#define HW_IPU_CSI0_CCIR_CODE_2_SET(x, v)    (HW_IPU_CSI0_CCIR_CODE_2_WR(x, HW_IPU_CSI0_CCIR_CODE_2_RD(x) |  (v)))
#define HW_IPU_CSI0_CCIR_CODE_2_CLR(x, v)    (HW_IPU_CSI0_CCIR_CODE_2_WR(x, HW_IPU_CSI0_CCIR_CODE_2_RD(x) & ~(v)))
#define HW_IPU_CSI0_CCIR_CODE_2_TOG(x, v)    (HW_IPU_CSI0_CCIR_CODE_2_WR(x, HW_IPU_CSI0_CCIR_CODE_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI0_CCIR_CODE_2 bitfields
 */

/* --- Register HW_IPU_CSI0_CCIR_CODE_2, field CSI0_END_FLD1_BLNK_1ST (RW)
 *
 * End of field 1 first blanking line command (interlaces mode). (In progressive mode this field is
 * ignored).
 */

#define BP_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_1ST      0
#define BM_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_1ST      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_1ST(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_1ST)
#else
#define BF_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_1ST(v)   (((v) << 0) & BM_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_1ST)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_END_FLD1_BLNK_1ST field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_1ST(v)   BF_CS1(IPU_CSI0_CCIR_CODE_2, CSI0_END_FLD1_BLNK_1ST, v)
#endif

/* --- Register HW_IPU_CSI0_CCIR_CODE_2, field CSI0_STRT_FLD1_BLNK_1ST (RW)
 *
 * Start of field 1 first blanking line command (interlaces mode). (In progressive mode this field
 * is ignored).
 */

#define BP_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_1ST      3
#define BM_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_1ST      0x00000038

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_1ST(v)   ((((reg32_t) v) << 3) & BM_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_1ST)
#else
#define BF_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_1ST(v)   (((v) << 3) & BM_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_1ST)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_STRT_FLD1_BLNK_1ST field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_1ST(v)   BF_CS1(IPU_CSI0_CCIR_CODE_2, CSI0_STRT_FLD1_BLNK_1ST, v)
#endif

/* --- Register HW_IPU_CSI0_CCIR_CODE_2, field CSI0_END_FLD1_BLNK_2ND (RW)
 *
 * End of field 1 second blanking line command (interlaces mode). (In progressive mode this field is
 * ignored).
 */

#define BP_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_2ND      6
#define BM_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_2ND      0x000001c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_2ND(v)   ((((reg32_t) v) << 6) & BM_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_2ND)
#else
#define BF_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_2ND(v)   (((v) << 6) & BM_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_2ND)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_END_FLD1_BLNK_2ND field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_BLNK_2ND(v)   BF_CS1(IPU_CSI0_CCIR_CODE_2, CSI0_END_FLD1_BLNK_2ND, v)
#endif

/* --- Register HW_IPU_CSI0_CCIR_CODE_2, field CSI0_STRT_FLD1_BLNK_2ND (RW)
 *
 * Start of field 1 second blanking line command (interlaces mode). (In progressive mode this field
 * is ignored).
 */

#define BP_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_2ND      9
#define BM_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_2ND      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_2ND(v)   ((((reg32_t) v) << 9) & BM_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_2ND)
#else
#define BF_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_2ND(v)   (((v) << 9) & BM_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_2ND)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_STRT_FLD1_BLNK_2ND field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_BLNK_2ND(v)   BF_CS1(IPU_CSI0_CCIR_CODE_2, CSI0_STRT_FLD1_BLNK_2ND, v)
#endif

/* --- Register HW_IPU_CSI0_CCIR_CODE_2, field CSI0_END_FLD1_ACTV (RW)
 *
 * End of field 1 active line command (interlaces mode). (In progressive mode this field is
 * ignored).
 */

#define BP_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_ACTV      16
#define BM_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_ACTV      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_ACTV(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_ACTV)
#else
#define BF_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_ACTV(v)   (((v) << 16) & BM_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_ACTV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_END_FLD1_ACTV field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_2_CSI0_END_FLD1_ACTV(v)   BF_CS1(IPU_CSI0_CCIR_CODE_2, CSI0_END_FLD1_ACTV, v)
#endif

/* --- Register HW_IPU_CSI0_CCIR_CODE_2, field CSI0_STRT_FLD1_ACTV (RW)
 *
 * Start of field 1 active line command (interlaces mode). (In progressive mode this field is
 * ignored).
 */

#define BP_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_ACTV      19
#define BM_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_ACTV      0x00380000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_ACTV(v)   ((((reg32_t) v) << 19) & BM_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_ACTV)
#else
#define BF_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_ACTV(v)   (((v) << 19) & BM_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_ACTV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_STRT_FLD1_ACTV field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_2_CSI0_STRT_FLD1_ACTV(v)   BF_CS1(IPU_CSI0_CCIR_CODE_2, CSI0_STRT_FLD1_ACTV, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI0_CCIR_CODE_3 - CSIO CCIR Code Register 3 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_CCIR_PRECOM : 30; //!< CCIR pre command. This field defines the sequence which comes before the CCIR command. For BT.656 the code should be written to bits [23:0] while bits [29:24] are ignored (3X8bit) For BT.1120 the code should be written to bits [29:0] (3X10bit)
        unsigned RESERVED0 : 2; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi0_ccir_code_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI0_CCIR_CODE_3 register
 */
#define HW_IPU_CSI0_CCIR_CODE_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x3001c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI0_CCIR_CODE_3(x)           (*(volatile hw_ipu_csi0_ccir_code_3_t *) HW_IPU_CSI0_CCIR_CODE_3_ADDR(x))
#define HW_IPU_CSI0_CCIR_CODE_3_RD(x)        (HW_IPU_CSI0_CCIR_CODE_3(x).U)
#define HW_IPU_CSI0_CCIR_CODE_3_WR(x, v)     (HW_IPU_CSI0_CCIR_CODE_3(x).U = (v))
#define HW_IPU_CSI0_CCIR_CODE_3_SET(x, v)    (HW_IPU_CSI0_CCIR_CODE_3_WR(x, HW_IPU_CSI0_CCIR_CODE_3_RD(x) |  (v)))
#define HW_IPU_CSI0_CCIR_CODE_3_CLR(x, v)    (HW_IPU_CSI0_CCIR_CODE_3_WR(x, HW_IPU_CSI0_CCIR_CODE_3_RD(x) & ~(v)))
#define HW_IPU_CSI0_CCIR_CODE_3_TOG(x, v)    (HW_IPU_CSI0_CCIR_CODE_3_WR(x, HW_IPU_CSI0_CCIR_CODE_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI0_CCIR_CODE_3 bitfields
 */

/* --- Register HW_IPU_CSI0_CCIR_CODE_3, field CSI0_CCIR_PRECOM (RW)
 *
 * CCIR pre command. This field defines the sequence which comes before the CCIR command. For BT.656
 * the code should be written to bits [23:0] while bits [29:24] are ignored (3X8bit) For BT.1120 the
 * code should be written to bits [29:0] (3X10bit)
 */

#define BP_IPU_CSI0_CCIR_CODE_3_CSI0_CCIR_PRECOM      0
#define BM_IPU_CSI0_CCIR_CODE_3_CSI0_CCIR_PRECOM      0x3fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CCIR_CODE_3_CSI0_CCIR_PRECOM(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI0_CCIR_CODE_3_CSI0_CCIR_PRECOM)
#else
#define BF_IPU_CSI0_CCIR_CODE_3_CSI0_CCIR_PRECOM(v)   (((v) << 0) & BM_IPU_CSI0_CCIR_CODE_3_CSI0_CCIR_PRECOM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CCIR_PRECOM field to a new value.
#define BW_IPU_CSI0_CCIR_CODE_3_CSI0_CCIR_PRECOM(v)   BF_CS1(IPU_CSI0_CCIR_CODE_3, CSI0_CCIR_PRECOM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI0_DI - CSI0 Data Identifier Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_MIPI_DI0 : 8; //!< Reserved CSI0_MIPI_DI0 This field holds the Data Identifier #0 handled by the CSI; This is the main stream.
        unsigned CSI0_MIPI_DI1 : 8; //!< Reserved CSI0_MIPI_DI1 This field holds the Data Identifier #1 handled by the CSI
        unsigned CSI0_MIPI_DI2 : 8; //!< Reserved CSI0_MIPI_DI2 This field holds the Data Identifier #2 handled by the CSI.
        unsigned CSI0_MIPI_DI3 : 8; //!< Reserved CSI0_MIPI_DI3 This field holds the Data Identifier #3 handled by the CSI.
    } B;
} hw_ipu_csi0_di_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI0_DI register
 */
#define HW_IPU_CSI0_DI_ADDR(x)      (REGS_IPU_BASE(x) + 0x30020)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI0_DI(x)           (*(volatile hw_ipu_csi0_di_t *) HW_IPU_CSI0_DI_ADDR(x))
#define HW_IPU_CSI0_DI_RD(x)        (HW_IPU_CSI0_DI(x).U)
#define HW_IPU_CSI0_DI_WR(x, v)     (HW_IPU_CSI0_DI(x).U = (v))
#define HW_IPU_CSI0_DI_SET(x, v)    (HW_IPU_CSI0_DI_WR(x, HW_IPU_CSI0_DI_RD(x) |  (v)))
#define HW_IPU_CSI0_DI_CLR(x, v)    (HW_IPU_CSI0_DI_WR(x, HW_IPU_CSI0_DI_RD(x) & ~(v)))
#define HW_IPU_CSI0_DI_TOG(x, v)    (HW_IPU_CSI0_DI_WR(x, HW_IPU_CSI0_DI_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI0_DI bitfields
 */

/* --- Register HW_IPU_CSI0_DI, field CSI0_MIPI_DI0 (RW)
 *
 * Reserved CSI0_MIPI_DI0 This field holds the Data Identifier #0 handled by the CSI; This is the
 * main stream.
 */

#define BP_IPU_CSI0_DI_CSI0_MIPI_DI0      0
#define BM_IPU_CSI0_DI_CSI0_MIPI_DI0      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_DI_CSI0_MIPI_DI0(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI0_DI_CSI0_MIPI_DI0)
#else
#define BF_IPU_CSI0_DI_CSI0_MIPI_DI0(v)   (((v) << 0) & BM_IPU_CSI0_DI_CSI0_MIPI_DI0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_MIPI_DI0 field to a new value.
#define BW_IPU_CSI0_DI_CSI0_MIPI_DI0(v)   BF_CS1(IPU_CSI0_DI, CSI0_MIPI_DI0, v)
#endif

/* --- Register HW_IPU_CSI0_DI, field CSI0_MIPI_DI1 (RW)
 *
 * Reserved CSI0_MIPI_DI1 This field holds the Data Identifier #1 handled by the CSI
 */

#define BP_IPU_CSI0_DI_CSI0_MIPI_DI1      8
#define BM_IPU_CSI0_DI_CSI0_MIPI_DI1      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_DI_CSI0_MIPI_DI1(v)   ((((reg32_t) v) << 8) & BM_IPU_CSI0_DI_CSI0_MIPI_DI1)
#else
#define BF_IPU_CSI0_DI_CSI0_MIPI_DI1(v)   (((v) << 8) & BM_IPU_CSI0_DI_CSI0_MIPI_DI1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_MIPI_DI1 field to a new value.
#define BW_IPU_CSI0_DI_CSI0_MIPI_DI1(v)   BF_CS1(IPU_CSI0_DI, CSI0_MIPI_DI1, v)
#endif

/* --- Register HW_IPU_CSI0_DI, field CSI0_MIPI_DI2 (RW)
 *
 * Reserved CSI0_MIPI_DI2 This field holds the Data Identifier #2 handled by the CSI.
 */

#define BP_IPU_CSI0_DI_CSI0_MIPI_DI2      16
#define BM_IPU_CSI0_DI_CSI0_MIPI_DI2      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_DI_CSI0_MIPI_DI2(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI0_DI_CSI0_MIPI_DI2)
#else
#define BF_IPU_CSI0_DI_CSI0_MIPI_DI2(v)   (((v) << 16) & BM_IPU_CSI0_DI_CSI0_MIPI_DI2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_MIPI_DI2 field to a new value.
#define BW_IPU_CSI0_DI_CSI0_MIPI_DI2(v)   BF_CS1(IPU_CSI0_DI, CSI0_MIPI_DI2, v)
#endif

/* --- Register HW_IPU_CSI0_DI, field CSI0_MIPI_DI3 (RW)
 *
 * Reserved CSI0_MIPI_DI3 This field holds the Data Identifier #3 handled by the CSI.
 */

#define BP_IPU_CSI0_DI_CSI0_MIPI_DI3      24
#define BM_IPU_CSI0_DI_CSI0_MIPI_DI3      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_DI_CSI0_MIPI_DI3(v)   ((((reg32_t) v) << 24) & BM_IPU_CSI0_DI_CSI0_MIPI_DI3)
#else
#define BF_IPU_CSI0_DI_CSI0_MIPI_DI3(v)   (((v) << 24) & BM_IPU_CSI0_DI_CSI0_MIPI_DI3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_MIPI_DI3 field to a new value.
#define BW_IPU_CSI0_DI_CSI0_MIPI_DI3(v)   BF_CS1(IPU_CSI0_DI, CSI0_MIPI_DI3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI0_SKIP - CSI0 SKIP Register (RW)
 *
 * This register controls the frame skipping supported between CSI0 and the SMFC.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_MAX_RATIO_SKIP_SMFC : 3; //!< CSI0 Maximum Ratio Skip for SMFC These bits define the number of frames in a skipping set. The skipping number is equal to CSI0_MAX_RATIO_SKIP_SMFC+1; The maximum value of this bits is 5. When set to 0 the skipping is disabled.
        unsigned CSI0_SKIP_SMFC : 5; //!< CSI0 SKIP SMFC These 5 bits define the skipping pattern of the frames send to the SMFC. Skipping is done for a set of frames. The number of frames in a set is defined at CSI0_MAX_RATIO_SKIP_SMFC. when CSI0_MAX_RATIO_SKIP_SMFC = 1 => CSI0_SKIP_SMFC[0] is used; other bits are ignored when CSI0_MAX_RATIO_SKIP_SMFC = 2 => CSI0_SKIP_SMFC[1:0] are used; other bits are ignored when CSI0_MAX_RATIO_SKIP_SMFC = 3 => CSI0_SKIP_SMFC[2:0] are used; other bits are ignored when CSI0_MAX_RATIO_SKIP_SMFC = 4 => CSI0_SKIP_SMFC[3:0] are used; other bits are ignored when CSI0_MAX_RATIO_SKIP_SMFC = 5 => CSI0_SKIP_SMFC[4:0] are used; Setting bit #n of CSI0_SKIP_SMFC means that the #n frame in the set is skipped. For example: if CSI0_MAX_RATIO_SKIP_SMFC = 4 and CSI0_SKIP_SMFC = 11010 Frames #0 & Frame #2 will not be skipped as bit0 and bit2 are cleared Frames #1 & Frame #3 will be skipped as bit1 and bit3 are set bit #4 is ignored as CSI0_MAX_RATIO_SKIP_SMFC is set to 4
        unsigned CSI0_ID_2_SKIP : 2; //!< Reserved CSI0 to SMFC Skipping ID. Data from the CSI0 to the SMFC has an ID associated with it. The ID is received from the MIPI interface. The skipping mechanism between the CSI0 and the SMFC can be used for only one ID. There is no skipping for data coming with ID different from the ID programed in this bits
        unsigned RESERVED0 : 6; //!< Reserved
        unsigned CSI0_MAX_RATIO_SKIP_ISP : 3; //!< CSI0 Maximum Ratio Skip for ISP These bits define the number of frames in a skipping set. The skipping number is equal to CSI0_MAX_RATIO_SKIP_ISP+1; The maximum value of this bits is 5. When set to 0 the skipping is disabled. Reserved
        unsigned CSI0_SKIP_ISP : 5; //!< CSI0 SKIP ISP These 5 bits define the skipping pattern of the frames send to the ISP. Skipping is done for a set of frames. The number of frames in a set is defined at CSI0_MAX_RATIO_SKIP. when CSI0_MAX_RATIO_SKIP = 1 => CSI0_SKIP_ISP[0] is used; other bits are ignored when CSI0_MAX_RATIO_SKIP = 2 => CSI0_SKIP_ISP[1:0] are used; other bits are ignored when CSI0_MAX_RATIO_SKIP = 3 => CSI0_SKIP_ISP[2:0] are used; other bits are ignored when CSI0_MAX_RATIO_SKIP = 4 => CSI0_SKIP_ISP[3:0] are used; other bits are ignored when CSI0_MAX_RATIO_SKIP = 5 => CSI0_SKIP_ISP[4:0] are used; Setting bit #n of CSI0_SKIP_ISP means that the #n frame in the set is skipped. For example: if CSI0_MAX_RATIO_SKIP = 4 and CSI0_SKIP_ISP = 11010 Frames #0 & Frame #2 will not be skipped as bit0 and bit2 are cleared Frames #1 & Frame #3 will be skipped as bit1 and bit3 are set bit #4 is ignored as CSI0_MAX_RATIO_SKIP is set to 4 Reserved
        unsigned RESERVED1 : 8; //!< Reserved
    } B;
} hw_ipu_csi0_skip_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI0_SKIP register
 */
#define HW_IPU_CSI0_SKIP_ADDR(x)      (REGS_IPU_BASE(x) + 0x30024)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI0_SKIP(x)           (*(volatile hw_ipu_csi0_skip_t *) HW_IPU_CSI0_SKIP_ADDR(x))
#define HW_IPU_CSI0_SKIP_RD(x)        (HW_IPU_CSI0_SKIP(x).U)
#define HW_IPU_CSI0_SKIP_WR(x, v)     (HW_IPU_CSI0_SKIP(x).U = (v))
#define HW_IPU_CSI0_SKIP_SET(x, v)    (HW_IPU_CSI0_SKIP_WR(x, HW_IPU_CSI0_SKIP_RD(x) |  (v)))
#define HW_IPU_CSI0_SKIP_CLR(x, v)    (HW_IPU_CSI0_SKIP_WR(x, HW_IPU_CSI0_SKIP_RD(x) & ~(v)))
#define HW_IPU_CSI0_SKIP_TOG(x, v)    (HW_IPU_CSI0_SKIP_WR(x, HW_IPU_CSI0_SKIP_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI0_SKIP bitfields
 */

/* --- Register HW_IPU_CSI0_SKIP, field CSI0_MAX_RATIO_SKIP_SMFC (RW)
 *
 * CSI0 Maximum Ratio Skip for SMFC These bits define the number of frames in a skipping set. The
 * skipping number is equal to CSI0_MAX_RATIO_SKIP_SMFC+1; The maximum value of this bits is 5. When
 * set to 0 the skipping is disabled.
 */

#define BP_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_SMFC      0
#define BM_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_SMFC      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_SMFC(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_SMFC)
#else
#define BF_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_SMFC(v)   (((v) << 0) & BM_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_SMFC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_MAX_RATIO_SKIP_SMFC field to a new value.
#define BW_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_SMFC(v)   BF_CS1(IPU_CSI0_SKIP, CSI0_MAX_RATIO_SKIP_SMFC, v)
#endif

/* --- Register HW_IPU_CSI0_SKIP, field CSI0_SKIP_SMFC (RW)
 *
 * CSI0 SKIP SMFC These 5 bits define the skipping pattern of the frames send to the SMFC. Skipping
 * is done for a set of frames. The number of frames in a set is defined at
 * CSI0_MAX_RATIO_SKIP_SMFC. when CSI0_MAX_RATIO_SKIP_SMFC = 1 => CSI0_SKIP_SMFC[0] is used; other
 * bits are ignored when CSI0_MAX_RATIO_SKIP_SMFC = 2 => CSI0_SKIP_SMFC[1:0] are used; other bits
 * are ignored when CSI0_MAX_RATIO_SKIP_SMFC = 3 => CSI0_SKIP_SMFC[2:0] are used; other bits are
 * ignored when CSI0_MAX_RATIO_SKIP_SMFC = 4 => CSI0_SKIP_SMFC[3:0] are used; other bits are ignored
 * when CSI0_MAX_RATIO_SKIP_SMFC = 5 => CSI0_SKIP_SMFC[4:0] are used; Setting bit #n of
 * CSI0_SKIP_SMFC means that the #n frame in the set is skipped. For example: if
 * CSI0_MAX_RATIO_SKIP_SMFC = 4 and CSI0_SKIP_SMFC = 11010 Frames #0 & Frame #2 will not be skipped
 * as bit0 and bit2 are cleared Frames #1 & Frame #3 will be skipped as bit1 and bit3 are set bit #4
 * is ignored as CSI0_MAX_RATIO_SKIP_SMFC is set to 4
 */

#define BP_IPU_CSI0_SKIP_CSI0_SKIP_SMFC      3
#define BM_IPU_CSI0_SKIP_CSI0_SKIP_SMFC      0x000000f8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SKIP_CSI0_SKIP_SMFC(v)   ((((reg32_t) v) << 3) & BM_IPU_CSI0_SKIP_CSI0_SKIP_SMFC)
#else
#define BF_IPU_CSI0_SKIP_CSI0_SKIP_SMFC(v)   (((v) << 3) & BM_IPU_CSI0_SKIP_CSI0_SKIP_SMFC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_SKIP_SMFC field to a new value.
#define BW_IPU_CSI0_SKIP_CSI0_SKIP_SMFC(v)   BF_CS1(IPU_CSI0_SKIP, CSI0_SKIP_SMFC, v)
#endif

/* --- Register HW_IPU_CSI0_SKIP, field CSI0_ID_2_SKIP (RW)
 *
 * Reserved CSI0 to SMFC Skipping ID. Data from the CSI0 to the SMFC has an ID associated with it.
 * The ID is received from the MIPI interface. The skipping mechanism between the CSI0 and the SMFC
 * can be used for only one ID. There is no skipping for data coming with ID different from the ID
 * programed in this bits
 *
 * Values:
 * 00 - - Skipping mechanism is activated on frames with ID equal to 00
 * 01 - - Skipping mechanism is activated on frames with ID equal to 01
 * 10 - - Skipping mechanism is activated on frames with ID equal to 10
 * 11 - - Skipping mechanism is activated on frames with ID equal to 11
 */

#define BP_IPU_CSI0_SKIP_CSI0_ID_2_SKIP      8
#define BM_IPU_CSI0_SKIP_CSI0_ID_2_SKIP      0x00000300

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SKIP_CSI0_ID_2_SKIP(v)   ((((reg32_t) v) << 8) & BM_IPU_CSI0_SKIP_CSI0_ID_2_SKIP)
#else
#define BF_IPU_CSI0_SKIP_CSI0_ID_2_SKIP(v)   (((v) << 8) & BM_IPU_CSI0_SKIP_CSI0_ID_2_SKIP)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_ID_2_SKIP field to a new value.
#define BW_IPU_CSI0_SKIP_CSI0_ID_2_SKIP(v)   BF_CS1(IPU_CSI0_SKIP, CSI0_ID_2_SKIP, v)
#endif


/* --- Register HW_IPU_CSI0_SKIP, field CSI0_MAX_RATIO_SKIP_ISP (RW)
 *
 * CSI0 Maximum Ratio Skip for ISP These bits define the number of frames in a skipping set. The
 * skipping number is equal to CSI0_MAX_RATIO_SKIP_ISP+1; The maximum value of this bits is 5. When
 * set to 0 the skipping is disabled. Reserved
 */

#define BP_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_ISP      16
#define BM_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_ISP      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_ISP(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_ISP)
#else
#define BF_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_ISP(v)   (((v) << 16) & BM_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_ISP)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_MAX_RATIO_SKIP_ISP field to a new value.
#define BW_IPU_CSI0_SKIP_CSI0_MAX_RATIO_SKIP_ISP(v)   BF_CS1(IPU_CSI0_SKIP, CSI0_MAX_RATIO_SKIP_ISP, v)
#endif

/* --- Register HW_IPU_CSI0_SKIP, field CSI0_SKIP_ISP (RW)
 *
 * CSI0 SKIP ISP These 5 bits define the skipping pattern of the frames send to the ISP. Skipping is
 * done for a set of frames. The number of frames in a set is defined at CSI0_MAX_RATIO_SKIP. when
 * CSI0_MAX_RATIO_SKIP = 1 => CSI0_SKIP_ISP[0] is used; other bits are ignored when
 * CSI0_MAX_RATIO_SKIP = 2 => CSI0_SKIP_ISP[1:0] are used; other bits are ignored when
 * CSI0_MAX_RATIO_SKIP = 3 => CSI0_SKIP_ISP[2:0] are used; other bits are ignored when
 * CSI0_MAX_RATIO_SKIP = 4 => CSI0_SKIP_ISP[3:0] are used; other bits are ignored when
 * CSI0_MAX_RATIO_SKIP = 5 => CSI0_SKIP_ISP[4:0] are used; Setting bit #n of CSI0_SKIP_ISP means
 * that the #n frame in the set is skipped. For example: if CSI0_MAX_RATIO_SKIP = 4 and
 * CSI0_SKIP_ISP = 11010 Frames #0 & Frame #2 will not be skipped as bit0 and bit2 are cleared
 * Frames #1 & Frame #3 will be skipped as bit1 and bit3 are set bit #4 is ignored as
 * CSI0_MAX_RATIO_SKIP is set to 4 Reserved
 */

#define BP_IPU_CSI0_SKIP_CSI0_SKIP_ISP      19
#define BM_IPU_CSI0_SKIP_CSI0_SKIP_ISP      0x00f80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_SKIP_CSI0_SKIP_ISP(v)   ((((reg32_t) v) << 19) & BM_IPU_CSI0_SKIP_CSI0_SKIP_ISP)
#else
#define BF_IPU_CSI0_SKIP_CSI0_SKIP_ISP(v)   (((v) << 19) & BM_IPU_CSI0_SKIP_CSI0_SKIP_ISP)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_SKIP_ISP field to a new value.
#define BW_IPU_CSI0_SKIP_CSI0_SKIP_ISP(v)   BF_CS1(IPU_CSI0_SKIP, CSI0_SKIP_ISP, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSIO_CPD_CTRL - CSI0 Compander Control Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_GREEN_P_BEGIN : 1; //!< Color of first component in the frame. Reserved
        unsigned CSI0_RED_ROW_BEGIN : 1; //!< Color of first row in the frame. Reserved
        unsigned CSI0_CPD : 3; //!< CSI0_CPD These bits enable the compander in the path to different destination. CSI0_CPD[0] - Enable for the compander for data sent to the ISP CSI0_CPD[1] - Enable for the compander for data sent to the IC CSI0_CPD[2] - Enable for the compander for data sent to the IDMAC via SMFC If all the 3 bits are zero the compander is disabled Reserved
        unsigned RESERVED0 : 27; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csio_cpd_ctrl_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSIO_CPD_CTRL register
 */
#define HW_IPU_CSIO_CPD_CTRL_ADDR(x)      (REGS_IPU_BASE(x) + 0x30028)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSIO_CPD_CTRL(x)           (*(volatile hw_ipu_csio_cpd_ctrl_t *) HW_IPU_CSIO_CPD_CTRL_ADDR(x))
#define HW_IPU_CSIO_CPD_CTRL_RD(x)        (HW_IPU_CSIO_CPD_CTRL(x).U)
#define HW_IPU_CSIO_CPD_CTRL_WR(x, v)     (HW_IPU_CSIO_CPD_CTRL(x).U = (v))
#define HW_IPU_CSIO_CPD_CTRL_SET(x, v)    (HW_IPU_CSIO_CPD_CTRL_WR(x, HW_IPU_CSIO_CPD_CTRL_RD(x) |  (v)))
#define HW_IPU_CSIO_CPD_CTRL_CLR(x, v)    (HW_IPU_CSIO_CPD_CTRL_WR(x, HW_IPU_CSIO_CPD_CTRL_RD(x) & ~(v)))
#define HW_IPU_CSIO_CPD_CTRL_TOG(x, v)    (HW_IPU_CSIO_CPD_CTRL_WR(x, HW_IPU_CSIO_CPD_CTRL_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSIO_CPD_CTRL bitfields
 */

/* --- Register HW_IPU_CSIO_CPD_CTRL, field CSI0_GREEN_P_BEGIN (RW)
 *
 * Color of first component in the frame. Reserved
 *
 * Values:
 * 0 - First component in the frame is blue or red, depending from RED_ROW bit.
 * 1 - First component in the frame is green
 */

#define BP_IPU_CSIO_CPD_CTRL_CSI0_GREEN_P_BEGIN      0
#define BM_IPU_CSIO_CPD_CTRL_CSI0_GREEN_P_BEGIN      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_CTRL_CSI0_GREEN_P_BEGIN(v)   ((((reg32_t) v) << 0) & BM_IPU_CSIO_CPD_CTRL_CSI0_GREEN_P_BEGIN)
#else
#define BF_IPU_CSIO_CPD_CTRL_CSI0_GREEN_P_BEGIN(v)   (((v) << 0) & BM_IPU_CSIO_CPD_CTRL_CSI0_GREEN_P_BEGIN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_GREEN_P_BEGIN field to a new value.
#define BW_IPU_CSIO_CPD_CTRL_CSI0_GREEN_P_BEGIN(v)   BF_CS1(IPU_CSIO_CPD_CTRL, CSI0_GREEN_P_BEGIN, v)
#endif


/* --- Register HW_IPU_CSIO_CPD_CTRL, field CSI0_RED_ROW_BEGIN (RW)
 *
 * Color of first row in the frame. Reserved
 *
 * Values:
 * 0 - First row in the frame is GBGB.
 * 1 - First row in the frame is GRGR.
 */

#define BP_IPU_CSIO_CPD_CTRL_CSI0_RED_ROW_BEGIN      1
#define BM_IPU_CSIO_CPD_CTRL_CSI0_RED_ROW_BEGIN      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_CTRL_CSI0_RED_ROW_BEGIN(v)   ((((reg32_t) v) << 1) & BM_IPU_CSIO_CPD_CTRL_CSI0_RED_ROW_BEGIN)
#else
#define BF_IPU_CSIO_CPD_CTRL_CSI0_RED_ROW_BEGIN(v)   (((v) << 1) & BM_IPU_CSIO_CPD_CTRL_CSI0_RED_ROW_BEGIN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_RED_ROW_BEGIN field to a new value.
#define BW_IPU_CSIO_CPD_CTRL_CSI0_RED_ROW_BEGIN(v)   BF_CS1(IPU_CSIO_CPD_CTRL, CSI0_RED_ROW_BEGIN, v)
#endif


/* --- Register HW_IPU_CSIO_CPD_CTRL, field CSI0_CPD (RW)
 *
 * CSI0_CPD These bits enable the compander in the path to different destination. CSI0_CPD[0] -
 * Enable for the compander for data sent to the ISP CSI0_CPD[1] - Enable for the compander for data
 * sent to the IC CSI0_CPD[2] - Enable for the compander for data sent to the IDMAC via SMFC If all
 * the 3 bits are zero the compander is disabled Reserved
 */

#define BP_IPU_CSIO_CPD_CTRL_CSI0_CPD      2
#define BM_IPU_CSIO_CPD_CTRL_CSI0_CPD      0x0000001c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_CTRL_CSI0_CPD(v)   ((((reg32_t) v) << 2) & BM_IPU_CSIO_CPD_CTRL_CSI0_CPD)
#else
#define BF_IPU_CSIO_CPD_CTRL_CSI0_CPD(v)   (((v) << 2) & BM_IPU_CSIO_CPD_CTRL_CSI0_CPD)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD field to a new value.
#define BW_IPU_CSIO_CPD_CTRL_CSI0_CPD(v)   BF_CS1(IPU_CSIO_CPD_CTRL, CSI0_CPD, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSIO_CPD_RC_I - CSI0 Red Component Compander Constants Register <i> (RW)
 *
 * These registers contain CONSTANT <i> parameters used for companding of red component.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_CPD_RC_ : 9; //!< CONSTANT <2*i> parameter of Compander, Red component. Reserved
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned CSI0_CPD_RC_1 : 9; //!< CONSTANT <2*i+1> parameter of Compander, Red component. Reserved
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_csio_cpd_rc_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSIO_CPD_RC_I register
 */
#define HW_IPU_CSIO_CPD_RC_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x3002c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSIO_CPD_RC_I(x)           (*(volatile hw_ipu_csio_cpd_rc_i_t *) HW_IPU_CSIO_CPD_RC_I_ADDR(x))
#define HW_IPU_CSIO_CPD_RC_I_RD(x)        (HW_IPU_CSIO_CPD_RC_I(x).U)
#define HW_IPU_CSIO_CPD_RC_I_WR(x, v)     (HW_IPU_CSIO_CPD_RC_I(x).U = (v))
#define HW_IPU_CSIO_CPD_RC_I_SET(x, v)    (HW_IPU_CSIO_CPD_RC_I_WR(x, HW_IPU_CSIO_CPD_RC_I_RD(x) |  (v)))
#define HW_IPU_CSIO_CPD_RC_I_CLR(x, v)    (HW_IPU_CSIO_CPD_RC_I_WR(x, HW_IPU_CSIO_CPD_RC_I_RD(x) & ~(v)))
#define HW_IPU_CSIO_CPD_RC_I_TOG(x, v)    (HW_IPU_CSIO_CPD_RC_I_WR(x, HW_IPU_CSIO_CPD_RC_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSIO_CPD_RC_I bitfields
 */

/* --- Register HW_IPU_CSIO_CPD_RC_I, field CSI0_CPD_RC_ (RW)
 *
 * CONSTANT <2*i> parameter of Compander, Red component. Reserved
 */

#define BP_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_      0
#define BM_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_(v)   ((((reg32_t) v) << 0) & BM_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_)
#else
#define BF_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_(v)   (((v) << 0) & BM_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_RC_ field to a new value.
#define BW_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_(v)   BF_CS1(IPU_CSIO_CPD_RC_I, CSI0_CPD_RC_, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_RC_I, field CSI0_CPD_RC_ (RW)
 *
 * CONSTANT <2*i+1> parameter of Compander, Red component. Reserved
 */

#define BP_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_      16
#define BM_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_(v)   ((((reg32_t) v) << 16) & BM_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_)
#else
#define BF_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_(v)   (((v) << 16) & BM_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_RC_ field to a new value.
#define BW_IPU_CSIO_CPD_RC_I_CSI0_CPD_RC_(v)   BF_CS1(IPU_CSIO_CPD_RC_I, CSI0_CPD_RC_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSIO_CPD_RS_I - CSI0 Red Component Compander SLOPE Register <i> (RW)
 *
 * These registers contain SLOPE <i> parameters used for companding of red component.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_CPD_RS : 8; //!< SLOPE<4*i> parameter of Compander, Red component. Reserved
        unsigned CSI0_CPD_RS1 : 8; //!< SLOPE<4*i+1> parameter of Compander, Red component. Reserved
        unsigned CSI0_CPD_RS2 : 8; //!< SLOPE<4*i+2> parameter of Compander, Red component. Reserved
        unsigned CSI0_CPD_RS3 : 8; //!< SLOPE<4*i+3> parameter of Compander, Red component. Reserved
    } B;
} hw_ipu_csio_cpd_rs_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSIO_CPD_RS_I register
 */
#define HW_IPU_CSIO_CPD_RS_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x3004c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSIO_CPD_RS_I(x)           (*(volatile hw_ipu_csio_cpd_rs_i_t *) HW_IPU_CSIO_CPD_RS_I_ADDR(x))
#define HW_IPU_CSIO_CPD_RS_I_RD(x)        (HW_IPU_CSIO_CPD_RS_I(x).U)
#define HW_IPU_CSIO_CPD_RS_I_WR(x, v)     (HW_IPU_CSIO_CPD_RS_I(x).U = (v))
#define HW_IPU_CSIO_CPD_RS_I_SET(x, v)    (HW_IPU_CSIO_CPD_RS_I_WR(x, HW_IPU_CSIO_CPD_RS_I_RD(x) |  (v)))
#define HW_IPU_CSIO_CPD_RS_I_CLR(x, v)    (HW_IPU_CSIO_CPD_RS_I_WR(x, HW_IPU_CSIO_CPD_RS_I_RD(x) & ~(v)))
#define HW_IPU_CSIO_CPD_RS_I_TOG(x, v)    (HW_IPU_CSIO_CPD_RS_I_WR(x, HW_IPU_CSIO_CPD_RS_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSIO_CPD_RS_I bitfields
 */

/* --- Register HW_IPU_CSIO_CPD_RS_I, field CSI0_CPD_RS (RW)
 *
 * SLOPE<4*i> parameter of Compander, Red component. Reserved
 */

#define BP_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS      0
#define BM_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS(v)   ((((reg32_t) v) << 0) & BM_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS)
#else
#define BF_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS(v)   (((v) << 0) & BM_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_RS field to a new value.
#define BW_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS(v)   BF_CS1(IPU_CSIO_CPD_RS_I, CSI0_CPD_RS, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_RS_I, field CSI0_CPD_RS (RW)
 *
 * SLOPE<4*i+1> parameter of Compander, Red component. Reserved
 */

#define BP_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS      8
#define BM_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS(v)   ((((reg32_t) v) << 8) & BM_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS)
#else
#define BF_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS(v)   (((v) << 8) & BM_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_RS field to a new value.
#define BW_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS(v)   BF_CS1(IPU_CSIO_CPD_RS_I, CSI0_CPD_RS, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_RS_I, field CSI0_CPD_RS (RW)
 *
 * SLOPE<4*i+2> parameter of Compander, Red component. Reserved
 */

#define BP_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS      16
#define BM_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS(v)   ((((reg32_t) v) << 16) & BM_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS)
#else
#define BF_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS(v)   (((v) << 16) & BM_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_RS field to a new value.
#define BW_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS(v)   BF_CS1(IPU_CSIO_CPD_RS_I, CSI0_CPD_RS, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_RS_I, field CSI0_CPD_RS (RW)
 *
 * SLOPE<4*i+3> parameter of Compander, Red component. Reserved
 */

#define BP_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS      24
#define BM_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS(v)   ((((reg32_t) v) << 24) & BM_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS)
#else
#define BF_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS(v)   (((v) << 24) & BM_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_RS field to a new value.
#define BW_IPU_CSIO_CPD_RS_I_CSI0_CPD_RS(v)   BF_CS1(IPU_CSIO_CPD_RS_I, CSI0_CPD_RS, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSIO_CPD_GRC_I - CSI0 GR Component Compander Constants Register <i> (RW)
 *
 * These registers contain CONSTANTi parameters used for companding of green components in GRGR
 * rows.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_CPD_GRC : 9; //!< CONSTANT<2*i> parameter of Compander, GR component. If the input format is RGB/YUV then CSI0_CPD_GRC should be equal to CSI0_CPD_GBC Reserved
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned CSI0_CPD_GRC1 : 9; //!< CONST<2*i+1> parameter of Compander, GR component. If the input format is RGB/YUV then CSI0_CPD_GRC should be equal to CSI0_CPD_GBC Reserved
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_csio_cpd_grc_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSIO_CPD_GRC_I register
 */
#define HW_IPU_CSIO_CPD_GRC_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x3005c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSIO_CPD_GRC_I(x)           (*(volatile hw_ipu_csio_cpd_grc_i_t *) HW_IPU_CSIO_CPD_GRC_I_ADDR(x))
#define HW_IPU_CSIO_CPD_GRC_I_RD(x)        (HW_IPU_CSIO_CPD_GRC_I(x).U)
#define HW_IPU_CSIO_CPD_GRC_I_WR(x, v)     (HW_IPU_CSIO_CPD_GRC_I(x).U = (v))
#define HW_IPU_CSIO_CPD_GRC_I_SET(x, v)    (HW_IPU_CSIO_CPD_GRC_I_WR(x, HW_IPU_CSIO_CPD_GRC_I_RD(x) |  (v)))
#define HW_IPU_CSIO_CPD_GRC_I_CLR(x, v)    (HW_IPU_CSIO_CPD_GRC_I_WR(x, HW_IPU_CSIO_CPD_GRC_I_RD(x) & ~(v)))
#define HW_IPU_CSIO_CPD_GRC_I_TOG(x, v)    (HW_IPU_CSIO_CPD_GRC_I_WR(x, HW_IPU_CSIO_CPD_GRC_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSIO_CPD_GRC_I bitfields
 */

/* --- Register HW_IPU_CSIO_CPD_GRC_I, field CSI0_CPD_GRC (RW)
 *
 * CONSTANT<2*i> parameter of Compander, GR component. If the input format is RGB/YUV then
 * CSI0_CPD_GRC should be equal to CSI0_CPD_GBC Reserved
 */

#define BP_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC      0
#define BM_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC(v)   ((((reg32_t) v) << 0) & BM_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC)
#else
#define BF_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC(v)   (((v) << 0) & BM_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_GRC field to a new value.
#define BW_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC(v)   BF_CS1(IPU_CSIO_CPD_GRC_I, CSI0_CPD_GRC, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_GRC_I, field CSI0_CPD_GRC (RW)
 *
 * CONST<2*i+1> parameter of Compander, GR component. If the input format is RGB/YUV then
 * CSI0_CPD_GRC should be equal to CSI0_CPD_GBC Reserved
 */

#define BP_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC      16
#define BM_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC(v)   ((((reg32_t) v) << 16) & BM_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC)
#else
#define BF_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC(v)   (((v) << 16) & BM_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_GRC field to a new value.
#define BW_IPU_CSIO_CPD_GRC_I_CSI0_CPD_GRC(v)   BF_CS1(IPU_CSIO_CPD_GRC_I, CSI0_CPD_GRC, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSIO_CPD_GRS_I - CSI0 GR Component Compander SLOPE Register <i> (RW)
 *
 * These registers contain SLOPEi parameters used for companding of green components in GRGR rows.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_CPD_GRS : 8; //!< SLOPE<4*i> parameter of Compander, GR component. If the input format is RGB/YUV then CSI0_CPD_GRS should be equal to CSI0_CPD_GBS Reserved
        unsigned CSI0_CPD_GRS1 : 8; //!< SLOPE<4*i+1> parameter of Compander, GR component. If the input format is RGB/YUV then CSI0_CPD_GRS should be equal to CSI0_CPD_GBS Reserved
        unsigned CSI0_CPD_GRS2 : 8; //!< SLOPE<4*i+2> parameter of Compander, GR component. If the input format is RGB/YUV then CSI0_CPD_GRS should be equal to CSI0_CPD_GBS Reserved
        unsigned CSI0_CPD_GRS3 : 8; //!< SLOPE<4*i+3> parameter of Compander, GR component. If the input format is RGB/YUV then CSI0_CPD_GRS should be equal to CSI0_CPD_GBS Reserved
    } B;
} hw_ipu_csio_cpd_grs_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSIO_CPD_GRS_I register
 */
#define HW_IPU_CSIO_CPD_GRS_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x3007c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSIO_CPD_GRS_I(x)           (*(volatile hw_ipu_csio_cpd_grs_i_t *) HW_IPU_CSIO_CPD_GRS_I_ADDR(x))
#define HW_IPU_CSIO_CPD_GRS_I_RD(x)        (HW_IPU_CSIO_CPD_GRS_I(x).U)
#define HW_IPU_CSIO_CPD_GRS_I_WR(x, v)     (HW_IPU_CSIO_CPD_GRS_I(x).U = (v))
#define HW_IPU_CSIO_CPD_GRS_I_SET(x, v)    (HW_IPU_CSIO_CPD_GRS_I_WR(x, HW_IPU_CSIO_CPD_GRS_I_RD(x) |  (v)))
#define HW_IPU_CSIO_CPD_GRS_I_CLR(x, v)    (HW_IPU_CSIO_CPD_GRS_I_WR(x, HW_IPU_CSIO_CPD_GRS_I_RD(x) & ~(v)))
#define HW_IPU_CSIO_CPD_GRS_I_TOG(x, v)    (HW_IPU_CSIO_CPD_GRS_I_WR(x, HW_IPU_CSIO_CPD_GRS_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSIO_CPD_GRS_I bitfields
 */

/* --- Register HW_IPU_CSIO_CPD_GRS_I, field CSI0_CPD_GRS (RW)
 *
 * SLOPE<4*i> parameter of Compander, GR component. If the input format is RGB/YUV then CSI0_CPD_GRS
 * should be equal to CSI0_CPD_GBS Reserved
 */

#define BP_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS      0
#define BM_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS(v)   ((((reg32_t) v) << 0) & BM_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS)
#else
#define BF_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS(v)   (((v) << 0) & BM_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_GRS field to a new value.
#define BW_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS(v)   BF_CS1(IPU_CSIO_CPD_GRS_I, CSI0_CPD_GRS, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_GRS_I, field CSI0_CPD_GRS (RW)
 *
 * SLOPE<4*i+1> parameter of Compander, GR component. If the input format is RGB/YUV then
 * CSI0_CPD_GRS should be equal to CSI0_CPD_GBS Reserved
 */

#define BP_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS      8
#define BM_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS(v)   ((((reg32_t) v) << 8) & BM_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS)
#else
#define BF_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS(v)   (((v) << 8) & BM_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_GRS field to a new value.
#define BW_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS(v)   BF_CS1(IPU_CSIO_CPD_GRS_I, CSI0_CPD_GRS, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_GRS_I, field CSI0_CPD_GRS (RW)
 *
 * SLOPE<4*i+2> parameter of Compander, GR component. If the input format is RGB/YUV then
 * CSI0_CPD_GRS should be equal to CSI0_CPD_GBS Reserved
 */

#define BP_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS      16
#define BM_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS(v)   ((((reg32_t) v) << 16) & BM_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS)
#else
#define BF_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS(v)   (((v) << 16) & BM_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_GRS field to a new value.
#define BW_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS(v)   BF_CS1(IPU_CSIO_CPD_GRS_I, CSI0_CPD_GRS, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_GRS_I, field CSI0_CPD_GRS (RW)
 *
 * SLOPE<4*i+3> parameter of Compander, GR component. If the input format is RGB/YUV then
 * CSI0_CPD_GRS should be equal to CSI0_CPD_GBS Reserved
 */

#define BP_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS      24
#define BM_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS(v)   ((((reg32_t) v) << 24) & BM_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS)
#else
#define BF_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS(v)   (((v) << 24) & BM_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_GRS field to a new value.
#define BW_IPU_CSIO_CPD_GRS_I_CSI0_CPD_GRS(v)   BF_CS1(IPU_CSIO_CPD_GRS_I, CSI0_CPD_GRS, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSIO_CPD_GBC_I - CSI0 GB Component Compander Constants Register <i> (RW)
 *
 * These registers contain CONSTANTi parameters used for companding of green components in GBGB
 * rows.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_CPD_GBC : 9; //!< CONSTANTi parameter of Compander, GB component. If the input format is RGB/YUV then CSI0_CPD_GBC should be equal to CSI0_CPD_GRC Reserved
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned CSI0_CPD_GBC1 : 9; //!< CONSTi+1 parameter of Compander, GB component. If the input format is RGB/YUV then CSI0_CPD_GBC should be equal to CSI0_CPD_GRC Reserved
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_csio_cpd_gbc_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSIO_CPD_GBC_I register
 */
#define HW_IPU_CSIO_CPD_GBC_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x3008c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSIO_CPD_GBC_I(x)           (*(volatile hw_ipu_csio_cpd_gbc_i_t *) HW_IPU_CSIO_CPD_GBC_I_ADDR(x))
#define HW_IPU_CSIO_CPD_GBC_I_RD(x)        (HW_IPU_CSIO_CPD_GBC_I(x).U)
#define HW_IPU_CSIO_CPD_GBC_I_WR(x, v)     (HW_IPU_CSIO_CPD_GBC_I(x).U = (v))
#define HW_IPU_CSIO_CPD_GBC_I_SET(x, v)    (HW_IPU_CSIO_CPD_GBC_I_WR(x, HW_IPU_CSIO_CPD_GBC_I_RD(x) |  (v)))
#define HW_IPU_CSIO_CPD_GBC_I_CLR(x, v)    (HW_IPU_CSIO_CPD_GBC_I_WR(x, HW_IPU_CSIO_CPD_GBC_I_RD(x) & ~(v)))
#define HW_IPU_CSIO_CPD_GBC_I_TOG(x, v)    (HW_IPU_CSIO_CPD_GBC_I_WR(x, HW_IPU_CSIO_CPD_GBC_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSIO_CPD_GBC_I bitfields
 */

/* --- Register HW_IPU_CSIO_CPD_GBC_I, field CSI0_CPD_GBC (RW)
 *
 * CONSTANTi parameter of Compander, GB component. If the input format is RGB/YUV then CSI0_CPD_GBC
 * should be equal to CSI0_CPD_GRC Reserved
 */

#define BP_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC      0
#define BM_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC(v)   ((((reg32_t) v) << 0) & BM_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC)
#else
#define BF_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC(v)   (((v) << 0) & BM_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_GBC field to a new value.
#define BW_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC(v)   BF_CS1(IPU_CSIO_CPD_GBC_I, CSI0_CPD_GBC, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_GBC_I, field CSI0_CPD_GBC (RW)
 *
 * CONSTi+1 parameter of Compander, GB component. If the input format is RGB/YUV then CSI0_CPD_GBC
 * should be equal to CSI0_CPD_GRC Reserved
 */

#define BP_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC      16
#define BM_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC(v)   ((((reg32_t) v) << 16) & BM_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC)
#else
#define BF_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC(v)   (((v) << 16) & BM_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_GBC field to a new value.
#define BW_IPU_CSIO_CPD_GBC_I_CSI0_CPD_GBC(v)   BF_CS1(IPU_CSIO_CPD_GBC_I, CSI0_CPD_GBC, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSIO_CPD_GBS_I - CSI0 GB Component Compander SLOPE Register <i> (RW)
 *
 * These registers contain SLOPEi parameters used for companding of green components in GBGB rows.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_CPD_GBS : 8; //!< SLOPE<4*i> parameter of Compander, GB component. If the input format is RGB/YUV then CSI0_CPD_GBS should be equal to CSI0_CPD_GRS Reserved
        unsigned CSI0_CPD_GBS1 : 8; //!< SLOPE<4*i+1> parameter of Compander, GB component. If the input format is RGB/YUV then CSI0_CPD_GBS should be equal to CSI0_CPD_GRS Reserved
        unsigned CSI0_CPD_GBS2 : 8; //!< SLOPE<4*i+2> parameter of Compander, GB component. If the input format is RGB/YUV then CSI0_CPD_GBS should be equal to CSI0_CPD_GRS Reserved
        unsigned CSI0_CPD_GBS3 : 8; //!< SLOPE<4*i+3> parameter of Compander, GB component. If the input format is RGB/YUV then CSI0_CPD_GBS should be equal to CSI0_CPD_GRS Reserved
    } B;
} hw_ipu_csio_cpd_gbs_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSIO_CPD_GBS_I register
 */
#define HW_IPU_CSIO_CPD_GBS_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x300ac)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSIO_CPD_GBS_I(x)           (*(volatile hw_ipu_csio_cpd_gbs_i_t *) HW_IPU_CSIO_CPD_GBS_I_ADDR(x))
#define HW_IPU_CSIO_CPD_GBS_I_RD(x)        (HW_IPU_CSIO_CPD_GBS_I(x).U)
#define HW_IPU_CSIO_CPD_GBS_I_WR(x, v)     (HW_IPU_CSIO_CPD_GBS_I(x).U = (v))
#define HW_IPU_CSIO_CPD_GBS_I_SET(x, v)    (HW_IPU_CSIO_CPD_GBS_I_WR(x, HW_IPU_CSIO_CPD_GBS_I_RD(x) |  (v)))
#define HW_IPU_CSIO_CPD_GBS_I_CLR(x, v)    (HW_IPU_CSIO_CPD_GBS_I_WR(x, HW_IPU_CSIO_CPD_GBS_I_RD(x) & ~(v)))
#define HW_IPU_CSIO_CPD_GBS_I_TOG(x, v)    (HW_IPU_CSIO_CPD_GBS_I_WR(x, HW_IPU_CSIO_CPD_GBS_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSIO_CPD_GBS_I bitfields
 */

/* --- Register HW_IPU_CSIO_CPD_GBS_I, field CSI0_CPD_GBS (RW)
 *
 * SLOPE<4*i> parameter of Compander, GB component. If the input format is RGB/YUV then CSI0_CPD_GBS
 * should be equal to CSI0_CPD_GRS Reserved
 */

#define BP_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS      0
#define BM_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS(v)   ((((reg32_t) v) << 0) & BM_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS)
#else
#define BF_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS(v)   (((v) << 0) & BM_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_GBS field to a new value.
#define BW_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS(v)   BF_CS1(IPU_CSIO_CPD_GBS_I, CSI0_CPD_GBS, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_GBS_I, field CSI0_CPD_GBS (RW)
 *
 * SLOPE<4*i+1> parameter of Compander, GB component. If the input format is RGB/YUV then
 * CSI0_CPD_GBS should be equal to CSI0_CPD_GRS Reserved
 */

#define BP_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS      8
#define BM_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS(v)   ((((reg32_t) v) << 8) & BM_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS)
#else
#define BF_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS(v)   (((v) << 8) & BM_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_GBS field to a new value.
#define BW_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS(v)   BF_CS1(IPU_CSIO_CPD_GBS_I, CSI0_CPD_GBS, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_GBS_I, field CSI0_CPD_GBS (RW)
 *
 * SLOPE<4*i+2> parameter of Compander, GB component. If the input format is RGB/YUV then
 * CSI0_CPD_GBS should be equal to CSI0_CPD_GRS Reserved
 */

#define BP_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS      16
#define BM_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS(v)   ((((reg32_t) v) << 16) & BM_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS)
#else
#define BF_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS(v)   (((v) << 16) & BM_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_GBS field to a new value.
#define BW_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS(v)   BF_CS1(IPU_CSIO_CPD_GBS_I, CSI0_CPD_GBS, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_GBS_I, field CSI0_CPD_GBS (RW)
 *
 * SLOPE<4*i+3> parameter of Compander, GB component. If the input format is RGB/YUV then
 * CSI0_CPD_GBS should be equal to CSI0_CPD_GRS Reserved
 */

#define BP_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS      24
#define BM_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS(v)   ((((reg32_t) v) << 24) & BM_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS)
#else
#define BF_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS(v)   (((v) << 24) & BM_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_GBS field to a new value.
#define BW_IPU_CSIO_CPD_GBS_I_CSI0_CPD_GBS(v)   BF_CS1(IPU_CSIO_CPD_GBS_I, CSI0_CPD_GBS, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSIO_CPD_BC_I - CSI0 Blue Component Compander Constants Register <i> (RW)
 *
 * These registers contain CONSTANTi parameters used for companding of blue component.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_CPD_BC : 9; //!< CONSTANT<2*i> parameter of Compander, Blue component. Reserved
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned CSI0_CPD_BC1 : 9; //!< CONSTANT<2*i+1> parameter of Compander, Blue component. Reserved
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_csio_cpd_bc_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSIO_CPD_BC_I register
 */
#define HW_IPU_CSIO_CPD_BC_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x300bc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSIO_CPD_BC_I(x)           (*(volatile hw_ipu_csio_cpd_bc_i_t *) HW_IPU_CSIO_CPD_BC_I_ADDR(x))
#define HW_IPU_CSIO_CPD_BC_I_RD(x)        (HW_IPU_CSIO_CPD_BC_I(x).U)
#define HW_IPU_CSIO_CPD_BC_I_WR(x, v)     (HW_IPU_CSIO_CPD_BC_I(x).U = (v))
#define HW_IPU_CSIO_CPD_BC_I_SET(x, v)    (HW_IPU_CSIO_CPD_BC_I_WR(x, HW_IPU_CSIO_CPD_BC_I_RD(x) |  (v)))
#define HW_IPU_CSIO_CPD_BC_I_CLR(x, v)    (HW_IPU_CSIO_CPD_BC_I_WR(x, HW_IPU_CSIO_CPD_BC_I_RD(x) & ~(v)))
#define HW_IPU_CSIO_CPD_BC_I_TOG(x, v)    (HW_IPU_CSIO_CPD_BC_I_WR(x, HW_IPU_CSIO_CPD_BC_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSIO_CPD_BC_I bitfields
 */

/* --- Register HW_IPU_CSIO_CPD_BC_I, field CSI0_CPD_BC (RW)
 *
 * CONSTANT<2*i> parameter of Compander, Blue component. Reserved
 */

#define BP_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC      0
#define BM_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC(v)   ((((reg32_t) v) << 0) & BM_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC)
#else
#define BF_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC(v)   (((v) << 0) & BM_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_BC field to a new value.
#define BW_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC(v)   BF_CS1(IPU_CSIO_CPD_BC_I, CSI0_CPD_BC, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_BC_I, field CSI0_CPD_BC (RW)
 *
 * CONSTANT<2*i+1> parameter of Compander, Blue component. Reserved
 */

#define BP_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC      16
#define BM_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC(v)   ((((reg32_t) v) << 16) & BM_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC)
#else
#define BF_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC(v)   (((v) << 16) & BM_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_BC field to a new value.
#define BW_IPU_CSIO_CPD_BC_I_CSI0_CPD_BC(v)   BF_CS1(IPU_CSIO_CPD_BC_I, CSI0_CPD_BC, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSIO_CPD_BS_I - CSI0 Blue Component Compander SLOPE Register <i> (RW)
 *
 * These registers contain SLOPEi parameters used for companding of red component.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_CPD_BS : 8; //!< SLOPE<4*i> parameter of Compander, Blue component. Reserved l
        unsigned CSI0_CPD_BS1 : 8; //!< SLOPE<4*i+1> parameter of Compander, Blue component. Reserved
        unsigned CSI0_CPD_BS2 : 8; //!< SLOPE<4*i+2> parameter of Compander, Blue component. Reserved
        unsigned CSI0_CPD_BS3 : 8; //!< SLOPE<4*i+3> parameter of Compander, Blue component. Reserved
    } B;
} hw_ipu_csio_cpd_bs_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSIO_CPD_BS_I register
 */
#define HW_IPU_CSIO_CPD_BS_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x300dc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSIO_CPD_BS_I(x)           (*(volatile hw_ipu_csio_cpd_bs_i_t *) HW_IPU_CSIO_CPD_BS_I_ADDR(x))
#define HW_IPU_CSIO_CPD_BS_I_RD(x)        (HW_IPU_CSIO_CPD_BS_I(x).U)
#define HW_IPU_CSIO_CPD_BS_I_WR(x, v)     (HW_IPU_CSIO_CPD_BS_I(x).U = (v))
#define HW_IPU_CSIO_CPD_BS_I_SET(x, v)    (HW_IPU_CSIO_CPD_BS_I_WR(x, HW_IPU_CSIO_CPD_BS_I_RD(x) |  (v)))
#define HW_IPU_CSIO_CPD_BS_I_CLR(x, v)    (HW_IPU_CSIO_CPD_BS_I_WR(x, HW_IPU_CSIO_CPD_BS_I_RD(x) & ~(v)))
#define HW_IPU_CSIO_CPD_BS_I_TOG(x, v)    (HW_IPU_CSIO_CPD_BS_I_WR(x, HW_IPU_CSIO_CPD_BS_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSIO_CPD_BS_I bitfields
 */

/* --- Register HW_IPU_CSIO_CPD_BS_I, field CSI0_CPD_BS (RW)
 *
 * SLOPE<4*i> parameter of Compander, Blue component. Reserved l
 */

#define BP_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS      0
#define BM_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS(v)   ((((reg32_t) v) << 0) & BM_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS)
#else
#define BF_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS(v)   (((v) << 0) & BM_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_BS field to a new value.
#define BW_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS(v)   BF_CS1(IPU_CSIO_CPD_BS_I, CSI0_CPD_BS, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_BS_I, field CSI0_CPD_BS (RW)
 *
 * SLOPE<4*i+1> parameter of Compander, Blue component. Reserved
 */

#define BP_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS      8
#define BM_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS(v)   ((((reg32_t) v) << 8) & BM_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS)
#else
#define BF_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS(v)   (((v) << 8) & BM_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_BS field to a new value.
#define BW_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS(v)   BF_CS1(IPU_CSIO_CPD_BS_I, CSI0_CPD_BS, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_BS_I, field CSI0_CPD_BS (RW)
 *
 * SLOPE<4*i+2> parameter of Compander, Blue component. Reserved
 */

#define BP_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS      16
#define BM_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS(v)   ((((reg32_t) v) << 16) & BM_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS)
#else
#define BF_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS(v)   (((v) << 16) & BM_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_BS field to a new value.
#define BW_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS(v)   BF_CS1(IPU_CSIO_CPD_BS_I, CSI0_CPD_BS, v)
#endif

/* --- Register HW_IPU_CSIO_CPD_BS_I, field CSI0_CPD_BS (RW)
 *
 * SLOPE<4*i+3> parameter of Compander, Blue component. Reserved
 */

#define BP_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS      24
#define BM_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS(v)   ((((reg32_t) v) << 24) & BM_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS)
#else
#define BF_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS(v)   (((v) << 24) & BM_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_BS field to a new value.
#define BW_IPU_CSIO_CPD_BS_I_CSI0_CPD_BS(v)   BF_CS1(IPU_CSIO_CPD_BS_I, CSI0_CPD_BS, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI0_CPD_OFFSET1 - CSI0 Compander Offset Register 1 (RW)
 *
 * These registers contain Offset parameters used for companding.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_GR_OFFSET : 10; //!< CSI0 Green Red component offset The value is between -512 to 511. The value is added to the green-red component before companding. Clipping: If the result of the green-red components value + the offset is smaller than 0, the result is zero If the result of the green-red components value + the offset is greater than 1023, the result is 1023 Reserved
        unsigned CSI0_GB_OFFSET : 10; //!< CSI0 Green Blue component offset The value is between -512 to 511. The value is added to the blue component before companding. Clipping: If the result of the green-blue components value + the offset is smaller than 0, the result is zero If the result of the green-blue components value + the offset is greater than 1023, the result is 1023 If the input format is RGB/YUV then CSI1_GB_OFFSET must be equal to CSI1_GR_OFFSET Reserved
        unsigned CSI0_CPD_B_OFFSET : 10; //!< CSI0 Blue component offset The value is between -512 to 511. The value is added to the blue component before companding. Clipping: If the result of the blue components value + the offset is smaller than 0, the result is zero If the result of the blue components value + the offset is greater than 1023, the result is 1023 Reserved
        unsigned RESERVED0 : 2; //!< Reserved
    } B;
} hw_ipu_csi0_cpd_offset1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI0_CPD_OFFSET1 register
 */
#define HW_IPU_CSI0_CPD_OFFSET1_ADDR(x)      (REGS_IPU_BASE(x) + 0x300ec)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI0_CPD_OFFSET1(x)           (*(volatile hw_ipu_csi0_cpd_offset1_t *) HW_IPU_CSI0_CPD_OFFSET1_ADDR(x))
#define HW_IPU_CSI0_CPD_OFFSET1_RD(x)        (HW_IPU_CSI0_CPD_OFFSET1(x).U)
#define HW_IPU_CSI0_CPD_OFFSET1_WR(x, v)     (HW_IPU_CSI0_CPD_OFFSET1(x).U = (v))
#define HW_IPU_CSI0_CPD_OFFSET1_SET(x, v)    (HW_IPU_CSI0_CPD_OFFSET1_WR(x, HW_IPU_CSI0_CPD_OFFSET1_RD(x) |  (v)))
#define HW_IPU_CSI0_CPD_OFFSET1_CLR(x, v)    (HW_IPU_CSI0_CPD_OFFSET1_WR(x, HW_IPU_CSI0_CPD_OFFSET1_RD(x) & ~(v)))
#define HW_IPU_CSI0_CPD_OFFSET1_TOG(x, v)    (HW_IPU_CSI0_CPD_OFFSET1_WR(x, HW_IPU_CSI0_CPD_OFFSET1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI0_CPD_OFFSET1 bitfields
 */

/* --- Register HW_IPU_CSI0_CPD_OFFSET1, field CSI0_GR_OFFSET (RW)
 *
 * CSI0 Green Red component offset The value is between -512 to 511. The value is added to the
 * green-red component before companding. Clipping: If the result of the green-red components value
 * + the offset is smaller than 0, the result is zero If the result of the green-red components
 * value + the offset is greater than 1023, the result is 1023 Reserved
 */

#define BP_IPU_CSI0_CPD_OFFSET1_CSI0_GR_OFFSET      0
#define BM_IPU_CSI0_CPD_OFFSET1_CSI0_GR_OFFSET      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CPD_OFFSET1_CSI0_GR_OFFSET(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI0_CPD_OFFSET1_CSI0_GR_OFFSET)
#else
#define BF_IPU_CSI0_CPD_OFFSET1_CSI0_GR_OFFSET(v)   (((v) << 0) & BM_IPU_CSI0_CPD_OFFSET1_CSI0_GR_OFFSET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_GR_OFFSET field to a new value.
#define BW_IPU_CSI0_CPD_OFFSET1_CSI0_GR_OFFSET(v)   BF_CS1(IPU_CSI0_CPD_OFFSET1, CSI0_GR_OFFSET, v)
#endif

/* --- Register HW_IPU_CSI0_CPD_OFFSET1, field CSI0_GB_OFFSET (RW)
 *
 * CSI0 Green Blue component offset The value is between -512 to 511. The value is added to the blue
 * component before companding. Clipping: If the result of the green-blue components value + the
 * offset is smaller than 0, the result is zero If the result of the green-blue components value +
 * the offset is greater than 1023, the result is 1023 If the input format is RGB/YUV then
 * CSI1_GB_OFFSET must be equal to CSI1_GR_OFFSET Reserved
 */

#define BP_IPU_CSI0_CPD_OFFSET1_CSI0_GB_OFFSET      10
#define BM_IPU_CSI0_CPD_OFFSET1_CSI0_GB_OFFSET      0x000ffc00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CPD_OFFSET1_CSI0_GB_OFFSET(v)   ((((reg32_t) v) << 10) & BM_IPU_CSI0_CPD_OFFSET1_CSI0_GB_OFFSET)
#else
#define BF_IPU_CSI0_CPD_OFFSET1_CSI0_GB_OFFSET(v)   (((v) << 10) & BM_IPU_CSI0_CPD_OFFSET1_CSI0_GB_OFFSET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_GB_OFFSET field to a new value.
#define BW_IPU_CSI0_CPD_OFFSET1_CSI0_GB_OFFSET(v)   BF_CS1(IPU_CSI0_CPD_OFFSET1, CSI0_GB_OFFSET, v)
#endif

/* --- Register HW_IPU_CSI0_CPD_OFFSET1, field CSI0_CPD_B_OFFSET (RW)
 *
 * CSI0 Blue component offset The value is between -512 to 511. The value is added to the blue
 * component before companding. Clipping: If the result of the blue components value + the offset is
 * smaller than 0, the result is zero If the result of the blue components value + the offset is
 * greater than 1023, the result is 1023 Reserved
 */

#define BP_IPU_CSI0_CPD_OFFSET1_CSI0_CPD_B_OFFSET      20
#define BM_IPU_CSI0_CPD_OFFSET1_CSI0_CPD_B_OFFSET      0x3ff00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CPD_OFFSET1_CSI0_CPD_B_OFFSET(v)   ((((reg32_t) v) << 20) & BM_IPU_CSI0_CPD_OFFSET1_CSI0_CPD_B_OFFSET)
#else
#define BF_IPU_CSI0_CPD_OFFSET1_CSI0_CPD_B_OFFSET(v)   (((v) << 20) & BM_IPU_CSI0_CPD_OFFSET1_CSI0_CPD_B_OFFSET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_B_OFFSET field to a new value.
#define BW_IPU_CSI0_CPD_OFFSET1_CSI0_CPD_B_OFFSET(v)   BF_CS1(IPU_CSI0_CPD_OFFSET1, CSI0_CPD_B_OFFSET, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI0_CPD_OFFSET2 - CSI0 Compander Offset Register 2 (RW)
 *
 * This register contain Offset parameters used for companding.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI0_CPD_R_OFFSET : 10; //!< CSI0 Red component offset The value is between -512 to 511. The value is added to the red component before companding. Clipping: If the result of the red components value + the offset is smaller than 0, the result is zero If the result of the red components value + the offset is greater than 1023, the result is 1023 Reserved
        unsigned RESERVED0 : 22; //!< Reserved
    } B;
} hw_ipu_csi0_cpd_offset2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI0_CPD_OFFSET2 register
 */
#define HW_IPU_CSI0_CPD_OFFSET2_ADDR(x)      (REGS_IPU_BASE(x) + 0x300f0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI0_CPD_OFFSET2(x)           (*(volatile hw_ipu_csi0_cpd_offset2_t *) HW_IPU_CSI0_CPD_OFFSET2_ADDR(x))
#define HW_IPU_CSI0_CPD_OFFSET2_RD(x)        (HW_IPU_CSI0_CPD_OFFSET2(x).U)
#define HW_IPU_CSI0_CPD_OFFSET2_WR(x, v)     (HW_IPU_CSI0_CPD_OFFSET2(x).U = (v))
#define HW_IPU_CSI0_CPD_OFFSET2_SET(x, v)    (HW_IPU_CSI0_CPD_OFFSET2_WR(x, HW_IPU_CSI0_CPD_OFFSET2_RD(x) |  (v)))
#define HW_IPU_CSI0_CPD_OFFSET2_CLR(x, v)    (HW_IPU_CSI0_CPD_OFFSET2_WR(x, HW_IPU_CSI0_CPD_OFFSET2_RD(x) & ~(v)))
#define HW_IPU_CSI0_CPD_OFFSET2_TOG(x, v)    (HW_IPU_CSI0_CPD_OFFSET2_WR(x, HW_IPU_CSI0_CPD_OFFSET2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI0_CPD_OFFSET2 bitfields
 */

/* --- Register HW_IPU_CSI0_CPD_OFFSET2, field CSI0_CPD_R_OFFSET (RW)
 *
 * CSI0 Red component offset The value is between -512 to 511. The value is added to the red
 * component before companding. Clipping: If the result of the red components value + the offset is
 * smaller than 0, the result is zero If the result of the red components value + the offset is
 * greater than 1023, the result is 1023 Reserved
 */

#define BP_IPU_CSI0_CPD_OFFSET2_CSI0_CPD_R_OFFSET      0
#define BM_IPU_CSI0_CPD_OFFSET2_CSI0_CPD_R_OFFSET      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI0_CPD_OFFSET2_CSI0_CPD_R_OFFSET(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI0_CPD_OFFSET2_CSI0_CPD_R_OFFSET)
#else
#define BF_IPU_CSI0_CPD_OFFSET2_CSI0_CPD_R_OFFSET(v)   (((v) << 0) & BM_IPU_CSI0_CPD_OFFSET2_CSI0_CPD_R_OFFSET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_CPD_R_OFFSET field to a new value.
#define BW_IPU_CSI0_CPD_OFFSET2_CSI0_CPD_R_OFFSET(v)   BF_CS1(IPU_CSI0_CPD_OFFSET2, CSI0_CPD_R_OFFSET, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_SENS_CONF - CSI1 Sensor Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_VSYNC_POL : 1; //!< Invert IPP_IND_SENSB_VSYNC input. This bit selects the polarity of IPP_IND_SENSB_VSYNC signal.
        unsigned CSI1_HSYNC_POL : 1; //!< Invert IPP_IND_SENSB_HSYNC input. This bit selects the polarity of IPP_IND_SENSB_HSYNC signal.
        unsigned CSI1_DATA_POL : 1; //!< Invert data input. This bit selects the polarity of data input.
        unsigned CSI1_SENS_PIX_CLK_POL : 1; //!< Invert Pixel clock input. This bit selects the polarity of pixel clock.
        unsigned CSI1_SENS_PRTCL : 3; //!< Sensor Protocol. This bit defines the Sensor timing/data mode protocol. Values:
        unsigned CSI1_PACK_TIGHT : 1; //!< CSI1 Pack Tight When the data format is YUV or RGB and the component's width is 9-16 bits, it can be sent to the memory in 2 different ways
        unsigned CSI1_SENS_DATA_FORMAT : 3; //!< Data format from the sensor. This field defines the data format for the input of the CSI sensor. Values:
        unsigned CSI1_DATA_WIDTH : 4; //!< Data width. This fields defines the number of bits per color. Values:
        unsigned CSI1_EXT_VSYNC : 1; //!< External VSYNC enable. This bits select between external and internal VSYNC.
        unsigned CSI1_DIV_RATIO : 8; //!< DIV Ratio Clock division ratio minus 1. This field defines the division ratio of HSP_CLK into SENSB_MCLK: SENSB_MCLK rate = HSP_CLK rate /(DIV_RATIO+1)
        unsigned CSI1_DATA_DEST : 3; //!< These bits enable the destination of the data coming from the CSI. CSI1_DATA_DEST[0] - destination is ISP (including statistics) Reserved CSI1_DATA_DEST[1] - destination is IC CSI1_DATA_DEST[2] - destination is IDMAC via SMFC
        unsigned CSI1_JPEG8_EN : 1; //!< JPEG8 enable bit
        unsigned CSI1_JPEG_MODE : 1; //!< JPEG Mode - this bit defines the mode of the control signals when working in JPEG mode
        unsigned CSI1_FORCE_EOF : 1; //!< Force End of frame This is a self clear bit allowing the user to force an End-of-frame event; This bit can be used in cases where the frame sent by the sensor was not completed.
        unsigned RESERVED0 : 1; //!< Reserved, should be cleared.
        unsigned CSI0_DATA_EN_POL : 1; //!< Invert IPP_IND_SENSB_DATA_EN input. This bit selects the polarity of IPP_IND_SENSB_DATA_EN signal.
    } B;
} hw_ipu_csi1_sens_conf_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_SENS_CONF register
 */
#define HW_IPU_CSI1_SENS_CONF_ADDR(x)      (REGS_IPU_BASE(x) + 0x38000)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_SENS_CONF(x)           (*(volatile hw_ipu_csi1_sens_conf_t *) HW_IPU_CSI1_SENS_CONF_ADDR(x))
#define HW_IPU_CSI1_SENS_CONF_RD(x)        (HW_IPU_CSI1_SENS_CONF(x).U)
#define HW_IPU_CSI1_SENS_CONF_WR(x, v)     (HW_IPU_CSI1_SENS_CONF(x).U = (v))
#define HW_IPU_CSI1_SENS_CONF_SET(x, v)    (HW_IPU_CSI1_SENS_CONF_WR(x, HW_IPU_CSI1_SENS_CONF_RD(x) |  (v)))
#define HW_IPU_CSI1_SENS_CONF_CLR(x, v)    (HW_IPU_CSI1_SENS_CONF_WR(x, HW_IPU_CSI1_SENS_CONF_RD(x) & ~(v)))
#define HW_IPU_CSI1_SENS_CONF_TOG(x, v)    (HW_IPU_CSI1_SENS_CONF_WR(x, HW_IPU_CSI1_SENS_CONF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_SENS_CONF bitfields
 */

/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_VSYNC_POL (RW)
 *
 * Invert IPP_IND_SENSB_VSYNC input. This bit selects the polarity of IPP_IND_SENSB_VSYNC signal.
 *
 * Values:
 * 0 - IPP_IND_SENSB_VSYNC is not inverted before applied to internal circuitry.
 * 1 - IPP_IND_SENSB_VSYNC is inverted before applied to internal circuitry.
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_VSYNC_POL      0
#define BM_IPU_CSI1_SENS_CONF_CSI1_VSYNC_POL      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_VSYNC_POL(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_SENS_CONF_CSI1_VSYNC_POL)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_VSYNC_POL(v)   (((v) << 0) & BM_IPU_CSI1_SENS_CONF_CSI1_VSYNC_POL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_VSYNC_POL field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_VSYNC_POL(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_VSYNC_POL, v)
#endif


/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_HSYNC_POL (RW)
 *
 * Invert IPP_IND_SENSB_HSYNC input. This bit selects the polarity of IPP_IND_SENSB_HSYNC signal.
 *
 * Values:
 * 0 - IPP_IND_SENSB_HSYNC is directly applied to internal circuitry.
 * 1 - IPP_IND_SENSB_HSYNC is inverted before applied to internal circuitry.
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_HSYNC_POL      1
#define BM_IPU_CSI1_SENS_CONF_CSI1_HSYNC_POL      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_HSYNC_POL(v)   ((((reg32_t) v) << 1) & BM_IPU_CSI1_SENS_CONF_CSI1_HSYNC_POL)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_HSYNC_POL(v)   (((v) << 1) & BM_IPU_CSI1_SENS_CONF_CSI1_HSYNC_POL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_HSYNC_POL field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_HSYNC_POL(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_HSYNC_POL, v)
#endif


/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_DATA_POL (RW)
 *
 * Invert data input. This bit selects the polarity of data input.
 *
 * Values:
 * 0 - data lines are directly applied to internal circuitry.
 * 1 - data lines are inverted before applied to internal circuitry.
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_DATA_POL      2
#define BM_IPU_CSI1_SENS_CONF_CSI1_DATA_POL      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_DATA_POL(v)   ((((reg32_t) v) << 2) & BM_IPU_CSI1_SENS_CONF_CSI1_DATA_POL)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_DATA_POL(v)   (((v) << 2) & BM_IPU_CSI1_SENS_CONF_CSI1_DATA_POL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_DATA_POL field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_DATA_POL(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_DATA_POL, v)
#endif


/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_SENS_PIX_CLK_POL (RW)
 *
 * Invert Pixel clock input. This bit selects the polarity of pixel clock.
 *
 * Values:
 * 0 - pixel clock is directly applied to internal circuitry.
 * 1 - pixel clock is inverted before applied to internal circuitry.
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_SENS_PIX_CLK_POL      3
#define BM_IPU_CSI1_SENS_CONF_CSI1_SENS_PIX_CLK_POL      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_SENS_PIX_CLK_POL(v)   ((((reg32_t) v) << 3) & BM_IPU_CSI1_SENS_CONF_CSI1_SENS_PIX_CLK_POL)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_SENS_PIX_CLK_POL(v)   (((v) << 3) & BM_IPU_CSI1_SENS_CONF_CSI1_SENS_PIX_CLK_POL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_SENS_PIX_CLK_POL field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_SENS_PIX_CLK_POL(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_SENS_PIX_CLK_POL, v)
#endif


/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_SENS_PRTCL (RW)
 *
 * Sensor Protocol. This bit defines the Sensor timing/data mode protocol. Values:
 *
 * Values:
 * 000 - Gated clock mode
 * 001 - Non-gated clock mode
 * 010 - CCIR progressive mode (BT.656)
 * 011 - CCIR interlaced mode (BT.656)
 * 100 - CCIR progressive (BT.1120 DDR mode: data arrives on every edge of the clock)
 * 101 - CCIR progressive (BT.1120 SDR mode: data arrives only on the positive edge of the clock)
 * 110 - CCIR interlaced mode (BT.1120 DDR mode: data arrives on every edge of the clock)
 * 111 - CCIR interlaced mode (BT.1120 SDR mode: data arrives only on the positive edge of the clock)
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_SENS_PRTCL      4
#define BM_IPU_CSI1_SENS_CONF_CSI1_SENS_PRTCL      0x00000070

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_SENS_PRTCL(v)   ((((reg32_t) v) << 4) & BM_IPU_CSI1_SENS_CONF_CSI1_SENS_PRTCL)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_SENS_PRTCL(v)   (((v) << 4) & BM_IPU_CSI1_SENS_CONF_CSI1_SENS_PRTCL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_SENS_PRTCL field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_SENS_PRTCL(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_SENS_PRTCL, v)
#endif


/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_PACK_TIGHT (RW)
 *
 * CSI1 Pack Tight When the data format is YUV or RGB and the component's width is 9-16 bits, it can
 * be sent to the memory in 2 different ways
 *
 * Values:
 * 1 - Three 10 bits components are packed into a 32 bit word. Color extension/reduction is performed
 * 0 - Each component is written as a 16 bit word where the MSB is written to bit #15, color extension is
 *     done for the remaining least significant bits.
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_PACK_TIGHT      7
#define BM_IPU_CSI1_SENS_CONF_CSI1_PACK_TIGHT      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_PACK_TIGHT(v)   ((((reg32_t) v) << 7) & BM_IPU_CSI1_SENS_CONF_CSI1_PACK_TIGHT)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_PACK_TIGHT(v)   (((v) << 7) & BM_IPU_CSI1_SENS_CONF_CSI1_PACK_TIGHT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_PACK_TIGHT field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_PACK_TIGHT(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_PACK_TIGHT, v)
#endif


/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_SENS_DATA_FORMAT (RW)
 *
 * Data format from the sensor. This field defines the data format for the input of the CSI sensor.
 * Values:
 *
 * Values:
 * 000 - full RGB or YUV444
 * 001 - YUV422 (YUYV...)
 * 010 - YUV422 (UYVY...)
 * 011 - Bayer or Generic data
 * 100 - RGB565
 * 101 - RGB555
 * 110 - RGB444
 * 111 - JPEG
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_SENS_DATA_FORMAT      8
#define BM_IPU_CSI1_SENS_CONF_CSI1_SENS_DATA_FORMAT      0x00000700

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_SENS_DATA_FORMAT(v)   ((((reg32_t) v) << 8) & BM_IPU_CSI1_SENS_CONF_CSI1_SENS_DATA_FORMAT)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_SENS_DATA_FORMAT(v)   (((v) << 8) & BM_IPU_CSI1_SENS_CONF_CSI1_SENS_DATA_FORMAT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_SENS_DATA_FORMAT field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_SENS_DATA_FORMAT(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_SENS_DATA_FORMAT, v)
#endif


/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_DATA_WIDTH (RW)
 *
 * Data width. This fields defines the number of bits per color. Values:
 *
 * Values:
 * 0000 - 4 bits per color
 * 0000 - Reserved
 * 0001 - 8 bits per color
 * 0010 - 9 bits per color
 * 0010 - Reserved
 * 0011 - 10 bits per color
 * 0100 - 11 bits per color
 * 0100 - Reserved
 * 0101 - 12 bits per color
 * 0101 - Reserved
 * 0110 - 13 bits per color
 * 0110 - Reserved
 * 0111 - 14 bits per color
 * 0111 - Reserved
 * 1000 - 15 bits per color
 * 1000 - Reserved
 * 1001 - 16 bits per color
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_DATA_WIDTH      11
#define BM_IPU_CSI1_SENS_CONF_CSI1_DATA_WIDTH      0x00007800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_DATA_WIDTH(v)   ((((reg32_t) v) << 11) & BM_IPU_CSI1_SENS_CONF_CSI1_DATA_WIDTH)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_DATA_WIDTH(v)   (((v) << 11) & BM_IPU_CSI1_SENS_CONF_CSI1_DATA_WIDTH)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_DATA_WIDTH field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_DATA_WIDTH(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_DATA_WIDTH, v)
#endif


/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_EXT_VSYNC (RW)
 *
 * External VSYNC enable. This bits select between external and internal VSYNC.
 *
 * Values:
 * 0 - Internal VSYNC mode.
 * 1 - External VSYNC mode.
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_EXT_VSYNC      15
#define BM_IPU_CSI1_SENS_CONF_CSI1_EXT_VSYNC      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_EXT_VSYNC(v)   ((((reg32_t) v) << 15) & BM_IPU_CSI1_SENS_CONF_CSI1_EXT_VSYNC)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_EXT_VSYNC(v)   (((v) << 15) & BM_IPU_CSI1_SENS_CONF_CSI1_EXT_VSYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_EXT_VSYNC field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_EXT_VSYNC(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_EXT_VSYNC, v)
#endif


/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_DIV_RATIO (RW)
 *
 * DIV Ratio Clock division ratio minus 1. This field defines the division ratio of HSP_CLK into
 * SENSB_MCLK: SENSB_MCLK rate = HSP_CLK rate /(DIV_RATIO+1)
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_DIV_RATIO      16
#define BM_IPU_CSI1_SENS_CONF_CSI1_DIV_RATIO      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_DIV_RATIO(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_SENS_CONF_CSI1_DIV_RATIO)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_DIV_RATIO(v)   (((v) << 16) & BM_IPU_CSI1_SENS_CONF_CSI1_DIV_RATIO)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_DIV_RATIO field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_DIV_RATIO(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_DIV_RATIO, v)
#endif

/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_DATA_DEST (RW)
 *
 * These bits enable the destination of the data coming from the CSI. CSI1_DATA_DEST[0] -
 * destination is ISP (including statistics) Reserved CSI1_DATA_DEST[1] - destination is IC
 * CSI1_DATA_DEST[2] - destination is IDMAC via SMFC
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_DATA_DEST      24
#define BM_IPU_CSI1_SENS_CONF_CSI1_DATA_DEST      0x07000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_DATA_DEST(v)   ((((reg32_t) v) << 24) & BM_IPU_CSI1_SENS_CONF_CSI1_DATA_DEST)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_DATA_DEST(v)   (((v) << 24) & BM_IPU_CSI1_SENS_CONF_CSI1_DATA_DEST)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_DATA_DEST field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_DATA_DEST(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_DATA_DEST, v)
#endif

/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_JPEG8_EN (RW)
 *
 * JPEG8 enable bit
 *
 * Values:
 * 1 - JPEG8 detection is enabled
 * 0 - JPEG8 is disabled
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_JPEG8_EN      27
#define BM_IPU_CSI1_SENS_CONF_CSI1_JPEG8_EN      0x08000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_JPEG8_EN(v)   ((((reg32_t) v) << 27) & BM_IPU_CSI1_SENS_CONF_CSI1_JPEG8_EN)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_JPEG8_EN(v)   (((v) << 27) & BM_IPU_CSI1_SENS_CONF_CSI1_JPEG8_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_JPEG8_EN field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_JPEG8_EN(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_JPEG8_EN, v)
#endif


/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_JPEG_MODE (RW)
 *
 * JPEG Mode - this bit defines the mode of the control signals when working in JPEG mode
 *
 * Values:
 * 1 - The data is valid as long as HSYNC and VSYNC signals are active; HSYNC is valid for single frame
 * 0 - The frame starts withe the assertion of VSYNC. The frame ends on the next VSYNC or by setting the
 *     CSI0_FORCE_EOF bit
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_JPEG_MODE      28
#define BM_IPU_CSI1_SENS_CONF_CSI1_JPEG_MODE      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_JPEG_MODE(v)   ((((reg32_t) v) << 28) & BM_IPU_CSI1_SENS_CONF_CSI1_JPEG_MODE)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_JPEG_MODE(v)   (((v) << 28) & BM_IPU_CSI1_SENS_CONF_CSI1_JPEG_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_JPEG_MODE field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_JPEG_MODE(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_JPEG_MODE, v)
#endif


/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI1_FORCE_EOF (RW)
 *
 * Force End of frame This is a self clear bit allowing the user to force an End-of-frame event;
 * This bit can be used in cases where the frame sent by the sensor was not completed.
 *
 * Values:
 * 1 - force end of frame
 * 0 - no action
 */

#define BP_IPU_CSI1_SENS_CONF_CSI1_FORCE_EOF      29
#define BM_IPU_CSI1_SENS_CONF_CSI1_FORCE_EOF      0x20000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI1_FORCE_EOF(v)   ((((reg32_t) v) << 29) & BM_IPU_CSI1_SENS_CONF_CSI1_FORCE_EOF)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI1_FORCE_EOF(v)   (((v) << 29) & BM_IPU_CSI1_SENS_CONF_CSI1_FORCE_EOF)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_FORCE_EOF field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI1_FORCE_EOF(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI1_FORCE_EOF, v)
#endif


/* --- Register HW_IPU_CSI1_SENS_CONF, field CSI0_DATA_EN_POL (RW)
 *
 * Invert IPP_IND_SENSB_DATA_EN input. This bit selects the polarity of IPP_IND_SENSB_DATA_EN
 * signal.
 *
 * Values:
 * 0 - IPP_IND_SENSB_DATA_EN is directly applied to internal circuitry.
 * 1 - IPP_IND_SENSB_DATA_EN is inverted before applied to internal circuitry.
 */

#define BP_IPU_CSI1_SENS_CONF_CSI0_DATA_EN_POL      31
#define BM_IPU_CSI1_SENS_CONF_CSI0_DATA_EN_POL      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_CONF_CSI0_DATA_EN_POL(v)   ((((reg32_t) v) << 31) & BM_IPU_CSI1_SENS_CONF_CSI0_DATA_EN_POL)
#else
#define BF_IPU_CSI1_SENS_CONF_CSI0_DATA_EN_POL(v)   (((v) << 31) & BM_IPU_CSI1_SENS_CONF_CSI0_DATA_EN_POL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_DATA_EN_POL field to a new value.
#define BW_IPU_CSI1_SENS_CONF_CSI0_DATA_EN_POL(v)   BF_CS1(IPU_CSI1_SENS_CONF, CSI0_DATA_EN_POL, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_SENS_FRM_SIZE - CSI1 Sense Frame Size Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_SENS_FRM_WIDTH : 13; //!< Sensor frame width minus 1. This field defines the sensor frame column number minus 1.
        unsigned RESERVED0 : 3; //!< Reserved, should be cleared.
        unsigned CSI1_SENS_FRM_HEIGHT : 12; //!< Sensor frame height minus 1. This field defines the sensor frame rows number minus 1.
        unsigned RESERVED1 : 4; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi1_sens_frm_size_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_SENS_FRM_SIZE register
 */
#define HW_IPU_CSI1_SENS_FRM_SIZE_ADDR(x)      (REGS_IPU_BASE(x) + 0x38004)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_SENS_FRM_SIZE(x)           (*(volatile hw_ipu_csi1_sens_frm_size_t *) HW_IPU_CSI1_SENS_FRM_SIZE_ADDR(x))
#define HW_IPU_CSI1_SENS_FRM_SIZE_RD(x)        (HW_IPU_CSI1_SENS_FRM_SIZE(x).U)
#define HW_IPU_CSI1_SENS_FRM_SIZE_WR(x, v)     (HW_IPU_CSI1_SENS_FRM_SIZE(x).U = (v))
#define HW_IPU_CSI1_SENS_FRM_SIZE_SET(x, v)    (HW_IPU_CSI1_SENS_FRM_SIZE_WR(x, HW_IPU_CSI1_SENS_FRM_SIZE_RD(x) |  (v)))
#define HW_IPU_CSI1_SENS_FRM_SIZE_CLR(x, v)    (HW_IPU_CSI1_SENS_FRM_SIZE_WR(x, HW_IPU_CSI1_SENS_FRM_SIZE_RD(x) & ~(v)))
#define HW_IPU_CSI1_SENS_FRM_SIZE_TOG(x, v)    (HW_IPU_CSI1_SENS_FRM_SIZE_WR(x, HW_IPU_CSI1_SENS_FRM_SIZE_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_SENS_FRM_SIZE bitfields
 */

/* --- Register HW_IPU_CSI1_SENS_FRM_SIZE, field CSI1_SENS_FRM_WIDTH (RW)
 *
 * Sensor frame width minus 1. This field defines the sensor frame column number minus 1.
 */

#define BP_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_WIDTH      0
#define BM_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_WIDTH      0x00001fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_WIDTH(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_WIDTH)
#else
#define BF_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_WIDTH(v)   (((v) << 0) & BM_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_WIDTH)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_SENS_FRM_WIDTH field to a new value.
#define BW_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_WIDTH(v)   BF_CS1(IPU_CSI1_SENS_FRM_SIZE, CSI1_SENS_FRM_WIDTH, v)
#endif

/* --- Register HW_IPU_CSI1_SENS_FRM_SIZE, field CSI1_SENS_FRM_HEIGHT (RW)
 *
 * Sensor frame height minus 1. This field defines the sensor frame rows number minus 1.
 */

#define BP_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_HEIGHT      16
#define BM_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_HEIGHT      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_HEIGHT(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_HEIGHT)
#else
#define BF_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_HEIGHT(v)   (((v) << 16) & BM_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_HEIGHT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_SENS_FRM_HEIGHT field to a new value.
#define BW_IPU_CSI1_SENS_FRM_SIZE_CSI1_SENS_FRM_HEIGHT(v)   BF_CS1(IPU_CSI1_SENS_FRM_SIZE, CSI1_SENS_FRM_HEIGHT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_ACT_FRM_SIZE - CSI1 Actual Frame Size Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_ACT_FRM_WIDTH : 13; //!< Actual frame width minus 1. This field defines the CSI output frame columns number minus 1.
        unsigned RESERVED0 : 3; //!< Reserved, should be cleared.
        unsigned CSI1_ACT_FRM_HEIGHT : 12; //!< Actual frame height minus 1. This field defines the CSI output frame rows number minus 1.
        unsigned RESERVED1 : 4; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi1_act_frm_size_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_ACT_FRM_SIZE register
 */
#define HW_IPU_CSI1_ACT_FRM_SIZE_ADDR(x)      (REGS_IPU_BASE(x) + 0x38008)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_ACT_FRM_SIZE(x)           (*(volatile hw_ipu_csi1_act_frm_size_t *) HW_IPU_CSI1_ACT_FRM_SIZE_ADDR(x))
#define HW_IPU_CSI1_ACT_FRM_SIZE_RD(x)        (HW_IPU_CSI1_ACT_FRM_SIZE(x).U)
#define HW_IPU_CSI1_ACT_FRM_SIZE_WR(x, v)     (HW_IPU_CSI1_ACT_FRM_SIZE(x).U = (v))
#define HW_IPU_CSI1_ACT_FRM_SIZE_SET(x, v)    (HW_IPU_CSI1_ACT_FRM_SIZE_WR(x, HW_IPU_CSI1_ACT_FRM_SIZE_RD(x) |  (v)))
#define HW_IPU_CSI1_ACT_FRM_SIZE_CLR(x, v)    (HW_IPU_CSI1_ACT_FRM_SIZE_WR(x, HW_IPU_CSI1_ACT_FRM_SIZE_RD(x) & ~(v)))
#define HW_IPU_CSI1_ACT_FRM_SIZE_TOG(x, v)    (HW_IPU_CSI1_ACT_FRM_SIZE_WR(x, HW_IPU_CSI1_ACT_FRM_SIZE_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_ACT_FRM_SIZE bitfields
 */

/* --- Register HW_IPU_CSI1_ACT_FRM_SIZE, field CSI1_ACT_FRM_WIDTH (RW)
 *
 * Actual frame width minus 1. This field defines the CSI output frame columns number minus 1.
 */

#define BP_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_WIDTH      0
#define BM_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_WIDTH      0x00001fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_WIDTH(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_WIDTH)
#else
#define BF_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_WIDTH(v)   (((v) << 0) & BM_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_WIDTH)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_ACT_FRM_WIDTH field to a new value.
#define BW_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_WIDTH(v)   BF_CS1(IPU_CSI1_ACT_FRM_SIZE, CSI1_ACT_FRM_WIDTH, v)
#endif

/* --- Register HW_IPU_CSI1_ACT_FRM_SIZE, field CSI1_ACT_FRM_HEIGHT (RW)
 *
 * Actual frame height minus 1. This field defines the CSI output frame rows number minus 1.
 */

#define BP_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_HEIGHT      16
#define BM_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_HEIGHT      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_HEIGHT(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_HEIGHT)
#else
#define BF_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_HEIGHT(v)   (((v) << 16) & BM_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_HEIGHT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_ACT_FRM_HEIGHT field to a new value.
#define BW_IPU_CSI1_ACT_FRM_SIZE_CSI1_ACT_FRM_HEIGHT(v)   BF_CS1(IPU_CSI1_ACT_FRM_SIZE, CSI1_ACT_FRM_HEIGHT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_OUT_FRM_CTRL - CSI1 Output Control Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_VSC : 12; //!< Vertical skip. This field defines the number of rows to skip.
        unsigned RESERVED0 : 4; //!< Reserved, should be cleared.
        unsigned CSI1_HSC : 13; //!< Horizontal skip. This field defines the number of columns to skip. In Interlaced mode this number refers to the number of lines per field
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned CSI1_VERT_DWNS : 1; //!< Enable vertical downsizing (decimation) by 2.
        unsigned CSI1_HORZ_DWNS : 1; //!< Enable horizontal downsizing (decimation) by 2.
    } B;
} hw_ipu_csi1_out_frm_ctrl_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_OUT_FRM_CTRL register
 */
#define HW_IPU_CSI1_OUT_FRM_CTRL_ADDR(x)      (REGS_IPU_BASE(x) + 0x3800c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_OUT_FRM_CTRL(x)           (*(volatile hw_ipu_csi1_out_frm_ctrl_t *) HW_IPU_CSI1_OUT_FRM_CTRL_ADDR(x))
#define HW_IPU_CSI1_OUT_FRM_CTRL_RD(x)        (HW_IPU_CSI1_OUT_FRM_CTRL(x).U)
#define HW_IPU_CSI1_OUT_FRM_CTRL_WR(x, v)     (HW_IPU_CSI1_OUT_FRM_CTRL(x).U = (v))
#define HW_IPU_CSI1_OUT_FRM_CTRL_SET(x, v)    (HW_IPU_CSI1_OUT_FRM_CTRL_WR(x, HW_IPU_CSI1_OUT_FRM_CTRL_RD(x) |  (v)))
#define HW_IPU_CSI1_OUT_FRM_CTRL_CLR(x, v)    (HW_IPU_CSI1_OUT_FRM_CTRL_WR(x, HW_IPU_CSI1_OUT_FRM_CTRL_RD(x) & ~(v)))
#define HW_IPU_CSI1_OUT_FRM_CTRL_TOG(x, v)    (HW_IPU_CSI1_OUT_FRM_CTRL_WR(x, HW_IPU_CSI1_OUT_FRM_CTRL_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_OUT_FRM_CTRL bitfields
 */

/* --- Register HW_IPU_CSI1_OUT_FRM_CTRL, field CSI1_VSC (RW)
 *
 * Vertical skip. This field defines the number of rows to skip.
 */

#define BP_IPU_CSI1_OUT_FRM_CTRL_CSI1_VSC      0
#define BM_IPU_CSI1_OUT_FRM_CTRL_CSI1_VSC      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_OUT_FRM_CTRL_CSI1_VSC(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_OUT_FRM_CTRL_CSI1_VSC)
#else
#define BF_IPU_CSI1_OUT_FRM_CTRL_CSI1_VSC(v)   (((v) << 0) & BM_IPU_CSI1_OUT_FRM_CTRL_CSI1_VSC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_VSC field to a new value.
#define BW_IPU_CSI1_OUT_FRM_CTRL_CSI1_VSC(v)   BF_CS1(IPU_CSI1_OUT_FRM_CTRL, CSI1_VSC, v)
#endif

/* --- Register HW_IPU_CSI1_OUT_FRM_CTRL, field CSI1_HSC (RW)
 *
 * Horizontal skip. This field defines the number of columns to skip. In Interlaced mode this number
 * refers to the number of lines per field
 */

#define BP_IPU_CSI1_OUT_FRM_CTRL_CSI1_HSC      16
#define BM_IPU_CSI1_OUT_FRM_CTRL_CSI1_HSC      0x1fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_OUT_FRM_CTRL_CSI1_HSC(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_OUT_FRM_CTRL_CSI1_HSC)
#else
#define BF_IPU_CSI1_OUT_FRM_CTRL_CSI1_HSC(v)   (((v) << 16) & BM_IPU_CSI1_OUT_FRM_CTRL_CSI1_HSC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_HSC field to a new value.
#define BW_IPU_CSI1_OUT_FRM_CTRL_CSI1_HSC(v)   BF_CS1(IPU_CSI1_OUT_FRM_CTRL, CSI1_HSC, v)
#endif

/* --- Register HW_IPU_CSI1_OUT_FRM_CTRL, field CSI1_VERT_DWNS (RW)
 *
 * Enable vertical downsizing (decimation) by 2.
 *
 * Values:
 * 0 - Downsizing disabled
 * 1 - Downsizing enabled
 */

#define BP_IPU_CSI1_OUT_FRM_CTRL_CSI1_VERT_DWNS      30
#define BM_IPU_CSI1_OUT_FRM_CTRL_CSI1_VERT_DWNS      0x40000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_OUT_FRM_CTRL_CSI1_VERT_DWNS(v)   ((((reg32_t) v) << 30) & BM_IPU_CSI1_OUT_FRM_CTRL_CSI1_VERT_DWNS)
#else
#define BF_IPU_CSI1_OUT_FRM_CTRL_CSI1_VERT_DWNS(v)   (((v) << 30) & BM_IPU_CSI1_OUT_FRM_CTRL_CSI1_VERT_DWNS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_VERT_DWNS field to a new value.
#define BW_IPU_CSI1_OUT_FRM_CTRL_CSI1_VERT_DWNS(v)   BF_CS1(IPU_CSI1_OUT_FRM_CTRL, CSI1_VERT_DWNS, v)
#endif


/* --- Register HW_IPU_CSI1_OUT_FRM_CTRL, field CSI1_HORZ_DWNS (RW)
 *
 * Enable horizontal downsizing (decimation) by 2.
 *
 * Values:
 * 0 - Downsizing disabled 1 Downsizing enabled
 */

#define BP_IPU_CSI1_OUT_FRM_CTRL_CSI1_HORZ_DWNS      31
#define BM_IPU_CSI1_OUT_FRM_CTRL_CSI1_HORZ_DWNS      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_OUT_FRM_CTRL_CSI1_HORZ_DWNS(v)   ((((reg32_t) v) << 31) & BM_IPU_CSI1_OUT_FRM_CTRL_CSI1_HORZ_DWNS)
#else
#define BF_IPU_CSI1_OUT_FRM_CTRL_CSI1_HORZ_DWNS(v)   (((v) << 31) & BM_IPU_CSI1_OUT_FRM_CTRL_CSI1_HORZ_DWNS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_HORZ_DWNS field to a new value.
#define BW_IPU_CSI1_OUT_FRM_CTRL_CSI1_HORZ_DWNS(v)   BF_CS1(IPU_CSI1_OUT_FRM_CTRL, CSI1_HORZ_DWNS, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_TST_CTRL - CSI1 Test Control Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned PG_R_VALUE : 8; //!< Pattern generator R value. This field selects the R value for the generated pattern of even pixel.
        unsigned PG_G_VALUE : 8; //!< Pattern generator G value. This field selects the G value for the generated pattern of even pixel.
        unsigned PG_B_VALUE : 8; //!< Pattern generator B value. This field selects the B value for the generated pattern of even pixel.
        unsigned TEST_GEN_MODE : 1; //!< Test generator mode. This bit activates the signal generation.
        unsigned RESERVED0 : 7; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi1_tst_ctrl_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_TST_CTRL register
 */
#define HW_IPU_CSI1_TST_CTRL_ADDR(x)      (REGS_IPU_BASE(x) + 0x38010)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_TST_CTRL(x)           (*(volatile hw_ipu_csi1_tst_ctrl_t *) HW_IPU_CSI1_TST_CTRL_ADDR(x))
#define HW_IPU_CSI1_TST_CTRL_RD(x)        (HW_IPU_CSI1_TST_CTRL(x).U)
#define HW_IPU_CSI1_TST_CTRL_WR(x, v)     (HW_IPU_CSI1_TST_CTRL(x).U = (v))
#define HW_IPU_CSI1_TST_CTRL_SET(x, v)    (HW_IPU_CSI1_TST_CTRL_WR(x, HW_IPU_CSI1_TST_CTRL_RD(x) |  (v)))
#define HW_IPU_CSI1_TST_CTRL_CLR(x, v)    (HW_IPU_CSI1_TST_CTRL_WR(x, HW_IPU_CSI1_TST_CTRL_RD(x) & ~(v)))
#define HW_IPU_CSI1_TST_CTRL_TOG(x, v)    (HW_IPU_CSI1_TST_CTRL_WR(x, HW_IPU_CSI1_TST_CTRL_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_TST_CTRL bitfields
 */

/* --- Register HW_IPU_CSI1_TST_CTRL, field PG_R_VALUE (RW)
 *
 * Pattern generator R value. This field selects the R value for the generated pattern of even
 * pixel.
 */

#define BP_IPU_CSI1_TST_CTRL_PG_R_VALUE      0
#define BM_IPU_CSI1_TST_CTRL_PG_R_VALUE      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_TST_CTRL_PG_R_VALUE(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_TST_CTRL_PG_R_VALUE)
#else
#define BF_IPU_CSI1_TST_CTRL_PG_R_VALUE(v)   (((v) << 0) & BM_IPU_CSI1_TST_CTRL_PG_R_VALUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PG_R_VALUE field to a new value.
#define BW_IPU_CSI1_TST_CTRL_PG_R_VALUE(v)   BF_CS1(IPU_CSI1_TST_CTRL, PG_R_VALUE, v)
#endif

/* --- Register HW_IPU_CSI1_TST_CTRL, field PG_G_VALUE (RW)
 *
 * Pattern generator G value. This field selects the G value for the generated pattern of even
 * pixel.
 */

#define BP_IPU_CSI1_TST_CTRL_PG_G_VALUE      8
#define BM_IPU_CSI1_TST_CTRL_PG_G_VALUE      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_TST_CTRL_PG_G_VALUE(v)   ((((reg32_t) v) << 8) & BM_IPU_CSI1_TST_CTRL_PG_G_VALUE)
#else
#define BF_IPU_CSI1_TST_CTRL_PG_G_VALUE(v)   (((v) << 8) & BM_IPU_CSI1_TST_CTRL_PG_G_VALUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PG_G_VALUE field to a new value.
#define BW_IPU_CSI1_TST_CTRL_PG_G_VALUE(v)   BF_CS1(IPU_CSI1_TST_CTRL, PG_G_VALUE, v)
#endif

/* --- Register HW_IPU_CSI1_TST_CTRL, field PG_B_VALUE (RW)
 *
 * Pattern generator B value. This field selects the B value for the generated pattern of even
 * pixel.
 */

#define BP_IPU_CSI1_TST_CTRL_PG_B_VALUE      16
#define BM_IPU_CSI1_TST_CTRL_PG_B_VALUE      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_TST_CTRL_PG_B_VALUE(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_TST_CTRL_PG_B_VALUE)
#else
#define BF_IPU_CSI1_TST_CTRL_PG_B_VALUE(v)   (((v) << 16) & BM_IPU_CSI1_TST_CTRL_PG_B_VALUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PG_B_VALUE field to a new value.
#define BW_IPU_CSI1_TST_CTRL_PG_B_VALUE(v)   BF_CS1(IPU_CSI1_TST_CTRL, PG_B_VALUE, v)
#endif

/* --- Register HW_IPU_CSI1_TST_CTRL, field TEST_GEN_MODE (RW)
 *
 * Test generator mode. This bit activates the signal generation.
 *
 * Values:
 * 0 - Test signal generator is inactive.
 * 1 - Test signal generator is active.
 */

#define BP_IPU_CSI1_TST_CTRL_TEST_GEN_MODE      24
#define BM_IPU_CSI1_TST_CTRL_TEST_GEN_MODE      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_TST_CTRL_TEST_GEN_MODE(v)   ((((reg32_t) v) << 24) & BM_IPU_CSI1_TST_CTRL_TEST_GEN_MODE)
#else
#define BF_IPU_CSI1_TST_CTRL_TEST_GEN_MODE(v)   (((v) << 24) & BM_IPU_CSI1_TST_CTRL_TEST_GEN_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the TEST_GEN_MODE field to a new value.
#define BW_IPU_CSI1_TST_CTRL_TEST_GEN_MODE(v)   BF_CS1(IPU_CSI1_TST_CTRL, TEST_GEN_MODE, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CCIR_CODE_1 - CSI1 CCIR Code Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_END_FLD0_BLNK_1ST : 3; //!< End of field 0 first blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned CSI1_STRT_FLD0_BLNK_1ST : 3; //!< Start of field 0 first blanking line command (interlaces mode). (In progressive mode this field indicates start of blanking line command).
        unsigned CSI1_END_FLD0_BLNK_2ND : 3; //!< End of field 0 second blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned CSI1_STRT_FLD0_BLNK_2ND : 3; //!< Start of field 0 second blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned RESERVED0 : 4; //!< Reserved, should be cleared.
        unsigned CSI1_END_FLD0_ACTV : 3; //!< End of field 0 active line command (interlaces mode). (In progressive mode, end of active line command mode).
        unsigned CSI1_STRT_FLD0_ACTV : 3; //!< Start of field 0 active line command (interlaces mode). (In progressive mode, start of active line command mode).
        unsigned RESERVED1 : 2; //!< Reserved, should be cleared.
        unsigned CSI1_CCIR_ERR_DET_EN : 1; //!< Enable error detection and correction for CCIR interlaced mode with protection bit.
        unsigned RESERVED2 : 7; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi1_ccir_code_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CCIR_CODE_1 register
 */
#define HW_IPU_CSI1_CCIR_CODE_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x38014)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CCIR_CODE_1(x)           (*(volatile hw_ipu_csi1_ccir_code_1_t *) HW_IPU_CSI1_CCIR_CODE_1_ADDR(x))
#define HW_IPU_CSI1_CCIR_CODE_1_RD(x)        (HW_IPU_CSI1_CCIR_CODE_1(x).U)
#define HW_IPU_CSI1_CCIR_CODE_1_WR(x, v)     (HW_IPU_CSI1_CCIR_CODE_1(x).U = (v))
#define HW_IPU_CSI1_CCIR_CODE_1_SET(x, v)    (HW_IPU_CSI1_CCIR_CODE_1_WR(x, HW_IPU_CSI1_CCIR_CODE_1_RD(x) |  (v)))
#define HW_IPU_CSI1_CCIR_CODE_1_CLR(x, v)    (HW_IPU_CSI1_CCIR_CODE_1_WR(x, HW_IPU_CSI1_CCIR_CODE_1_RD(x) & ~(v)))
#define HW_IPU_CSI1_CCIR_CODE_1_TOG(x, v)    (HW_IPU_CSI1_CCIR_CODE_1_WR(x, HW_IPU_CSI1_CCIR_CODE_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CCIR_CODE_1 bitfields
 */

/* --- Register HW_IPU_CSI1_CCIR_CODE_1, field CSI1_END_FLD0_BLNK_1ST (RW)
 *
 * End of field 0 first blanking line command (interlaces mode). (In progressive mode this field is
 * ignored).
 */

#define BP_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_1ST      0
#define BM_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_1ST      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_1ST(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_1ST)
#else
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_1ST(v)   (((v) << 0) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_1ST)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_END_FLD0_BLNK_1ST field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_1ST(v)   BF_CS1(IPU_CSI1_CCIR_CODE_1, CSI1_END_FLD0_BLNK_1ST, v)
#endif

/* --- Register HW_IPU_CSI1_CCIR_CODE_1, field CSI1_STRT_FLD0_BLNK_1ST (RW)
 *
 * Start of field 0 first blanking line command (interlaces mode). (In progressive mode this field
 * indicates start of blanking line command).
 */

#define BP_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_1ST      3
#define BM_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_1ST      0x00000038

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_1ST(v)   ((((reg32_t) v) << 3) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_1ST)
#else
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_1ST(v)   (((v) << 3) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_1ST)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_STRT_FLD0_BLNK_1ST field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_1ST(v)   BF_CS1(IPU_CSI1_CCIR_CODE_1, CSI1_STRT_FLD0_BLNK_1ST, v)
#endif

/* --- Register HW_IPU_CSI1_CCIR_CODE_1, field CSI1_END_FLD0_BLNK_2ND (RW)
 *
 * End of field 0 second blanking line command (interlaces mode). (In progressive mode this field is
 * ignored).
 */

#define BP_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_2ND      6
#define BM_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_2ND      0x000001c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_2ND(v)   ((((reg32_t) v) << 6) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_2ND)
#else
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_2ND(v)   (((v) << 6) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_2ND)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_END_FLD0_BLNK_2ND field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_BLNK_2ND(v)   BF_CS1(IPU_CSI1_CCIR_CODE_1, CSI1_END_FLD0_BLNK_2ND, v)
#endif

/* --- Register HW_IPU_CSI1_CCIR_CODE_1, field CSI1_STRT_FLD0_BLNK_2ND (RW)
 *
 * Start of field 0 second blanking line command (interlaces mode). (In progressive mode this field
 * is ignored).
 */

#define BP_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_2ND      9
#define BM_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_2ND      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_2ND(v)   ((((reg32_t) v) << 9) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_2ND)
#else
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_2ND(v)   (((v) << 9) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_2ND)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_STRT_FLD0_BLNK_2ND field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_BLNK_2ND(v)   BF_CS1(IPU_CSI1_CCIR_CODE_1, CSI1_STRT_FLD0_BLNK_2ND, v)
#endif

/* --- Register HW_IPU_CSI1_CCIR_CODE_1, field CSI1_END_FLD0_ACTV (RW)
 *
 * End of field 0 active line command (interlaces mode). (In progressive mode, end of active line
 * command mode).
 */

#define BP_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_ACTV      16
#define BM_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_ACTV      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_ACTV(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_ACTV)
#else
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_ACTV(v)   (((v) << 16) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_ACTV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_END_FLD0_ACTV field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_1_CSI1_END_FLD0_ACTV(v)   BF_CS1(IPU_CSI1_CCIR_CODE_1, CSI1_END_FLD0_ACTV, v)
#endif

/* --- Register HW_IPU_CSI1_CCIR_CODE_1, field CSI1_STRT_FLD0_ACTV (RW)
 *
 * Start of field 0 active line command (interlaces mode). (In progressive mode, start of active
 * line command mode).
 */

#define BP_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_ACTV      19
#define BM_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_ACTV      0x00380000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_ACTV(v)   ((((reg32_t) v) << 19) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_ACTV)
#else
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_ACTV(v)   (((v) << 19) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_ACTV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_STRT_FLD0_ACTV field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_1_CSI1_STRT_FLD0_ACTV(v)   BF_CS1(IPU_CSI1_CCIR_CODE_1, CSI1_STRT_FLD0_ACTV, v)
#endif

/* --- Register HW_IPU_CSI1_CCIR_CODE_1, field CSI1_CCIR_ERR_DET_EN (RW)
 *
 * Enable error detection and correction for CCIR interlaced mode with protection bit.
 *
 * Values:
 * 0 - Error detection and correction is disabled.
 * 1 - Error detection and correction is enabled.
 */

#define BP_IPU_CSI1_CCIR_CODE_1_CSI1_CCIR_ERR_DET_EN      24
#define BM_IPU_CSI1_CCIR_CODE_1_CSI1_CCIR_ERR_DET_EN      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_CCIR_ERR_DET_EN(v)   ((((reg32_t) v) << 24) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_CCIR_ERR_DET_EN)
#else
#define BF_IPU_CSI1_CCIR_CODE_1_CSI1_CCIR_ERR_DET_EN(v)   (((v) << 24) & BM_IPU_CSI1_CCIR_CODE_1_CSI1_CCIR_ERR_DET_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CCIR_ERR_DET_EN field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_1_CSI1_CCIR_ERR_DET_EN(v)   BF_CS1(IPU_CSI1_CCIR_CODE_1, CSI1_CCIR_ERR_DET_EN, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CCIR_CODE_2 - CSI1 CCIR Code Register 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_END_FLD1_BLNK_1ST : 3; //!< End of field 1 first blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned CSI1_STRT_FLD1_BLNK_1ST : 3; //!< Start of field 1 first blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned CSI1_END_FLD1_BLNK_2ND : 3; //!< End of field 1 second blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned CSI1_STRT_FLD1_BLNK_2ND : 3; //!< Start of field 1 second blanking line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned RESERVED0 : 4; //!< Reserved, should be cleared.
        unsigned CSI1_END_FLD1_ACTV : 3; //!< End of field 1 active line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned CSI1_STRT_FLD1_ACTV : 3; //!< Start of field 1 active line command (interlaces mode). (In progressive mode this field is ignored).
        unsigned RESERVED1 : 10; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi1_ccir_code_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CCIR_CODE_2 register
 */
#define HW_IPU_CSI1_CCIR_CODE_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x38018)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CCIR_CODE_2(x)           (*(volatile hw_ipu_csi1_ccir_code_2_t *) HW_IPU_CSI1_CCIR_CODE_2_ADDR(x))
#define HW_IPU_CSI1_CCIR_CODE_2_RD(x)        (HW_IPU_CSI1_CCIR_CODE_2(x).U)
#define HW_IPU_CSI1_CCIR_CODE_2_WR(x, v)     (HW_IPU_CSI1_CCIR_CODE_2(x).U = (v))
#define HW_IPU_CSI1_CCIR_CODE_2_SET(x, v)    (HW_IPU_CSI1_CCIR_CODE_2_WR(x, HW_IPU_CSI1_CCIR_CODE_2_RD(x) |  (v)))
#define HW_IPU_CSI1_CCIR_CODE_2_CLR(x, v)    (HW_IPU_CSI1_CCIR_CODE_2_WR(x, HW_IPU_CSI1_CCIR_CODE_2_RD(x) & ~(v)))
#define HW_IPU_CSI1_CCIR_CODE_2_TOG(x, v)    (HW_IPU_CSI1_CCIR_CODE_2_WR(x, HW_IPU_CSI1_CCIR_CODE_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CCIR_CODE_2 bitfields
 */

/* --- Register HW_IPU_CSI1_CCIR_CODE_2, field CSI1_END_FLD1_BLNK_1ST (RW)
 *
 * End of field 1 first blanking line command (interlaces mode). (In progressive mode this field is
 * ignored).
 */

#define BP_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_1ST      0
#define BM_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_1ST      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_1ST(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_1ST)
#else
#define BF_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_1ST(v)   (((v) << 0) & BM_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_1ST)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_END_FLD1_BLNK_1ST field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_1ST(v)   BF_CS1(IPU_CSI1_CCIR_CODE_2, CSI1_END_FLD1_BLNK_1ST, v)
#endif

/* --- Register HW_IPU_CSI1_CCIR_CODE_2, field CSI1_STRT_FLD1_BLNK_1ST (RW)
 *
 * Start of field 1 first blanking line command (interlaces mode). (In progressive mode this field
 * is ignored).
 */

#define BP_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_1ST      3
#define BM_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_1ST      0x00000038

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_1ST(v)   ((((reg32_t) v) << 3) & BM_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_1ST)
#else
#define BF_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_1ST(v)   (((v) << 3) & BM_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_1ST)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_STRT_FLD1_BLNK_1ST field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_1ST(v)   BF_CS1(IPU_CSI1_CCIR_CODE_2, CSI1_STRT_FLD1_BLNK_1ST, v)
#endif

/* --- Register HW_IPU_CSI1_CCIR_CODE_2, field CSI1_END_FLD1_BLNK_2ND (RW)
 *
 * End of field 1 second blanking line command (interlaces mode). (In progressive mode this field is
 * ignored).
 */

#define BP_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_2ND      6
#define BM_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_2ND      0x000001c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_2ND(v)   ((((reg32_t) v) << 6) & BM_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_2ND)
#else
#define BF_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_2ND(v)   (((v) << 6) & BM_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_2ND)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_END_FLD1_BLNK_2ND field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_BLNK_2ND(v)   BF_CS1(IPU_CSI1_CCIR_CODE_2, CSI1_END_FLD1_BLNK_2ND, v)
#endif

/* --- Register HW_IPU_CSI1_CCIR_CODE_2, field CSI1_STRT_FLD1_BLNK_2ND (RW)
 *
 * Start of field 1 second blanking line command (interlaces mode). (In progressive mode this field
 * is ignored).
 */

#define BP_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_2ND      9
#define BM_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_2ND      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_2ND(v)   ((((reg32_t) v) << 9) & BM_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_2ND)
#else
#define BF_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_2ND(v)   (((v) << 9) & BM_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_2ND)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_STRT_FLD1_BLNK_2ND field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_BLNK_2ND(v)   BF_CS1(IPU_CSI1_CCIR_CODE_2, CSI1_STRT_FLD1_BLNK_2ND, v)
#endif

/* --- Register HW_IPU_CSI1_CCIR_CODE_2, field CSI1_END_FLD1_ACTV (RW)
 *
 * End of field 1 active line command (interlaces mode). (In progressive mode this field is
 * ignored).
 */

#define BP_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_ACTV      16
#define BM_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_ACTV      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_ACTV(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_ACTV)
#else
#define BF_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_ACTV(v)   (((v) << 16) & BM_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_ACTV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_END_FLD1_ACTV field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_2_CSI1_END_FLD1_ACTV(v)   BF_CS1(IPU_CSI1_CCIR_CODE_2, CSI1_END_FLD1_ACTV, v)
#endif

/* --- Register HW_IPU_CSI1_CCIR_CODE_2, field CSI1_STRT_FLD1_ACTV (RW)
 *
 * Start of field 1 active line command (interlaces mode). (In progressive mode this field is
 * ignored).
 */

#define BP_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_ACTV      19
#define BM_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_ACTV      0x00380000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_ACTV(v)   ((((reg32_t) v) << 19) & BM_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_ACTV)
#else
#define BF_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_ACTV(v)   (((v) << 19) & BM_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_ACTV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_STRT_FLD1_ACTV field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_2_CSI1_STRT_FLD1_ACTV(v)   BF_CS1(IPU_CSI1_CCIR_CODE_2, CSI1_STRT_FLD1_ACTV, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CCIR_CODE_3 - CSI1 CCIR Code Register 3 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_CCIR_PRECOM : 30; //!< CCIR pre command. This field defines the sequence which comes before the CCIR command. For BT.656 the code should be written to bits [23:0] while bits [29:24] are ignored (3X8bit) For BT.1120 the code should be written to bits [29:0] (3X10bit)
        unsigned RESERVED0 : 2; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi1_ccir_code_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CCIR_CODE_3 register
 */
#define HW_IPU_CSI1_CCIR_CODE_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x3801c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CCIR_CODE_3(x)           (*(volatile hw_ipu_csi1_ccir_code_3_t *) HW_IPU_CSI1_CCIR_CODE_3_ADDR(x))
#define HW_IPU_CSI1_CCIR_CODE_3_RD(x)        (HW_IPU_CSI1_CCIR_CODE_3(x).U)
#define HW_IPU_CSI1_CCIR_CODE_3_WR(x, v)     (HW_IPU_CSI1_CCIR_CODE_3(x).U = (v))
#define HW_IPU_CSI1_CCIR_CODE_3_SET(x, v)    (HW_IPU_CSI1_CCIR_CODE_3_WR(x, HW_IPU_CSI1_CCIR_CODE_3_RD(x) |  (v)))
#define HW_IPU_CSI1_CCIR_CODE_3_CLR(x, v)    (HW_IPU_CSI1_CCIR_CODE_3_WR(x, HW_IPU_CSI1_CCIR_CODE_3_RD(x) & ~(v)))
#define HW_IPU_CSI1_CCIR_CODE_3_TOG(x, v)    (HW_IPU_CSI1_CCIR_CODE_3_WR(x, HW_IPU_CSI1_CCIR_CODE_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CCIR_CODE_3 bitfields
 */

/* --- Register HW_IPU_CSI1_CCIR_CODE_3, field CSI1_CCIR_PRECOM (RW)
 *
 * CCIR pre command. This field defines the sequence which comes before the CCIR command. For BT.656
 * the code should be written to bits [23:0] while bits [29:24] are ignored (3X8bit) For BT.1120 the
 * code should be written to bits [29:0] (3X10bit)
 */

#define BP_IPU_CSI1_CCIR_CODE_3_CSI1_CCIR_PRECOM      0
#define BM_IPU_CSI1_CCIR_CODE_3_CSI1_CCIR_PRECOM      0x3fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CCIR_CODE_3_CSI1_CCIR_PRECOM(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CCIR_CODE_3_CSI1_CCIR_PRECOM)
#else
#define BF_IPU_CSI1_CCIR_CODE_3_CSI1_CCIR_PRECOM(v)   (((v) << 0) & BM_IPU_CSI1_CCIR_CODE_3_CSI1_CCIR_PRECOM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CCIR_PRECOM field to a new value.
#define BW_IPU_CSI1_CCIR_CODE_3_CSI1_CCIR_PRECOM(v)   BF_CS1(IPU_CSI1_CCIR_CODE_3, CSI1_CCIR_PRECOM, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_DI - CSI1 Data Identifier Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_MIPI_DI0 : 8; //!< Reserved CSI1_MIPI_DI0 This field holds the Data Identifier #0 handled by the CSI; This is the main stream.
        unsigned CSI0_MIPI_DI1 : 8; //!< Reserved CSI1_MIPI_DI1 This field holds the Data Identifier #1 handled by the CSI
        unsigned CSI1_MIPI_DI2 : 8; //!< Reserved CSI1_MIPI_DI2 This field holds the Data Identifier #2 handled by the CSI.
        unsigned CSI1_MIPI_DI3 : 8; //!< Reserved CSI1_MIPI_DI3 This field holds the Data Identifier #3 handled by the CSI.
    } B;
} hw_ipu_csi1_di_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_DI register
 */
#define HW_IPU_CSI1_DI_ADDR(x)      (REGS_IPU_BASE(x) + 0x38020)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_DI(x)           (*(volatile hw_ipu_csi1_di_t *) HW_IPU_CSI1_DI_ADDR(x))
#define HW_IPU_CSI1_DI_RD(x)        (HW_IPU_CSI1_DI(x).U)
#define HW_IPU_CSI1_DI_WR(x, v)     (HW_IPU_CSI1_DI(x).U = (v))
#define HW_IPU_CSI1_DI_SET(x, v)    (HW_IPU_CSI1_DI_WR(x, HW_IPU_CSI1_DI_RD(x) |  (v)))
#define HW_IPU_CSI1_DI_CLR(x, v)    (HW_IPU_CSI1_DI_WR(x, HW_IPU_CSI1_DI_RD(x) & ~(v)))
#define HW_IPU_CSI1_DI_TOG(x, v)    (HW_IPU_CSI1_DI_WR(x, HW_IPU_CSI1_DI_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_DI bitfields
 */

/* --- Register HW_IPU_CSI1_DI, field CSI1_MIPI_DI0 (RW)
 *
 * Reserved CSI1_MIPI_DI0 This field holds the Data Identifier #0 handled by the CSI; This is the
 * main stream.
 */

#define BP_IPU_CSI1_DI_CSI1_MIPI_DI0      0
#define BM_IPU_CSI1_DI_CSI1_MIPI_DI0      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_DI_CSI1_MIPI_DI0(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_DI_CSI1_MIPI_DI0)
#else
#define BF_IPU_CSI1_DI_CSI1_MIPI_DI0(v)   (((v) << 0) & BM_IPU_CSI1_DI_CSI1_MIPI_DI0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_MIPI_DI0 field to a new value.
#define BW_IPU_CSI1_DI_CSI1_MIPI_DI0(v)   BF_CS1(IPU_CSI1_DI, CSI1_MIPI_DI0, v)
#endif

/* --- Register HW_IPU_CSI1_DI, field CSI0_MIPI_DI1 (RW)
 *
 * Reserved CSI1_MIPI_DI1 This field holds the Data Identifier #1 handled by the CSI
 */

#define BP_IPU_CSI1_DI_CSI0_MIPI_DI1      8
#define BM_IPU_CSI1_DI_CSI0_MIPI_DI1      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_DI_CSI0_MIPI_DI1(v)   ((((reg32_t) v) << 8) & BM_IPU_CSI1_DI_CSI0_MIPI_DI1)
#else
#define BF_IPU_CSI1_DI_CSI0_MIPI_DI1(v)   (((v) << 8) & BM_IPU_CSI1_DI_CSI0_MIPI_DI1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI0_MIPI_DI1 field to a new value.
#define BW_IPU_CSI1_DI_CSI0_MIPI_DI1(v)   BF_CS1(IPU_CSI1_DI, CSI0_MIPI_DI1, v)
#endif

/* --- Register HW_IPU_CSI1_DI, field CSI1_MIPI_DI2 (RW)
 *
 * Reserved CSI1_MIPI_DI2 This field holds the Data Identifier #2 handled by the CSI.
 */

#define BP_IPU_CSI1_DI_CSI1_MIPI_DI2      16
#define BM_IPU_CSI1_DI_CSI1_MIPI_DI2      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_DI_CSI1_MIPI_DI2(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_DI_CSI1_MIPI_DI2)
#else
#define BF_IPU_CSI1_DI_CSI1_MIPI_DI2(v)   (((v) << 16) & BM_IPU_CSI1_DI_CSI1_MIPI_DI2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_MIPI_DI2 field to a new value.
#define BW_IPU_CSI1_DI_CSI1_MIPI_DI2(v)   BF_CS1(IPU_CSI1_DI, CSI1_MIPI_DI2, v)
#endif

/* --- Register HW_IPU_CSI1_DI, field CSI1_MIPI_DI3 (RW)
 *
 * Reserved CSI1_MIPI_DI3 This field holds the Data Identifier #3 handled by the CSI.
 */

#define BP_IPU_CSI1_DI_CSI1_MIPI_DI3      24
#define BM_IPU_CSI1_DI_CSI1_MIPI_DI3      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_DI_CSI1_MIPI_DI3(v)   ((((reg32_t) v) << 24) & BM_IPU_CSI1_DI_CSI1_MIPI_DI3)
#else
#define BF_IPU_CSI1_DI_CSI1_MIPI_DI3(v)   (((v) << 24) & BM_IPU_CSI1_DI_CSI1_MIPI_DI3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_MIPI_DI3 field to a new value.
#define BW_IPU_CSI1_DI_CSI1_MIPI_DI3(v)   BF_CS1(IPU_CSI1_DI, CSI1_MIPI_DI3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_SKIP - CSI1 SKIP Register (RW)
 *
 * This register control the frame skipping supported between CSI1 and the SMFC.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_MAX_RATIO_SKIP_SMFC : 3; //!< CSI1 Maximum Ratio Skip for SMFC These bits define the number of frames in a skipping set. These bits define the number of frames in a skipping set. The skipping number is equal to CSI1_MAX_RATIO_SKIP_SMFC+1; The maximum value of this bits is 5. When set to 0 the skipping is disabled.
        unsigned CSI1_SKIP_SMFC : 5; //!< CSI1 SKIP SMFC These 5 bits define the skipping pattern of the frames send to the SMFC. Skipping is done for a set of frames. The number of frames in a set is defined at CSI1_MAX_RATIO_SKIP_SMFC. when CSI1_MAX_RATIO_SKIP_SMFC = 1 => CSI1_SKIP_SMFC[0] is used; other bits are ignored when CSI1_MAX_RATIO_SKIP_SMFC = 2 => CSI1_SKIP_SMFC[1:0] are used; other bits are ignored when CSI1_MAX_RATIO_SKIP_SMFC = 3 => CSI1_SKIP_SMFC[2:0] are used; other bits are ignored when CSI1_MAX_RATIO_SKIP_SMFC = 4 => CSI1_SKIP_SMFC[3:0] are used; other bits are ignored when CSI1_MAX_RATIO_SKIP_SMFC = 5 => CSI1_SKIP_SMFC[4:0] are used; Setting bit #n of CSI1_SKIP_SMFC means that the #n frame in the set is skipped. For example: if CSI1_MAX_RATIO_SKIP_SMFC = 4 and CSI1_SKIP_SMFC = 11010 Frames #0 & Frame #2 will not be skipped as bit0 and bit2 are cleared Frames #1 & Frame #3 will be skipped as bit1 and bit3 are set bit #4 is ignored as CSI1_MAX_RATIO_SKIP_SMFC is set to 4
        unsigned CSI1_ID_2_SKIP : 2; //!< Reserved CSI1 to SMFC Skipping ID. Data from the CSI1 to the SMFC has an ID associated with it. The ID is received from the MIPI interface. The skipping mechanism between the CSI1 and the SMFC can be used for only one ID. There is no skipping for data coming with ID different from the ID programed in this bits
        unsigned RESERVED0 : 6; //!< Reserved
        unsigned CSI1_MAX_RATIO_SKIP_ISP : 3; //!< CSI1 Maximum Ratio Skip for ISP These bits define the number of frames in a skipping set. The skipping number is equal to CSI1_MAX_RATIO_SKIP_ISP+1; The maximum value of this bits is 5. When set to 0 the skipping is disabled. Reserved
        unsigned CSI1_SKIP_ISP : 5; //!< CSI1 SKIP ISP These 5 bits define the skipping pattern of the frames send to the ISP. Skipping is done for a set of frames. The number of frames in a set is defined at CSI1_MAX_RATIO_SKIP. when CSI1_MAX_RATIO_SKIP = 1 => CSI1_SKIP_ISP[0] is used; other bits are ignored when CSI1_MAX_RATIO_SKIP = 2 => CSI1_SKIP_ISP[1:0] are used; other bits are ignored when CSI1_MAX_RATIO_SKIP = 3 => CSI1_SKIP_ISP[2:0] are used; other bits are ignored when CSI1_MAX_RATIO_SKIP = 4 => CSI1_SKIP_ISP[3:0] are used; other bits are ignored when CSI1_MAX_RATIO_SKIP = 5 => CSI1_SKIP_ISP[4:0] are used; Setting bit #n of CSI1_SKIP_ISP means that the #n frame in the set is skipped. For example: if CSI1_MAX_RATIO_SKIP = 4 and CSI1_SKIP_ISP = 11010 Frames #0 & Frame #2 will not be skipped as bit0 and bit2 are cleared Frames #1 & Frame #3 will be skipped as bit1 and bit3 are set bit #4 is ignored as CSI1_MAX_RATIO_SKIP is set to 4 Reserved
        unsigned RESERVED1 : 8; //!< Reserved
    } B;
} hw_ipu_csi1_skip_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_SKIP register
 */
#define HW_IPU_CSI1_SKIP_ADDR(x)      (REGS_IPU_BASE(x) + 0x38024)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_SKIP(x)           (*(volatile hw_ipu_csi1_skip_t *) HW_IPU_CSI1_SKIP_ADDR(x))
#define HW_IPU_CSI1_SKIP_RD(x)        (HW_IPU_CSI1_SKIP(x).U)
#define HW_IPU_CSI1_SKIP_WR(x, v)     (HW_IPU_CSI1_SKIP(x).U = (v))
#define HW_IPU_CSI1_SKIP_SET(x, v)    (HW_IPU_CSI1_SKIP_WR(x, HW_IPU_CSI1_SKIP_RD(x) |  (v)))
#define HW_IPU_CSI1_SKIP_CLR(x, v)    (HW_IPU_CSI1_SKIP_WR(x, HW_IPU_CSI1_SKIP_RD(x) & ~(v)))
#define HW_IPU_CSI1_SKIP_TOG(x, v)    (HW_IPU_CSI1_SKIP_WR(x, HW_IPU_CSI1_SKIP_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_SKIP bitfields
 */

/* --- Register HW_IPU_CSI1_SKIP, field CSI1_MAX_RATIO_SKIP_SMFC (RW)
 *
 * CSI1 Maximum Ratio Skip for SMFC These bits define the number of frames in a skipping set. These
 * bits define the number of frames in a skipping set. The skipping number is equal to
 * CSI1_MAX_RATIO_SKIP_SMFC+1; The maximum value of this bits is 5. When set to 0 the skipping is
 * disabled.
 */

#define BP_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_SMFC      0
#define BM_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_SMFC      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_SMFC(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_SMFC)
#else
#define BF_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_SMFC(v)   (((v) << 0) & BM_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_SMFC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_MAX_RATIO_SKIP_SMFC field to a new value.
#define BW_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_SMFC(v)   BF_CS1(IPU_CSI1_SKIP, CSI1_MAX_RATIO_SKIP_SMFC, v)
#endif

/* --- Register HW_IPU_CSI1_SKIP, field CSI1_SKIP_SMFC (RW)
 *
 * CSI1 SKIP SMFC These 5 bits define the skipping pattern of the frames send to the SMFC. Skipping
 * is done for a set of frames. The number of frames in a set is defined at
 * CSI1_MAX_RATIO_SKIP_SMFC. when CSI1_MAX_RATIO_SKIP_SMFC = 1 => CSI1_SKIP_SMFC[0] is used; other
 * bits are ignored when CSI1_MAX_RATIO_SKIP_SMFC = 2 => CSI1_SKIP_SMFC[1:0] are used; other bits
 * are ignored when CSI1_MAX_RATIO_SKIP_SMFC = 3 => CSI1_SKIP_SMFC[2:0] are used; other bits are
 * ignored when CSI1_MAX_RATIO_SKIP_SMFC = 4 => CSI1_SKIP_SMFC[3:0] are used; other bits are ignored
 * when CSI1_MAX_RATIO_SKIP_SMFC = 5 => CSI1_SKIP_SMFC[4:0] are used; Setting bit #n of
 * CSI1_SKIP_SMFC means that the #n frame in the set is skipped. For example: if
 * CSI1_MAX_RATIO_SKIP_SMFC = 4 and CSI1_SKIP_SMFC = 11010 Frames #0 & Frame #2 will not be skipped
 * as bit0 and bit2 are cleared Frames #1 & Frame #3 will be skipped as bit1 and bit3 are set bit #4
 * is ignored as CSI1_MAX_RATIO_SKIP_SMFC is set to 4
 */

#define BP_IPU_CSI1_SKIP_CSI1_SKIP_SMFC      3
#define BM_IPU_CSI1_SKIP_CSI1_SKIP_SMFC      0x000000f8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SKIP_CSI1_SKIP_SMFC(v)   ((((reg32_t) v) << 3) & BM_IPU_CSI1_SKIP_CSI1_SKIP_SMFC)
#else
#define BF_IPU_CSI1_SKIP_CSI1_SKIP_SMFC(v)   (((v) << 3) & BM_IPU_CSI1_SKIP_CSI1_SKIP_SMFC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_SKIP_SMFC field to a new value.
#define BW_IPU_CSI1_SKIP_CSI1_SKIP_SMFC(v)   BF_CS1(IPU_CSI1_SKIP, CSI1_SKIP_SMFC, v)
#endif

/* --- Register HW_IPU_CSI1_SKIP, field CSI1_ID_2_SKIP (RW)
 *
 * Reserved CSI1 to SMFC Skipping ID. Data from the CSI1 to the SMFC has an ID associated with it.
 * The ID is received from the MIPI interface. The skipping mechanism between the CSI1 and the SMFC
 * can be used for only one ID. There is no skipping for data coming with ID different from the ID
 * programed in this bits
 *
 * Values:
 * 00 - - Skipping mechanism is activated on frames with ID equal to 00
 * 01 - - Skipping mechanism is activated on frames with ID equal to 01
 * 10 - - Skipping mechanism is activated on frames with ID equal to 10
 * 11 - - Skipping mechanism is activated on frames with ID equal to 11
 */

#define BP_IPU_CSI1_SKIP_CSI1_ID_2_SKIP      8
#define BM_IPU_CSI1_SKIP_CSI1_ID_2_SKIP      0x00000300

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SKIP_CSI1_ID_2_SKIP(v)   ((((reg32_t) v) << 8) & BM_IPU_CSI1_SKIP_CSI1_ID_2_SKIP)
#else
#define BF_IPU_CSI1_SKIP_CSI1_ID_2_SKIP(v)   (((v) << 8) & BM_IPU_CSI1_SKIP_CSI1_ID_2_SKIP)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_ID_2_SKIP field to a new value.
#define BW_IPU_CSI1_SKIP_CSI1_ID_2_SKIP(v)   BF_CS1(IPU_CSI1_SKIP, CSI1_ID_2_SKIP, v)
#endif


/* --- Register HW_IPU_CSI1_SKIP, field CSI1_MAX_RATIO_SKIP_ISP (RW)
 *
 * CSI1 Maximum Ratio Skip for ISP These bits define the number of frames in a skipping set. The
 * skipping number is equal to CSI1_MAX_RATIO_SKIP_ISP+1; The maximum value of this bits is 5. When
 * set to 0 the skipping is disabled. Reserved
 */

#define BP_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_ISP      16
#define BM_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_ISP      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_ISP(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_ISP)
#else
#define BF_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_ISP(v)   (((v) << 16) & BM_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_ISP)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_MAX_RATIO_SKIP_ISP field to a new value.
#define BW_IPU_CSI1_SKIP_CSI1_MAX_RATIO_SKIP_ISP(v)   BF_CS1(IPU_CSI1_SKIP, CSI1_MAX_RATIO_SKIP_ISP, v)
#endif

/* --- Register HW_IPU_CSI1_SKIP, field CSI1_SKIP_ISP (RW)
 *
 * CSI1 SKIP ISP These 5 bits define the skipping pattern of the frames send to the ISP. Skipping is
 * done for a set of frames. The number of frames in a set is defined at CSI1_MAX_RATIO_SKIP. when
 * CSI1_MAX_RATIO_SKIP = 1 => CSI1_SKIP_ISP[0] is used; other bits are ignored when
 * CSI1_MAX_RATIO_SKIP = 2 => CSI1_SKIP_ISP[1:0] are used; other bits are ignored when
 * CSI1_MAX_RATIO_SKIP = 3 => CSI1_SKIP_ISP[2:0] are used; other bits are ignored when
 * CSI1_MAX_RATIO_SKIP = 4 => CSI1_SKIP_ISP[3:0] are used; other bits are ignored when
 * CSI1_MAX_RATIO_SKIP = 5 => CSI1_SKIP_ISP[4:0] are used; Setting bit #n of CSI1_SKIP_ISP means
 * that the #n frame in the set is skipped. For example: if CSI1_MAX_RATIO_SKIP = 4 and
 * CSI1_SKIP_ISP = 11010 Frames #0 & Frame #2 will not be skipped as bit0 and bit2 are cleared
 * Frames #1 & Frame #3 will be skipped as bit1 and bit3 are set bit #4 is ignored as
 * CSI1_MAX_RATIO_SKIP is set to 4 Reserved
 */

#define BP_IPU_CSI1_SKIP_CSI1_SKIP_ISP      19
#define BM_IPU_CSI1_SKIP_CSI1_SKIP_ISP      0x00f80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_SKIP_CSI1_SKIP_ISP(v)   ((((reg32_t) v) << 19) & BM_IPU_CSI1_SKIP_CSI1_SKIP_ISP)
#else
#define BF_IPU_CSI1_SKIP_CSI1_SKIP_ISP(v)   (((v) << 19) & BM_IPU_CSI1_SKIP_CSI1_SKIP_ISP)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_SKIP_ISP field to a new value.
#define BW_IPU_CSI1_SKIP_CSI1_SKIP_ISP(v)   BF_CS1(IPU_CSI1_SKIP, CSI1_SKIP_ISP, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CPD_CTRL - CSI1 Compander Control Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned RESERVED2 : 3; //!< Reserved
        unsigned RESERVED3 : 27; //!< Reserved, should be cleared.
    } B;
} hw_ipu_csi1_cpd_ctrl_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CPD_CTRL register
 */
#define HW_IPU_CSI1_CPD_CTRL_ADDR(x)      (REGS_IPU_BASE(x) + 0x38028)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CPD_CTRL(x)           (*(volatile hw_ipu_csi1_cpd_ctrl_t *) HW_IPU_CSI1_CPD_CTRL_ADDR(x))
#define HW_IPU_CSI1_CPD_CTRL_RD(x)        (HW_IPU_CSI1_CPD_CTRL(x).U)
#define HW_IPU_CSI1_CPD_CTRL_WR(x, v)     (HW_IPU_CSI1_CPD_CTRL(x).U = (v))
#define HW_IPU_CSI1_CPD_CTRL_SET(x, v)    (HW_IPU_CSI1_CPD_CTRL_WR(x, HW_IPU_CSI1_CPD_CTRL_RD(x) |  (v)))
#define HW_IPU_CSI1_CPD_CTRL_CLR(x, v)    (HW_IPU_CSI1_CPD_CTRL_WR(x, HW_IPU_CSI1_CPD_CTRL_RD(x) & ~(v)))
#define HW_IPU_CSI1_CPD_CTRL_TOG(x, v)    (HW_IPU_CSI1_CPD_CTRL_WR(x, HW_IPU_CSI1_CPD_CTRL_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CPD_CTRL bitfields
 */

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CPD_RC_I - CSI1 Red Component Compander Constants Register <i> (RW)
 *
 * These registers contain CONSTANT <i> parameters used for companding of red component.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_CPD_RC_ : 9; //!< CONSTANT <2*i> parameter of Compander, Red component. Reserved
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned CSI1_CPD_RC_1 : 9; //!< CONSTANT <2*i+1> parameter of Compander, Red component. Reserved
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_csi1_cpd_rc_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CPD_RC_I register
 */
#define HW_IPU_CSI1_CPD_RC_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x3802c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CPD_RC_I(x)           (*(volatile hw_ipu_csi1_cpd_rc_i_t *) HW_IPU_CSI1_CPD_RC_I_ADDR(x))
#define HW_IPU_CSI1_CPD_RC_I_RD(x)        (HW_IPU_CSI1_CPD_RC_I(x).U)
#define HW_IPU_CSI1_CPD_RC_I_WR(x, v)     (HW_IPU_CSI1_CPD_RC_I(x).U = (v))
#define HW_IPU_CSI1_CPD_RC_I_SET(x, v)    (HW_IPU_CSI1_CPD_RC_I_WR(x, HW_IPU_CSI1_CPD_RC_I_RD(x) |  (v)))
#define HW_IPU_CSI1_CPD_RC_I_CLR(x, v)    (HW_IPU_CSI1_CPD_RC_I_WR(x, HW_IPU_CSI1_CPD_RC_I_RD(x) & ~(v)))
#define HW_IPU_CSI1_CPD_RC_I_TOG(x, v)    (HW_IPU_CSI1_CPD_RC_I_WR(x, HW_IPU_CSI1_CPD_RC_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CPD_RC_I bitfields
 */

/* --- Register HW_IPU_CSI1_CPD_RC_I, field CSI1_CPD_RC_ (RW)
 *
 * CONSTANT <2*i> parameter of Compander, Red component. Reserved
 */

#define BP_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_      0
#define BM_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_)
#else
#define BF_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_(v)   (((v) << 0) & BM_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_RC_ field to a new value.
#define BW_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_(v)   BF_CS1(IPU_CSI1_CPD_RC_I, CSI1_CPD_RC_, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_RC_I, field CSI1_CPD_RC_ (RW)
 *
 * CONSTANT <2*i+1> parameter of Compander, Red component. Reserved
 */

#define BP_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_      16
#define BM_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_)
#else
#define BF_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_(v)   (((v) << 16) & BM_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_RC_ field to a new value.
#define BW_IPU_CSI1_CPD_RC_I_CSI1_CPD_RC_(v)   BF_CS1(IPU_CSI1_CPD_RC_I, CSI1_CPD_RC_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CPD_RS_I - CSI1 Red Component Compander SLOPE Register <i> (RW)
 *
 * These registers contain SLOPE <i> parameters used for companding of red component.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_CPD_RS : 8; //!< SLOPE<4*i> parameter of Compander, Red component. Reserved
        unsigned CSI1_CPD_RS1 : 8; //!< SLOPE<4*i+1> parameter of Compander, Red component. Reserved
        unsigned CSI1_CPD_RS2 : 8; //!< SLOPE<4*i+2> parameter of Compander, Red component. Reserved
        unsigned CSI1_CPD_RS3 : 8; //!< SLOPE<4*i+3> parameter of Compander, Red component. Reserved
    } B;
} hw_ipu_csi1_cpd_rs_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CPD_RS_I register
 */
#define HW_IPU_CSI1_CPD_RS_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x3804c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CPD_RS_I(x)           (*(volatile hw_ipu_csi1_cpd_rs_i_t *) HW_IPU_CSI1_CPD_RS_I_ADDR(x))
#define HW_IPU_CSI1_CPD_RS_I_RD(x)        (HW_IPU_CSI1_CPD_RS_I(x).U)
#define HW_IPU_CSI1_CPD_RS_I_WR(x, v)     (HW_IPU_CSI1_CPD_RS_I(x).U = (v))
#define HW_IPU_CSI1_CPD_RS_I_SET(x, v)    (HW_IPU_CSI1_CPD_RS_I_WR(x, HW_IPU_CSI1_CPD_RS_I_RD(x) |  (v)))
#define HW_IPU_CSI1_CPD_RS_I_CLR(x, v)    (HW_IPU_CSI1_CPD_RS_I_WR(x, HW_IPU_CSI1_CPD_RS_I_RD(x) & ~(v)))
#define HW_IPU_CSI1_CPD_RS_I_TOG(x, v)    (HW_IPU_CSI1_CPD_RS_I_WR(x, HW_IPU_CSI1_CPD_RS_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CPD_RS_I bitfields
 */

/* --- Register HW_IPU_CSI1_CPD_RS_I, field CSI1_CPD_RS (RW)
 *
 * SLOPE<4*i> parameter of Compander, Red component. Reserved
 */

#define BP_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS      0
#define BM_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS)
#else
#define BF_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS(v)   (((v) << 0) & BM_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_RS field to a new value.
#define BW_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS(v)   BF_CS1(IPU_CSI1_CPD_RS_I, CSI1_CPD_RS, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_RS_I, field CSI1_CPD_RS (RW)
 *
 * SLOPE<4*i+1> parameter of Compander, Red component. Reserved
 */

#define BP_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS      8
#define BM_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS(v)   ((((reg32_t) v) << 8) & BM_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS)
#else
#define BF_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS(v)   (((v) << 8) & BM_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_RS field to a new value.
#define BW_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS(v)   BF_CS1(IPU_CSI1_CPD_RS_I, CSI1_CPD_RS, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_RS_I, field CSI1_CPD_RS (RW)
 *
 * SLOPE<4*i+2> parameter of Compander, Red component. Reserved
 */

#define BP_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS      16
#define BM_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS)
#else
#define BF_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS(v)   (((v) << 16) & BM_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_RS field to a new value.
#define BW_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS(v)   BF_CS1(IPU_CSI1_CPD_RS_I, CSI1_CPD_RS, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_RS_I, field CSI1_CPD_RS (RW)
 *
 * SLOPE<4*i+3> parameter of Compander, Red component. Reserved
 */

#define BP_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS      24
#define BM_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS(v)   ((((reg32_t) v) << 24) & BM_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS)
#else
#define BF_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS(v)   (((v) << 24) & BM_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_RS field to a new value.
#define BW_IPU_CSI1_CPD_RS_I_CSI1_CPD_RS(v)   BF_CS1(IPU_CSI1_CPD_RS_I, CSI1_CPD_RS, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CPD_GRC_I - CSI1 GR Component Compander Constants Register <i> (RW)
 *
 * These registers contain CONSTANTi parameters used for companding of green components in GRGR
 * rows.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_CPD_GRC : 9; //!< CONSTANT<2*i> parameter of Compander, GR component. If the input format is RGB/YUV then CSI1_CPD_GRC should be equal to CSI1_CPD_GBC Reserved
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned CSI1_CPD_GRC1 : 9; //!< CONST<2*i+1> parameter of Compander, GR component. If the input format is RGB/YUV then CSI1_CPD_GRC should be equal to CSI1_CPD_GBC Reserved
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_csi1_cpd_grc_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CPD_GRC_I register
 */
#define HW_IPU_CSI1_CPD_GRC_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x3805c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CPD_GRC_I(x)           (*(volatile hw_ipu_csi1_cpd_grc_i_t *) HW_IPU_CSI1_CPD_GRC_I_ADDR(x))
#define HW_IPU_CSI1_CPD_GRC_I_RD(x)        (HW_IPU_CSI1_CPD_GRC_I(x).U)
#define HW_IPU_CSI1_CPD_GRC_I_WR(x, v)     (HW_IPU_CSI1_CPD_GRC_I(x).U = (v))
#define HW_IPU_CSI1_CPD_GRC_I_SET(x, v)    (HW_IPU_CSI1_CPD_GRC_I_WR(x, HW_IPU_CSI1_CPD_GRC_I_RD(x) |  (v)))
#define HW_IPU_CSI1_CPD_GRC_I_CLR(x, v)    (HW_IPU_CSI1_CPD_GRC_I_WR(x, HW_IPU_CSI1_CPD_GRC_I_RD(x) & ~(v)))
#define HW_IPU_CSI1_CPD_GRC_I_TOG(x, v)    (HW_IPU_CSI1_CPD_GRC_I_WR(x, HW_IPU_CSI1_CPD_GRC_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CPD_GRC_I bitfields
 */

/* --- Register HW_IPU_CSI1_CPD_GRC_I, field CSI1_CPD_GRC (RW)
 *
 * CONSTANT<2*i> parameter of Compander, GR component. If the input format is RGB/YUV then
 * CSI1_CPD_GRC should be equal to CSI1_CPD_GBC Reserved
 */

#define BP_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC      0
#define BM_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC)
#else
#define BF_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC(v)   (((v) << 0) & BM_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GRC field to a new value.
#define BW_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC(v)   BF_CS1(IPU_CSI1_CPD_GRC_I, CSI1_CPD_GRC, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_GRC_I, field CSI1_CPD_GRC (RW)
 *
 * CONST<2*i+1> parameter of Compander, GR component. If the input format is RGB/YUV then
 * CSI1_CPD_GRC should be equal to CSI1_CPD_GBC Reserved
 */

#define BP_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC      16
#define BM_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC)
#else
#define BF_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC(v)   (((v) << 16) & BM_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GRC field to a new value.
#define BW_IPU_CSI1_CPD_GRC_I_CSI1_CPD_GRC(v)   BF_CS1(IPU_CSI1_CPD_GRC_I, CSI1_CPD_GRC, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CPD_GRS_I - CSI1 GR Component Compander SLOPE Register <i> (RW)
 *
 * These registers contain SLOPEi parameters used for companding of green components in GRGR rows.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_CPD_GRS : 8; //!< SLOPE<4*i> parameter of Compander, GR component. If the input format is RGB/YUV then CSI1_CPD_GRS should be equal to CSI1_CPD_GBS Reserved
        unsigned CSI1_CPD_GRS1 : 8; //!< SLOPE<4*i+1> parameter of Compander, GR component. If the input format is RGB/YUV then CSI1_CPD_GRS should be equal to CSI1_CPD_GBS Reserved
        unsigned CSI1_CPD_GRS2 : 8; //!< SLOPE<4*i+2> parameter of Compander, GR component. If the input format is RGB/YUV then CSI1_CPD_GRS should be equal to CSI1_CPD_GBS Reserved
        unsigned CSI1_CPD_GRS3 : 8; //!< SLOPE<4*i+3> parameter of Compander, GR component. If the input format is RGB/YUV then CSI1_CPD_GRS should be equal to CSI1_CPD_GBS Reserved
    } B;
} hw_ipu_csi1_cpd_grs_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CPD_GRS_I register
 */
#define HW_IPU_CSI1_CPD_GRS_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x3807c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CPD_GRS_I(x)           (*(volatile hw_ipu_csi1_cpd_grs_i_t *) HW_IPU_CSI1_CPD_GRS_I_ADDR(x))
#define HW_IPU_CSI1_CPD_GRS_I_RD(x)        (HW_IPU_CSI1_CPD_GRS_I(x).U)
#define HW_IPU_CSI1_CPD_GRS_I_WR(x, v)     (HW_IPU_CSI1_CPD_GRS_I(x).U = (v))
#define HW_IPU_CSI1_CPD_GRS_I_SET(x, v)    (HW_IPU_CSI1_CPD_GRS_I_WR(x, HW_IPU_CSI1_CPD_GRS_I_RD(x) |  (v)))
#define HW_IPU_CSI1_CPD_GRS_I_CLR(x, v)    (HW_IPU_CSI1_CPD_GRS_I_WR(x, HW_IPU_CSI1_CPD_GRS_I_RD(x) & ~(v)))
#define HW_IPU_CSI1_CPD_GRS_I_TOG(x, v)    (HW_IPU_CSI1_CPD_GRS_I_WR(x, HW_IPU_CSI1_CPD_GRS_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CPD_GRS_I bitfields
 */

/* --- Register HW_IPU_CSI1_CPD_GRS_I, field CSI1_CPD_GRS (RW)
 *
 * SLOPE<4*i> parameter of Compander, GR component. If the input format is RGB/YUV then CSI1_CPD_GRS
 * should be equal to CSI1_CPD_GBS Reserved
 */

#define BP_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS      0
#define BM_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS)
#else
#define BF_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS(v)   (((v) << 0) & BM_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GRS field to a new value.
#define BW_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS(v)   BF_CS1(IPU_CSI1_CPD_GRS_I, CSI1_CPD_GRS, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_GRS_I, field CSI1_CPD_GRS (RW)
 *
 * SLOPE<4*i+1> parameter of Compander, GR component. If the input format is RGB/YUV then
 * CSI1_CPD_GRS should be equal to CSI1_CPD_GBS Reserved
 */

#define BP_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS      8
#define BM_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS(v)   ((((reg32_t) v) << 8) & BM_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS)
#else
#define BF_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS(v)   (((v) << 8) & BM_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GRS field to a new value.
#define BW_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS(v)   BF_CS1(IPU_CSI1_CPD_GRS_I, CSI1_CPD_GRS, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_GRS_I, field CSI1_CPD_GRS (RW)
 *
 * SLOPE<4*i+2> parameter of Compander, GR component. If the input format is RGB/YUV then
 * CSI1_CPD_GRS should be equal to CSI1_CPD_GBS Reserved
 */

#define BP_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS      16
#define BM_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS)
#else
#define BF_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS(v)   (((v) << 16) & BM_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GRS field to a new value.
#define BW_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS(v)   BF_CS1(IPU_CSI1_CPD_GRS_I, CSI1_CPD_GRS, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_GRS_I, field CSI1_CPD_GRS (RW)
 *
 * SLOPE<4*i+3> parameter of Compander, GR component. If the input format is RGB/YUV then
 * CSI1_CPD_GRS should be equal to CSI1_CPD_GBS Reserved
 */

#define BP_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS      24
#define BM_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS(v)   ((((reg32_t) v) << 24) & BM_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS)
#else
#define BF_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS(v)   (((v) << 24) & BM_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GRS field to a new value.
#define BW_IPU_CSI1_CPD_GRS_I_CSI1_CPD_GRS(v)   BF_CS1(IPU_CSI1_CPD_GRS_I, CSI1_CPD_GRS, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CPD_GBC_I - CSI1 GB Component Compander Constants Register <i> (RW)
 *
 * These registers contain CONSTANTi parameters used for companding of green components in GBGB
 * rows.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_CPD_GBC : 9; //!< CONSTANTi parameter of Compander, GB component. If the input format is RGB/YUV then CSI1_CPD_GBC should be equal to CSI1_CPD_GRC Reserved
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned CSI1_CPD_GBC1 : 9; //!< CONSTi+1 parameter of Compander, GB component. If the input format is RGB/YUV then CSI1_CPD_GBC should be equal to CSI1_CPD_GRC Reserved
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_csi1_cpd_gbc_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CPD_GBC_I register
 */
#define HW_IPU_CSI1_CPD_GBC_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x3808c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CPD_GBC_I(x)           (*(volatile hw_ipu_csi1_cpd_gbc_i_t *) HW_IPU_CSI1_CPD_GBC_I_ADDR(x))
#define HW_IPU_CSI1_CPD_GBC_I_RD(x)        (HW_IPU_CSI1_CPD_GBC_I(x).U)
#define HW_IPU_CSI1_CPD_GBC_I_WR(x, v)     (HW_IPU_CSI1_CPD_GBC_I(x).U = (v))
#define HW_IPU_CSI1_CPD_GBC_I_SET(x, v)    (HW_IPU_CSI1_CPD_GBC_I_WR(x, HW_IPU_CSI1_CPD_GBC_I_RD(x) |  (v)))
#define HW_IPU_CSI1_CPD_GBC_I_CLR(x, v)    (HW_IPU_CSI1_CPD_GBC_I_WR(x, HW_IPU_CSI1_CPD_GBC_I_RD(x) & ~(v)))
#define HW_IPU_CSI1_CPD_GBC_I_TOG(x, v)    (HW_IPU_CSI1_CPD_GBC_I_WR(x, HW_IPU_CSI1_CPD_GBC_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CPD_GBC_I bitfields
 */

/* --- Register HW_IPU_CSI1_CPD_GBC_I, field CSI1_CPD_GBC (RW)
 *
 * CONSTANTi parameter of Compander, GB component. If the input format is RGB/YUV then CSI1_CPD_GBC
 * should be equal to CSI1_CPD_GRC Reserved
 */

#define BP_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC      0
#define BM_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC)
#else
#define BF_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC(v)   (((v) << 0) & BM_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GBC field to a new value.
#define BW_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC(v)   BF_CS1(IPU_CSI1_CPD_GBC_I, CSI1_CPD_GBC, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_GBC_I, field CSI1_CPD_GBC (RW)
 *
 * CONSTi+1 parameter of Compander, GB component. If the input format is RGB/YUV then CSI1_CPD_GBC
 * should be equal to CSI1_CPD_GRC Reserved
 */

#define BP_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC      16
#define BM_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC)
#else
#define BF_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC(v)   (((v) << 16) & BM_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GBC field to a new value.
#define BW_IPU_CSI1_CPD_GBC_I_CSI1_CPD_GBC(v)   BF_CS1(IPU_CSI1_CPD_GBC_I, CSI1_CPD_GBC, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CPD_GBS_I - CSI1 GB Component Compander SLOPE Register <i> (RW)
 *
 * These registers contain SLOPEi parameters used for companding of green components in GBGB rows.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_CPD_GBS : 8; //!< SLOPE<4*i> parameter of Compander, GB component. If the input format is RGB/YUV then CSI1_CPD_GBS should be equal to CSI1_CPD_GRS Reserved
        unsigned CSI1_CPD_GBS1 : 8; //!< SLOPE<4*i+1> parameter of Compander, GB component. If the input format is RGB/YUV then CSI1_CPD_GBS should be equal to CSI1_CPD_GRS Reserved
        unsigned CSI1_CPD_GBS2 : 8; //!< SLOPE<4*i+2> parameter of Compander, GB component. If the input format is RGB/YUV then CSI1_CPD_GBS should be equal to CSI1_CPD_GRS Reserved
        unsigned CSI1_CPD_GBS3 : 8; //!< SLOPE<4*i+3> parameter of Compander, GB component. If the input format is RGB/YUV then CSI1_CPD_GBS should be equal to CSI1_CPD_GRS Reserved
    } B;
} hw_ipu_csi1_cpd_gbs_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CPD_GBS_I register
 */
#define HW_IPU_CSI1_CPD_GBS_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x380ac)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CPD_GBS_I(x)           (*(volatile hw_ipu_csi1_cpd_gbs_i_t *) HW_IPU_CSI1_CPD_GBS_I_ADDR(x))
#define HW_IPU_CSI1_CPD_GBS_I_RD(x)        (HW_IPU_CSI1_CPD_GBS_I(x).U)
#define HW_IPU_CSI1_CPD_GBS_I_WR(x, v)     (HW_IPU_CSI1_CPD_GBS_I(x).U = (v))
#define HW_IPU_CSI1_CPD_GBS_I_SET(x, v)    (HW_IPU_CSI1_CPD_GBS_I_WR(x, HW_IPU_CSI1_CPD_GBS_I_RD(x) |  (v)))
#define HW_IPU_CSI1_CPD_GBS_I_CLR(x, v)    (HW_IPU_CSI1_CPD_GBS_I_WR(x, HW_IPU_CSI1_CPD_GBS_I_RD(x) & ~(v)))
#define HW_IPU_CSI1_CPD_GBS_I_TOG(x, v)    (HW_IPU_CSI1_CPD_GBS_I_WR(x, HW_IPU_CSI1_CPD_GBS_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CPD_GBS_I bitfields
 */

/* --- Register HW_IPU_CSI1_CPD_GBS_I, field CSI1_CPD_GBS (RW)
 *
 * SLOPE<4*i> parameter of Compander, GB component. If the input format is RGB/YUV then CSI1_CPD_GBS
 * should be equal to CSI1_CPD_GRS Reserved
 */

#define BP_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS      0
#define BM_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS)
#else
#define BF_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS(v)   (((v) << 0) & BM_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GBS field to a new value.
#define BW_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS(v)   BF_CS1(IPU_CSI1_CPD_GBS_I, CSI1_CPD_GBS, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_GBS_I, field CSI1_CPD_GBS (RW)
 *
 * SLOPE<4*i+1> parameter of Compander, GB component. If the input format is RGB/YUV then
 * CSI1_CPD_GBS should be equal to CSI1_CPD_GRS Reserved
 */

#define BP_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS      8
#define BM_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS(v)   ((((reg32_t) v) << 8) & BM_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS)
#else
#define BF_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS(v)   (((v) << 8) & BM_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GBS field to a new value.
#define BW_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS(v)   BF_CS1(IPU_CSI1_CPD_GBS_I, CSI1_CPD_GBS, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_GBS_I, field CSI1_CPD_GBS (RW)
 *
 * SLOPE<4*i+2> parameter of Compander, GB component. If the input format is RGB/YUV then
 * CSI1_CPD_GBS should be equal to CSI1_CPD_GRS Reserved
 */

#define BP_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS      16
#define BM_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS)
#else
#define BF_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS(v)   (((v) << 16) & BM_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GBS field to a new value.
#define BW_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS(v)   BF_CS1(IPU_CSI1_CPD_GBS_I, CSI1_CPD_GBS, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_GBS_I, field CSI1_CPD_GBS (RW)
 *
 * SLOPE<4*i+3> parameter of Compander, GB component. If the input format is RGB/YUV then
 * CSI1_CPD_GBS should be equal to CSI1_CPD_GRS Reserved
 */

#define BP_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS      24
#define BM_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS(v)   ((((reg32_t) v) << 24) & BM_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS)
#else
#define BF_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS(v)   (((v) << 24) & BM_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GBS field to a new value.
#define BW_IPU_CSI1_CPD_GBS_I_CSI1_CPD_GBS(v)   BF_CS1(IPU_CSI1_CPD_GBS_I, CSI1_CPD_GBS, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CPD_BC_I - CSI1 Blue Component Compander Constants Register <i> (RW)
 *
 * These registers contend CONSTANTi parameters used for companding of blue component.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_CPD_BC : 9; //!< CONSTANT<2*i> parameter of Compander, Blue component. Reserved
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned CSI1_CPD_BC1 : 9; //!< CONSTANT<2*i+1> parameter of Compander, Blue component. Reserved
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_csi1_cpd_bc_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CPD_BC_I register
 */
#define HW_IPU_CSI1_CPD_BC_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x380bc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CPD_BC_I(x)           (*(volatile hw_ipu_csi1_cpd_bc_i_t *) HW_IPU_CSI1_CPD_BC_I_ADDR(x))
#define HW_IPU_CSI1_CPD_BC_I_RD(x)        (HW_IPU_CSI1_CPD_BC_I(x).U)
#define HW_IPU_CSI1_CPD_BC_I_WR(x, v)     (HW_IPU_CSI1_CPD_BC_I(x).U = (v))
#define HW_IPU_CSI1_CPD_BC_I_SET(x, v)    (HW_IPU_CSI1_CPD_BC_I_WR(x, HW_IPU_CSI1_CPD_BC_I_RD(x) |  (v)))
#define HW_IPU_CSI1_CPD_BC_I_CLR(x, v)    (HW_IPU_CSI1_CPD_BC_I_WR(x, HW_IPU_CSI1_CPD_BC_I_RD(x) & ~(v)))
#define HW_IPU_CSI1_CPD_BC_I_TOG(x, v)    (HW_IPU_CSI1_CPD_BC_I_WR(x, HW_IPU_CSI1_CPD_BC_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CPD_BC_I bitfields
 */

/* --- Register HW_IPU_CSI1_CPD_BC_I, field CSI1_CPD_BC (RW)
 *
 * CONSTANT<2*i> parameter of Compander, Blue component. Reserved
 */

#define BP_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC      0
#define BM_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC)
#else
#define BF_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC(v)   (((v) << 0) & BM_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_BC field to a new value.
#define BW_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC(v)   BF_CS1(IPU_CSI1_CPD_BC_I, CSI1_CPD_BC, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_BC_I, field CSI1_CPD_BC (RW)
 *
 * CONSTANT<2*i+1> parameter of Compander, Blue component. Reserved
 */

#define BP_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC      16
#define BM_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC)
#else
#define BF_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC(v)   (((v) << 16) & BM_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_BC field to a new value.
#define BW_IPU_CSI1_CPD_BC_I_CSI1_CPD_BC(v)   BF_CS1(IPU_CSI1_CPD_BC_I, CSI1_CPD_BC, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CPD_BS_I - CSI1 Blue Component Compander SLOPE Register <i> (RW)
 *
 * This registers contain SLOPEi parameters used for companding of red component.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_CPD_BS : 8; //!< SLOPE<4*i> parameter of Compander, Blue component. Reserved
        unsigned CSI1_CPD_BS1 : 8; //!< SLOPE<4*i+1> parameter of Compander, Blue component. Reserved
        unsigned CSI1_CPD_BS2 : 8; //!< SLOPE<4*i+2> parameter of Compander, Blue component. Reserved
        unsigned CSI1_CPD_BS3 : 8; //!< SLOPE<4*i+3> parameter of Compander, Blue component. Reserved
    } B;
} hw_ipu_csi1_cpd_bs_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CPD_BS_I register
 */
#define HW_IPU_CSI1_CPD_BS_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x380dc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CPD_BS_I(x)           (*(volatile hw_ipu_csi1_cpd_bs_i_t *) HW_IPU_CSI1_CPD_BS_I_ADDR(x))
#define HW_IPU_CSI1_CPD_BS_I_RD(x)        (HW_IPU_CSI1_CPD_BS_I(x).U)
#define HW_IPU_CSI1_CPD_BS_I_WR(x, v)     (HW_IPU_CSI1_CPD_BS_I(x).U = (v))
#define HW_IPU_CSI1_CPD_BS_I_SET(x, v)    (HW_IPU_CSI1_CPD_BS_I_WR(x, HW_IPU_CSI1_CPD_BS_I_RD(x) |  (v)))
#define HW_IPU_CSI1_CPD_BS_I_CLR(x, v)    (HW_IPU_CSI1_CPD_BS_I_WR(x, HW_IPU_CSI1_CPD_BS_I_RD(x) & ~(v)))
#define HW_IPU_CSI1_CPD_BS_I_TOG(x, v)    (HW_IPU_CSI1_CPD_BS_I_WR(x, HW_IPU_CSI1_CPD_BS_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CPD_BS_I bitfields
 */

/* --- Register HW_IPU_CSI1_CPD_BS_I, field CSI1_CPD_BS (RW)
 *
 * SLOPE<4*i> parameter of Compander, Blue component. Reserved
 */

#define BP_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS      0
#define BM_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS)
#else
#define BF_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS(v)   (((v) << 0) & BM_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_BS field to a new value.
#define BW_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS(v)   BF_CS1(IPU_CSI1_CPD_BS_I, CSI1_CPD_BS, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_BS_I, field CSI1_CPD_BS (RW)
 *
 * SLOPE<4*i+1> parameter of Compander, Blue component. Reserved
 */

#define BP_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS      8
#define BM_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS(v)   ((((reg32_t) v) << 8) & BM_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS)
#else
#define BF_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS(v)   (((v) << 8) & BM_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_BS field to a new value.
#define BW_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS(v)   BF_CS1(IPU_CSI1_CPD_BS_I, CSI1_CPD_BS, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_BS_I, field CSI1_CPD_BS (RW)
 *
 * SLOPE<4*i+2> parameter of Compander, Blue component. Reserved
 */

#define BP_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS      16
#define BM_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS(v)   ((((reg32_t) v) << 16) & BM_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS)
#else
#define BF_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS(v)   (((v) << 16) & BM_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_BS field to a new value.
#define BW_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS(v)   BF_CS1(IPU_CSI1_CPD_BS_I, CSI1_CPD_BS, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_BS_I, field CSI1_CPD_BS (RW)
 *
 * SLOPE<4*i+3> parameter of Compander, Blue component. Reserved
 */

#define BP_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS      24
#define BM_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS(v)   ((((reg32_t) v) << 24) & BM_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS)
#else
#define BF_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS(v)   (((v) << 24) & BM_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_BS field to a new value.
#define BW_IPU_CSI1_CPD_BS_I_CSI1_CPD_BS(v)   BF_CS1(IPU_CSI1_CPD_BS_I, CSI1_CPD_BS, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CPD_OFFSET1 - CSI1 Compander Offset Register 1 (RW)
 *
 * These registers contain Offset parameters used for companding.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_CPD_GR_OFFSET : 10; //!< CSI1 Green Red component offset The value is between -512 to 511. The value is added to the green-red component before companding. Clipping: If the result of the green-red components value + the offset is smaller than 0, the result is zero If the result of the green-red components value + the offset is greater than 1023, the result is 1023 Reserved
        unsigned CSI1_CPD_GB_OFFSET : 10; //!< CSI1 Green Blue component offset The value is between -512 to 511. The value is added to the blue component before companding. Clipping: If the result of the green-blue components value + the offset is smaller than 0, the result is zero If the result of the green-blue components value + the offset is greater than 1023, the result is 1023 If the input format is RGB/YUV then CSI1_GB_OFFSET must be equal to CSI1_GR_OFFSET Reserved
        unsigned CSI1_CPD_B_OFFSET : 10; //!< CSI1 Blue component offset The value is between -512 to 511. The value is added to the blue component before companding. Clipping: If the result of the blue components value + the offset is smaller than 0, the result is zero If the result of the blue components value + the offset is greater than 1023, the result is 1023 Reserved
        unsigned RESERVED0 : 2; //!< Reserved
    } B;
} hw_ipu_csi1_cpd_offset1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CPD_OFFSET1 register
 */
#define HW_IPU_CSI1_CPD_OFFSET1_ADDR(x)      (REGS_IPU_BASE(x) + 0x380ec)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CPD_OFFSET1(x)           (*(volatile hw_ipu_csi1_cpd_offset1_t *) HW_IPU_CSI1_CPD_OFFSET1_ADDR(x))
#define HW_IPU_CSI1_CPD_OFFSET1_RD(x)        (HW_IPU_CSI1_CPD_OFFSET1(x).U)
#define HW_IPU_CSI1_CPD_OFFSET1_WR(x, v)     (HW_IPU_CSI1_CPD_OFFSET1(x).U = (v))
#define HW_IPU_CSI1_CPD_OFFSET1_SET(x, v)    (HW_IPU_CSI1_CPD_OFFSET1_WR(x, HW_IPU_CSI1_CPD_OFFSET1_RD(x) |  (v)))
#define HW_IPU_CSI1_CPD_OFFSET1_CLR(x, v)    (HW_IPU_CSI1_CPD_OFFSET1_WR(x, HW_IPU_CSI1_CPD_OFFSET1_RD(x) & ~(v)))
#define HW_IPU_CSI1_CPD_OFFSET1_TOG(x, v)    (HW_IPU_CSI1_CPD_OFFSET1_WR(x, HW_IPU_CSI1_CPD_OFFSET1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CPD_OFFSET1 bitfields
 */

/* --- Register HW_IPU_CSI1_CPD_OFFSET1, field CSI1_CPD_GR_OFFSET (RW)
 *
 * CSI1 Green Red component offset The value is between -512 to 511. The value is added to the
 * green-red component before companding. Clipping: If the result of the green-red components value
 * + the offset is smaller than 0, the result is zero If the result of the green-red components
 * value + the offset is greater than 1023, the result is 1023 Reserved
 */

#define BP_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GR_OFFSET      0
#define BM_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GR_OFFSET      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GR_OFFSET(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GR_OFFSET)
#else
#define BF_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GR_OFFSET(v)   (((v) << 0) & BM_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GR_OFFSET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GR_OFFSET field to a new value.
#define BW_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GR_OFFSET(v)   BF_CS1(IPU_CSI1_CPD_OFFSET1, CSI1_CPD_GR_OFFSET, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_OFFSET1, field CSI1_CPD_GB_OFFSET (RW)
 *
 * CSI1 Green Blue component offset The value is between -512 to 511. The value is added to the blue
 * component before companding. Clipping: If the result of the green-blue components value + the
 * offset is smaller than 0, the result is zero If the result of the green-blue components value +
 * the offset is greater than 1023, the result is 1023 If the input format is RGB/YUV then
 * CSI1_GB_OFFSET must be equal to CSI1_GR_OFFSET Reserved
 */

#define BP_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GB_OFFSET      10
#define BM_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GB_OFFSET      0x000ffc00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GB_OFFSET(v)   ((((reg32_t) v) << 10) & BM_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GB_OFFSET)
#else
#define BF_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GB_OFFSET(v)   (((v) << 10) & BM_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GB_OFFSET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_GB_OFFSET field to a new value.
#define BW_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_GB_OFFSET(v)   BF_CS1(IPU_CSI1_CPD_OFFSET1, CSI1_CPD_GB_OFFSET, v)
#endif

/* --- Register HW_IPU_CSI1_CPD_OFFSET1, field CSI1_CPD_B_OFFSET (RW)
 *
 * CSI1 Blue component offset The value is between -512 to 511. The value is added to the blue
 * component before companding. Clipping: If the result of the blue components value + the offset is
 * smaller than 0, the result is zero If the result of the blue components value + the offset is
 * greater than 1023, the result is 1023 Reserved
 */

#define BP_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_B_OFFSET      20
#define BM_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_B_OFFSET      0x3ff00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_B_OFFSET(v)   ((((reg32_t) v) << 20) & BM_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_B_OFFSET)
#else
#define BF_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_B_OFFSET(v)   (((v) << 20) & BM_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_B_OFFSET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_B_OFFSET field to a new value.
#define BW_IPU_CSI1_CPD_OFFSET1_CSI1_CPD_B_OFFSET(v)   BF_CS1(IPU_CSI1_CPD_OFFSET1, CSI1_CPD_B_OFFSET, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_CSI1_CPD_OFFSET2 - CSI1 Compander Offset Register 2 (RW)
 *
 * These registers contain Offset parameters used for companding.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned CSI1_CPD_R_OFFSET : 10; //!< CSI1 Red component offset The value is between -512 to 511. The value is added to the red component before companding. Clipping: If the result of the red components value + the offset is smaller than 0, the result is zero If the result of the red components value + the offset is greater than 1023, the result is 1023 Reserved
        unsigned RESERVED0 : 22; //!< Reserved
    } B;
} hw_ipu_csi1_cpd_offset2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_CSI1_CPD_OFFSET2 register
 */
#define HW_IPU_CSI1_CPD_OFFSET2_ADDR(x)      (REGS_IPU_BASE(x) + 0x380f0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_CSI1_CPD_OFFSET2(x)           (*(volatile hw_ipu_csi1_cpd_offset2_t *) HW_IPU_CSI1_CPD_OFFSET2_ADDR(x))
#define HW_IPU_CSI1_CPD_OFFSET2_RD(x)        (HW_IPU_CSI1_CPD_OFFSET2(x).U)
#define HW_IPU_CSI1_CPD_OFFSET2_WR(x, v)     (HW_IPU_CSI1_CPD_OFFSET2(x).U = (v))
#define HW_IPU_CSI1_CPD_OFFSET2_SET(x, v)    (HW_IPU_CSI1_CPD_OFFSET2_WR(x, HW_IPU_CSI1_CPD_OFFSET2_RD(x) |  (v)))
#define HW_IPU_CSI1_CPD_OFFSET2_CLR(x, v)    (HW_IPU_CSI1_CPD_OFFSET2_WR(x, HW_IPU_CSI1_CPD_OFFSET2_RD(x) & ~(v)))
#define HW_IPU_CSI1_CPD_OFFSET2_TOG(x, v)    (HW_IPU_CSI1_CPD_OFFSET2_WR(x, HW_IPU_CSI1_CPD_OFFSET2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_CSI1_CPD_OFFSET2 bitfields
 */

/* --- Register HW_IPU_CSI1_CPD_OFFSET2, field CSI1_CPD_R_OFFSET (RW)
 *
 * CSI1 Red component offset The value is between -512 to 511. The value is added to the red
 * component before companding. Clipping: If the result of the red components value + the offset is
 * smaller than 0, the result is zero If the result of the red components value + the offset is
 * greater than 1023, the result is 1023 Reserved
 */

#define BP_IPU_CSI1_CPD_OFFSET2_CSI1_CPD_R_OFFSET      0
#define BM_IPU_CSI1_CPD_OFFSET2_CSI1_CPD_R_OFFSET      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_CSI1_CPD_OFFSET2_CSI1_CPD_R_OFFSET(v)   ((((reg32_t) v) << 0) & BM_IPU_CSI1_CPD_OFFSET2_CSI1_CPD_R_OFFSET)
#else
#define BF_IPU_CSI1_CPD_OFFSET2_CSI1_CPD_R_OFFSET(v)   (((v) << 0) & BM_IPU_CSI1_CPD_OFFSET2_CSI1_CPD_R_OFFSET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CSI1_CPD_R_OFFSET field to a new value.
#define BW_IPU_CSI1_CPD_OFFSET2_CSI1_CPD_R_OFFSET(v)   BF_CS1(IPU_CSI1_CPD_OFFSET2, CSI1_CPD_R_OFFSET, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_GENERAL - DI0 General Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_POLARITY_ : 8; //!< DI0 output pin's polarity This bits define the polarity of each of the DI's outputs.
        unsigned DI0_POLARITY_CS0 : 1; //!< DI0 Chip Select's 0 polarity This bits define the polarity of the DI's CS0.
        unsigned DI0_POLARITY_CS1 : 1; //!< DI0 Chip Select's 1 polarity This bits define the polarity of the DI's CS1.
        unsigned DI0_ERM_VSYNC_SEL : 1; //!< DI0 error recovery block's VSYNC source select The error recovery block detect a case where the DI's VSYNC is asserted before the EOF. This bit selects the source of the VSYNC signal monitored by this mechanism.
        unsigned DI0_ERR_TREATMENT : 1; //!< In case of synchronous flow error there are 2 ways to handle the display
        unsigned DI0_SYNC_COUNT_SEL : 4; //!< For synchronous flow error: selects synchronous flow synchronization counter in DI:
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI0_POLARITY_DISP_CLK : 1; //!< DI0 Output Clock's polarity This bits define the polarity of the DI0's clock.
        unsigned DI0_WATCHDOG_MODE : 2; //!< DI0 watchdog mode In case of a display error where the DI clock is stopped (defined at di0_err_treatment). An internal watchdog counts DI clocks. If this timer reached its pre defined value the DI will skip the current frame and restart on the frame. This 2 bits define the number of DI clock cycles that the timer counts.
        unsigned DI0_CLK_EXT : 1; //!< DI0 External Clock. This bit selects the source of the DI0's clock
        unsigned DI0_VSYNC_EXT : 1; //!< DI0 External VSYNC. This bit selects the source of the VSYNC signal
        unsigned DI0_MASK_SEL : 1; //!< DI0 Mask select. IPP_PIN_2 output of the DI that functions as MASK signal can come from 2 sources: counter #2 or extracted from the MASK data coming from the memory.
        unsigned DI0_DISP_CLOCK_INIT : 1; //!< Display clock's initial mode For synchronization error conditions the display clock can be stopped on the next VSYNC
        unsigned DI0_CLOCK_STOP_MODE : 4; //!< DI clock stop mode When performing a clock change. The DI stops the clock to the display. These field defines when the clock will be stopped. Stopping at EOL/EOF is supported for the case where the data is coming from the IDMAC (DMA access). In case that only direct accesses is performed, the user should set this field to 0000 0001-1001 stop at the next event of one of the counters (counter #1 to counter #9)
        unsigned DI0_DISP_Y_SEL : 3; //!< DI0 Display Vertical coordinate (Y) select. This field defines which one of the 8 counters will be used as a display's line counter.
        unsigned DI0_PIN8_PIN15_SEL : 1; //!< Reserved. This bit routes PIN8 over PIN15
    } B;
} hw_ipu_di0_general_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_GENERAL register
 */
#define HW_IPU_DI0_GENERAL_ADDR(x)      (REGS_IPU_BASE(x) + 0x40000)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_GENERAL(x)           (*(volatile hw_ipu_di0_general_t *) HW_IPU_DI0_GENERAL_ADDR(x))
#define HW_IPU_DI0_GENERAL_RD(x)        (HW_IPU_DI0_GENERAL(x).U)
#define HW_IPU_DI0_GENERAL_WR(x, v)     (HW_IPU_DI0_GENERAL(x).U = (v))
#define HW_IPU_DI0_GENERAL_SET(x, v)    (HW_IPU_DI0_GENERAL_WR(x, HW_IPU_DI0_GENERAL_RD(x) |  (v)))
#define HW_IPU_DI0_GENERAL_CLR(x, v)    (HW_IPU_DI0_GENERAL_WR(x, HW_IPU_DI0_GENERAL_RD(x) & ~(v)))
#define HW_IPU_DI0_GENERAL_TOG(x, v)    (HW_IPU_DI0_GENERAL_WR(x, HW_IPU_DI0_GENERAL_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_GENERAL bitfields
 */

/* --- Register HW_IPU_DI0_GENERAL, field DI0_POLARITY_ (RW)
 *
 * DI0 output pin's polarity This bits define the polarity of each of the DI's outputs.
 *
 * Values:
 * 0 - The output pin is active low
 * 1 - The output pin is active high
 */

#define BP_IPU_DI0_GENERAL_DI0_POLARITY_      0
#define BM_IPU_DI0_GENERAL_DI0_POLARITY_      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_POLARITY_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_GENERAL_DI0_POLARITY_)
#else
#define BF_IPU_DI0_GENERAL_DI0_POLARITY_(v)   (((v) << 0) & BM_IPU_DI0_GENERAL_DI0_POLARITY_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_POLARITY_ field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_POLARITY_(v)   BF_CS1(IPU_DI0_GENERAL, DI0_POLARITY_, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_POLARITY_CS0 (RW)
 *
 * DI0 Chip Select's 0 polarity This bits define the polarity of the DI's CS0.
 *
 * Values:
 * 1 - The CS0 is active high
 * 0 - The CS0 is active low
 */

#define BP_IPU_DI0_GENERAL_DI0_POLARITY_CS0      8
#define BM_IPU_DI0_GENERAL_DI0_POLARITY_CS0      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_POLARITY_CS0(v)   ((((reg32_t) v) << 8) & BM_IPU_DI0_GENERAL_DI0_POLARITY_CS0)
#else
#define BF_IPU_DI0_GENERAL_DI0_POLARITY_CS0(v)   (((v) << 8) & BM_IPU_DI0_GENERAL_DI0_POLARITY_CS0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_POLARITY_CS0 field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_POLARITY_CS0(v)   BF_CS1(IPU_DI0_GENERAL, DI0_POLARITY_CS0, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_POLARITY_CS1 (RW)
 *
 * DI0 Chip Select's 1 polarity This bits define the polarity of the DI's CS1.
 *
 * Values:
 * 1 - The CS1 is active high
 * 0 - The CS1 is active low
 */

#define BP_IPU_DI0_GENERAL_DI0_POLARITY_CS1      9
#define BM_IPU_DI0_GENERAL_DI0_POLARITY_CS1      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_POLARITY_CS1(v)   ((((reg32_t) v) << 9) & BM_IPU_DI0_GENERAL_DI0_POLARITY_CS1)
#else
#define BF_IPU_DI0_GENERAL_DI0_POLARITY_CS1(v)   (((v) << 9) & BM_IPU_DI0_GENERAL_DI0_POLARITY_CS1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_POLARITY_CS1 field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_POLARITY_CS1(v)   BF_CS1(IPU_DI0_GENERAL, DI0_POLARITY_CS1, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_ERM_VSYNC_SEL (RW)
 *
 * DI0 error recovery block's VSYNC source select The error recovery block detect a case where the
 * DI's VSYNC is asserted before the EOF. This bit selects the source of the VSYNC signal monitored
 * by this mechanism.
 *
 * Values:
 * 1 - vsync_post - an internal VSYNC signal asserted 2 lines after the DI's VSYNC
 * 0 - vsync_pre - an internal VSYNC signal asserted 2 lines before the DI's VSYNC
 */

#define BP_IPU_DI0_GENERAL_DI0_ERM_VSYNC_SEL      10
#define BM_IPU_DI0_GENERAL_DI0_ERM_VSYNC_SEL      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_ERM_VSYNC_SEL(v)   ((((reg32_t) v) << 10) & BM_IPU_DI0_GENERAL_DI0_ERM_VSYNC_SEL)
#else
#define BF_IPU_DI0_GENERAL_DI0_ERM_VSYNC_SEL(v)   (((v) << 10) & BM_IPU_DI0_GENERAL_DI0_ERM_VSYNC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_ERM_VSYNC_SEL field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_ERM_VSYNC_SEL(v)   BF_CS1(IPU_DI0_GENERAL, DI0_ERM_VSYNC_SEL, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_ERR_TREATMENT (RW)
 *
 * In case of synchronous flow error there are 2 ways to handle the display
 *
 * Values:
 * 1 - to wait (stop clock)
 * 0 - Drive the last component
 */

#define BP_IPU_DI0_GENERAL_DI0_ERR_TREATMENT      11
#define BM_IPU_DI0_GENERAL_DI0_ERR_TREATMENT      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_ERR_TREATMENT(v)   ((((reg32_t) v) << 11) & BM_IPU_DI0_GENERAL_DI0_ERR_TREATMENT)
#else
#define BF_IPU_DI0_GENERAL_DI0_ERR_TREATMENT(v)   (((v) << 11) & BM_IPU_DI0_GENERAL_DI0_ERR_TREATMENT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_ERR_TREATMENT field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_ERR_TREATMENT(v)   BF_CS1(IPU_DI0_GENERAL, DI0_ERR_TREATMENT, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_SYNC_COUNT_SEL (RW)
 *
 * For synchronous flow error: selects synchronous flow synchronization counter in DI:
 */

#define BP_IPU_DI0_GENERAL_DI0_SYNC_COUNT_SEL      12
#define BM_IPU_DI0_GENERAL_DI0_SYNC_COUNT_SEL      0x0000f000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_SYNC_COUNT_SEL(v)   ((((reg32_t) v) << 12) & BM_IPU_DI0_GENERAL_DI0_SYNC_COUNT_SEL)
#else
#define BF_IPU_DI0_GENERAL_DI0_SYNC_COUNT_SEL(v)   (((v) << 12) & BM_IPU_DI0_GENERAL_DI0_SYNC_COUNT_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SYNC_COUNT_SEL field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_SYNC_COUNT_SEL(v)   BF_CS1(IPU_DI0_GENERAL, DI0_SYNC_COUNT_SEL, v)
#endif

/* --- Register HW_IPU_DI0_GENERAL, field DI0_POLARITY_DISP_CLK (RW)
 *
 * DI0 Output Clock's polarity This bits define the polarity of the DI0's clock.
 *
 * Values:
 * 1 - The output clock is active high
 * 0 - The output clock is active low
 */

#define BP_IPU_DI0_GENERAL_DI0_POLARITY_DISP_CLK      17
#define BM_IPU_DI0_GENERAL_DI0_POLARITY_DISP_CLK      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_POLARITY_DISP_CLK(v)   ((((reg32_t) v) << 17) & BM_IPU_DI0_GENERAL_DI0_POLARITY_DISP_CLK)
#else
#define BF_IPU_DI0_GENERAL_DI0_POLARITY_DISP_CLK(v)   (((v) << 17) & BM_IPU_DI0_GENERAL_DI0_POLARITY_DISP_CLK)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_POLARITY_DISP_CLK field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_POLARITY_DISP_CLK(v)   BF_CS1(IPU_DI0_GENERAL, DI0_POLARITY_DISP_CLK, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_WATCHDOG_MODE (RW)
 *
 * DI0 watchdog mode In case of a display error where the DI clock is stopped (defined at
 * di0_err_treatment). An internal watchdog counts DI clocks. If this timer reached its pre defined
 * value the DI will skip the current frame and restart on the frame. This 2 bits define the number
 * of DI clock cycles that the timer counts.
 *
 * Values:
 * 00 - The timer counts 4 DI cycles
 * 01 - The timer counts 16 DI cycles
 * 10 - The timer counts 64 DI cycles
 * 11 - The timer counts 128 DI cycles
 */

#define BP_IPU_DI0_GENERAL_DI0_WATCHDOG_MODE      18
#define BM_IPU_DI0_GENERAL_DI0_WATCHDOG_MODE      0x000c0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_WATCHDOG_MODE(v)   ((((reg32_t) v) << 18) & BM_IPU_DI0_GENERAL_DI0_WATCHDOG_MODE)
#else
#define BF_IPU_DI0_GENERAL_DI0_WATCHDOG_MODE(v)   (((v) << 18) & BM_IPU_DI0_GENERAL_DI0_WATCHDOG_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_WATCHDOG_MODE field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_WATCHDOG_MODE(v)   BF_CS1(IPU_DI0_GENERAL, DI0_WATCHDOG_MODE, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_CLK_EXT (RW)
 *
 * DI0 External Clock. This bit selects the source of the DI0's clock
 *
 * Values:
 * 1 - The source of the clock is external to the IPU
 * 0 - The clock is internally generated by the IPU
 */

#define BP_IPU_DI0_GENERAL_DI0_CLK_EXT      20
#define BM_IPU_DI0_GENERAL_DI0_CLK_EXT      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_CLK_EXT(v)   ((((reg32_t) v) << 20) & BM_IPU_DI0_GENERAL_DI0_CLK_EXT)
#else
#define BF_IPU_DI0_GENERAL_DI0_CLK_EXT(v)   (((v) << 20) & BM_IPU_DI0_GENERAL_DI0_CLK_EXT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CLK_EXT field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_CLK_EXT(v)   BF_CS1(IPU_DI0_GENERAL, DI0_CLK_EXT, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_VSYNC_EXT (RW)
 *
 * DI0 External VSYNC. This bit selects the source of the VSYNC signal
 *
 * Values:
 * 1 - External to the IPU
 * 0 - Internally generated by the IPU
 */

#define BP_IPU_DI0_GENERAL_DI0_VSYNC_EXT      21
#define BM_IPU_DI0_GENERAL_DI0_VSYNC_EXT      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_VSYNC_EXT(v)   ((((reg32_t) v) << 21) & BM_IPU_DI0_GENERAL_DI0_VSYNC_EXT)
#else
#define BF_IPU_DI0_GENERAL_DI0_VSYNC_EXT(v)   (((v) << 21) & BM_IPU_DI0_GENERAL_DI0_VSYNC_EXT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_VSYNC_EXT field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_VSYNC_EXT(v)   BF_CS1(IPU_DI0_GENERAL, DI0_VSYNC_EXT, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_MASK_SEL (RW)
 *
 * DI0 Mask select. IPP_PIN_2 output of the DI that functions as MASK signal can come from 2
 * sources: counter #2 or extracted from the MASK data coming from the memory.
 *
 * Values:
 * 1 - IPP_PIN_2 is coming from extracted MASK data coming from the memory
 * 0 - IPP_PIN_2 is coming from counter #2
 */

#define BP_IPU_DI0_GENERAL_DI0_MASK_SEL      22
#define BM_IPU_DI0_GENERAL_DI0_MASK_SEL      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_MASK_SEL(v)   ((((reg32_t) v) << 22) & BM_IPU_DI0_GENERAL_DI0_MASK_SEL)
#else
#define BF_IPU_DI0_GENERAL_DI0_MASK_SEL(v)   (((v) << 22) & BM_IPU_DI0_GENERAL_DI0_MASK_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_MASK_SEL field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_MASK_SEL(v)   BF_CS1(IPU_DI0_GENERAL, DI0_MASK_SEL, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_DISP_CLOCK_INIT (RW)
 *
 * Display clock's initial mode For synchronization error conditions the display clock can be
 * stopped on the next VSYNC
 *
 * Values:
 * 1 - The display's clock is running after the next VSYNC (indicating new frame)
 * 0 - The display's clock is stopped after the next VSYNC (indicating new frame)
 */

#define BP_IPU_DI0_GENERAL_DI0_DISP_CLOCK_INIT      23
#define BM_IPU_DI0_GENERAL_DI0_DISP_CLOCK_INIT      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_DISP_CLOCK_INIT(v)   ((((reg32_t) v) << 23) & BM_IPU_DI0_GENERAL_DI0_DISP_CLOCK_INIT)
#else
#define BF_IPU_DI0_GENERAL_DI0_DISP_CLOCK_INIT(v)   (((v) << 23) & BM_IPU_DI0_GENERAL_DI0_DISP_CLOCK_INIT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DISP_CLOCK_INIT field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_DISP_CLOCK_INIT(v)   BF_CS1(IPU_DI0_GENERAL, DI0_DISP_CLOCK_INIT, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_CLOCK_STOP_MODE (RW)
 *
 * DI clock stop mode When performing a clock change. The DI stops the clock to the display. These
 * field defines when the clock will be stopped. Stopping at EOL/EOF is supported for the case where
 * the data is coming from the IDMAC (DMA access). In case that only direct accesses is performed,
 * the user should set this field to 0000 0001-1001 stop at the next event of one of the counters
 * (counter #1 to counter #9)
 *
 * Values:
 * 0000 - stop at the next edge of the display clock
 * 1100 - stop at EOL (end of a line), but if stop request is during blanking interval, stop now
 * 1101 - stop at EOF (end of a frame), but if stop request is during blanking interval, stop now
 * 1110 - stop at EOL (end of a line), but if stop request is during blanking interval, stop at the end of the
 *     next line
 * 1111 - stop at EOF (end of a frame), but if stop request is during blanking interval, stop at the end of
 *     the next frame
 */

#define BP_IPU_DI0_GENERAL_DI0_CLOCK_STOP_MODE      24
#define BM_IPU_DI0_GENERAL_DI0_CLOCK_STOP_MODE      0x0f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_CLOCK_STOP_MODE(v)   ((((reg32_t) v) << 24) & BM_IPU_DI0_GENERAL_DI0_CLOCK_STOP_MODE)
#else
#define BF_IPU_DI0_GENERAL_DI0_CLOCK_STOP_MODE(v)   (((v) << 24) & BM_IPU_DI0_GENERAL_DI0_CLOCK_STOP_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CLOCK_STOP_MODE field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_CLOCK_STOP_MODE(v)   BF_CS1(IPU_DI0_GENERAL, DI0_CLOCK_STOP_MODE, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_DISP_Y_SEL (RW)
 *
 * DI0 Display Vertical coordinate (Y) select. This field defines which one of the 8 counters will
 * be used as a display's line counter.
 *
 * Values:
 * 000 - counter #1 is selected
 * 111 - counter #8 is selected
 */

#define BP_IPU_DI0_GENERAL_DI0_DISP_Y_SEL      28
#define BM_IPU_DI0_GENERAL_DI0_DISP_Y_SEL      0x70000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_DISP_Y_SEL(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_GENERAL_DI0_DISP_Y_SEL)
#else
#define BF_IPU_DI0_GENERAL_DI0_DISP_Y_SEL(v)   (((v) << 28) & BM_IPU_DI0_GENERAL_DI0_DISP_Y_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DISP_Y_SEL field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_DISP_Y_SEL(v)   BF_CS1(IPU_DI0_GENERAL, DI0_DISP_Y_SEL, v)
#endif


/* --- Register HW_IPU_DI0_GENERAL, field DI0_PIN8_PIN15_SEL (RW)
 *
 * Reserved. This bit routes PIN8 over PIN15
 *
 * Values:
 * 1 - PIN8 is routed to PIN15, PIN8 is also routed to PIN8
 * 0 - PIN15 is routed to PIN15, PIN8 is routed to PIN8
 */

#define BP_IPU_DI0_GENERAL_DI0_PIN8_PIN15_SEL      31
#define BM_IPU_DI0_GENERAL_DI0_PIN8_PIN15_SEL      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_GENERAL_DI0_PIN8_PIN15_SEL(v)   ((((reg32_t) v) << 31) & BM_IPU_DI0_GENERAL_DI0_PIN8_PIN15_SEL)
#else
#define BF_IPU_DI0_GENERAL_DI0_PIN8_PIN15_SEL(v)   (((v) << 31) & BM_IPU_DI0_GENERAL_DI0_PIN8_PIN15_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PIN8_PIN15_SEL field to a new value.
#define BW_IPU_DI0_GENERAL_DI0_PIN8_PIN15_SEL(v)   BF_CS1(IPU_DI0_GENERAL, DI0_PIN8_PIN15_SEL, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_BS_CLKGEN0 - DI0 Base Sync Clock Gen 0 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_DISP_CLK_PERIOD : 12; //!< DI0 Display Clock Period This field defines the Display interface clock period for display write access. This parameter contains an integer part (bits 11:4) and a fractional part (bits 3:0). It defines a fractional division ratio of the HSP_CLK clock for generation of the display's interface clock.
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned DI0_DISP_CLK_OFFSET : 9; //!< DI0 Display Clock Offset The DI has the ability to delay the display's clock This field defines the amount of IPU's clock cycles added as delay on this clock.
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_di0_bs_clkgen0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_BS_CLKGEN0 register
 */
#define HW_IPU_DI0_BS_CLKGEN0_ADDR(x)      (REGS_IPU_BASE(x) + 0x40004)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_BS_CLKGEN0(x)           (*(volatile hw_ipu_di0_bs_clkgen0_t *) HW_IPU_DI0_BS_CLKGEN0_ADDR(x))
#define HW_IPU_DI0_BS_CLKGEN0_RD(x)        (HW_IPU_DI0_BS_CLKGEN0(x).U)
#define HW_IPU_DI0_BS_CLKGEN0_WR(x, v)     (HW_IPU_DI0_BS_CLKGEN0(x).U = (v))
#define HW_IPU_DI0_BS_CLKGEN0_SET(x, v)    (HW_IPU_DI0_BS_CLKGEN0_WR(x, HW_IPU_DI0_BS_CLKGEN0_RD(x) |  (v)))
#define HW_IPU_DI0_BS_CLKGEN0_CLR(x, v)    (HW_IPU_DI0_BS_CLKGEN0_WR(x, HW_IPU_DI0_BS_CLKGEN0_RD(x) & ~(v)))
#define HW_IPU_DI0_BS_CLKGEN0_TOG(x, v)    (HW_IPU_DI0_BS_CLKGEN0_WR(x, HW_IPU_DI0_BS_CLKGEN0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_BS_CLKGEN0 bitfields
 */

/* --- Register HW_IPU_DI0_BS_CLKGEN0, field DI0_DISP_CLK_PERIOD (RW)
 *
 * DI0 Display Clock Period This field defines the Display interface clock period for display write
 * access. This parameter contains an integer part (bits 11:4) and a fractional part (bits 3:0). It
 * defines a fractional division ratio of the HSP_CLK clock for generation of the display's
 * interface clock.
 */

#define BP_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_PERIOD      0
#define BM_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_PERIOD      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_PERIOD(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_PERIOD)
#else
#define BF_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_PERIOD(v)   (((v) << 0) & BM_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_PERIOD)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DISP_CLK_PERIOD field to a new value.
#define BW_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_PERIOD(v)   BF_CS1(IPU_DI0_BS_CLKGEN0, DI0_DISP_CLK_PERIOD, v)
#endif

/* --- Register HW_IPU_DI0_BS_CLKGEN0, field DI0_DISP_CLK_OFFSET (RW)
 *
 * DI0 Display Clock Offset The DI has the ability to delay the display's clock This field defines
 * the amount of IPU's clock cycles added as delay on this clock.
 */

#define BP_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_OFFSET      16
#define BM_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_OFFSET      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_OFFSET(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_OFFSET)
#else
#define BF_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_OFFSET(v)   (((v) << 16) & BM_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_OFFSET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DISP_CLK_OFFSET field to a new value.
#define BW_IPU_DI0_BS_CLKGEN0_DI0_DISP_CLK_OFFSET(v)   BF_CS1(IPU_DI0_BS_CLKGEN0, DI0_DISP_CLK_OFFSET, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_BS_CLKGEN1 - DI0 Base Sync Clock Gen 1 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_DISP_CLK_UP : 9; //!< DI0 display clock rising edge position This parameter contains an integer part (bits 8:1) and a fractional part (bit 0). The position value is a time interval between display's access start point and display's interface clock rising edge.
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DI0_DISP_CLK_DOWN : 9; //!< DI0 display clock falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is a time interval between display's access start point and display's interface clock falling edge.
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_di0_bs_clkgen1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_BS_CLKGEN1 register
 */
#define HW_IPU_DI0_BS_CLKGEN1_ADDR(x)      (REGS_IPU_BASE(x) + 0x40008)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_BS_CLKGEN1(x)           (*(volatile hw_ipu_di0_bs_clkgen1_t *) HW_IPU_DI0_BS_CLKGEN1_ADDR(x))
#define HW_IPU_DI0_BS_CLKGEN1_RD(x)        (HW_IPU_DI0_BS_CLKGEN1(x).U)
#define HW_IPU_DI0_BS_CLKGEN1_WR(x, v)     (HW_IPU_DI0_BS_CLKGEN1(x).U = (v))
#define HW_IPU_DI0_BS_CLKGEN1_SET(x, v)    (HW_IPU_DI0_BS_CLKGEN1_WR(x, HW_IPU_DI0_BS_CLKGEN1_RD(x) |  (v)))
#define HW_IPU_DI0_BS_CLKGEN1_CLR(x, v)    (HW_IPU_DI0_BS_CLKGEN1_WR(x, HW_IPU_DI0_BS_CLKGEN1_RD(x) & ~(v)))
#define HW_IPU_DI0_BS_CLKGEN1_TOG(x, v)    (HW_IPU_DI0_BS_CLKGEN1_WR(x, HW_IPU_DI0_BS_CLKGEN1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_BS_CLKGEN1 bitfields
 */

/* --- Register HW_IPU_DI0_BS_CLKGEN1, field DI0_DISP_CLK_UP (RW)
 *
 * DI0 display clock rising edge position This parameter contains an integer part (bits 8:1) and a
 * fractional part (bit 0). The position value is a time interval between display's access start
 * point and display's interface clock rising edge.
 */

#define BP_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_UP      0
#define BM_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_UP      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_UP(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_UP)
#else
#define BF_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_UP(v)   (((v) << 0) & BM_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_UP)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DISP_CLK_UP field to a new value.
#define BW_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_UP(v)   BF_CS1(IPU_DI0_BS_CLKGEN1, DI0_DISP_CLK_UP, v)
#endif

/* --- Register HW_IPU_DI0_BS_CLKGEN1, field DI0_DISP_CLK_DOWN (RW)
 *
 * DI0 display clock falling edge position This parameter contains an integer part (bits 24:17) and
 * a fractional part (bit 16). The position value is a time interval between display's access start
 * point and display's interface clock falling edge.
 */

#define BP_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_DOWN      16
#define BM_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_DOWN      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_DOWN(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_DOWN)
#else
#define BF_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_DOWN(v)   (((v) << 16) & BM_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_DOWN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DISP_CLK_DOWN field to a new value.
#define BW_IPU_DI0_BS_CLKGEN1_DI0_DISP_CLK_DOWN(v)   BF_CS1(IPU_DI0_BS_CLKGEN1, DI0_DISP_CLK_DOWN, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN0_1 - DI0 Sync Wave Gen 1 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_OFFSET_RESOLUTION_1 : 3; //!< DI0 counter #1 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI0_OFFSET_VALUE_1 : 12; //!< DI0 counter #1 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI0_RUN_RESOLUTION_1 : 3; //!< DI0 counter #1 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI0_RUN_VALUE_M1_1 : 12; //!< DI0 counter #1 pre defined value This fields defines the counter #1 pre defines value. When the counter is auto reload mode (di0_cnt_auto_reload_1 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di0_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen0_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN0_1 register
 */
#define HW_IPU_DI0_SW_GEN0_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x4000c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN0_1(x)           (*(volatile hw_ipu_di0_sw_gen0_1_t *) HW_IPU_DI0_SW_GEN0_1_ADDR(x))
#define HW_IPU_DI0_SW_GEN0_1_RD(x)        (HW_IPU_DI0_SW_GEN0_1(x).U)
#define HW_IPU_DI0_SW_GEN0_1_WR(x, v)     (HW_IPU_DI0_SW_GEN0_1(x).U = (v))
#define HW_IPU_DI0_SW_GEN0_1_SET(x, v)    (HW_IPU_DI0_SW_GEN0_1_WR(x, HW_IPU_DI0_SW_GEN0_1_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN0_1_CLR(x, v)    (HW_IPU_DI0_SW_GEN0_1_WR(x, HW_IPU_DI0_SW_GEN0_1_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN0_1_TOG(x, v)    (HW_IPU_DI0_SW_GEN0_1_WR(x, HW_IPU_DI0_SW_GEN0_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN0_1 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN0_1, field DI0_OFFSET_RESOLUTION_1 (RW)
 *
 * DI0 counter #1 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock
 * 010 - NA
 * 011 - NA
 * 100 - NA
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSIs according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_1_DI0_OFFSET_RESOLUTION_1      0
#define BM_IPU_DI0_SW_GEN0_1_DI0_OFFSET_RESOLUTION_1      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_1_DI0_OFFSET_RESOLUTION_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN0_1_DI0_OFFSET_RESOLUTION_1)
#else
#define BF_IPU_DI0_SW_GEN0_1_DI0_OFFSET_RESOLUTION_1(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN0_1_DI0_OFFSET_RESOLUTION_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_RESOLUTION_1 field to a new value.
#define BW_IPU_DI0_SW_GEN0_1_DI0_OFFSET_RESOLUTION_1(v)   BF_CS1(IPU_DI0_SW_GEN0_1, DI0_OFFSET_RESOLUTION_1, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_1, field DI0_OFFSET_VALUE_1 (RW)
 *
 * DI0 counter #1 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI0_SW_GEN0_1_DI0_OFFSET_VALUE_1      3
#define BM_IPU_DI0_SW_GEN0_1_DI0_OFFSET_VALUE_1      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_1_DI0_OFFSET_VALUE_1(v)   ((((reg32_t) v) << 3) & BM_IPU_DI0_SW_GEN0_1_DI0_OFFSET_VALUE_1)
#else
#define BF_IPU_DI0_SW_GEN0_1_DI0_OFFSET_VALUE_1(v)   (((v) << 3) & BM_IPU_DI0_SW_GEN0_1_DI0_OFFSET_VALUE_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_VALUE_1 field to a new value.
#define BW_IPU_DI0_SW_GEN0_1_DI0_OFFSET_VALUE_1(v)   BF_CS1(IPU_DI0_SW_GEN0_1, DI0_OFFSET_VALUE_1, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN0_1, field DI0_RUN_RESOLUTION_1 (RW)
 *
 * DI0 counter #1 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - NA
 * 011 - NA
 * 100 - NA
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSIs according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_1_DI0_RUN_RESOLUTION_1      16
#define BM_IPU_DI0_SW_GEN0_1_DI0_RUN_RESOLUTION_1      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_1_DI0_RUN_RESOLUTION_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN0_1_DI0_RUN_RESOLUTION_1)
#else
#define BF_IPU_DI0_SW_GEN0_1_DI0_RUN_RESOLUTION_1(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN0_1_DI0_RUN_RESOLUTION_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_RESOLUTION_1 field to a new value.
#define BW_IPU_DI0_SW_GEN0_1_DI0_RUN_RESOLUTION_1(v)   BF_CS1(IPU_DI0_SW_GEN0_1, DI0_RUN_RESOLUTION_1, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_1, field DI0_RUN_VALUE_M1_1 (RW)
 *
 * DI0 counter #1 pre defined value This fields defines the counter #1 pre defines value. When the
 * counter is auto reload mode (di0_cnt_auto_reload_1 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di0_step_repeat field.
 */

#define BP_IPU_DI0_SW_GEN0_1_DI0_RUN_VALUE_M1_1      19
#define BM_IPU_DI0_SW_GEN0_1_DI0_RUN_VALUE_M1_1      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_1_DI0_RUN_VALUE_M1_1(v)   ((((reg32_t) v) << 19) & BM_IPU_DI0_SW_GEN0_1_DI0_RUN_VALUE_M1_1)
#else
#define BF_IPU_DI0_SW_GEN0_1_DI0_RUN_VALUE_M1_1(v)   (((v) << 19) & BM_IPU_DI0_SW_GEN0_1_DI0_RUN_VALUE_M1_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_VALUE_M1_1 field to a new value.
#define BW_IPU_DI0_SW_GEN0_1_DI0_RUN_VALUE_M1_1(v)   BF_CS1(IPU_DI0_SW_GEN0_1, DI0_RUN_VALUE_M1_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN0_2 - DI0 Sync Wave Gen 2 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_OFFSET_RESOLUTION_2 : 3; //!< DI0 counter #2 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI0_OFFSET_VALUE_2 : 12; //!< DI0 counter #2 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DI0_RUN_RESOLUTION_2 : 3; //!< DI0 counter #2 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI0_RUN_VALUE_M1_2 : 12; //!< DI0 counter #2 pre defined value This fields defines the counter #2 pre defines value. When the counter is auto reload mode (di0_cnt_auto_reload_2 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di0_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen0_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN0_2 register
 */
#define HW_IPU_DI0_SW_GEN0_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x40010)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN0_2(x)           (*(volatile hw_ipu_di0_sw_gen0_2_t *) HW_IPU_DI0_SW_GEN0_2_ADDR(x))
#define HW_IPU_DI0_SW_GEN0_2_RD(x)        (HW_IPU_DI0_SW_GEN0_2(x).U)
#define HW_IPU_DI0_SW_GEN0_2_WR(x, v)     (HW_IPU_DI0_SW_GEN0_2(x).U = (v))
#define HW_IPU_DI0_SW_GEN0_2_SET(x, v)    (HW_IPU_DI0_SW_GEN0_2_WR(x, HW_IPU_DI0_SW_GEN0_2_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN0_2_CLR(x, v)    (HW_IPU_DI0_SW_GEN0_2_WR(x, HW_IPU_DI0_SW_GEN0_2_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN0_2_TOG(x, v)    (HW_IPU_DI0_SW_GEN0_2_WR(x, HW_IPU_DI0_SW_GEN0_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN0_2 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN0_2, field DI0_OFFSET_RESOLUTION_2 (RW)
 *
 * DI0 counter #2 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - NA
 * 100 - NA
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSIs according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_2_DI0_OFFSET_RESOLUTION_2      0
#define BM_IPU_DI0_SW_GEN0_2_DI0_OFFSET_RESOLUTION_2      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_2_DI0_OFFSET_RESOLUTION_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN0_2_DI0_OFFSET_RESOLUTION_2)
#else
#define BF_IPU_DI0_SW_GEN0_2_DI0_OFFSET_RESOLUTION_2(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN0_2_DI0_OFFSET_RESOLUTION_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_RESOLUTION_2 field to a new value.
#define BW_IPU_DI0_SW_GEN0_2_DI0_OFFSET_RESOLUTION_2(v)   BF_CS1(IPU_DI0_SW_GEN0_2, DI0_OFFSET_RESOLUTION_2, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_2, field DI0_OFFSET_VALUE_2 (RW)
 *
 * DI0 counter #2 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI0_SW_GEN0_2_DI0_OFFSET_VALUE_2      3
#define BM_IPU_DI0_SW_GEN0_2_DI0_OFFSET_VALUE_2      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_2_DI0_OFFSET_VALUE_2(v)   ((((reg32_t) v) << 3) & BM_IPU_DI0_SW_GEN0_2_DI0_OFFSET_VALUE_2)
#else
#define BF_IPU_DI0_SW_GEN0_2_DI0_OFFSET_VALUE_2(v)   (((v) << 3) & BM_IPU_DI0_SW_GEN0_2_DI0_OFFSET_VALUE_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_VALUE_2 field to a new value.
#define BW_IPU_DI0_SW_GEN0_2_DI0_OFFSET_VALUE_2(v)   BF_CS1(IPU_DI0_SW_GEN0_2, DI0_OFFSET_VALUE_2, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN0_2, field DI0_RUN_RESOLUTION_2 (RW)
 *
 * DI0 counter #2 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock
 * 010 - The Counter is triggered by counter #1
 * 011 - NA
 * 100 - NA
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_2_DI0_RUN_RESOLUTION_2      16
#define BM_IPU_DI0_SW_GEN0_2_DI0_RUN_RESOLUTION_2      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_2_DI0_RUN_RESOLUTION_2(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN0_2_DI0_RUN_RESOLUTION_2)
#else
#define BF_IPU_DI0_SW_GEN0_2_DI0_RUN_RESOLUTION_2(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN0_2_DI0_RUN_RESOLUTION_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_RESOLUTION_2 field to a new value.
#define BW_IPU_DI0_SW_GEN0_2_DI0_RUN_RESOLUTION_2(v)   BF_CS1(IPU_DI0_SW_GEN0_2, DI0_RUN_RESOLUTION_2, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_2, field DI0_RUN_VALUE_M1_2 (RW)
 *
 * DI0 counter #2 pre defined value This fields defines the counter #2 pre defines value. When the
 * counter is auto reload mode (di0_cnt_auto_reload_2 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di0_step_repeat field.
 */

#define BP_IPU_DI0_SW_GEN0_2_DI0_RUN_VALUE_M1_2      19
#define BM_IPU_DI0_SW_GEN0_2_DI0_RUN_VALUE_M1_2      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_2_DI0_RUN_VALUE_M1_2(v)   ((((reg32_t) v) << 19) & BM_IPU_DI0_SW_GEN0_2_DI0_RUN_VALUE_M1_2)
#else
#define BF_IPU_DI0_SW_GEN0_2_DI0_RUN_VALUE_M1_2(v)   (((v) << 19) & BM_IPU_DI0_SW_GEN0_2_DI0_RUN_VALUE_M1_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_VALUE_M1_2 field to a new value.
#define BW_IPU_DI0_SW_GEN0_2_DI0_RUN_VALUE_M1_2(v)   BF_CS1(IPU_DI0_SW_GEN0_2, DI0_RUN_VALUE_M1_2, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN0_3 - DI0 Sync Wave Gen 3 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_OFFSET_RESOLUTION_3 : 3; //!< DI0 counter #3 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI0_OFFSET_VALUE_3 : 12; //!< DI0 counter #3 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DI0_RUN_RESOLUTION_3 : 3; //!< DI0 counter #3 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI0_RUN_VALUE_M1_3 : 12; //!< DI0 counter #3 pre defined value This fields defines the counter #3 pre defines value. When the counter is auto reload mode (di0_cnt_auto_reload_3 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di0_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen0_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN0_3 register
 */
#define HW_IPU_DI0_SW_GEN0_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x40014)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN0_3(x)           (*(volatile hw_ipu_di0_sw_gen0_3_t *) HW_IPU_DI0_SW_GEN0_3_ADDR(x))
#define HW_IPU_DI0_SW_GEN0_3_RD(x)        (HW_IPU_DI0_SW_GEN0_3(x).U)
#define HW_IPU_DI0_SW_GEN0_3_WR(x, v)     (HW_IPU_DI0_SW_GEN0_3(x).U = (v))
#define HW_IPU_DI0_SW_GEN0_3_SET(x, v)    (HW_IPU_DI0_SW_GEN0_3_WR(x, HW_IPU_DI0_SW_GEN0_3_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN0_3_CLR(x, v)    (HW_IPU_DI0_SW_GEN0_3_WR(x, HW_IPU_DI0_SW_GEN0_3_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN0_3_TOG(x, v)    (HW_IPU_DI0_SW_GEN0_3_WR(x, HW_IPU_DI0_SW_GEN0_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN0_3 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN0_3, field DI0_OFFSET_RESOLUTION_3 (RW)
 *
 * DI0 counter #3 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - NA
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_3_DI0_OFFSET_RESOLUTION_3      0
#define BM_IPU_DI0_SW_GEN0_3_DI0_OFFSET_RESOLUTION_3      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_3_DI0_OFFSET_RESOLUTION_3(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN0_3_DI0_OFFSET_RESOLUTION_3)
#else
#define BF_IPU_DI0_SW_GEN0_3_DI0_OFFSET_RESOLUTION_3(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN0_3_DI0_OFFSET_RESOLUTION_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_RESOLUTION_3 field to a new value.
#define BW_IPU_DI0_SW_GEN0_3_DI0_OFFSET_RESOLUTION_3(v)   BF_CS1(IPU_DI0_SW_GEN0_3, DI0_OFFSET_RESOLUTION_3, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_3, field DI0_OFFSET_VALUE_3 (RW)
 *
 * DI0 counter #3 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI0_SW_GEN0_3_DI0_OFFSET_VALUE_3      3
#define BM_IPU_DI0_SW_GEN0_3_DI0_OFFSET_VALUE_3      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_3_DI0_OFFSET_VALUE_3(v)   ((((reg32_t) v) << 3) & BM_IPU_DI0_SW_GEN0_3_DI0_OFFSET_VALUE_3)
#else
#define BF_IPU_DI0_SW_GEN0_3_DI0_OFFSET_VALUE_3(v)   (((v) << 3) & BM_IPU_DI0_SW_GEN0_3_DI0_OFFSET_VALUE_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_VALUE_3 field to a new value.
#define BW_IPU_DI0_SW_GEN0_3_DI0_OFFSET_VALUE_3(v)   BF_CS1(IPU_DI0_SW_GEN0_3, DI0_OFFSET_VALUE_3, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN0_3, field DI0_RUN_RESOLUTION_3 (RW)
 *
 * DI0 counter #3 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - NA
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_3_DI0_RUN_RESOLUTION_3      16
#define BM_IPU_DI0_SW_GEN0_3_DI0_RUN_RESOLUTION_3      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_3_DI0_RUN_RESOLUTION_3(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN0_3_DI0_RUN_RESOLUTION_3)
#else
#define BF_IPU_DI0_SW_GEN0_3_DI0_RUN_RESOLUTION_3(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN0_3_DI0_RUN_RESOLUTION_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_RESOLUTION_3 field to a new value.
#define BW_IPU_DI0_SW_GEN0_3_DI0_RUN_RESOLUTION_3(v)   BF_CS1(IPU_DI0_SW_GEN0_3, DI0_RUN_RESOLUTION_3, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_3, field DI0_RUN_VALUE_M1_3 (RW)
 *
 * DI0 counter #3 pre defined value This fields defines the counter #3 pre defines value. When the
 * counter is auto reload mode (di0_cnt_auto_reload_3 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di0_step_repeat field.
 */

#define BP_IPU_DI0_SW_GEN0_3_DI0_RUN_VALUE_M1_3      19
#define BM_IPU_DI0_SW_GEN0_3_DI0_RUN_VALUE_M1_3      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_3_DI0_RUN_VALUE_M1_3(v)   ((((reg32_t) v) << 19) & BM_IPU_DI0_SW_GEN0_3_DI0_RUN_VALUE_M1_3)
#else
#define BF_IPU_DI0_SW_GEN0_3_DI0_RUN_VALUE_M1_3(v)   (((v) << 19) & BM_IPU_DI0_SW_GEN0_3_DI0_RUN_VALUE_M1_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_VALUE_M1_3 field to a new value.
#define BW_IPU_DI0_SW_GEN0_3_DI0_RUN_VALUE_M1_3(v)   BF_CS1(IPU_DI0_SW_GEN0_3, DI0_RUN_VALUE_M1_3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN0_4 - DI0 Sync Wave Gen 4 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_OFFSET_RESOLUTION_4 : 3; //!< DI0 counter #4 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI0_OFFSET_VALUE_4 : 12; //!< DI0 counter #4 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DI0_RUN_RESOLUTION_4 : 3; //!< DI0 counter #4 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI0_RUN_VALUE_M1_4 : 12; //!< DI0 counter #4 pre defined value This fields defines the counter #4 pre defines value. When the counter is auto reload mode (di0_cnt_auto_reload_4 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di0_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen0_4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN0_4 register
 */
#define HW_IPU_DI0_SW_GEN0_4_ADDR(x)      (REGS_IPU_BASE(x) + 0x40018)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN0_4(x)           (*(volatile hw_ipu_di0_sw_gen0_4_t *) HW_IPU_DI0_SW_GEN0_4_ADDR(x))
#define HW_IPU_DI0_SW_GEN0_4_RD(x)        (HW_IPU_DI0_SW_GEN0_4(x).U)
#define HW_IPU_DI0_SW_GEN0_4_WR(x, v)     (HW_IPU_DI0_SW_GEN0_4(x).U = (v))
#define HW_IPU_DI0_SW_GEN0_4_SET(x, v)    (HW_IPU_DI0_SW_GEN0_4_WR(x, HW_IPU_DI0_SW_GEN0_4_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN0_4_CLR(x, v)    (HW_IPU_DI0_SW_GEN0_4_WR(x, HW_IPU_DI0_SW_GEN0_4_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN0_4_TOG(x, v)    (HW_IPU_DI0_SW_GEN0_4_WR(x, HW_IPU_DI0_SW_GEN0_4_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN0_4 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN0_4, field DI0_OFFSET_RESOLUTION_4 (RW)
 *
 * DI0 counter #4 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_4_DI0_OFFSET_RESOLUTION_4      0
#define BM_IPU_DI0_SW_GEN0_4_DI0_OFFSET_RESOLUTION_4      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_4_DI0_OFFSET_RESOLUTION_4(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN0_4_DI0_OFFSET_RESOLUTION_4)
#else
#define BF_IPU_DI0_SW_GEN0_4_DI0_OFFSET_RESOLUTION_4(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN0_4_DI0_OFFSET_RESOLUTION_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_RESOLUTION_4 field to a new value.
#define BW_IPU_DI0_SW_GEN0_4_DI0_OFFSET_RESOLUTION_4(v)   BF_CS1(IPU_DI0_SW_GEN0_4, DI0_OFFSET_RESOLUTION_4, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_4, field DI0_OFFSET_VALUE_4 (RW)
 *
 * DI0 counter #4 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI0_SW_GEN0_4_DI0_OFFSET_VALUE_4      3
#define BM_IPU_DI0_SW_GEN0_4_DI0_OFFSET_VALUE_4      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_4_DI0_OFFSET_VALUE_4(v)   ((((reg32_t) v) << 3) & BM_IPU_DI0_SW_GEN0_4_DI0_OFFSET_VALUE_4)
#else
#define BF_IPU_DI0_SW_GEN0_4_DI0_OFFSET_VALUE_4(v)   (((v) << 3) & BM_IPU_DI0_SW_GEN0_4_DI0_OFFSET_VALUE_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_VALUE_4 field to a new value.
#define BW_IPU_DI0_SW_GEN0_4_DI0_OFFSET_VALUE_4(v)   BF_CS1(IPU_DI0_SW_GEN0_4, DI0_OFFSET_VALUE_4, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN0_4, field DI0_RUN_RESOLUTION_4 (RW)
 *
 * DI0 counter #4 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_4_DI0_RUN_RESOLUTION_4      16
#define BM_IPU_DI0_SW_GEN0_4_DI0_RUN_RESOLUTION_4      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_4_DI0_RUN_RESOLUTION_4(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN0_4_DI0_RUN_RESOLUTION_4)
#else
#define BF_IPU_DI0_SW_GEN0_4_DI0_RUN_RESOLUTION_4(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN0_4_DI0_RUN_RESOLUTION_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_RESOLUTION_4 field to a new value.
#define BW_IPU_DI0_SW_GEN0_4_DI0_RUN_RESOLUTION_4(v)   BF_CS1(IPU_DI0_SW_GEN0_4, DI0_RUN_RESOLUTION_4, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_4, field DI0_RUN_VALUE_M1_4 (RW)
 *
 * DI0 counter #4 pre defined value This fields defines the counter #4 pre defines value. When the
 * counter is auto reload mode (di0_cnt_auto_reload_4 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di0_step_repeat field.
 */

#define BP_IPU_DI0_SW_GEN0_4_DI0_RUN_VALUE_M1_4      19
#define BM_IPU_DI0_SW_GEN0_4_DI0_RUN_VALUE_M1_4      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_4_DI0_RUN_VALUE_M1_4(v)   ((((reg32_t) v) << 19) & BM_IPU_DI0_SW_GEN0_4_DI0_RUN_VALUE_M1_4)
#else
#define BF_IPU_DI0_SW_GEN0_4_DI0_RUN_VALUE_M1_4(v)   (((v) << 19) & BM_IPU_DI0_SW_GEN0_4_DI0_RUN_VALUE_M1_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_VALUE_M1_4 field to a new value.
#define BW_IPU_DI0_SW_GEN0_4_DI0_RUN_VALUE_M1_4(v)   BF_CS1(IPU_DI0_SW_GEN0_4, DI0_RUN_VALUE_M1_4, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN0_5 - DI0 Sync Wave Gen 5 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_OFFSET_RESOLUTION_5 : 3; //!< DI0 counter #5 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI0_OFFSET_VALUE_5 : 12; //!< DI0 counter #5 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DI0_RUN_RESOLUTION_5 : 3; //!< DI0 counter #5 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI0_RUN_VALUE_M1_5 : 12; //!< DI0 counter #5 pre defined value This fields defines the counter #5 pre defines value. When the counter is auto reload mode (di0_cnt_auto_reload_5 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di0_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen0_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN0_5 register
 */
#define HW_IPU_DI0_SW_GEN0_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x4001c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN0_5(x)           (*(volatile hw_ipu_di0_sw_gen0_5_t *) HW_IPU_DI0_SW_GEN0_5_ADDR(x))
#define HW_IPU_DI0_SW_GEN0_5_RD(x)        (HW_IPU_DI0_SW_GEN0_5(x).U)
#define HW_IPU_DI0_SW_GEN0_5_WR(x, v)     (HW_IPU_DI0_SW_GEN0_5(x).U = (v))
#define HW_IPU_DI0_SW_GEN0_5_SET(x, v)    (HW_IPU_DI0_SW_GEN0_5_WR(x, HW_IPU_DI0_SW_GEN0_5_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN0_5_CLR(x, v)    (HW_IPU_DI0_SW_GEN0_5_WR(x, HW_IPU_DI0_SW_GEN0_5_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN0_5_TOG(x, v)    (HW_IPU_DI0_SW_GEN0_5_WR(x, HW_IPU_DI0_SW_GEN0_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN0_5 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN0_5, field DI0_OFFSET_RESOLUTION_5 (RW)
 *
 * DI0 counter #5 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - -The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_5_DI0_OFFSET_RESOLUTION_5      0
#define BM_IPU_DI0_SW_GEN0_5_DI0_OFFSET_RESOLUTION_5      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_5_DI0_OFFSET_RESOLUTION_5(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN0_5_DI0_OFFSET_RESOLUTION_5)
#else
#define BF_IPU_DI0_SW_GEN0_5_DI0_OFFSET_RESOLUTION_5(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN0_5_DI0_OFFSET_RESOLUTION_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_RESOLUTION_5 field to a new value.
#define BW_IPU_DI0_SW_GEN0_5_DI0_OFFSET_RESOLUTION_5(v)   BF_CS1(IPU_DI0_SW_GEN0_5, DI0_OFFSET_RESOLUTION_5, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_5, field DI0_OFFSET_VALUE_5 (RW)
 *
 * DI0 counter #5 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI0_SW_GEN0_5_DI0_OFFSET_VALUE_5      3
#define BM_IPU_DI0_SW_GEN0_5_DI0_OFFSET_VALUE_5      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_5_DI0_OFFSET_VALUE_5(v)   ((((reg32_t) v) << 3) & BM_IPU_DI0_SW_GEN0_5_DI0_OFFSET_VALUE_5)
#else
#define BF_IPU_DI0_SW_GEN0_5_DI0_OFFSET_VALUE_5(v)   (((v) << 3) & BM_IPU_DI0_SW_GEN0_5_DI0_OFFSET_VALUE_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_VALUE_5 field to a new value.
#define BW_IPU_DI0_SW_GEN0_5_DI0_OFFSET_VALUE_5(v)   BF_CS1(IPU_DI0_SW_GEN0_5, DI0_OFFSET_VALUE_5, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN0_5, field DI0_RUN_RESOLUTION_5 (RW)
 *
 * DI0 counter #5 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_5_DI0_RUN_RESOLUTION_5      16
#define BM_IPU_DI0_SW_GEN0_5_DI0_RUN_RESOLUTION_5      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_5_DI0_RUN_RESOLUTION_5(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN0_5_DI0_RUN_RESOLUTION_5)
#else
#define BF_IPU_DI0_SW_GEN0_5_DI0_RUN_RESOLUTION_5(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN0_5_DI0_RUN_RESOLUTION_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_RESOLUTION_5 field to a new value.
#define BW_IPU_DI0_SW_GEN0_5_DI0_RUN_RESOLUTION_5(v)   BF_CS1(IPU_DI0_SW_GEN0_5, DI0_RUN_RESOLUTION_5, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_5, field DI0_RUN_VALUE_M1_5 (RW)
 *
 * DI0 counter #5 pre defined value This fields defines the counter #5 pre defines value. When the
 * counter is auto reload mode (di0_cnt_auto_reload_5 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di0_step_repeat field.
 */

#define BP_IPU_DI0_SW_GEN0_5_DI0_RUN_VALUE_M1_5      19
#define BM_IPU_DI0_SW_GEN0_5_DI0_RUN_VALUE_M1_5      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_5_DI0_RUN_VALUE_M1_5(v)   ((((reg32_t) v) << 19) & BM_IPU_DI0_SW_GEN0_5_DI0_RUN_VALUE_M1_5)
#else
#define BF_IPU_DI0_SW_GEN0_5_DI0_RUN_VALUE_M1_5(v)   (((v) << 19) & BM_IPU_DI0_SW_GEN0_5_DI0_RUN_VALUE_M1_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_VALUE_M1_5 field to a new value.
#define BW_IPU_DI0_SW_GEN0_5_DI0_RUN_VALUE_M1_5(v)   BF_CS1(IPU_DI0_SW_GEN0_5, DI0_RUN_VALUE_M1_5, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN0_6 - DI0 Sync Wave Gen 6 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_OFFSET_RESOLUTION_6 : 3; //!< DI0 counter #6 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI0_OFFSET_VALUE_6 : 12; //!< DI0 counter #6 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DI0_RUN_RESOLUTION_6 : 3; //!< DI0 counter #6 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI0_RUN_VALUE_M1_6 : 12; //!< DI0 counter #6 pre defined value This fields defines the counter #6 pre defines value. When the counter is auto reload mode (di0_cnt_auto_reload_6 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di0_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen0_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN0_6 register
 */
#define HW_IPU_DI0_SW_GEN0_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x40020)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN0_6(x)           (*(volatile hw_ipu_di0_sw_gen0_6_t *) HW_IPU_DI0_SW_GEN0_6_ADDR(x))
#define HW_IPU_DI0_SW_GEN0_6_RD(x)        (HW_IPU_DI0_SW_GEN0_6(x).U)
#define HW_IPU_DI0_SW_GEN0_6_WR(x, v)     (HW_IPU_DI0_SW_GEN0_6(x).U = (v))
#define HW_IPU_DI0_SW_GEN0_6_SET(x, v)    (HW_IPU_DI0_SW_GEN0_6_WR(x, HW_IPU_DI0_SW_GEN0_6_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN0_6_CLR(x, v)    (HW_IPU_DI0_SW_GEN0_6_WR(x, HW_IPU_DI0_SW_GEN0_6_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN0_6_TOG(x, v)    (HW_IPU_DI0_SW_GEN0_6_WR(x, HW_IPU_DI0_SW_GEN0_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN0_6 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN0_6, field DI0_OFFSET_RESOLUTION_6 (RW)
 *
 * DI0 counter #6 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_6_DI0_OFFSET_RESOLUTION_6      0
#define BM_IPU_DI0_SW_GEN0_6_DI0_OFFSET_RESOLUTION_6      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_6_DI0_OFFSET_RESOLUTION_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN0_6_DI0_OFFSET_RESOLUTION_6)
#else
#define BF_IPU_DI0_SW_GEN0_6_DI0_OFFSET_RESOLUTION_6(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN0_6_DI0_OFFSET_RESOLUTION_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_RESOLUTION_6 field to a new value.
#define BW_IPU_DI0_SW_GEN0_6_DI0_OFFSET_RESOLUTION_6(v)   BF_CS1(IPU_DI0_SW_GEN0_6, DI0_OFFSET_RESOLUTION_6, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_6, field DI0_OFFSET_VALUE_6 (RW)
 *
 * DI0 counter #6 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI0_SW_GEN0_6_DI0_OFFSET_VALUE_6      3
#define BM_IPU_DI0_SW_GEN0_6_DI0_OFFSET_VALUE_6      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_6_DI0_OFFSET_VALUE_6(v)   ((((reg32_t) v) << 3) & BM_IPU_DI0_SW_GEN0_6_DI0_OFFSET_VALUE_6)
#else
#define BF_IPU_DI0_SW_GEN0_6_DI0_OFFSET_VALUE_6(v)   (((v) << 3) & BM_IPU_DI0_SW_GEN0_6_DI0_OFFSET_VALUE_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_VALUE_6 field to a new value.
#define BW_IPU_DI0_SW_GEN0_6_DI0_OFFSET_VALUE_6(v)   BF_CS1(IPU_DI0_SW_GEN0_6, DI0_OFFSET_VALUE_6, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN0_6, field DI0_RUN_RESOLUTION_6 (RW)
 *
 * DI0 counter #6 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_6_DI0_RUN_RESOLUTION_6      16
#define BM_IPU_DI0_SW_GEN0_6_DI0_RUN_RESOLUTION_6      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_6_DI0_RUN_RESOLUTION_6(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN0_6_DI0_RUN_RESOLUTION_6)
#else
#define BF_IPU_DI0_SW_GEN0_6_DI0_RUN_RESOLUTION_6(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN0_6_DI0_RUN_RESOLUTION_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_RESOLUTION_6 field to a new value.
#define BW_IPU_DI0_SW_GEN0_6_DI0_RUN_RESOLUTION_6(v)   BF_CS1(IPU_DI0_SW_GEN0_6, DI0_RUN_RESOLUTION_6, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_6, field DI0_RUN_VALUE_M1_6 (RW)
 *
 * DI0 counter #6 pre defined value This fields defines the counter #6 pre defines value. When the
 * counter is auto reload mode (di0_cnt_auto_reload_6 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di0_step_repeat field.
 */

#define BP_IPU_DI0_SW_GEN0_6_DI0_RUN_VALUE_M1_6      19
#define BM_IPU_DI0_SW_GEN0_6_DI0_RUN_VALUE_M1_6      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_6_DI0_RUN_VALUE_M1_6(v)   ((((reg32_t) v) << 19) & BM_IPU_DI0_SW_GEN0_6_DI0_RUN_VALUE_M1_6)
#else
#define BF_IPU_DI0_SW_GEN0_6_DI0_RUN_VALUE_M1_6(v)   (((v) << 19) & BM_IPU_DI0_SW_GEN0_6_DI0_RUN_VALUE_M1_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_VALUE_M1_6 field to a new value.
#define BW_IPU_DI0_SW_GEN0_6_DI0_RUN_VALUE_M1_6(v)   BF_CS1(IPU_DI0_SW_GEN0_6, DI0_RUN_VALUE_M1_6, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN0_7 - DI0 Sync Wave Gen 7 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_OFFSET_RESOLUTION_1 : 3; //!< DI0 counter #7 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI0_OFFSET_VALUE_7 : 12; //!< DI0 counter #7 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DI0_RUN_RESOLUTION_7 : 3; //!< DI0 counter #1 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI0_RUN_VALUE_M1_7 : 12; //!< DI0 counter #7 pre defined value This fields defines the counter #7 pre defines value. When the counter is auto reload mode (di0_cnt_auto_reload_7 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di0_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen0_7_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN0_7 register
 */
#define HW_IPU_DI0_SW_GEN0_7_ADDR(x)      (REGS_IPU_BASE(x) + 0x40024)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN0_7(x)           (*(volatile hw_ipu_di0_sw_gen0_7_t *) HW_IPU_DI0_SW_GEN0_7_ADDR(x))
#define HW_IPU_DI0_SW_GEN0_7_RD(x)        (HW_IPU_DI0_SW_GEN0_7(x).U)
#define HW_IPU_DI0_SW_GEN0_7_WR(x, v)     (HW_IPU_DI0_SW_GEN0_7(x).U = (v))
#define HW_IPU_DI0_SW_GEN0_7_SET(x, v)    (HW_IPU_DI0_SW_GEN0_7_WR(x, HW_IPU_DI0_SW_GEN0_7_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN0_7_CLR(x, v)    (HW_IPU_DI0_SW_GEN0_7_WR(x, HW_IPU_DI0_SW_GEN0_7_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN0_7_TOG(x, v)    (HW_IPU_DI0_SW_GEN0_7_WR(x, HW_IPU_DI0_SW_GEN0_7_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN0_7 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN0_7, field DI0_OFFSET_RESOLUTION_1 (RW)
 *
 * DI0 counter #7 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_7_DI0_OFFSET_RESOLUTION_1      0
#define BM_IPU_DI0_SW_GEN0_7_DI0_OFFSET_RESOLUTION_1      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_7_DI0_OFFSET_RESOLUTION_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN0_7_DI0_OFFSET_RESOLUTION_1)
#else
#define BF_IPU_DI0_SW_GEN0_7_DI0_OFFSET_RESOLUTION_1(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN0_7_DI0_OFFSET_RESOLUTION_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_RESOLUTION_1 field to a new value.
#define BW_IPU_DI0_SW_GEN0_7_DI0_OFFSET_RESOLUTION_1(v)   BF_CS1(IPU_DI0_SW_GEN0_7, DI0_OFFSET_RESOLUTION_1, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_7, field DI0_OFFSET_VALUE_7 (RW)
 *
 * DI0 counter #7 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI0_SW_GEN0_7_DI0_OFFSET_VALUE_7      3
#define BM_IPU_DI0_SW_GEN0_7_DI0_OFFSET_VALUE_7      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_7_DI0_OFFSET_VALUE_7(v)   ((((reg32_t) v) << 3) & BM_IPU_DI0_SW_GEN0_7_DI0_OFFSET_VALUE_7)
#else
#define BF_IPU_DI0_SW_GEN0_7_DI0_OFFSET_VALUE_7(v)   (((v) << 3) & BM_IPU_DI0_SW_GEN0_7_DI0_OFFSET_VALUE_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_VALUE_7 field to a new value.
#define BW_IPU_DI0_SW_GEN0_7_DI0_OFFSET_VALUE_7(v)   BF_CS1(IPU_DI0_SW_GEN0_7, DI0_OFFSET_VALUE_7, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN0_7, field DI0_RUN_RESOLUTION_7 (RW)
 *
 * DI0 counter #1 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_7_DI0_RUN_RESOLUTION_7      16
#define BM_IPU_DI0_SW_GEN0_7_DI0_RUN_RESOLUTION_7      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_7_DI0_RUN_RESOLUTION_7(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN0_7_DI0_RUN_RESOLUTION_7)
#else
#define BF_IPU_DI0_SW_GEN0_7_DI0_RUN_RESOLUTION_7(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN0_7_DI0_RUN_RESOLUTION_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_RESOLUTION_7 field to a new value.
#define BW_IPU_DI0_SW_GEN0_7_DI0_RUN_RESOLUTION_7(v)   BF_CS1(IPU_DI0_SW_GEN0_7, DI0_RUN_RESOLUTION_7, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_7, field DI0_RUN_VALUE_M1_7 (RW)
 *
 * DI0 counter #7 pre defined value This fields defines the counter #7 pre defines value. When the
 * counter is auto reload mode (di0_cnt_auto_reload_7 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di0_step_repeat field.
 */

#define BP_IPU_DI0_SW_GEN0_7_DI0_RUN_VALUE_M1_7      19
#define BM_IPU_DI0_SW_GEN0_7_DI0_RUN_VALUE_M1_7      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_7_DI0_RUN_VALUE_M1_7(v)   ((((reg32_t) v) << 19) & BM_IPU_DI0_SW_GEN0_7_DI0_RUN_VALUE_M1_7)
#else
#define BF_IPU_DI0_SW_GEN0_7_DI0_RUN_VALUE_M1_7(v)   (((v) << 19) & BM_IPU_DI0_SW_GEN0_7_DI0_RUN_VALUE_M1_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_VALUE_M1_7 field to a new value.
#define BW_IPU_DI0_SW_GEN0_7_DI0_RUN_VALUE_M1_7(v)   BF_CS1(IPU_DI0_SW_GEN0_7, DI0_RUN_VALUE_M1_7, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN0_8 - DI0 Sync Wave Gen 8 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_OFFSET_RESOLUTION_8 : 3; //!< DI0 counter #8 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI0_OFFSET_VALUE_8 : 12; //!< DI0 counter #8 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DI0_RUN_RESOLUTION_8 : 3; //!< DI0 counter #8 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI0_RUN_VALUE_M1_8 : 12; //!< DI0 counter #8 pre defined value This fields defines the counter #8 pre defines value. When the counter is auto reload mode (di0_cnt_auto_reload_8 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di0_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen0_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN0_8 register
 */
#define HW_IPU_DI0_SW_GEN0_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x40028)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN0_8(x)           (*(volatile hw_ipu_di0_sw_gen0_8_t *) HW_IPU_DI0_SW_GEN0_8_ADDR(x))
#define HW_IPU_DI0_SW_GEN0_8_RD(x)        (HW_IPU_DI0_SW_GEN0_8(x).U)
#define HW_IPU_DI0_SW_GEN0_8_WR(x, v)     (HW_IPU_DI0_SW_GEN0_8(x).U = (v))
#define HW_IPU_DI0_SW_GEN0_8_SET(x, v)    (HW_IPU_DI0_SW_GEN0_8_WR(x, HW_IPU_DI0_SW_GEN0_8_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN0_8_CLR(x, v)    (HW_IPU_DI0_SW_GEN0_8_WR(x, HW_IPU_DI0_SW_GEN0_8_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN0_8_TOG(x, v)    (HW_IPU_DI0_SW_GEN0_8_WR(x, HW_IPU_DI0_SW_GEN0_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN0_8 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN0_8, field DI0_OFFSET_RESOLUTION_8 (RW)
 *
 * DI0 counter #8 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_8_DI0_OFFSET_RESOLUTION_8      0
#define BM_IPU_DI0_SW_GEN0_8_DI0_OFFSET_RESOLUTION_8      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_8_DI0_OFFSET_RESOLUTION_8(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN0_8_DI0_OFFSET_RESOLUTION_8)
#else
#define BF_IPU_DI0_SW_GEN0_8_DI0_OFFSET_RESOLUTION_8(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN0_8_DI0_OFFSET_RESOLUTION_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_RESOLUTION_8 field to a new value.
#define BW_IPU_DI0_SW_GEN0_8_DI0_OFFSET_RESOLUTION_8(v)   BF_CS1(IPU_DI0_SW_GEN0_8, DI0_OFFSET_RESOLUTION_8, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_8, field DI0_OFFSET_VALUE_8 (RW)
 *
 * DI0 counter #8 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI0_SW_GEN0_8_DI0_OFFSET_VALUE_8      3
#define BM_IPU_DI0_SW_GEN0_8_DI0_OFFSET_VALUE_8      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_8_DI0_OFFSET_VALUE_8(v)   ((((reg32_t) v) << 3) & BM_IPU_DI0_SW_GEN0_8_DI0_OFFSET_VALUE_8)
#else
#define BF_IPU_DI0_SW_GEN0_8_DI0_OFFSET_VALUE_8(v)   (((v) << 3) & BM_IPU_DI0_SW_GEN0_8_DI0_OFFSET_VALUE_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_VALUE_8 field to a new value.
#define BW_IPU_DI0_SW_GEN0_8_DI0_OFFSET_VALUE_8(v)   BF_CS1(IPU_DI0_SW_GEN0_8, DI0_OFFSET_VALUE_8, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN0_8, field DI0_RUN_RESOLUTION_8 (RW)
 *
 * DI0 counter #8 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_8_DI0_RUN_RESOLUTION_8      16
#define BM_IPU_DI0_SW_GEN0_8_DI0_RUN_RESOLUTION_8      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_8_DI0_RUN_RESOLUTION_8(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN0_8_DI0_RUN_RESOLUTION_8)
#else
#define BF_IPU_DI0_SW_GEN0_8_DI0_RUN_RESOLUTION_8(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN0_8_DI0_RUN_RESOLUTION_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_RESOLUTION_8 field to a new value.
#define BW_IPU_DI0_SW_GEN0_8_DI0_RUN_RESOLUTION_8(v)   BF_CS1(IPU_DI0_SW_GEN0_8, DI0_RUN_RESOLUTION_8, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_8, field DI0_RUN_VALUE_M1_8 (RW)
 *
 * DI0 counter #8 pre defined value This fields defines the counter #8 pre defines value. When the
 * counter is auto reload mode (di0_cnt_auto_reload_8 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di0_step_repeat field.
 */

#define BP_IPU_DI0_SW_GEN0_8_DI0_RUN_VALUE_M1_8      19
#define BM_IPU_DI0_SW_GEN0_8_DI0_RUN_VALUE_M1_8      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_8_DI0_RUN_VALUE_M1_8(v)   ((((reg32_t) v) << 19) & BM_IPU_DI0_SW_GEN0_8_DI0_RUN_VALUE_M1_8)
#else
#define BF_IPU_DI0_SW_GEN0_8_DI0_RUN_VALUE_M1_8(v)   (((v) << 19) & BM_IPU_DI0_SW_GEN0_8_DI0_RUN_VALUE_M1_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_VALUE_M1_8 field to a new value.
#define BW_IPU_DI0_SW_GEN0_8_DI0_RUN_VALUE_M1_8(v)   BF_CS1(IPU_DI0_SW_GEN0_8, DI0_RUN_VALUE_M1_8, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN0_9 - DI0 Sync Wave Gen 9 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_OFFSET_RESOLUTION_9 : 3; //!< DI0 counter #9 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI0_OFFSET_VALUE_9 : 12; //!< DI0 counter #9 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DI0_RUN_RESOLUTION_9 : 3; //!< DI0 counter #9 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI0_RUN_VALUE_M1_9 : 12; //!< DI0 counter #9 pre defined value This fields defines the counter #9 pre defines value. When the counter is auto reload mode (di0_cnt_auto_reload_9 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di0_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen0_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN0_9 register
 */
#define HW_IPU_DI0_SW_GEN0_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x4002c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN0_9(x)           (*(volatile hw_ipu_di0_sw_gen0_9_t *) HW_IPU_DI0_SW_GEN0_9_ADDR(x))
#define HW_IPU_DI0_SW_GEN0_9_RD(x)        (HW_IPU_DI0_SW_GEN0_9(x).U)
#define HW_IPU_DI0_SW_GEN0_9_WR(x, v)     (HW_IPU_DI0_SW_GEN0_9(x).U = (v))
#define HW_IPU_DI0_SW_GEN0_9_SET(x, v)    (HW_IPU_DI0_SW_GEN0_9_WR(x, HW_IPU_DI0_SW_GEN0_9_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN0_9_CLR(x, v)    (HW_IPU_DI0_SW_GEN0_9_WR(x, HW_IPU_DI0_SW_GEN0_9_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN0_9_TOG(x, v)    (HW_IPU_DI0_SW_GEN0_9_WR(x, HW_IPU_DI0_SW_GEN0_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN0_9 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN0_9, field DI0_OFFSET_RESOLUTION_9 (RW)
 *
 * DI0 counter #9 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_9_DI0_OFFSET_RESOLUTION_9      0
#define BM_IPU_DI0_SW_GEN0_9_DI0_OFFSET_RESOLUTION_9      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_9_DI0_OFFSET_RESOLUTION_9(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN0_9_DI0_OFFSET_RESOLUTION_9)
#else
#define BF_IPU_DI0_SW_GEN0_9_DI0_OFFSET_RESOLUTION_9(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN0_9_DI0_OFFSET_RESOLUTION_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_RESOLUTION_9 field to a new value.
#define BW_IPU_DI0_SW_GEN0_9_DI0_OFFSET_RESOLUTION_9(v)   BF_CS1(IPU_DI0_SW_GEN0_9, DI0_OFFSET_RESOLUTION_9, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_9, field DI0_OFFSET_VALUE_9 (RW)
 *
 * DI0 counter #9 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI0_SW_GEN0_9_DI0_OFFSET_VALUE_9      3
#define BM_IPU_DI0_SW_GEN0_9_DI0_OFFSET_VALUE_9      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_9_DI0_OFFSET_VALUE_9(v)   ((((reg32_t) v) << 3) & BM_IPU_DI0_SW_GEN0_9_DI0_OFFSET_VALUE_9)
#else
#define BF_IPU_DI0_SW_GEN0_9_DI0_OFFSET_VALUE_9(v)   (((v) << 3) & BM_IPU_DI0_SW_GEN0_9_DI0_OFFSET_VALUE_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_OFFSET_VALUE_9 field to a new value.
#define BW_IPU_DI0_SW_GEN0_9_DI0_OFFSET_VALUE_9(v)   BF_CS1(IPU_DI0_SW_GEN0_9, DI0_OFFSET_VALUE_9, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN0_9, field DI0_RUN_RESOLUTION_9 (RW)
 *
 * DI0 counter #9 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN0_9_DI0_RUN_RESOLUTION_9      16
#define BM_IPU_DI0_SW_GEN0_9_DI0_RUN_RESOLUTION_9      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_9_DI0_RUN_RESOLUTION_9(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN0_9_DI0_RUN_RESOLUTION_9)
#else
#define BF_IPU_DI0_SW_GEN0_9_DI0_RUN_RESOLUTION_9(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN0_9_DI0_RUN_RESOLUTION_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_RESOLUTION_9 field to a new value.
#define BW_IPU_DI0_SW_GEN0_9_DI0_RUN_RESOLUTION_9(v)   BF_CS1(IPU_DI0_SW_GEN0_9, DI0_RUN_RESOLUTION_9, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN0_9, field DI0_RUN_VALUE_M1_9 (RW)
 *
 * DI0 counter #9 pre defined value This fields defines the counter #9 pre defines value. When the
 * counter is auto reload mode (di0_cnt_auto_reload_9 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di0_step_repeat field.
 */

#define BP_IPU_DI0_SW_GEN0_9_DI0_RUN_VALUE_M1_9      19
#define BM_IPU_DI0_SW_GEN0_9_DI0_RUN_VALUE_M1_9      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN0_9_DI0_RUN_VALUE_M1_9(v)   ((((reg32_t) v) << 19) & BM_IPU_DI0_SW_GEN0_9_DI0_RUN_VALUE_M1_9)
#else
#define BF_IPU_DI0_SW_GEN0_9_DI0_RUN_VALUE_M1_9(v)   (((v) << 19) & BM_IPU_DI0_SW_GEN0_9_DI0_RUN_VALUE_M1_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_RUN_VALUE_M1_9 field to a new value.
#define BW_IPU_DI0_SW_GEN0_9_DI0_RUN_VALUE_M1_9(v)   BF_CS1(IPU_DI0_SW_GEN0_9, DI0_RUN_VALUE_M1_9, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN1_1 - DI0 Sync Wave Gen 1 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_CNT_UP_1 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI0_CNT_POLARITY_CLR_SEL_1 : 3; //!< DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI0_CNT_POLARITY_TRIGGER_SEL_1 : 3; //!< DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI0_CNT_DOWN_1 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI0_CNT_CLR_SEL_1 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI0_CNT_AUTO_RELOAD_1 : 1; //!< Counter auto reload mode
        unsigned DI0_CNT_POLARITY_GEN_EN_1 : 2; //!< DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen1_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN1_1 register
 */
#define HW_IPU_DI0_SW_GEN1_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x40030)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN1_1(x)           (*(volatile hw_ipu_di0_sw_gen1_1_t *) HW_IPU_DI0_SW_GEN1_1_ADDR(x))
#define HW_IPU_DI0_SW_GEN1_1_RD(x)        (HW_IPU_DI0_SW_GEN1_1(x).U)
#define HW_IPU_DI0_SW_GEN1_1_WR(x, v)     (HW_IPU_DI0_SW_GEN1_1(x).U = (v))
#define HW_IPU_DI0_SW_GEN1_1_SET(x, v)    (HW_IPU_DI0_SW_GEN1_1_WR(x, HW_IPU_DI0_SW_GEN1_1_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN1_1_CLR(x, v)    (HW_IPU_DI0_SW_GEN1_1_WR(x, HW_IPU_DI0_SW_GEN1_1_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN1_1_TOG(x, v)    (HW_IPU_DI0_SW_GEN1_1_WR(x, HW_IPU_DI0_SW_GEN1_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN1_1 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN1_1, field DI0_CNT_UP_1 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI0_SW_GEN1_1_DI0_CNT_UP_1      0
#define BM_IPU_DI0_SW_GEN1_1_DI0_CNT_UP_1      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_UP_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_UP_1)
#else
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_UP_1(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_UP_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_UP_1 field to a new value.
#define BW_IPU_DI0_SW_GEN1_1_DI0_CNT_UP_1(v)   BF_CS1(IPU_DI0_SW_GEN1_1, DI0_CNT_UP_1, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_1, field DI0_CNT_POLARITY_CLR_SEL_1 (RW)
 *
 * DI0 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Reserved
 * 011 - Reserved
 * 100 - Reserved
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_CLR_SEL_1      9
#define BM_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_CLR_SEL_1      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_CLR_SEL_1(v)   ((((reg32_t) v) << 9) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_CLR_SEL_1)
#else
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_CLR_SEL_1(v)   (((v) << 9) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_CLR_SEL_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_CLR_SEL_1 field to a new value.
#define BW_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_CLR_SEL_1(v)   BF_CS1(IPU_DI0_SW_GEN1_1, DI0_CNT_POLARITY_CLR_SEL_1, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_1, field DI0_CNT_POLARITY_TRIGGER_SEL_1 (RW)
 *
 * DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - Reserved
 * 011 - Reserved
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_TRIGGER_SEL_1      12
#define BM_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_TRIGGER_SEL_1      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_TRIGGER_SEL_1(v)   ((((reg32_t) v) << 12) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_TRIGGER_SEL_1)
#else
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_TRIGGER_SEL_1(v)   (((v) << 12) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_TRIGGER_SEL_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_TRIGGER_SEL_1 field to a new value.
#define BW_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_TRIGGER_SEL_1(v)   BF_CS1(IPU_DI0_SW_GEN1_1, DI0_CNT_POLARITY_TRIGGER_SEL_1, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_1, field DI0_CNT_DOWN_1 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI0_SW_GEN1_1_DI0_CNT_DOWN_1      16
#define BM_IPU_DI0_SW_GEN1_1_DI0_CNT_DOWN_1      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_DOWN_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_DOWN_1)
#else
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_DOWN_1(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_DOWN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_DOWN_1 field to a new value.
#define BW_IPU_DI0_SW_GEN1_1_DI0_CNT_DOWN_1(v)   BF_CS1(IPU_DI0_SW_GEN1_1, DI0_CNT_DOWN_1, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_1, field DI0_CNT_CLR_SEL_1 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - Reserved
 * 011 - Reserved
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_1_DI0_CNT_CLR_SEL_1      25
#define BM_IPU_DI0_SW_GEN1_1_DI0_CNT_CLR_SEL_1      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_CLR_SEL_1(v)   ((((reg32_t) v) << 25) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_CLR_SEL_1)
#else
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_CLR_SEL_1(v)   (((v) << 25) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_CLR_SEL_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_CLR_SEL_1 field to a new value.
#define BW_IPU_DI0_SW_GEN1_1_DI0_CNT_CLR_SEL_1(v)   BF_CS1(IPU_DI0_SW_GEN1_1, DI0_CNT_CLR_SEL_1, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_1, field DI0_CNT_AUTO_RELOAD_1 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di0_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di0_step_repeat_1 field
 */

#define BP_IPU_DI0_SW_GEN1_1_DI0_CNT_AUTO_RELOAD_1      28
#define BM_IPU_DI0_SW_GEN1_1_DI0_CNT_AUTO_RELOAD_1      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_AUTO_RELOAD_1(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_AUTO_RELOAD_1)
#else
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_AUTO_RELOAD_1(v)   (((v) << 28) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_AUTO_RELOAD_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_AUTO_RELOAD_1 field to a new value.
#define BW_IPU_DI0_SW_GEN1_1_DI0_CNT_AUTO_RELOAD_1(v)   BF_CS1(IPU_DI0_SW_GEN1_1, DI0_CNT_AUTO_RELOAD_1, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_1, field DI0_CNT_POLARITY_GEN_EN_1 (RW)
 *
 * DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_GEN_EN_1      29
#define BM_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_GEN_EN_1      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_GEN_EN_1(v)   ((((reg32_t) v) << 29) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_GEN_EN_1)
#else
#define BF_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_GEN_EN_1(v)   (((v) << 29) & BM_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_GEN_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_GEN_EN_1 field to a new value.
#define BW_IPU_DI0_SW_GEN1_1_DI0_CNT_POLARITY_GEN_EN_1(v)   BF_CS1(IPU_DI0_SW_GEN1_1, DI0_CNT_POLARITY_GEN_EN_1, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN1_2 - DI0 Sync Wave Gen 2 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_CNT_UP_2 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI0_CNT_POLARITY_CLR_SEL_2 : 3; //!< DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI0_CNT_POLARITY_TRIGGER_SEL_2 : 3; //!< DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI0_CNT_DOWN_2 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI0_CNT_CLR_SEL_2 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI0_CNT_AUTO_RELOAD_2 : 1; //!< Counter auto reload mode
        unsigned DI0_CNT_POLARITY_GEN_EN_2 : 2; //!< DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen1_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN1_2 register
 */
#define HW_IPU_DI0_SW_GEN1_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x40034)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN1_2(x)           (*(volatile hw_ipu_di0_sw_gen1_2_t *) HW_IPU_DI0_SW_GEN1_2_ADDR(x))
#define HW_IPU_DI0_SW_GEN1_2_RD(x)        (HW_IPU_DI0_SW_GEN1_2(x).U)
#define HW_IPU_DI0_SW_GEN1_2_WR(x, v)     (HW_IPU_DI0_SW_GEN1_2(x).U = (v))
#define HW_IPU_DI0_SW_GEN1_2_SET(x, v)    (HW_IPU_DI0_SW_GEN1_2_WR(x, HW_IPU_DI0_SW_GEN1_2_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN1_2_CLR(x, v)    (HW_IPU_DI0_SW_GEN1_2_WR(x, HW_IPU_DI0_SW_GEN1_2_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN1_2_TOG(x, v)    (HW_IPU_DI0_SW_GEN1_2_WR(x, HW_IPU_DI0_SW_GEN1_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN1_2 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN1_2, field DI0_CNT_UP_2 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI0_SW_GEN1_2_DI0_CNT_UP_2      0
#define BM_IPU_DI0_SW_GEN1_2_DI0_CNT_UP_2      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_UP_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_UP_2)
#else
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_UP_2(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_UP_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_UP_2 field to a new value.
#define BW_IPU_DI0_SW_GEN1_2_DI0_CNT_UP_2(v)   BF_CS1(IPU_DI0_SW_GEN1_2, DI0_CNT_UP_2, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_2, field DI0_CNT_POLARITY_CLR_SEL_2 (RW)
 *
 * DI0 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Reserved
 * 011 - Reserved
 * 100 - Reserved
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_CLR_SEL_2      9
#define BM_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_CLR_SEL_2      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_CLR_SEL_2(v)   ((((reg32_t) v) << 9) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_CLR_SEL_2)
#else
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_CLR_SEL_2(v)   (((v) << 9) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_CLR_SEL_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_CLR_SEL_2 field to a new value.
#define BW_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_CLR_SEL_2(v)   BF_CS1(IPU_DI0_SW_GEN1_2, DI0_CNT_POLARITY_CLR_SEL_2, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_2, field DI0_CNT_POLARITY_TRIGGER_SEL_2 (RW)
 *
 * DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - Reserved
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_TRIGGER_SEL_2      12
#define BM_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_TRIGGER_SEL_2      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_TRIGGER_SEL_2(v)   ((((reg32_t) v) << 12) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_TRIGGER_SEL_2)
#else
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_TRIGGER_SEL_2(v)   (((v) << 12) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_TRIGGER_SEL_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_TRIGGER_SEL_2 field to a new value.
#define BW_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_TRIGGER_SEL_2(v)   BF_CS1(IPU_DI0_SW_GEN1_2, DI0_CNT_POLARITY_TRIGGER_SEL_2, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_2, field DI0_CNT_DOWN_2 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI0_SW_GEN1_2_DI0_CNT_DOWN_2      16
#define BM_IPU_DI0_SW_GEN1_2_DI0_CNT_DOWN_2      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_DOWN_2(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_DOWN_2)
#else
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_DOWN_2(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_DOWN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_DOWN_2 field to a new value.
#define BW_IPU_DI0_SW_GEN1_2_DI0_CNT_DOWN_2(v)   BF_CS1(IPU_DI0_SW_GEN1_2, DI0_CNT_DOWN_2, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_2, field DI0_CNT_CLR_SEL_2 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - Reserved
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_2_DI0_CNT_CLR_SEL_2      25
#define BM_IPU_DI0_SW_GEN1_2_DI0_CNT_CLR_SEL_2      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_CLR_SEL_2(v)   ((((reg32_t) v) << 25) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_CLR_SEL_2)
#else
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_CLR_SEL_2(v)   (((v) << 25) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_CLR_SEL_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_CLR_SEL_2 field to a new value.
#define BW_IPU_DI0_SW_GEN1_2_DI0_CNT_CLR_SEL_2(v)   BF_CS1(IPU_DI0_SW_GEN1_2, DI0_CNT_CLR_SEL_2, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_2, field DI0_CNT_AUTO_RELOAD_2 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di0_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di0_step_repeat_<i> field
 */

#define BP_IPU_DI0_SW_GEN1_2_DI0_CNT_AUTO_RELOAD_2      28
#define BM_IPU_DI0_SW_GEN1_2_DI0_CNT_AUTO_RELOAD_2      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_AUTO_RELOAD_2(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_AUTO_RELOAD_2)
#else
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_AUTO_RELOAD_2(v)   (((v) << 28) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_AUTO_RELOAD_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_AUTO_RELOAD_2 field to a new value.
#define BW_IPU_DI0_SW_GEN1_2_DI0_CNT_AUTO_RELOAD_2(v)   BF_CS1(IPU_DI0_SW_GEN1_2, DI0_CNT_AUTO_RELOAD_2, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_2, field DI0_CNT_POLARITY_GEN_EN_2 (RW)
 *
 * DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_GEN_EN_2      29
#define BM_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_GEN_EN_2      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_GEN_EN_2(v)   ((((reg32_t) v) << 29) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_GEN_EN_2)
#else
#define BF_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_GEN_EN_2(v)   (((v) << 29) & BM_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_GEN_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_GEN_EN_2 field to a new value.
#define BW_IPU_DI0_SW_GEN1_2_DI0_CNT_POLARITY_GEN_EN_2(v)   BF_CS1(IPU_DI0_SW_GEN1_2, DI0_CNT_POLARITY_GEN_EN_2, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN1_3 - DI0 Sync Wave Gen 3 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_CNT_UP_3 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI0_CNT_POLARITY_CLR_SEL_3 : 3; //!< DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI0_CNT_POLARITY_TRIGGER_SEL_3 : 3; //!< DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI0_CNT_DOWN_3 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI0_CNT_CLR_SEL_3 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI0_CNT_AUTO_RELOAD_3 : 1; //!< Counter auto reload mode
        unsigned DI0_CNT_POLARITY_GEN_EN_3 : 2; //!< DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen1_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN1_3 register
 */
#define HW_IPU_DI0_SW_GEN1_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x40038)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN1_3(x)           (*(volatile hw_ipu_di0_sw_gen1_3_t *) HW_IPU_DI0_SW_GEN1_3_ADDR(x))
#define HW_IPU_DI0_SW_GEN1_3_RD(x)        (HW_IPU_DI0_SW_GEN1_3(x).U)
#define HW_IPU_DI0_SW_GEN1_3_WR(x, v)     (HW_IPU_DI0_SW_GEN1_3(x).U = (v))
#define HW_IPU_DI0_SW_GEN1_3_SET(x, v)    (HW_IPU_DI0_SW_GEN1_3_WR(x, HW_IPU_DI0_SW_GEN1_3_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN1_3_CLR(x, v)    (HW_IPU_DI0_SW_GEN1_3_WR(x, HW_IPU_DI0_SW_GEN1_3_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN1_3_TOG(x, v)    (HW_IPU_DI0_SW_GEN1_3_WR(x, HW_IPU_DI0_SW_GEN1_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN1_3 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN1_3, field DI0_CNT_UP_3 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI0_SW_GEN1_3_DI0_CNT_UP_3      0
#define BM_IPU_DI0_SW_GEN1_3_DI0_CNT_UP_3      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_UP_3(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_UP_3)
#else
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_UP_3(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_UP_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_UP_3 field to a new value.
#define BW_IPU_DI0_SW_GEN1_3_DI0_CNT_UP_3(v)   BF_CS1(IPU_DI0_SW_GEN1_3, DI0_CNT_UP_3, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_3, field DI0_CNT_POLARITY_CLR_SEL_3 (RW)
 *
 * DI0 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Output is inverted if the output of counter #1 is set
 * 011 - Output is inverted if the output of counter #2 is set
 * 100 - Reserved
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_CLR_SEL_3      9
#define BM_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_CLR_SEL_3      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_CLR_SEL_3(v)   ((((reg32_t) v) << 9) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_CLR_SEL_3)
#else
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_CLR_SEL_3(v)   (((v) << 9) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_CLR_SEL_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_CLR_SEL_3 field to a new value.
#define BW_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_CLR_SEL_3(v)   BF_CS1(IPU_DI0_SW_GEN1_3, DI0_CNT_POLARITY_CLR_SEL_3, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_3, field DI0_CNT_POLARITY_TRIGGER_SEL_3 (RW)
 *
 * DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_TRIGGER_SEL_3      12
#define BM_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_TRIGGER_SEL_3      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_TRIGGER_SEL_3(v)   ((((reg32_t) v) << 12) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_TRIGGER_SEL_3)
#else
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_TRIGGER_SEL_3(v)   (((v) << 12) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_TRIGGER_SEL_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_TRIGGER_SEL_3 field to a new value.
#define BW_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_TRIGGER_SEL_3(v)   BF_CS1(IPU_DI0_SW_GEN1_3, DI0_CNT_POLARITY_TRIGGER_SEL_3, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_3, field DI0_CNT_DOWN_3 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI0_SW_GEN1_3_DI0_CNT_DOWN_3      16
#define BM_IPU_DI0_SW_GEN1_3_DI0_CNT_DOWN_3      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_DOWN_3(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_DOWN_3)
#else
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_DOWN_3(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_DOWN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_DOWN_3 field to a new value.
#define BW_IPU_DI0_SW_GEN1_3_DI0_CNT_DOWN_3(v)   BF_CS1(IPU_DI0_SW_GEN1_3, DI0_CNT_DOWN_3, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_3, field DI0_CNT_CLR_SEL_3 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_3_DI0_CNT_CLR_SEL_3      25
#define BM_IPU_DI0_SW_GEN1_3_DI0_CNT_CLR_SEL_3      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_CLR_SEL_3(v)   ((((reg32_t) v) << 25) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_CLR_SEL_3)
#else
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_CLR_SEL_3(v)   (((v) << 25) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_CLR_SEL_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_CLR_SEL_3 field to a new value.
#define BW_IPU_DI0_SW_GEN1_3_DI0_CNT_CLR_SEL_3(v)   BF_CS1(IPU_DI0_SW_GEN1_3, DI0_CNT_CLR_SEL_3, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_3, field DI0_CNT_AUTO_RELOAD_3 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di0_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di0_step_repeat_<i> field
 */

#define BP_IPU_DI0_SW_GEN1_3_DI0_CNT_AUTO_RELOAD_3      28
#define BM_IPU_DI0_SW_GEN1_3_DI0_CNT_AUTO_RELOAD_3      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_AUTO_RELOAD_3(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_AUTO_RELOAD_3)
#else
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_AUTO_RELOAD_3(v)   (((v) << 28) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_AUTO_RELOAD_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_AUTO_RELOAD_3 field to a new value.
#define BW_IPU_DI0_SW_GEN1_3_DI0_CNT_AUTO_RELOAD_3(v)   BF_CS1(IPU_DI0_SW_GEN1_3, DI0_CNT_AUTO_RELOAD_3, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_3, field DI0_CNT_POLARITY_GEN_EN_3 (RW)
 *
 * DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_GEN_EN_3      29
#define BM_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_GEN_EN_3      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_GEN_EN_3(v)   ((((reg32_t) v) << 29) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_GEN_EN_3)
#else
#define BF_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_GEN_EN_3(v)   (((v) << 29) & BM_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_GEN_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_GEN_EN_3 field to a new value.
#define BW_IPU_DI0_SW_GEN1_3_DI0_CNT_POLARITY_GEN_EN_3(v)   BF_CS1(IPU_DI0_SW_GEN1_3, DI0_CNT_POLARITY_GEN_EN_3, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN1_4 - DI0 Sync Wave Gen 4 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_CNT_UP_4 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI0_CNT_POLARITY_CLR_SEL_4 : 3; //!< DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI0_CNT_POLARITY_TRIGGER_SEL_4 : 3; //!< DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI0_CNT_DOWN_4 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI0_CNT_CLR_SEL_4 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI0_CNT_AUTO_RELOAD_4 : 1; //!< Counter auto reload mode
        unsigned DI0_CNT_POLARITY_GEN_EN_4 : 2; //!< DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen1_4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN1_4 register
 */
#define HW_IPU_DI0_SW_GEN1_4_ADDR(x)      (REGS_IPU_BASE(x) + 0x4003c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN1_4(x)           (*(volatile hw_ipu_di0_sw_gen1_4_t *) HW_IPU_DI0_SW_GEN1_4_ADDR(x))
#define HW_IPU_DI0_SW_GEN1_4_RD(x)        (HW_IPU_DI0_SW_GEN1_4(x).U)
#define HW_IPU_DI0_SW_GEN1_4_WR(x, v)     (HW_IPU_DI0_SW_GEN1_4(x).U = (v))
#define HW_IPU_DI0_SW_GEN1_4_SET(x, v)    (HW_IPU_DI0_SW_GEN1_4_WR(x, HW_IPU_DI0_SW_GEN1_4_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN1_4_CLR(x, v)    (HW_IPU_DI0_SW_GEN1_4_WR(x, HW_IPU_DI0_SW_GEN1_4_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN1_4_TOG(x, v)    (HW_IPU_DI0_SW_GEN1_4_WR(x, HW_IPU_DI0_SW_GEN1_4_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN1_4 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN1_4, field DI0_CNT_UP_4 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI0_SW_GEN1_4_DI0_CNT_UP_4      0
#define BM_IPU_DI0_SW_GEN1_4_DI0_CNT_UP_4      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_UP_4(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_UP_4)
#else
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_UP_4(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_UP_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_UP_4 field to a new value.
#define BW_IPU_DI0_SW_GEN1_4_DI0_CNT_UP_4(v)   BF_CS1(IPU_DI0_SW_GEN1_4, DI0_CNT_UP_4, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_4, field DI0_CNT_POLARITY_CLR_SEL_4 (RW)
 *
 * DI0 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Output is inverted if the output of counter #1 is set
 * 011 - Output is inverted if the output of counter #2 is set
 * 100 - Output is inverted if the output of counter #3 is set
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_CLR_SEL_4      9
#define BM_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_CLR_SEL_4      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_CLR_SEL_4(v)   ((((reg32_t) v) << 9) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_CLR_SEL_4)
#else
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_CLR_SEL_4(v)   (((v) << 9) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_CLR_SEL_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_CLR_SEL_4 field to a new value.
#define BW_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_CLR_SEL_4(v)   BF_CS1(IPU_DI0_SW_GEN1_4, DI0_CNT_POLARITY_CLR_SEL_4, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_4, field DI0_CNT_POLARITY_TRIGGER_SEL_4 (RW)
 *
 * DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_TRIGGER_SEL_4      12
#define BM_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_TRIGGER_SEL_4      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_TRIGGER_SEL_4(v)   ((((reg32_t) v) << 12) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_TRIGGER_SEL_4)
#else
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_TRIGGER_SEL_4(v)   (((v) << 12) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_TRIGGER_SEL_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_TRIGGER_SEL_4 field to a new value.
#define BW_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_TRIGGER_SEL_4(v)   BF_CS1(IPU_DI0_SW_GEN1_4, DI0_CNT_POLARITY_TRIGGER_SEL_4, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_4, field DI0_CNT_DOWN_4 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI0_SW_GEN1_4_DI0_CNT_DOWN_4      16
#define BM_IPU_DI0_SW_GEN1_4_DI0_CNT_DOWN_4      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_DOWN_4(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_DOWN_4)
#else
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_DOWN_4(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_DOWN_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_DOWN_4 field to a new value.
#define BW_IPU_DI0_SW_GEN1_4_DI0_CNT_DOWN_4(v)   BF_CS1(IPU_DI0_SW_GEN1_4, DI0_CNT_DOWN_4, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_4, field DI0_CNT_CLR_SEL_4 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_4_DI0_CNT_CLR_SEL_4      25
#define BM_IPU_DI0_SW_GEN1_4_DI0_CNT_CLR_SEL_4      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_CLR_SEL_4(v)   ((((reg32_t) v) << 25) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_CLR_SEL_4)
#else
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_CLR_SEL_4(v)   (((v) << 25) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_CLR_SEL_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_CLR_SEL_4 field to a new value.
#define BW_IPU_DI0_SW_GEN1_4_DI0_CNT_CLR_SEL_4(v)   BF_CS1(IPU_DI0_SW_GEN1_4, DI0_CNT_CLR_SEL_4, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_4, field DI0_CNT_AUTO_RELOAD_4 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di0_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di0_step_repeat_<i> field
 */

#define BP_IPU_DI0_SW_GEN1_4_DI0_CNT_AUTO_RELOAD_4      28
#define BM_IPU_DI0_SW_GEN1_4_DI0_CNT_AUTO_RELOAD_4      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_AUTO_RELOAD_4(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_AUTO_RELOAD_4)
#else
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_AUTO_RELOAD_4(v)   (((v) << 28) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_AUTO_RELOAD_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_AUTO_RELOAD_4 field to a new value.
#define BW_IPU_DI0_SW_GEN1_4_DI0_CNT_AUTO_RELOAD_4(v)   BF_CS1(IPU_DI0_SW_GEN1_4, DI0_CNT_AUTO_RELOAD_4, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_4, field DI0_CNT_POLARITY_GEN_EN_4 (RW)
 *
 * DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_GEN_EN_4      29
#define BM_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_GEN_EN_4      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_GEN_EN_4(v)   ((((reg32_t) v) << 29) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_GEN_EN_4)
#else
#define BF_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_GEN_EN_4(v)   (((v) << 29) & BM_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_GEN_EN_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_GEN_EN_4 field to a new value.
#define BW_IPU_DI0_SW_GEN1_4_DI0_CNT_POLARITY_GEN_EN_4(v)   BF_CS1(IPU_DI0_SW_GEN1_4, DI0_CNT_POLARITY_GEN_EN_4, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN1_5 - DI0 Sync Wave Gen 5 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_CNT_UP_5 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI0_CNT_POLARITY_CLR_SEL_5 : 3; //!< DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI0_CNT_POLARITY_TRIGGER_SEL_5 : 3; //!< DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI0_CNT_DOWN_5 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI0_CNT_CLR_SEL_5 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI0_CNT_AUTO_RELOAD_5 : 1; //!< Counter auto reload mode
        unsigned DI0_CNT_POLARITY_GEN_EN_5 : 2; //!< DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen1_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN1_5 register
 */
#define HW_IPU_DI0_SW_GEN1_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x40040)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN1_5(x)           (*(volatile hw_ipu_di0_sw_gen1_5_t *) HW_IPU_DI0_SW_GEN1_5_ADDR(x))
#define HW_IPU_DI0_SW_GEN1_5_RD(x)        (HW_IPU_DI0_SW_GEN1_5(x).U)
#define HW_IPU_DI0_SW_GEN1_5_WR(x, v)     (HW_IPU_DI0_SW_GEN1_5(x).U = (v))
#define HW_IPU_DI0_SW_GEN1_5_SET(x, v)    (HW_IPU_DI0_SW_GEN1_5_WR(x, HW_IPU_DI0_SW_GEN1_5_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN1_5_CLR(x, v)    (HW_IPU_DI0_SW_GEN1_5_WR(x, HW_IPU_DI0_SW_GEN1_5_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN1_5_TOG(x, v)    (HW_IPU_DI0_SW_GEN1_5_WR(x, HW_IPU_DI0_SW_GEN1_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN1_5 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN1_5, field DI0_CNT_UP_5 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI0_SW_GEN1_5_DI0_CNT_UP_5      0
#define BM_IPU_DI0_SW_GEN1_5_DI0_CNT_UP_5      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_UP_5(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_UP_5)
#else
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_UP_5(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_UP_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_UP_5 field to a new value.
#define BW_IPU_DI0_SW_GEN1_5_DI0_CNT_UP_5(v)   BF_CS1(IPU_DI0_SW_GEN1_5, DI0_CNT_UP_5, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_5, field DI0_CNT_POLARITY_CLR_SEL_5 (RW)
 *
 * DI0 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Output is inverted if the output of counter #1 is set
 * 011 - Output is inverted if the output of counter #2 is set
 * 100 - Output is inverted if the output of counter #3 is set
 * 101 - Output is inverted if the output of counter #4 is set
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_CLR_SEL_5      9
#define BM_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_CLR_SEL_5      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_CLR_SEL_5(v)   ((((reg32_t) v) << 9) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_CLR_SEL_5)
#else
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_CLR_SEL_5(v)   (((v) << 9) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_CLR_SEL_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_CLR_SEL_5 field to a new value.
#define BW_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_CLR_SEL_5(v)   BF_CS1(IPU_DI0_SW_GEN1_5, DI0_CNT_POLARITY_CLR_SEL_5, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_5, field DI0_CNT_POLARITY_TRIGGER_SEL_5 (RW)
 *
 * DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_TRIGGER_SEL_5      12
#define BM_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_TRIGGER_SEL_5      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_TRIGGER_SEL_5(v)   ((((reg32_t) v) << 12) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_TRIGGER_SEL_5)
#else
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_TRIGGER_SEL_5(v)   (((v) << 12) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_TRIGGER_SEL_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_TRIGGER_SEL_5 field to a new value.
#define BW_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_TRIGGER_SEL_5(v)   BF_CS1(IPU_DI0_SW_GEN1_5, DI0_CNT_POLARITY_TRIGGER_SEL_5, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_5, field DI0_CNT_DOWN_5 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI0_SW_GEN1_5_DI0_CNT_DOWN_5      16
#define BM_IPU_DI0_SW_GEN1_5_DI0_CNT_DOWN_5      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_DOWN_5(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_DOWN_5)
#else
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_DOWN_5(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_DOWN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_DOWN_5 field to a new value.
#define BW_IPU_DI0_SW_GEN1_5_DI0_CNT_DOWN_5(v)   BF_CS1(IPU_DI0_SW_GEN1_5, DI0_CNT_DOWN_5, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_5, field DI0_CNT_CLR_SEL_5 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_5_DI0_CNT_CLR_SEL_5      25
#define BM_IPU_DI0_SW_GEN1_5_DI0_CNT_CLR_SEL_5      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_CLR_SEL_5(v)   ((((reg32_t) v) << 25) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_CLR_SEL_5)
#else
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_CLR_SEL_5(v)   (((v) << 25) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_CLR_SEL_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_CLR_SEL_5 field to a new value.
#define BW_IPU_DI0_SW_GEN1_5_DI0_CNT_CLR_SEL_5(v)   BF_CS1(IPU_DI0_SW_GEN1_5, DI0_CNT_CLR_SEL_5, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_5, field DI0_CNT_AUTO_RELOAD_5 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di0_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di0_step_repeat_<i> field
 */

#define BP_IPU_DI0_SW_GEN1_5_DI0_CNT_AUTO_RELOAD_5      28
#define BM_IPU_DI0_SW_GEN1_5_DI0_CNT_AUTO_RELOAD_5      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_AUTO_RELOAD_5(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_AUTO_RELOAD_5)
#else
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_AUTO_RELOAD_5(v)   (((v) << 28) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_AUTO_RELOAD_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_AUTO_RELOAD_5 field to a new value.
#define BW_IPU_DI0_SW_GEN1_5_DI0_CNT_AUTO_RELOAD_5(v)   BF_CS1(IPU_DI0_SW_GEN1_5, DI0_CNT_AUTO_RELOAD_5, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_5, field DI0_CNT_POLARITY_GEN_EN_5 (RW)
 *
 * DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_GEN_EN_5      29
#define BM_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_GEN_EN_5      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_GEN_EN_5(v)   ((((reg32_t) v) << 29) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_GEN_EN_5)
#else
#define BF_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_GEN_EN_5(v)   (((v) << 29) & BM_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_GEN_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_GEN_EN_5 field to a new value.
#define BW_IPU_DI0_SW_GEN1_5_DI0_CNT_POLARITY_GEN_EN_5(v)   BF_CS1(IPU_DI0_SW_GEN1_5, DI0_CNT_POLARITY_GEN_EN_5, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN1_6 - DI0 Sync Wave Gen 6 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_CNT_UP_6 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI0_CNT_POLARITY_CLR_SEL_6 : 3; //!< DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI0_CNT_POLARITY_TRIGGER_SEL_6 : 3; //!< DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI0_CNT_DOWN_6 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI0_CNT_CLR_SEL_6 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI0_CNT_AUTO_RELOAD_6 : 1; //!< Counter auto reload mode
        unsigned DI0_CNT_POLARITY_GEN_EN_6 : 2; //!< DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen1_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN1_6 register
 */
#define HW_IPU_DI0_SW_GEN1_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x40044)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN1_6(x)           (*(volatile hw_ipu_di0_sw_gen1_6_t *) HW_IPU_DI0_SW_GEN1_6_ADDR(x))
#define HW_IPU_DI0_SW_GEN1_6_RD(x)        (HW_IPU_DI0_SW_GEN1_6(x).U)
#define HW_IPU_DI0_SW_GEN1_6_WR(x, v)     (HW_IPU_DI0_SW_GEN1_6(x).U = (v))
#define HW_IPU_DI0_SW_GEN1_6_SET(x, v)    (HW_IPU_DI0_SW_GEN1_6_WR(x, HW_IPU_DI0_SW_GEN1_6_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN1_6_CLR(x, v)    (HW_IPU_DI0_SW_GEN1_6_WR(x, HW_IPU_DI0_SW_GEN1_6_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN1_6_TOG(x, v)    (HW_IPU_DI0_SW_GEN1_6_WR(x, HW_IPU_DI0_SW_GEN1_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN1_6 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN1_6, field DI0_CNT_UP_6 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI0_SW_GEN1_6_DI0_CNT_UP_6      0
#define BM_IPU_DI0_SW_GEN1_6_DI0_CNT_UP_6      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_UP_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_UP_6)
#else
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_UP_6(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_UP_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_UP_6 field to a new value.
#define BW_IPU_DI0_SW_GEN1_6_DI0_CNT_UP_6(v)   BF_CS1(IPU_DI0_SW_GEN1_6, DI0_CNT_UP_6, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_6, field DI0_CNT_POLARITY_CLR_SEL_6 (RW)
 *
 * DI0 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Output is inverted if the output of counter #1 is set
 * 011 - Output is inverted if the output of counter #2 is set
 * 100 - Output is inverted if the output of counter #3 is set
 * 101 - Output is inverted if the output of counter #4 is set
 * 110 - Output is inverted if the output of counter #5 is set
 * 111 - Reserved
 */

#define BP_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_CLR_SEL_6      9
#define BM_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_CLR_SEL_6      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_CLR_SEL_6(v)   ((((reg32_t) v) << 9) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_CLR_SEL_6)
#else
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_CLR_SEL_6(v)   (((v) << 9) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_CLR_SEL_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_CLR_SEL_6 field to a new value.
#define BW_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_CLR_SEL_6(v)   BF_CS1(IPU_DI0_SW_GEN1_6, DI0_CNT_POLARITY_CLR_SEL_6, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_6, field DI0_CNT_POLARITY_TRIGGER_SEL_6 (RW)
 *
 * DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_TRIGGER_SEL_6      12
#define BM_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_TRIGGER_SEL_6      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_TRIGGER_SEL_6(v)   ((((reg32_t) v) << 12) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_TRIGGER_SEL_6)
#else
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_TRIGGER_SEL_6(v)   (((v) << 12) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_TRIGGER_SEL_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_TRIGGER_SEL_6 field to a new value.
#define BW_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_TRIGGER_SEL_6(v)   BF_CS1(IPU_DI0_SW_GEN1_6, DI0_CNT_POLARITY_TRIGGER_SEL_6, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_6, field DI0_CNT_DOWN_6 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI0_SW_GEN1_6_DI0_CNT_DOWN_6      16
#define BM_IPU_DI0_SW_GEN1_6_DI0_CNT_DOWN_6      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_DOWN_6(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_DOWN_6)
#else
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_DOWN_6(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_DOWN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_DOWN_6 field to a new value.
#define BW_IPU_DI0_SW_GEN1_6_DI0_CNT_DOWN_6(v)   BF_CS1(IPU_DI0_SW_GEN1_6, DI0_CNT_DOWN_6, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_6, field DI0_CNT_CLR_SEL_6 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_6_DI0_CNT_CLR_SEL_6      25
#define BM_IPU_DI0_SW_GEN1_6_DI0_CNT_CLR_SEL_6      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_CLR_SEL_6(v)   ((((reg32_t) v) << 25) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_CLR_SEL_6)
#else
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_CLR_SEL_6(v)   (((v) << 25) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_CLR_SEL_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_CLR_SEL_6 field to a new value.
#define BW_IPU_DI0_SW_GEN1_6_DI0_CNT_CLR_SEL_6(v)   BF_CS1(IPU_DI0_SW_GEN1_6, DI0_CNT_CLR_SEL_6, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_6, field DI0_CNT_AUTO_RELOAD_6 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di0_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di0_step_repeat_<i> field
 */

#define BP_IPU_DI0_SW_GEN1_6_DI0_CNT_AUTO_RELOAD_6      28
#define BM_IPU_DI0_SW_GEN1_6_DI0_CNT_AUTO_RELOAD_6      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_AUTO_RELOAD_6(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_AUTO_RELOAD_6)
#else
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_AUTO_RELOAD_6(v)   (((v) << 28) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_AUTO_RELOAD_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_AUTO_RELOAD_6 field to a new value.
#define BW_IPU_DI0_SW_GEN1_6_DI0_CNT_AUTO_RELOAD_6(v)   BF_CS1(IPU_DI0_SW_GEN1_6, DI0_CNT_AUTO_RELOAD_6, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_6, field DI0_CNT_POLARITY_GEN_EN_6 (RW)
 *
 * DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_GEN_EN_6      29
#define BM_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_GEN_EN_6      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_GEN_EN_6(v)   ((((reg32_t) v) << 29) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_GEN_EN_6)
#else
#define BF_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_GEN_EN_6(v)   (((v) << 29) & BM_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_GEN_EN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_GEN_EN_6 field to a new value.
#define BW_IPU_DI0_SW_GEN1_6_DI0_CNT_POLARITY_GEN_EN_6(v)   BF_CS1(IPU_DI0_SW_GEN1_6, DI0_CNT_POLARITY_GEN_EN_6, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN1_7 - DI0 Sync Wave Gen 7 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_CNT_UP_7 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI0_CNT_POLARITY_CLR_SEL_7 : 3; //!< DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI0_CNT_POLARITY_TRIGGER_SEL_7 : 3; //!< DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI0_CNT_DOWN_7 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI0_CNT_CLR_SEL_7 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI0_CNT_AUTO_RELOAD_7 : 1; //!< Counter auto reload mode
        unsigned DI0_CNT_POLARITY_GEN_EN_7 : 2; //!< DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen1_7_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN1_7 register
 */
#define HW_IPU_DI0_SW_GEN1_7_ADDR(x)      (REGS_IPU_BASE(x) + 0x40048)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN1_7(x)           (*(volatile hw_ipu_di0_sw_gen1_7_t *) HW_IPU_DI0_SW_GEN1_7_ADDR(x))
#define HW_IPU_DI0_SW_GEN1_7_RD(x)        (HW_IPU_DI0_SW_GEN1_7(x).U)
#define HW_IPU_DI0_SW_GEN1_7_WR(x, v)     (HW_IPU_DI0_SW_GEN1_7(x).U = (v))
#define HW_IPU_DI0_SW_GEN1_7_SET(x, v)    (HW_IPU_DI0_SW_GEN1_7_WR(x, HW_IPU_DI0_SW_GEN1_7_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN1_7_CLR(x, v)    (HW_IPU_DI0_SW_GEN1_7_WR(x, HW_IPU_DI0_SW_GEN1_7_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN1_7_TOG(x, v)    (HW_IPU_DI0_SW_GEN1_7_WR(x, HW_IPU_DI0_SW_GEN1_7_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN1_7 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN1_7, field DI0_CNT_UP_7 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI0_SW_GEN1_7_DI0_CNT_UP_7      0
#define BM_IPU_DI0_SW_GEN1_7_DI0_CNT_UP_7      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_UP_7(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_UP_7)
#else
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_UP_7(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_UP_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_UP_7 field to a new value.
#define BW_IPU_DI0_SW_GEN1_7_DI0_CNT_UP_7(v)   BF_CS1(IPU_DI0_SW_GEN1_7, DI0_CNT_UP_7, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_7, field DI0_CNT_POLARITY_CLR_SEL_7 (RW)
 *
 * DI0 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Output is inverted if the output of counter #1 is set
 * 011 - Output is inverted if the output of counter #2 is set
 * 100 - Output is inverted if the output of counter #3 is set
 * 101 - Output is inverted if the output of counter #4 is set
 * 110 - Output is inverted if the output of counter #5 is set
 * 111 - Output is inverted if the output of counter #6 is set
 */

#define BP_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_CLR_SEL_7      9
#define BM_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_CLR_SEL_7      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_CLR_SEL_7(v)   ((((reg32_t) v) << 9) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_CLR_SEL_7)
#else
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_CLR_SEL_7(v)   (((v) << 9) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_CLR_SEL_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_CLR_SEL_7 field to a new value.
#define BW_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_CLR_SEL_7(v)   BF_CS1(IPU_DI0_SW_GEN1_7, DI0_CNT_POLARITY_CLR_SEL_7, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_7, field DI0_CNT_POLARITY_TRIGGER_SEL_7 (RW)
 *
 * DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_TRIGGER_SEL_7      12
#define BM_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_TRIGGER_SEL_7      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_TRIGGER_SEL_7(v)   ((((reg32_t) v) << 12) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_TRIGGER_SEL_7)
#else
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_TRIGGER_SEL_7(v)   (((v) << 12) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_TRIGGER_SEL_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_TRIGGER_SEL_7 field to a new value.
#define BW_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_TRIGGER_SEL_7(v)   BF_CS1(IPU_DI0_SW_GEN1_7, DI0_CNT_POLARITY_TRIGGER_SEL_7, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_7, field DI0_CNT_DOWN_7 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI0_SW_GEN1_7_DI0_CNT_DOWN_7      16
#define BM_IPU_DI0_SW_GEN1_7_DI0_CNT_DOWN_7      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_DOWN_7(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_DOWN_7)
#else
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_DOWN_7(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_DOWN_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_DOWN_7 field to a new value.
#define BW_IPU_DI0_SW_GEN1_7_DI0_CNT_DOWN_7(v)   BF_CS1(IPU_DI0_SW_GEN1_7, DI0_CNT_DOWN_7, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_7, field DI0_CNT_CLR_SEL_7 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_7_DI0_CNT_CLR_SEL_7      25
#define BM_IPU_DI0_SW_GEN1_7_DI0_CNT_CLR_SEL_7      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_CLR_SEL_7(v)   ((((reg32_t) v) << 25) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_CLR_SEL_7)
#else
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_CLR_SEL_7(v)   (((v) << 25) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_CLR_SEL_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_CLR_SEL_7 field to a new value.
#define BW_IPU_DI0_SW_GEN1_7_DI0_CNT_CLR_SEL_7(v)   BF_CS1(IPU_DI0_SW_GEN1_7, DI0_CNT_CLR_SEL_7, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_7, field DI0_CNT_AUTO_RELOAD_7 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di0_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di0_step_repeat_<i> field
 */

#define BP_IPU_DI0_SW_GEN1_7_DI0_CNT_AUTO_RELOAD_7      28
#define BM_IPU_DI0_SW_GEN1_7_DI0_CNT_AUTO_RELOAD_7      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_AUTO_RELOAD_7(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_AUTO_RELOAD_7)
#else
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_AUTO_RELOAD_7(v)   (((v) << 28) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_AUTO_RELOAD_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_AUTO_RELOAD_7 field to a new value.
#define BW_IPU_DI0_SW_GEN1_7_DI0_CNT_AUTO_RELOAD_7(v)   BF_CS1(IPU_DI0_SW_GEN1_7, DI0_CNT_AUTO_RELOAD_7, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_7, field DI0_CNT_POLARITY_GEN_EN_7 (RW)
 *
 * DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_GEN_EN_7      29
#define BM_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_GEN_EN_7      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_GEN_EN_7(v)   ((((reg32_t) v) << 29) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_GEN_EN_7)
#else
#define BF_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_GEN_EN_7(v)   (((v) << 29) & BM_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_GEN_EN_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_GEN_EN_7 field to a new value.
#define BW_IPU_DI0_SW_GEN1_7_DI0_CNT_POLARITY_GEN_EN_7(v)   BF_CS1(IPU_DI0_SW_GEN1_7, DI0_CNT_POLARITY_GEN_EN_7, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN1_8 - DI0 Sync Wave Gen 8 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_CNT_UP_8 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI0_CNT_POLARITY_CLR_SEL_8 : 3; //!< DI0 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI0_CNT_POLARITY_TRIGGER_SEL_8 : 3; //!< DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI0_CNT_DOWN_8 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI0_CNT_CLR_SEL_8 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI0_CNT_AUTO_RELOAD_8 : 1; //!< Counter auto reload mode
        unsigned DI0_CNT_POLARITY_GEN_EN_8 : 2; //!< DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di0_sw_gen1_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN1_8 register
 */
#define HW_IPU_DI0_SW_GEN1_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x4004c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN1_8(x)           (*(volatile hw_ipu_di0_sw_gen1_8_t *) HW_IPU_DI0_SW_GEN1_8_ADDR(x))
#define HW_IPU_DI0_SW_GEN1_8_RD(x)        (HW_IPU_DI0_SW_GEN1_8(x).U)
#define HW_IPU_DI0_SW_GEN1_8_WR(x, v)     (HW_IPU_DI0_SW_GEN1_8(x).U = (v))
#define HW_IPU_DI0_SW_GEN1_8_SET(x, v)    (HW_IPU_DI0_SW_GEN1_8_WR(x, HW_IPU_DI0_SW_GEN1_8_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN1_8_CLR(x, v)    (HW_IPU_DI0_SW_GEN1_8_WR(x, HW_IPU_DI0_SW_GEN1_8_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN1_8_TOG(x, v)    (HW_IPU_DI0_SW_GEN1_8_WR(x, HW_IPU_DI0_SW_GEN1_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN1_8 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN1_8, field DI0_CNT_UP_8 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI0_SW_GEN1_8_DI0_CNT_UP_8      0
#define BM_IPU_DI0_SW_GEN1_8_DI0_CNT_UP_8      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_UP_8(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_UP_8)
#else
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_UP_8(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_UP_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_UP_8 field to a new value.
#define BW_IPU_DI0_SW_GEN1_8_DI0_CNT_UP_8(v)   BF_CS1(IPU_DI0_SW_GEN1_8, DI0_CNT_UP_8, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_8, field DI0_CNT_POLARITY_CLR_SEL_8 (RW)
 *
 * DI0 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Output is inverted if the output of counter #1 is set
 * 011 - Output is inverted if the output of counter #2 is set
 * 100 - Output is inverted if the output of counter #3 is set
 * 101 - Output is inverted if the output of counter #4 is set
 * 110 - Output is inverted if the output of counter #5 is set
 * 111 - Output is inverted if the output of counter #6 is set
 */

#define BP_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_CLR_SEL_8      9
#define BM_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_CLR_SEL_8      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_CLR_SEL_8(v)   ((((reg32_t) v) << 9) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_CLR_SEL_8)
#else
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_CLR_SEL_8(v)   (((v) << 9) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_CLR_SEL_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_CLR_SEL_8 field to a new value.
#define BW_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_CLR_SEL_8(v)   BF_CS1(IPU_DI0_SW_GEN1_8, DI0_CNT_POLARITY_CLR_SEL_8, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_8, field DI0_CNT_POLARITY_TRIGGER_SEL_8 (RW)
 *
 * DI0 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_TRIGGER_SEL_8      12
#define BM_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_TRIGGER_SEL_8      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_TRIGGER_SEL_8(v)   ((((reg32_t) v) << 12) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_TRIGGER_SEL_8)
#else
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_TRIGGER_SEL_8(v)   (((v) << 12) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_TRIGGER_SEL_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_TRIGGER_SEL_8 field to a new value.
#define BW_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_TRIGGER_SEL_8(v)   BF_CS1(IPU_DI0_SW_GEN1_8, DI0_CNT_POLARITY_TRIGGER_SEL_8, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_8, field DI0_CNT_DOWN_8 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI0_SW_GEN1_8_DI0_CNT_DOWN_8      16
#define BM_IPU_DI0_SW_GEN1_8_DI0_CNT_DOWN_8      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_DOWN_8(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_DOWN_8)
#else
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_DOWN_8(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_DOWN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_DOWN_8 field to a new value.
#define BW_IPU_DI0_SW_GEN1_8_DI0_CNT_DOWN_8(v)   BF_CS1(IPU_DI0_SW_GEN1_8, DI0_CNT_DOWN_8, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_8, field DI0_CNT_CLR_SEL_8 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_8_DI0_CNT_CLR_SEL_8      25
#define BM_IPU_DI0_SW_GEN1_8_DI0_CNT_CLR_SEL_8      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_CLR_SEL_8(v)   ((((reg32_t) v) << 25) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_CLR_SEL_8)
#else
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_CLR_SEL_8(v)   (((v) << 25) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_CLR_SEL_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_CLR_SEL_8 field to a new value.
#define BW_IPU_DI0_SW_GEN1_8_DI0_CNT_CLR_SEL_8(v)   BF_CS1(IPU_DI0_SW_GEN1_8, DI0_CNT_CLR_SEL_8, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_8, field DI0_CNT_AUTO_RELOAD_8 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di0_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di0_step_repeat_<i> field
 */

#define BP_IPU_DI0_SW_GEN1_8_DI0_CNT_AUTO_RELOAD_8      28
#define BM_IPU_DI0_SW_GEN1_8_DI0_CNT_AUTO_RELOAD_8      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_AUTO_RELOAD_8(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_AUTO_RELOAD_8)
#else
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_AUTO_RELOAD_8(v)   (((v) << 28) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_AUTO_RELOAD_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_AUTO_RELOAD_8 field to a new value.
#define BW_IPU_DI0_SW_GEN1_8_DI0_CNT_AUTO_RELOAD_8(v)   BF_CS1(IPU_DI0_SW_GEN1_8, DI0_CNT_AUTO_RELOAD_8, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_8, field DI0_CNT_POLARITY_GEN_EN_8 (RW)
 *
 * DI0 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_GEN_EN_8      29
#define BM_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_GEN_EN_8      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_GEN_EN_8(v)   ((((reg32_t) v) << 29) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_GEN_EN_8)
#else
#define BF_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_GEN_EN_8(v)   (((v) << 29) & BM_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_GEN_EN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_POLARITY_GEN_EN_8 field to a new value.
#define BW_IPU_DI0_SW_GEN1_8_DI0_CNT_POLARITY_GEN_EN_8(v)   BF_CS1(IPU_DI0_SW_GEN1_8, DI0_CNT_POLARITY_GEN_EN_8, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SW_GEN1_9 - DI0 Sync Wave Gen 9 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_CNT_UP_9 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned RESERVED0 : 6; //!< Reserved
        unsigned DI0_TAG_SEL_9 : 1; //!< Counter #9 can send a synchronous tag when counter #9 reach its predefined value or when it's triggering counter reaches its pre defined value.
        unsigned DI0_CNT_DOWN_9 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI0_CNT_CLR_SEL_9 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI0_CNT_AUTO_RELOAD_9 : 1; //!< Counter auto reload mode
        unsigned DI0_GENTIME_SEL_9 : 3; //!< Counter #9 main waveform select This field defines the counter that counter #9's auxiliary waveform will be attached too.
    } B;
} hw_ipu_di0_sw_gen1_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SW_GEN1_9 register
 */
#define HW_IPU_DI0_SW_GEN1_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x40050)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SW_GEN1_9(x)           (*(volatile hw_ipu_di0_sw_gen1_9_t *) HW_IPU_DI0_SW_GEN1_9_ADDR(x))
#define HW_IPU_DI0_SW_GEN1_9_RD(x)        (HW_IPU_DI0_SW_GEN1_9(x).U)
#define HW_IPU_DI0_SW_GEN1_9_WR(x, v)     (HW_IPU_DI0_SW_GEN1_9(x).U = (v))
#define HW_IPU_DI0_SW_GEN1_9_SET(x, v)    (HW_IPU_DI0_SW_GEN1_9_WR(x, HW_IPU_DI0_SW_GEN1_9_RD(x) |  (v)))
#define HW_IPU_DI0_SW_GEN1_9_CLR(x, v)    (HW_IPU_DI0_SW_GEN1_9_WR(x, HW_IPU_DI0_SW_GEN1_9_RD(x) & ~(v)))
#define HW_IPU_DI0_SW_GEN1_9_TOG(x, v)    (HW_IPU_DI0_SW_GEN1_9_WR(x, HW_IPU_DI0_SW_GEN1_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SW_GEN1_9 bitfields
 */

/* --- Register HW_IPU_DI0_SW_GEN1_9, field DI0_CNT_UP_9 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI0_SW_GEN1_9_DI0_CNT_UP_9      0
#define BM_IPU_DI0_SW_GEN1_9_DI0_CNT_UP_9      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_9_DI0_CNT_UP_9(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SW_GEN1_9_DI0_CNT_UP_9)
#else
#define BF_IPU_DI0_SW_GEN1_9_DI0_CNT_UP_9(v)   (((v) << 0) & BM_IPU_DI0_SW_GEN1_9_DI0_CNT_UP_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_UP_9 field to a new value.
#define BW_IPU_DI0_SW_GEN1_9_DI0_CNT_UP_9(v)   BF_CS1(IPU_DI0_SW_GEN1_9, DI0_CNT_UP_9, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_9, field DI0_TAG_SEL_9 (RW)
 *
 * Counter #9 can send a synchronous tag when counter #9 reach its predefined value or when it's
 * triggering counter reaches its pre defined value.
 *
 * Values:
 * 1 - tag source is counter #9
 * 0 - Tag's source is the triggering counter.
 */

#define BP_IPU_DI0_SW_GEN1_9_DI0_TAG_SEL_9      15
#define BM_IPU_DI0_SW_GEN1_9_DI0_TAG_SEL_9      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_9_DI0_TAG_SEL_9(v)   ((((reg32_t) v) << 15) & BM_IPU_DI0_SW_GEN1_9_DI0_TAG_SEL_9)
#else
#define BF_IPU_DI0_SW_GEN1_9_DI0_TAG_SEL_9(v)   (((v) << 15) & BM_IPU_DI0_SW_GEN1_9_DI0_TAG_SEL_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_TAG_SEL_9 field to a new value.
#define BW_IPU_DI0_SW_GEN1_9_DI0_TAG_SEL_9(v)   BF_CS1(IPU_DI0_SW_GEN1_9, DI0_TAG_SEL_9, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_9, field DI0_CNT_DOWN_9 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI0_SW_GEN1_9_DI0_CNT_DOWN_9      16
#define BM_IPU_DI0_SW_GEN1_9_DI0_CNT_DOWN_9      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_9_DI0_CNT_DOWN_9(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SW_GEN1_9_DI0_CNT_DOWN_9)
#else
#define BF_IPU_DI0_SW_GEN1_9_DI0_CNT_DOWN_9(v)   (((v) << 16) & BM_IPU_DI0_SW_GEN1_9_DI0_CNT_DOWN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_DOWN_9 field to a new value.
#define BW_IPU_DI0_SW_GEN1_9_DI0_CNT_DOWN_9(v)   BF_CS1(IPU_DI0_SW_GEN1_9, DI0_CNT_DOWN_9, v)
#endif

/* --- Register HW_IPU_DI0_SW_GEN1_9, field DI0_CNT_CLR_SEL_9 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI0_SW_GEN1_9_DI0_CNT_CLR_SEL_9      25
#define BM_IPU_DI0_SW_GEN1_9_DI0_CNT_CLR_SEL_9      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_9_DI0_CNT_CLR_SEL_9(v)   ((((reg32_t) v) << 25) & BM_IPU_DI0_SW_GEN1_9_DI0_CNT_CLR_SEL_9)
#else
#define BF_IPU_DI0_SW_GEN1_9_DI0_CNT_CLR_SEL_9(v)   (((v) << 25) & BM_IPU_DI0_SW_GEN1_9_DI0_CNT_CLR_SEL_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_CLR_SEL_9 field to a new value.
#define BW_IPU_DI0_SW_GEN1_9_DI0_CNT_CLR_SEL_9(v)   BF_CS1(IPU_DI0_SW_GEN1_9, DI0_CNT_CLR_SEL_9, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_9, field DI0_CNT_AUTO_RELOAD_9 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di0_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di0_step_repeat_<i> field
 */

#define BP_IPU_DI0_SW_GEN1_9_DI0_CNT_AUTO_RELOAD_9      28
#define BM_IPU_DI0_SW_GEN1_9_DI0_CNT_AUTO_RELOAD_9      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_9_DI0_CNT_AUTO_RELOAD_9(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_SW_GEN1_9_DI0_CNT_AUTO_RELOAD_9)
#else
#define BF_IPU_DI0_SW_GEN1_9_DI0_CNT_AUTO_RELOAD_9(v)   (((v) << 28) & BM_IPU_DI0_SW_GEN1_9_DI0_CNT_AUTO_RELOAD_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CNT_AUTO_RELOAD_9 field to a new value.
#define BW_IPU_DI0_SW_GEN1_9_DI0_CNT_AUTO_RELOAD_9(v)   BF_CS1(IPU_DI0_SW_GEN1_9, DI0_CNT_AUTO_RELOAD_9, v)
#endif


/* --- Register HW_IPU_DI0_SW_GEN1_9, field DI0_GENTIME_SEL_9 (RW)
 *
 * Counter #9 main waveform select This field defines the counter that counter #9's auxiliary
 * waveform will be attached too.
 *
 * Values:
 * 000 - Counter #9's waveform is attached to counter #1's waveform
 * 001 - Counter #9's waveform is attached to counter #2's waveform
 * 010 - Counter #9's waveform is attached to counter #3's waveform
 * 011 - Counter #9's waveform is attached to counter #4's waveform
 * 100 - Counter #9's waveform is attached to counter #5's waveform
 * 101 - Counter #9's waveform is attached to counter #6's waveform
 * 110 - Counter #9's waveform is attached to counter #7's waveform
 * 111 - Counter #9's waveform is attached to counter #8's waveform
 */

#define BP_IPU_DI0_SW_GEN1_9_DI0_GENTIME_SEL_9      29
#define BM_IPU_DI0_SW_GEN1_9_DI0_GENTIME_SEL_9      0xe0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SW_GEN1_9_DI0_GENTIME_SEL_9(v)   ((((reg32_t) v) << 29) & BM_IPU_DI0_SW_GEN1_9_DI0_GENTIME_SEL_9)
#else
#define BF_IPU_DI0_SW_GEN1_9_DI0_GENTIME_SEL_9(v)   (((v) << 29) & BM_IPU_DI0_SW_GEN1_9_DI0_GENTIME_SEL_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_GENTIME_SEL_9 field to a new value.
#define BW_IPU_DI0_SW_GEN1_9_DI0_GENTIME_SEL_9(v)   BF_CS1(IPU_DI0_SW_GEN1_9, DI0_GENTIME_SEL_9, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SYNC_AS_GEN - DI0 Sync Assistance Gen Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_SYNC_START : 12; //!< DI0 Sync start This field defines the number of low (including blanking rows) on the which the DI0 starts preparing the data for the next frame.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DI0_VSYNC_SEL : 3; //!< VSYNC select This field defines which of the counters functions as VSYNC signal
        unsigned RESERVED1 : 12; //!< Reserved
        unsigned DI0_SYNC_START_EN : 1; //!< di0_sync_start_en
        unsigned RESERVED2 : 3; //!< Reserved
    } B;
} hw_ipu_di0_sync_as_gen_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SYNC_AS_GEN register
 */
#define HW_IPU_DI0_SYNC_AS_GEN_ADDR(x)      (REGS_IPU_BASE(x) + 0x40054)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SYNC_AS_GEN(x)           (*(volatile hw_ipu_di0_sync_as_gen_t *) HW_IPU_DI0_SYNC_AS_GEN_ADDR(x))
#define HW_IPU_DI0_SYNC_AS_GEN_RD(x)        (HW_IPU_DI0_SYNC_AS_GEN(x).U)
#define HW_IPU_DI0_SYNC_AS_GEN_WR(x, v)     (HW_IPU_DI0_SYNC_AS_GEN(x).U = (v))
#define HW_IPU_DI0_SYNC_AS_GEN_SET(x, v)    (HW_IPU_DI0_SYNC_AS_GEN_WR(x, HW_IPU_DI0_SYNC_AS_GEN_RD(x) |  (v)))
#define HW_IPU_DI0_SYNC_AS_GEN_CLR(x, v)    (HW_IPU_DI0_SYNC_AS_GEN_WR(x, HW_IPU_DI0_SYNC_AS_GEN_RD(x) & ~(v)))
#define HW_IPU_DI0_SYNC_AS_GEN_TOG(x, v)    (HW_IPU_DI0_SYNC_AS_GEN_WR(x, HW_IPU_DI0_SYNC_AS_GEN_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SYNC_AS_GEN bitfields
 */

/* --- Register HW_IPU_DI0_SYNC_AS_GEN, field DI0_SYNC_START (RW)
 *
 * DI0 Sync start This field defines the number of low (including blanking rows) on the which the
 * DI0 starts preparing the data for the next frame.
 */

#define BP_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START      0
#define BM_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START)
#else
#define BF_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START(v)   (((v) << 0) & BM_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SYNC_START field to a new value.
#define BW_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START(v)   BF_CS1(IPU_DI0_SYNC_AS_GEN, DI0_SYNC_START, v)
#endif

/* --- Register HW_IPU_DI0_SYNC_AS_GEN, field DI0_VSYNC_SEL (RW)
 *
 * VSYNC select This field defines which of the counters functions as VSYNC signal
 *
 * Values:
 * 000 - VSYNC is coming from counter #1
 * 001 - VSYNC is coming from counter #2
 * 111 - VSYNC is coming from counter #8
 */

#define BP_IPU_DI0_SYNC_AS_GEN_DI0_VSYNC_SEL      13
#define BM_IPU_DI0_SYNC_AS_GEN_DI0_VSYNC_SEL      0x0000e000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SYNC_AS_GEN_DI0_VSYNC_SEL(v)   ((((reg32_t) v) << 13) & BM_IPU_DI0_SYNC_AS_GEN_DI0_VSYNC_SEL)
#else
#define BF_IPU_DI0_SYNC_AS_GEN_DI0_VSYNC_SEL(v)   (((v) << 13) & BM_IPU_DI0_SYNC_AS_GEN_DI0_VSYNC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_VSYNC_SEL field to a new value.
#define BW_IPU_DI0_SYNC_AS_GEN_DI0_VSYNC_SEL(v)   BF_CS1(IPU_DI0_SYNC_AS_GEN, DI0_VSYNC_SEL, v)
#endif


/* --- Register HW_IPU_DI0_SYNC_AS_GEN, field DI0_SYNC_START_EN (RW)
 *
 * di0_sync_start_en
 */

#define BP_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START_EN      28
#define BM_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START_EN      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START_EN(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START_EN)
#else
#define BF_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START_EN(v)   (((v) << 28) & BM_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SYNC_START_EN field to a new value.
#define BW_IPU_DI0_SYNC_AS_GEN_DI0_SYNC_START_EN(v)   BF_CS1(IPU_DI0_SYNC_AS_GEN, DI0_SYNC_START_EN, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_DW_GEN_I - DI0 Data Wave Gen <i> Register (RW)
 *
 * The DI0_DW_GEN_<i> register holds pointers for the waveform generators.  These registers have
 * different bit arrangements for parallel and serial display. When using a parallel display VDI
 * Plane Size Register 4 is applicable. When using a serial interface VDI Plane Size Register 4 is
 * applicable.   Register Field Descriptions for Serial Display       Field  Description      31-24
 * di0_serial_period_<i>  DI0 Serial Period <i> This field defines the period of the time base
 * serial display clock. The units are the internal DI clock    23-16 di0_start_period_<i>  DI0
 * start period This field defines the amount of cycles between the point where the access is ready
 * to be launched to the actual point where the time base serial display clock restarts. The units
 * are the internal DI clock    15-14 di0_cst_<i>  DI0 Chip Select pointer for waveform <i> This
 * field points to a register that defines the waveform of the CS pin. For serial displays the down
 * value as defined on DI0_DW_SET*_<i> is measured from the assertion of the last serial display
 * time base clock. 00 The waveform is defined according to the settings on DI0_DW_SET0_<i> 01 The
 * waveform is defined according to the settings on DI0_DW_SET1_<i> 10 The waveform is defined
 * according to the settings on DI0_DW_SET2_<i> 11 The waveform is defined according to the settings
 * on DI0_DW_SET3_<i>    13-9  Reserved    8-4 di0_serial_valid_bits<i>  DI0 Serial valid bits. This
 * field defines the amount of valid bits to be transmitted within the 32 bits internal word aligned
 * to bit[0]. The actual amount of valid bits is di0_serial_valid_bits_<i> + 1    3-2
 * di0_serial_rs_<i>  DI0 Serial RS This field points to a register that defines the waveform of the
 * RS pin. For serial displays the down value as defined on DI0_DW_SET*_<i> is measured from the
 * assertion of the last serial display time base clock. 00 The waveform is defined according to the
 * settings on DI0_DW_SET0_<i> 01 The waveform is defined according to the settings on
 * DI0_DW_SET1_<i> 10 The waveform is defined according to the settings on DI0_DW_SET2_<i> 11 The
 * waveform is defined according to the settings on DI0_DW_SET3_<i>    1-0 di0_serial_clk_<i>  DI0
 * serial clock<i> This field points to a register that defines the waveform of the Serial clock
 * pin. 00 The waveform is defined according to the settings on DI0_DW_SET0_<i> 01 The waveform is
 * defined according to the settings on DI0_DW_SET1_<i> 10 The waveform is defined according to the
 * settings on DI0_DW_SET2_<i> 11 The waveform is defined according to the settings on
 * DI0_DW_SET3_<i>
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_PT_0_ : 2; //!< DI0 PIN_11 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_11 pin.
        unsigned DI0_PT_1_ : 2; //!< DI0 PIN_12 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_12 pin.
        unsigned DI0_PT_2_ : 2; //!< DI0 PIN_13 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_13 pin.
        unsigned DI0_PT_3_ : 2; //!< DI0 PIN_14 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_14 pin.
        unsigned DI0_PT_4_ : 2; //!< DI0 PIN_15 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_15 pin.
        unsigned DI0_PT_5_ : 2; //!< DI0 PIN_16 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_16 pin.
        unsigned DI0_PT_6_ : 2; //!< DI0 PIN_17 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_17 pin.
        unsigned DI0_CST_ : 2; //!< DI0 Chip Select pointer for waveform <i> This field points to a register that defines the waveform of the CS pin. The CS is automatically mapped to a specific display
        unsigned DI0_COMPONNENT_SIZE_ : 8; //!< DI0 component Size This field defines the amount of IPU cycles between any 2 components
        unsigned DI0_ACCESS_SIZE_ : 8; //!< DI0 Access Size <i> This field defines the amount of IPU cycles between any 2 accesses (an access may be a pixel or generic data that may have more one component)
    } B;
} hw_ipu_di0_dw_gen_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_DW_GEN_I register
 */
#define HW_IPU_DI0_DW_GEN_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x40058)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_DW_GEN_I(x)           (*(volatile hw_ipu_di0_dw_gen_i_t *) HW_IPU_DI0_DW_GEN_I_ADDR(x))
#define HW_IPU_DI0_DW_GEN_I_RD(x)        (HW_IPU_DI0_DW_GEN_I(x).U)
#define HW_IPU_DI0_DW_GEN_I_WR(x, v)     (HW_IPU_DI0_DW_GEN_I(x).U = (v))
#define HW_IPU_DI0_DW_GEN_I_SET(x, v)    (HW_IPU_DI0_DW_GEN_I_WR(x, HW_IPU_DI0_DW_GEN_I_RD(x) |  (v)))
#define HW_IPU_DI0_DW_GEN_I_CLR(x, v)    (HW_IPU_DI0_DW_GEN_I_WR(x, HW_IPU_DI0_DW_GEN_I_RD(x) & ~(v)))
#define HW_IPU_DI0_DW_GEN_I_TOG(x, v)    (HW_IPU_DI0_DW_GEN_I_WR(x, HW_IPU_DI0_DW_GEN_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_DW_GEN_I bitfields
 */

/* --- Register HW_IPU_DI0_DW_GEN_I, field DI0_PT_0_ (RW)
 *
 * DI0 PIN_11 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_11 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI0_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI0_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI0_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI0_DW_SET3_<i>
 */

#define BP_IPU_DI0_DW_GEN_I_DI0_PT_0_      0
#define BM_IPU_DI0_DW_GEN_I_DI0_PT_0_      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_0_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_DW_GEN_I_DI0_PT_0_)
#else
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_0_(v)   (((v) << 0) & BM_IPU_DI0_DW_GEN_I_DI0_PT_0_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PT_0_ field to a new value.
#define BW_IPU_DI0_DW_GEN_I_DI0_PT_0_(v)   BF_CS1(IPU_DI0_DW_GEN_I, DI0_PT_0_, v)
#endif


/* --- Register HW_IPU_DI0_DW_GEN_I, field DI0_PT_1_ (RW)
 *
 * DI0 PIN_12 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_12 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI0_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI0_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI0_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI0_DW_SET3_<i>
 */

#define BP_IPU_DI0_DW_GEN_I_DI0_PT_1_      2
#define BM_IPU_DI0_DW_GEN_I_DI0_PT_1_      0x0000000c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_1_(v)   ((((reg32_t) v) << 2) & BM_IPU_DI0_DW_GEN_I_DI0_PT_1_)
#else
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_1_(v)   (((v) << 2) & BM_IPU_DI0_DW_GEN_I_DI0_PT_1_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PT_1_ field to a new value.
#define BW_IPU_DI0_DW_GEN_I_DI0_PT_1_(v)   BF_CS1(IPU_DI0_DW_GEN_I, DI0_PT_1_, v)
#endif


/* --- Register HW_IPU_DI0_DW_GEN_I, field DI0_PT_2_ (RW)
 *
 * DI0 PIN_13 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_13 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI0_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI0_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI0_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI0_DW_SET3_<i>
 */

#define BP_IPU_DI0_DW_GEN_I_DI0_PT_2_      4
#define BM_IPU_DI0_DW_GEN_I_DI0_PT_2_      0x00000030

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_2_(v)   ((((reg32_t) v) << 4) & BM_IPU_DI0_DW_GEN_I_DI0_PT_2_)
#else
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_2_(v)   (((v) << 4) & BM_IPU_DI0_DW_GEN_I_DI0_PT_2_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PT_2_ field to a new value.
#define BW_IPU_DI0_DW_GEN_I_DI0_PT_2_(v)   BF_CS1(IPU_DI0_DW_GEN_I, DI0_PT_2_, v)
#endif


/* --- Register HW_IPU_DI0_DW_GEN_I, field DI0_PT_3_ (RW)
 *
 * DI0 PIN_14 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_14 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI0_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI0_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI0_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI0_DW_SET3_<i>
 */

#define BP_IPU_DI0_DW_GEN_I_DI0_PT_3_      6
#define BM_IPU_DI0_DW_GEN_I_DI0_PT_3_      0x000000c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_3_(v)   ((((reg32_t) v) << 6) & BM_IPU_DI0_DW_GEN_I_DI0_PT_3_)
#else
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_3_(v)   (((v) << 6) & BM_IPU_DI0_DW_GEN_I_DI0_PT_3_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PT_3_ field to a new value.
#define BW_IPU_DI0_DW_GEN_I_DI0_PT_3_(v)   BF_CS1(IPU_DI0_DW_GEN_I, DI0_PT_3_, v)
#endif


/* --- Register HW_IPU_DI0_DW_GEN_I, field DI0_PT_4_ (RW)
 *
 * DI0 PIN_15 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_15 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI0_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI0_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI0_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI0_DW_SET3_<i>
 */

#define BP_IPU_DI0_DW_GEN_I_DI0_PT_4_      8
#define BM_IPU_DI0_DW_GEN_I_DI0_PT_4_      0x00000300

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_4_(v)   ((((reg32_t) v) << 8) & BM_IPU_DI0_DW_GEN_I_DI0_PT_4_)
#else
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_4_(v)   (((v) << 8) & BM_IPU_DI0_DW_GEN_I_DI0_PT_4_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PT_4_ field to a new value.
#define BW_IPU_DI0_DW_GEN_I_DI0_PT_4_(v)   BF_CS1(IPU_DI0_DW_GEN_I, DI0_PT_4_, v)
#endif


/* --- Register HW_IPU_DI0_DW_GEN_I, field DI0_PT_5_ (RW)
 *
 * DI0 PIN_16 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_16 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI0_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI0_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI0_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI0_DW_SET3_<i>
 */

#define BP_IPU_DI0_DW_GEN_I_DI0_PT_5_      10
#define BM_IPU_DI0_DW_GEN_I_DI0_PT_5_      0x00000c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_5_(v)   ((((reg32_t) v) << 10) & BM_IPU_DI0_DW_GEN_I_DI0_PT_5_)
#else
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_5_(v)   (((v) << 10) & BM_IPU_DI0_DW_GEN_I_DI0_PT_5_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PT_5_ field to a new value.
#define BW_IPU_DI0_DW_GEN_I_DI0_PT_5_(v)   BF_CS1(IPU_DI0_DW_GEN_I, DI0_PT_5_, v)
#endif


/* --- Register HW_IPU_DI0_DW_GEN_I, field DI0_PT_6_ (RW)
 *
 * DI0 PIN_17 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_17 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI0_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI0_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI0_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI0_DW_SET3_<i>
 */

#define BP_IPU_DI0_DW_GEN_I_DI0_PT_6_      12
#define BM_IPU_DI0_DW_GEN_I_DI0_PT_6_      0x00003000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_6_(v)   ((((reg32_t) v) << 12) & BM_IPU_DI0_DW_GEN_I_DI0_PT_6_)
#else
#define BF_IPU_DI0_DW_GEN_I_DI0_PT_6_(v)   (((v) << 12) & BM_IPU_DI0_DW_GEN_I_DI0_PT_6_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PT_6_ field to a new value.
#define BW_IPU_DI0_DW_GEN_I_DI0_PT_6_(v)   BF_CS1(IPU_DI0_DW_GEN_I, DI0_PT_6_, v)
#endif


/* --- Register HW_IPU_DI0_DW_GEN_I, field DI0_CST_ (RW)
 *
 * DI0 Chip Select pointer for waveform <i> This field points to a register that defines the
 * waveform of the CS pin. The CS is automatically mapped to a specific display
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI0_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI0_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI0_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI0_DW_SET3_<i>
 */

#define BP_IPU_DI0_DW_GEN_I_DI0_CST_      14
#define BM_IPU_DI0_DW_GEN_I_DI0_CST_      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_GEN_I_DI0_CST_(v)   ((((reg32_t) v) << 14) & BM_IPU_DI0_DW_GEN_I_DI0_CST_)
#else
#define BF_IPU_DI0_DW_GEN_I_DI0_CST_(v)   (((v) << 14) & BM_IPU_DI0_DW_GEN_I_DI0_CST_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CST_ field to a new value.
#define BW_IPU_DI0_DW_GEN_I_DI0_CST_(v)   BF_CS1(IPU_DI0_DW_GEN_I, DI0_CST_, v)
#endif


/* --- Register HW_IPU_DI0_DW_GEN_I, field DI0_COMPONNENT_SIZE_ (RW)
 *
 * DI0 component Size This field defines the amount of IPU cycles between any 2 components
 */

#define BP_IPU_DI0_DW_GEN_I_DI0_COMPONNENT_SIZE_      16
#define BM_IPU_DI0_DW_GEN_I_DI0_COMPONNENT_SIZE_      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_GEN_I_DI0_COMPONNENT_SIZE_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_DW_GEN_I_DI0_COMPONNENT_SIZE_)
#else
#define BF_IPU_DI0_DW_GEN_I_DI0_COMPONNENT_SIZE_(v)   (((v) << 16) & BM_IPU_DI0_DW_GEN_I_DI0_COMPONNENT_SIZE_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_COMPONNENT_SIZE_ field to a new value.
#define BW_IPU_DI0_DW_GEN_I_DI0_COMPONNENT_SIZE_(v)   BF_CS1(IPU_DI0_DW_GEN_I, DI0_COMPONNENT_SIZE_, v)
#endif

/* --- Register HW_IPU_DI0_DW_GEN_I, field DI0_ACCESS_SIZE_ (RW)
 *
 * DI0 Access Size <i> This field defines the amount of IPU cycles between any 2 accesses (an access
 * may be a pixel or generic data that may have more one component)
 */

#define BP_IPU_DI0_DW_GEN_I_DI0_ACCESS_SIZE_      24
#define BM_IPU_DI0_DW_GEN_I_DI0_ACCESS_SIZE_      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_GEN_I_DI0_ACCESS_SIZE_(v)   ((((reg32_t) v) << 24) & BM_IPU_DI0_DW_GEN_I_DI0_ACCESS_SIZE_)
#else
#define BF_IPU_DI0_DW_GEN_I_DI0_ACCESS_SIZE_(v)   (((v) << 24) & BM_IPU_DI0_DW_GEN_I_DI0_ACCESS_SIZE_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_ACCESS_SIZE_ field to a new value.
#define BW_IPU_DI0_DW_GEN_I_DI0_ACCESS_SIZE_(v)   BF_CS1(IPU_DI0_DW_GEN_I, DI0_ACCESS_SIZE_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_DW_SET0_I - DI0 Data Wave Set 0 <i> Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_DATA_CNT_UP0_ : 9; //!< Waveform's rising edge position. This field defines the Waveform's rising edge position. The Waveform is mapped to a point according to the corresponding di0_pt_*_<i>
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DI0_DATA_CNT_DOWN0_ : 9; //!< Waveform's falling edge position. This field defines the Waveform's falling edge position. The Waveform is mapped to a point according to the corresponding di0_pt_*_<i>
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_di0_dw_set0_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_DW_SET0_I register
 */
#define HW_IPU_DI0_DW_SET0_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x40088)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_DW_SET0_I(x)           (*(volatile hw_ipu_di0_dw_set0_i_t *) HW_IPU_DI0_DW_SET0_I_ADDR(x))
#define HW_IPU_DI0_DW_SET0_I_RD(x)        (HW_IPU_DI0_DW_SET0_I(x).U)
#define HW_IPU_DI0_DW_SET0_I_WR(x, v)     (HW_IPU_DI0_DW_SET0_I(x).U = (v))
#define HW_IPU_DI0_DW_SET0_I_SET(x, v)    (HW_IPU_DI0_DW_SET0_I_WR(x, HW_IPU_DI0_DW_SET0_I_RD(x) |  (v)))
#define HW_IPU_DI0_DW_SET0_I_CLR(x, v)    (HW_IPU_DI0_DW_SET0_I_WR(x, HW_IPU_DI0_DW_SET0_I_RD(x) & ~(v)))
#define HW_IPU_DI0_DW_SET0_I_TOG(x, v)    (HW_IPU_DI0_DW_SET0_I_WR(x, HW_IPU_DI0_DW_SET0_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_DW_SET0_I bitfields
 */

/* --- Register HW_IPU_DI0_DW_SET0_I, field DI0_DATA_CNT_UP0_ (RW)
 *
 * Waveform's rising edge position. This field defines the Waveform's rising edge position. The
 * Waveform is mapped to a point according to the corresponding di0_pt_*_<i>
 */

#define BP_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_UP0_      0
#define BM_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_UP0_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_UP0_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_UP0_)
#else
#define BF_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_UP0_(v)   (((v) << 0) & BM_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_UP0_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DATA_CNT_UP0_ field to a new value.
#define BW_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_UP0_(v)   BF_CS1(IPU_DI0_DW_SET0_I, DI0_DATA_CNT_UP0_, v)
#endif

/* --- Register HW_IPU_DI0_DW_SET0_I, field DI0_DATA_CNT_DOWN0_ (RW)
 *
 * Waveform's falling edge position. This field defines the Waveform's falling edge position. The
 * Waveform is mapped to a point according to the corresponding di0_pt_*_<i>
 */

#define BP_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_DOWN0_      16
#define BM_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_DOWN0_      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_DOWN0_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_DOWN0_)
#else
#define BF_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_DOWN0_(v)   (((v) << 16) & BM_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_DOWN0_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DATA_CNT_DOWN0_ field to a new value.
#define BW_IPU_DI0_DW_SET0_I_DI0_DATA_CNT_DOWN0_(v)   BF_CS1(IPU_DI0_DW_SET0_I, DI0_DATA_CNT_DOWN0_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_DW_SET1_I - DI0 Data Wave Set 1 <i> Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_DATA_CNT_UP1_ : 9; //!< Waveform's rising edge position. This field defines the Waveform's rising edge position. The Waveform is mapped to a pint according to the corresponding di0_pt_*_<i>
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DI0_DATA_CNT_DOWN1_ : 9; //!< Waveform's falling edge position. This field defines the Waveform's falling edge position. The Waveform is mapped to a pint according to the corresponding di0_pt_*_<i>
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_di0_dw_set1_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_DW_SET1_I register
 */
#define HW_IPU_DI0_DW_SET1_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x400b8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_DW_SET1_I(x)           (*(volatile hw_ipu_di0_dw_set1_i_t *) HW_IPU_DI0_DW_SET1_I_ADDR(x))
#define HW_IPU_DI0_DW_SET1_I_RD(x)        (HW_IPU_DI0_DW_SET1_I(x).U)
#define HW_IPU_DI0_DW_SET1_I_WR(x, v)     (HW_IPU_DI0_DW_SET1_I(x).U = (v))
#define HW_IPU_DI0_DW_SET1_I_SET(x, v)    (HW_IPU_DI0_DW_SET1_I_WR(x, HW_IPU_DI0_DW_SET1_I_RD(x) |  (v)))
#define HW_IPU_DI0_DW_SET1_I_CLR(x, v)    (HW_IPU_DI0_DW_SET1_I_WR(x, HW_IPU_DI0_DW_SET1_I_RD(x) & ~(v)))
#define HW_IPU_DI0_DW_SET1_I_TOG(x, v)    (HW_IPU_DI0_DW_SET1_I_WR(x, HW_IPU_DI0_DW_SET1_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_DW_SET1_I bitfields
 */

/* --- Register HW_IPU_DI0_DW_SET1_I, field DI0_DATA_CNT_UP1_ (RW)
 *
 * Waveform's rising edge position. This field defines the Waveform's rising edge position. The
 * Waveform is mapped to a pint according to the corresponding di0_pt_*_<i>
 */

#define BP_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_UP1_      0
#define BM_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_UP1_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_UP1_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_UP1_)
#else
#define BF_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_UP1_(v)   (((v) << 0) & BM_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_UP1_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DATA_CNT_UP1_ field to a new value.
#define BW_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_UP1_(v)   BF_CS1(IPU_DI0_DW_SET1_I, DI0_DATA_CNT_UP1_, v)
#endif

/* --- Register HW_IPU_DI0_DW_SET1_I, field DI0_DATA_CNT_DOWN1_ (RW)
 *
 * Waveform's falling edge position. This field defines the Waveform's falling edge position. The
 * Waveform is mapped to a pint according to the corresponding di0_pt_*_<i>
 */

#define BP_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_DOWN1_      16
#define BM_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_DOWN1_      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_DOWN1_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_DOWN1_)
#else
#define BF_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_DOWN1_(v)   (((v) << 16) & BM_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_DOWN1_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DATA_CNT_DOWN1_ field to a new value.
#define BW_IPU_DI0_DW_SET1_I_DI0_DATA_CNT_DOWN1_(v)   BF_CS1(IPU_DI0_DW_SET1_I, DI0_DATA_CNT_DOWN1_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_DW_SET2_I - DI0 Data Wave Set 2 <i> Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_DATA_CNT_UP2_ : 9; //!< Waveform's rising edge position. This field defines the Waveform's rising edge position. The Waveform is mapped to a pint according to the corresponding di0_pt_*_<i>
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DI0_DATA_CNT_DOWN2_ : 9; //!< Waveform's falling edge position. This field defines the Waveform's falling edge position. The Waveform is mapped to a pint according to the corresponding di0_pt_*_<i>
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_di0_dw_set2_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_DW_SET2_I register
 */
#define HW_IPU_DI0_DW_SET2_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x400e8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_DW_SET2_I(x)           (*(volatile hw_ipu_di0_dw_set2_i_t *) HW_IPU_DI0_DW_SET2_I_ADDR(x))
#define HW_IPU_DI0_DW_SET2_I_RD(x)        (HW_IPU_DI0_DW_SET2_I(x).U)
#define HW_IPU_DI0_DW_SET2_I_WR(x, v)     (HW_IPU_DI0_DW_SET2_I(x).U = (v))
#define HW_IPU_DI0_DW_SET2_I_SET(x, v)    (HW_IPU_DI0_DW_SET2_I_WR(x, HW_IPU_DI0_DW_SET2_I_RD(x) |  (v)))
#define HW_IPU_DI0_DW_SET2_I_CLR(x, v)    (HW_IPU_DI0_DW_SET2_I_WR(x, HW_IPU_DI0_DW_SET2_I_RD(x) & ~(v)))
#define HW_IPU_DI0_DW_SET2_I_TOG(x, v)    (HW_IPU_DI0_DW_SET2_I_WR(x, HW_IPU_DI0_DW_SET2_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_DW_SET2_I bitfields
 */

/* --- Register HW_IPU_DI0_DW_SET2_I, field DI0_DATA_CNT_UP2_ (RW)
 *
 * Waveform's rising edge position. This field defines the Waveform's rising edge position. The
 * Waveform is mapped to a pint according to the corresponding di0_pt_*_<i>
 */

#define BP_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_UP2_      0
#define BM_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_UP2_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_UP2_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_UP2_)
#else
#define BF_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_UP2_(v)   (((v) << 0) & BM_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_UP2_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DATA_CNT_UP2_ field to a new value.
#define BW_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_UP2_(v)   BF_CS1(IPU_DI0_DW_SET2_I, DI0_DATA_CNT_UP2_, v)
#endif

/* --- Register HW_IPU_DI0_DW_SET2_I, field DI0_DATA_CNT_DOWN2_ (RW)
 *
 * Waveform's falling edge position. This field defines the Waveform's falling edge position. The
 * Waveform is mapped to a pint according to the corresponding di0_pt_*_<i>
 */

#define BP_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_DOWN2_      16
#define BM_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_DOWN2_      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_DOWN2_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_DOWN2_)
#else
#define BF_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_DOWN2_(v)   (((v) << 16) & BM_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_DOWN2_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DATA_CNT_DOWN2_ field to a new value.
#define BW_IPU_DI0_DW_SET2_I_DI0_DATA_CNT_DOWN2_(v)   BF_CS1(IPU_DI0_DW_SET2_I, DI0_DATA_CNT_DOWN2_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_DW_SET3_I - DI0 Data Wave Set 3 <i> Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_DATA_CNT_UP3_ : 9; //!< Waveform's rising edge position. This field defines the Waveform's rising edge position. The Waveform is mapped to a pint according to the corresponding di0_pt_*_<i>
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DI0_DATA_CNT_DOWN3_ : 9; //!< Waveform's falling edge position. This field defines the Waveform's falling edge position. The Waveform is mapped to a pint according to the corresponding di0_pt_*_<i>
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_di0_dw_set3_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_DW_SET3_I register
 */
#define HW_IPU_DI0_DW_SET3_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x40118)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_DW_SET3_I(x)           (*(volatile hw_ipu_di0_dw_set3_i_t *) HW_IPU_DI0_DW_SET3_I_ADDR(x))
#define HW_IPU_DI0_DW_SET3_I_RD(x)        (HW_IPU_DI0_DW_SET3_I(x).U)
#define HW_IPU_DI0_DW_SET3_I_WR(x, v)     (HW_IPU_DI0_DW_SET3_I(x).U = (v))
#define HW_IPU_DI0_DW_SET3_I_SET(x, v)    (HW_IPU_DI0_DW_SET3_I_WR(x, HW_IPU_DI0_DW_SET3_I_RD(x) |  (v)))
#define HW_IPU_DI0_DW_SET3_I_CLR(x, v)    (HW_IPU_DI0_DW_SET3_I_WR(x, HW_IPU_DI0_DW_SET3_I_RD(x) & ~(v)))
#define HW_IPU_DI0_DW_SET3_I_TOG(x, v)    (HW_IPU_DI0_DW_SET3_I_WR(x, HW_IPU_DI0_DW_SET3_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_DW_SET3_I bitfields
 */

/* --- Register HW_IPU_DI0_DW_SET3_I, field DI0_DATA_CNT_UP3_ (RW)
 *
 * Waveform's rising edge position. This field defines the Waveform's rising edge position. The
 * Waveform is mapped to a pint according to the corresponding di0_pt_*_<i>
 */

#define BP_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_UP3_      0
#define BM_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_UP3_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_UP3_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_UP3_)
#else
#define BF_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_UP3_(v)   (((v) << 0) & BM_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_UP3_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DATA_CNT_UP3_ field to a new value.
#define BW_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_UP3_(v)   BF_CS1(IPU_DI0_DW_SET3_I, DI0_DATA_CNT_UP3_, v)
#endif

/* --- Register HW_IPU_DI0_DW_SET3_I, field DI0_DATA_CNT_DOWN3_ (RW)
 *
 * Waveform's falling edge position. This field defines the Waveform's falling edge position. The
 * Waveform is mapped to a pint according to the corresponding di0_pt_*_<i>
 */

#define BP_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_DOWN3_      16
#define BM_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_DOWN3_      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_DOWN3_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_DOWN3_)
#else
#define BF_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_DOWN3_(v)   (((v) << 16) & BM_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_DOWN3_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DATA_CNT_DOWN3_ field to a new value.
#define BW_IPU_DI0_DW_SET3_I_DI0_DATA_CNT_DOWN3_(v)   BF_CS1(IPU_DI0_DW_SET3_I, DI0_DATA_CNT_DOWN3_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_STP_REP_I - DI0 Step Repeat <i> Registers (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_STEP_REPEAT_ : 12; //!< Step Repeat <i> This fields defines the amount of repetitions that will be performed by the counter <i>
        unsigned RESERVED0 : 4; //!< Reserved
        unsigned DI0_STEP_REPEAT_1 : 12; //!< Step Repeat <i> This fields defines the amount of repetitions that will be performed by the counter <i>
        unsigned RESERVED1 : 4; //!< Reserved
    } B;
} hw_ipu_di0_stp_rep_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_STP_REP_I register
 */
#define HW_IPU_DI0_STP_REP_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x40148)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_STP_REP_I(x)           (*(volatile hw_ipu_di0_stp_rep_i_t *) HW_IPU_DI0_STP_REP_I_ADDR(x))
#define HW_IPU_DI0_STP_REP_I_RD(x)        (HW_IPU_DI0_STP_REP_I(x).U)
#define HW_IPU_DI0_STP_REP_I_WR(x, v)     (HW_IPU_DI0_STP_REP_I(x).U = (v))
#define HW_IPU_DI0_STP_REP_I_SET(x, v)    (HW_IPU_DI0_STP_REP_I_WR(x, HW_IPU_DI0_STP_REP_I_RD(x) |  (v)))
#define HW_IPU_DI0_STP_REP_I_CLR(x, v)    (HW_IPU_DI0_STP_REP_I_WR(x, HW_IPU_DI0_STP_REP_I_RD(x) & ~(v)))
#define HW_IPU_DI0_STP_REP_I_TOG(x, v)    (HW_IPU_DI0_STP_REP_I_WR(x, HW_IPU_DI0_STP_REP_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_STP_REP_I bitfields
 */

/* --- Register HW_IPU_DI0_STP_REP_I, field DI0_STEP_REPEAT_ (RW)
 *
 * Step Repeat <i> This fields defines the amount of repetitions that will be performed by the
 * counter <i>
 */

#define BP_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_      0
#define BM_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_)
#else
#define BF_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_(v)   (((v) << 0) & BM_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_STEP_REPEAT_ field to a new value.
#define BW_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_(v)   BF_CS1(IPU_DI0_STP_REP_I, DI0_STEP_REPEAT_, v)
#endif

/* --- Register HW_IPU_DI0_STP_REP_I, field DI0_STEP_REPEAT_ (RW)
 *
 * Step Repeat <i> This fields defines the amount of repetitions that will be performed by the
 * counter <i>
 */

#define BP_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_      16
#define BM_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_)
#else
#define BF_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_(v)   (((v) << 16) & BM_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_STEP_REPEAT_ field to a new value.
#define BW_IPU_DI0_STP_REP_I_DI0_STEP_REPEAT_(v)   BF_CS1(IPU_DI0_STP_REP_I, DI0_STEP_REPEAT_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_STP_REP_9 - DI0 Step Repeat 9 Registers (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_STEP_REPEAT_9 : 12; //!< Step Repeat 9 This fields defines the amount of repetitions that will be performed by the counter 9
        unsigned RESERVED0 : 20; //!< Reserved
    } B;
} hw_ipu_di0_stp_rep_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_STP_REP_9 register
 */
#define HW_IPU_DI0_STP_REP_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x40158)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_STP_REP_9(x)           (*(volatile hw_ipu_di0_stp_rep_9_t *) HW_IPU_DI0_STP_REP_9_ADDR(x))
#define HW_IPU_DI0_STP_REP_9_RD(x)        (HW_IPU_DI0_STP_REP_9(x).U)
#define HW_IPU_DI0_STP_REP_9_WR(x, v)     (HW_IPU_DI0_STP_REP_9(x).U = (v))
#define HW_IPU_DI0_STP_REP_9_SET(x, v)    (HW_IPU_DI0_STP_REP_9_WR(x, HW_IPU_DI0_STP_REP_9_RD(x) |  (v)))
#define HW_IPU_DI0_STP_REP_9_CLR(x, v)    (HW_IPU_DI0_STP_REP_9_WR(x, HW_IPU_DI0_STP_REP_9_RD(x) & ~(v)))
#define HW_IPU_DI0_STP_REP_9_TOG(x, v)    (HW_IPU_DI0_STP_REP_9_WR(x, HW_IPU_DI0_STP_REP_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_STP_REP_9 bitfields
 */

/* --- Register HW_IPU_DI0_STP_REP_9, field DI0_STEP_REPEAT_9 (RW)
 *
 * Step Repeat 9 This fields defines the amount of repetitions that will be performed by the counter
 * 9
 */

#define BP_IPU_DI0_STP_REP_9_DI0_STEP_REPEAT_9      0
#define BM_IPU_DI0_STP_REP_9_DI0_STEP_REPEAT_9      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_STP_REP_9_DI0_STEP_REPEAT_9(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_STP_REP_9_DI0_STEP_REPEAT_9)
#else
#define BF_IPU_DI0_STP_REP_9_DI0_STEP_REPEAT_9(v)   (((v) << 0) & BM_IPU_DI0_STP_REP_9_DI0_STEP_REPEAT_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_STEP_REPEAT_9 field to a new value.
#define BW_IPU_DI0_STP_REP_9_DI0_STEP_REPEAT_9(v)   BF_CS1(IPU_DI0_STP_REP_9, DI0_STEP_REPEAT_9, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SER_CONF - DI0 Serial Display Control Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_WAIT4SERIAL : 1; //!< Wait for Serial When the parallel display share pins with the serial port. Accessing the parallel port is not allowed till the serial port completes its access.
        unsigned DI0_SERIAL_CS_POLARITY : 1; //!< Serial Chip Select Polarity The output polarity of the SER_CS pin
        unsigned DI0_SERIAL_RS_POLARITY : 1; //!< Serial RS Polarity The output polarity of the SER_RS pin
        unsigned DI0_SERIAL_DATA_POLARITY : 1; //!< Serial Data Polarity The output polarity of the SER_DATA pin
        unsigned DI0_SER_CLK_POLARITY : 1; //!< Serial Clock Polarity The output polarity of the SER_CLK pin
        unsigned DI0_LLA_SER_ACCESS : 1; //!< Direct Low Level Access to Serial display
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DI0_SERIAL_LATCH : 8; //!< DI0 Serial Latch This field defines how many cycles to insert between serial read accesses start to data sampling in the
        unsigned DI0_SERIAL_LLA_PNTR_RS_W_0 : 4; //!< RS 0 waveform pointer for write low level access This pointer defines which waveform set will be chosen when the low level write access is targeted to RS group 0.
        unsigned DI0_SERIAL_LLA_PNTR_RS_W_1 : 4; //!< RS 1 waveform pointer for write low level access This pointer defines which waveform set will be chosen when the low level write access is targeted to RS group 1.
        unsigned DI0_SERIAL_LLA_PNTR_RS_R_0 : 4; //!< RS 2 waveform pointer for read low level access This pointer defines which waveform set will be chosen when the read low level access is targeted to RS group 0.
        unsigned DI0_SERIAL_LLA_PNTR_RS_R_1 : 4; //!< RS 3 waveform pointer for read low level access This pointer defines which waveform set will be chosen when the read low level access is targeted to RS group 1.
    } B;
} hw_ipu_di0_ser_conf_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SER_CONF register
 */
#define HW_IPU_DI0_SER_CONF_ADDR(x)      (REGS_IPU_BASE(x) + 0x4015c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SER_CONF(x)           (*(volatile hw_ipu_di0_ser_conf_t *) HW_IPU_DI0_SER_CONF_ADDR(x))
#define HW_IPU_DI0_SER_CONF_RD(x)        (HW_IPU_DI0_SER_CONF(x).U)
#define HW_IPU_DI0_SER_CONF_WR(x, v)     (HW_IPU_DI0_SER_CONF(x).U = (v))
#define HW_IPU_DI0_SER_CONF_SET(x, v)    (HW_IPU_DI0_SER_CONF_WR(x, HW_IPU_DI0_SER_CONF_RD(x) |  (v)))
#define HW_IPU_DI0_SER_CONF_CLR(x, v)    (HW_IPU_DI0_SER_CONF_WR(x, HW_IPU_DI0_SER_CONF_RD(x) & ~(v)))
#define HW_IPU_DI0_SER_CONF_TOG(x, v)    (HW_IPU_DI0_SER_CONF_WR(x, HW_IPU_DI0_SER_CONF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SER_CONF bitfields
 */

/* --- Register HW_IPU_DI0_SER_CONF, field DI0_WAIT4SERIAL (RW)
 *
 * Wait for Serial When the parallel display share pins with the serial port. Accessing the parallel
 * port is not allowed till the serial port completes its access.
 *
 * Values:
 * 1 - The parallel port should wait to the serial port as the pins are shared
 * 0 - The parallel port should not wait to the serial port as the pins are not shared
 */

#define BP_IPU_DI0_SER_CONF_DI0_WAIT4SERIAL      0
#define BM_IPU_DI0_SER_CONF_DI0_WAIT4SERIAL      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SER_CONF_DI0_WAIT4SERIAL(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SER_CONF_DI0_WAIT4SERIAL)
#else
#define BF_IPU_DI0_SER_CONF_DI0_WAIT4SERIAL(v)   (((v) << 0) & BM_IPU_DI0_SER_CONF_DI0_WAIT4SERIAL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_WAIT4SERIAL field to a new value.
#define BW_IPU_DI0_SER_CONF_DI0_WAIT4SERIAL(v)   BF_CS1(IPU_DI0_SER_CONF, DI0_WAIT4SERIAL, v)
#endif


/* --- Register HW_IPU_DI0_SER_CONF, field DI0_SERIAL_CS_POLARITY (RW)
 *
 * Serial Chip Select Polarity The output polarity of the SER_CS pin
 *
 * Values:
 * 1 - The CS is inverted
 * 0 - The CS is not inverted
 */

#define BP_IPU_DI0_SER_CONF_DI0_SERIAL_CS_POLARITY      1
#define BM_IPU_DI0_SER_CONF_DI0_SERIAL_CS_POLARITY      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_CS_POLARITY(v)   ((((reg32_t) v) << 1) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_CS_POLARITY)
#else
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_CS_POLARITY(v)   (((v) << 1) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_CS_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SERIAL_CS_POLARITY field to a new value.
#define BW_IPU_DI0_SER_CONF_DI0_SERIAL_CS_POLARITY(v)   BF_CS1(IPU_DI0_SER_CONF, DI0_SERIAL_CS_POLARITY, v)
#endif


/* --- Register HW_IPU_DI0_SER_CONF, field DI0_SERIAL_RS_POLARITY (RW)
 *
 * Serial RS Polarity The output polarity of the SER_RS pin
 *
 * Values:
 * 1 - The RS is inverted
 * 0 - The RS is not inverted
 */

#define BP_IPU_DI0_SER_CONF_DI0_SERIAL_RS_POLARITY      2
#define BM_IPU_DI0_SER_CONF_DI0_SERIAL_RS_POLARITY      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_RS_POLARITY(v)   ((((reg32_t) v) << 2) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_RS_POLARITY)
#else
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_RS_POLARITY(v)   (((v) << 2) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_RS_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SERIAL_RS_POLARITY field to a new value.
#define BW_IPU_DI0_SER_CONF_DI0_SERIAL_RS_POLARITY(v)   BF_CS1(IPU_DI0_SER_CONF, DI0_SERIAL_RS_POLARITY, v)
#endif


/* --- Register HW_IPU_DI0_SER_CONF, field DI0_SERIAL_DATA_POLARITY (RW)
 *
 * Serial Data Polarity The output polarity of the SER_DATA pin
 *
 * Values:
 * 1 - The data is inverted
 * 0 - The data is not inverted
 */

#define BP_IPU_DI0_SER_CONF_DI0_SERIAL_DATA_POLARITY      3
#define BM_IPU_DI0_SER_CONF_DI0_SERIAL_DATA_POLARITY      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_DATA_POLARITY(v)   ((((reg32_t) v) << 3) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_DATA_POLARITY)
#else
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_DATA_POLARITY(v)   (((v) << 3) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_DATA_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SERIAL_DATA_POLARITY field to a new value.
#define BW_IPU_DI0_SER_CONF_DI0_SERIAL_DATA_POLARITY(v)   BF_CS1(IPU_DI0_SER_CONF, DI0_SERIAL_DATA_POLARITY, v)
#endif


/* --- Register HW_IPU_DI0_SER_CONF, field DI0_SER_CLK_POLARITY (RW)
 *
 * Serial Clock Polarity The output polarity of the SER_CLK pin
 *
 * Values:
 * 1 - The clock is inverted
 * 0 - The clock is not inverted
 */

#define BP_IPU_DI0_SER_CONF_DI0_SER_CLK_POLARITY      4
#define BM_IPU_DI0_SER_CONF_DI0_SER_CLK_POLARITY      0x00000010

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SER_CONF_DI0_SER_CLK_POLARITY(v)   ((((reg32_t) v) << 4) & BM_IPU_DI0_SER_CONF_DI0_SER_CLK_POLARITY)
#else
#define BF_IPU_DI0_SER_CONF_DI0_SER_CLK_POLARITY(v)   (((v) << 4) & BM_IPU_DI0_SER_CONF_DI0_SER_CLK_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SER_CLK_POLARITY field to a new value.
#define BW_IPU_DI0_SER_CONF_DI0_SER_CLK_POLARITY(v)   BF_CS1(IPU_DI0_SER_CONF, DI0_SER_CLK_POLARITY, v)
#endif


/* --- Register HW_IPU_DI0_SER_CONF, field DI0_LLA_SER_ACCESS (RW)
 *
 * Direct Low Level Access to Serial display
 *
 * Values:
 * 1 - ARM platform access is performed via a direct path to the serial display in LLA mode, in this mode
 *     only the ARM platform in LLA mode can access the serial port
 * 0 - ARM platform access to the serial display port is not done directly, hence other source are allowed
 *     to access the serial port. The arbitration is done automatically
 */

#define BP_IPU_DI0_SER_CONF_DI0_LLA_SER_ACCESS      5
#define BM_IPU_DI0_SER_CONF_DI0_LLA_SER_ACCESS      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SER_CONF_DI0_LLA_SER_ACCESS(v)   ((((reg32_t) v) << 5) & BM_IPU_DI0_SER_CONF_DI0_LLA_SER_ACCESS)
#else
#define BF_IPU_DI0_SER_CONF_DI0_LLA_SER_ACCESS(v)   (((v) << 5) & BM_IPU_DI0_SER_CONF_DI0_LLA_SER_ACCESS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_LLA_SER_ACCESS field to a new value.
#define BW_IPU_DI0_SER_CONF_DI0_LLA_SER_ACCESS(v)   BF_CS1(IPU_DI0_SER_CONF, DI0_LLA_SER_ACCESS, v)
#endif


/* --- Register HW_IPU_DI0_SER_CONF, field DI0_SERIAL_LATCH (RW)
 *
 * DI0 Serial Latch This field defines how many cycles to insert between serial read accesses start
 * to data sampling in the
 */

#define BP_IPU_DI0_SER_CONF_DI0_SERIAL_LATCH      8
#define BM_IPU_DI0_SER_CONF_DI0_SERIAL_LATCH      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_LATCH(v)   ((((reg32_t) v) << 8) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_LATCH)
#else
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_LATCH(v)   (((v) << 8) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_LATCH)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SERIAL_LATCH field to a new value.
#define BW_IPU_DI0_SER_CONF_DI0_SERIAL_LATCH(v)   BF_CS1(IPU_DI0_SER_CONF, DI0_SERIAL_LATCH, v)
#endif

/* --- Register HW_IPU_DI0_SER_CONF, field DI0_SERIAL_LLA_PNTR_RS_W_0 (RW)
 *
 * RS 0 waveform pointer for write low level access This pointer defines which waveform set will be
 * chosen when the low level write access is targeted to RS group 0.
 *
 * Values:
 * 0000 - Waveform set #1
 * 0001 - Waveform set #2
 * 1011 - Waveform set #12
 * 1100 - Reserved
 * 1101 - Reserved
 * 1100 - Reserved
 */

#define BP_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_0      16
#define BM_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_0      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_0(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_0)
#else
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_0(v)   (((v) << 16) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SERIAL_LLA_PNTR_RS_W_0 field to a new value.
#define BW_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_0(v)   BF_CS1(IPU_DI0_SER_CONF, DI0_SERIAL_LLA_PNTR_RS_W_0, v)
#endif


/* --- Register HW_IPU_DI0_SER_CONF, field DI0_SERIAL_LLA_PNTR_RS_W_1 (RW)
 *
 * RS 1 waveform pointer for write low level access This pointer defines which waveform set will be
 * chosen when the low level write access is targeted to RS group 1.
 *
 * Values:
 * 0000 - Waveform set #1
 * 0001 - Waveform set #2
 * 1011 - Waveform set #12
 * 1100 - Reserved
 * 1101 - Reserved
 * 1100 - Reserved
 */

#define BP_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_1      20
#define BM_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_1      0x00f00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_1(v)   ((((reg32_t) v) << 20) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_1)
#else
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_1(v)   (((v) << 20) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SERIAL_LLA_PNTR_RS_W_1 field to a new value.
#define BW_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_W_1(v)   BF_CS1(IPU_DI0_SER_CONF, DI0_SERIAL_LLA_PNTR_RS_W_1, v)
#endif


/* --- Register HW_IPU_DI0_SER_CONF, field DI0_SERIAL_LLA_PNTR_RS_R_0 (RW)
 *
 * RS 2 waveform pointer for read low level access This pointer defines which waveform set will be
 * chosen when the read low level access is targeted to RS group 0.
 *
 * Values:
 * 0000 - Waveform set #1
 * 0001 - Waveform set #2
 * 1011 - Waveform set #12
 * 1100 - Reserved
 * 1101 - Reserved
 * 1100 - Reserved
 */

#define BP_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_0      24
#define BM_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_0      0x0f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_0(v)   ((((reg32_t) v) << 24) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_0)
#else
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_0(v)   (((v) << 24) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SERIAL_LLA_PNTR_RS_R_0 field to a new value.
#define BW_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_0(v)   BF_CS1(IPU_DI0_SER_CONF, DI0_SERIAL_LLA_PNTR_RS_R_0, v)
#endif


/* --- Register HW_IPU_DI0_SER_CONF, field DI0_SERIAL_LLA_PNTR_RS_R_1 (RW)
 *
 * RS 3 waveform pointer for read low level access This pointer defines which waveform set will be
 * chosen when the read low level access is targeted to RS group 1.
 *
 * Values:
 * 0000 - Waveform set #1
 * 0001 - Waveform set #2
 * 1011 - Waveform set #12
 * 1100 - Reserved
 * 1101 - Reserved
 * 1100 - Reserved
 */

#define BP_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_1      28
#define BM_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_1      0xf0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_1(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_1)
#else
#define BF_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_1(v)   (((v) << 28) & BM_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SERIAL_LLA_PNTR_RS_R_1 field to a new value.
#define BW_IPU_DI0_SER_CONF_DI0_SERIAL_LLA_PNTR_RS_R_1(v)   BF_CS1(IPU_DI0_SER_CONF, DI0_SERIAL_LLA_PNTR_RS_R_1, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SSC - DI0 Special Signals Control Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_BYTE_EN_PNTR : 3; //!< Byte Enable Pointer This pointer selects the pin asserted along with the byte enables signals
        unsigned DI0_BYTE_EN_RD_IN : 1; //!< Byte Enable Read In This bit selects the source of the byte enable pins
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI0_WAIT_ON : 1; //!< Wait On This field defines the DC's response to WAIT signal
        unsigned RESERVED1 : 10; //!< Reserved.
        unsigned DI0_CS_ERM : 1; //!< DI0 GLUELOGIC error recovery mode. This bit defines the error recovery mode of the GLUELOGIC.
        unsigned DI0_PIN11_ERM : 1; //!< DI0 PIN11 error recovery mode. This bit defines the error recovery mode of the PIN11 pin.
        unsigned DI0_PIN12_ERM : 1; //!< DI0 PIN12 error recovery mode. This bit defines the error recovery mode of the PIN12 pin.
        unsigned DI0_PIN13_ERM : 1; //!< DI0 PIN13 error recovery mode. This bit defines the error recovery mode of the PIN13 pin.
        unsigned DI0_PIN14_ERM : 1; //!< DI0 PIN14 error recovery mode. This bit defines the error recovery mode of the PIN14 pin.
        unsigned DI0_PIN15_ERM : 1; //!< DI0 PIN15 error recovery mode. This bit defines the error recovery mode of the PIN15 pin.
        unsigned DI0_PIN16_ERM : 1; //!< DI0 PIN16 error recovery mode. This bit defines the error recovery mode of the PIN16 pin.
        unsigned DI0_PIN17_ERM : 1; //!< DI0 PIN17 error recovery mode. This bit defines the error recovery mode of the PIN17 pin.
        unsigned RESERVED2 : 8; //!< Reserved.
    } B;
} hw_ipu_di0_ssc_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SSC register
 */
#define HW_IPU_DI0_SSC_ADDR(x)      (REGS_IPU_BASE(x) + 0x40160)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SSC(x)           (*(volatile hw_ipu_di0_ssc_t *) HW_IPU_DI0_SSC_ADDR(x))
#define HW_IPU_DI0_SSC_RD(x)        (HW_IPU_DI0_SSC(x).U)
#define HW_IPU_DI0_SSC_WR(x, v)     (HW_IPU_DI0_SSC(x).U = (v))
#define HW_IPU_DI0_SSC_SET(x, v)    (HW_IPU_DI0_SSC_WR(x, HW_IPU_DI0_SSC_RD(x) |  (v)))
#define HW_IPU_DI0_SSC_CLR(x, v)    (HW_IPU_DI0_SSC_WR(x, HW_IPU_DI0_SSC_RD(x) & ~(v)))
#define HW_IPU_DI0_SSC_TOG(x, v)    (HW_IPU_DI0_SSC_WR(x, HW_IPU_DI0_SSC_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SSC bitfields
 */

/* --- Register HW_IPU_DI0_SSC, field DI0_BYTE_EN_PNTR (RW)
 *
 * Byte Enable Pointer This pointer selects the pin asserted along with the byte enables signals
 *
 * Values:
 * 000 - wave form of byte enable as pin_11
 * 001 - wave form of byte enable as pin_12
 * 111 - wave form of byte enable as suitable CS pin
 */

#define BP_IPU_DI0_SSC_DI0_BYTE_EN_PNTR      0
#define BM_IPU_DI0_SSC_DI0_BYTE_EN_PNTR      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SSC_DI0_BYTE_EN_PNTR(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SSC_DI0_BYTE_EN_PNTR)
#else
#define BF_IPU_DI0_SSC_DI0_BYTE_EN_PNTR(v)   (((v) << 0) & BM_IPU_DI0_SSC_DI0_BYTE_EN_PNTR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_BYTE_EN_PNTR field to a new value.
#define BW_IPU_DI0_SSC_DI0_BYTE_EN_PNTR(v)   BF_CS1(IPU_DI0_SSC, DI0_BYTE_EN_PNTR, v)
#endif


/* --- Register HW_IPU_DI0_SSC, field DI0_BYTE_EN_RD_IN (RW)
 *
 * Byte Enable Read In This bit selects the source of the byte enable pins
 *
 * Values:
 * 1 - The write byte enable signals are routed via bits [17:16] of the display's data, The read byte
 *     enable signals are routed via bits [19:18 of the display's data
 * 0 - The byte enable signals are routed via bits [17:16] of the display's data for both read and write
 */

#define BP_IPU_DI0_SSC_DI0_BYTE_EN_RD_IN      3
#define BM_IPU_DI0_SSC_DI0_BYTE_EN_RD_IN      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SSC_DI0_BYTE_EN_RD_IN(v)   ((((reg32_t) v) << 3) & BM_IPU_DI0_SSC_DI0_BYTE_EN_RD_IN)
#else
#define BF_IPU_DI0_SSC_DI0_BYTE_EN_RD_IN(v)   (((v) << 3) & BM_IPU_DI0_SSC_DI0_BYTE_EN_RD_IN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_BYTE_EN_RD_IN field to a new value.
#define BW_IPU_DI0_SSC_DI0_BYTE_EN_RD_IN(v)   BF_CS1(IPU_DI0_SSC, DI0_BYTE_EN_RD_IN, v)
#endif


/* --- Register HW_IPU_DI0_SSC, field DI0_WAIT_ON (RW)
 *
 * Wait On This field defines the DC's response to WAIT signal
 *
 * Values:
 * 1 - The DC holds the flow as long as WAIT is asserted
 * 0 - The DC continues the flow regardless the WAIT signal
 */

#define BP_IPU_DI0_SSC_DI0_WAIT_ON      5
#define BM_IPU_DI0_SSC_DI0_WAIT_ON      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SSC_DI0_WAIT_ON(v)   ((((reg32_t) v) << 5) & BM_IPU_DI0_SSC_DI0_WAIT_ON)
#else
#define BF_IPU_DI0_SSC_DI0_WAIT_ON(v)   (((v) << 5) & BM_IPU_DI0_SSC_DI0_WAIT_ON)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_WAIT_ON field to a new value.
#define BW_IPU_DI0_SSC_DI0_WAIT_ON(v)   BF_CS1(IPU_DI0_SSC, DI0_WAIT_ON, v)
#endif


/* --- Register HW_IPU_DI0_SSC, field DI0_CS_ERM (RW)
 *
 * DI0 GLUELOGIC error recovery mode. This bit defines the error recovery mode of the GLUELOGIC.
 *
 * Values:
 * 1 - The GLUELOGIC is release in case of a synchronous display error. The release will be done on the
 *     next VSYNC
 * 0 - Nothing is done to the GLUELOGIC following a display error detection
 */

#define BP_IPU_DI0_SSC_DI0_CS_ERM      16
#define BM_IPU_DI0_SSC_DI0_CS_ERM      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SSC_DI0_CS_ERM(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_SSC_DI0_CS_ERM)
#else
#define BF_IPU_DI0_SSC_DI0_CS_ERM(v)   (((v) << 16) & BM_IPU_DI0_SSC_DI0_CS_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CS_ERM field to a new value.
#define BW_IPU_DI0_SSC_DI0_CS_ERM(v)   BF_CS1(IPU_DI0_SSC, DI0_CS_ERM, v)
#endif


/* --- Register HW_IPU_DI0_SSC, field DI0_PIN11_ERM (RW)
 *
 * DI0 PIN11 error recovery mode. This bit defines the error recovery mode of the PIN11 pin.
 *
 * Values:
 * 1 - The PIN11 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC
 * 0 - Nothing is done to the PIN11 pin following a display error detection
 */

#define BP_IPU_DI0_SSC_DI0_PIN11_ERM      17
#define BM_IPU_DI0_SSC_DI0_PIN11_ERM      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SSC_DI0_PIN11_ERM(v)   ((((reg32_t) v) << 17) & BM_IPU_DI0_SSC_DI0_PIN11_ERM)
#else
#define BF_IPU_DI0_SSC_DI0_PIN11_ERM(v)   (((v) << 17) & BM_IPU_DI0_SSC_DI0_PIN11_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PIN11_ERM field to a new value.
#define BW_IPU_DI0_SSC_DI0_PIN11_ERM(v)   BF_CS1(IPU_DI0_SSC, DI0_PIN11_ERM, v)
#endif


/* --- Register HW_IPU_DI0_SSC, field DI0_PIN12_ERM (RW)
 *
 * DI0 PIN12 error recovery mode. This bit defines the error recovery mode of the PIN12 pin.
 *
 * Values:
 * 1 - The PIN12 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC
 * 0 - Nothing is done to the PIN12 pin following a display error detection
 */

#define BP_IPU_DI0_SSC_DI0_PIN12_ERM      18
#define BM_IPU_DI0_SSC_DI0_PIN12_ERM      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SSC_DI0_PIN12_ERM(v)   ((((reg32_t) v) << 18) & BM_IPU_DI0_SSC_DI0_PIN12_ERM)
#else
#define BF_IPU_DI0_SSC_DI0_PIN12_ERM(v)   (((v) << 18) & BM_IPU_DI0_SSC_DI0_PIN12_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PIN12_ERM field to a new value.
#define BW_IPU_DI0_SSC_DI0_PIN12_ERM(v)   BF_CS1(IPU_DI0_SSC, DI0_PIN12_ERM, v)
#endif


/* --- Register HW_IPU_DI0_SSC, field DI0_PIN13_ERM (RW)
 *
 * DI0 PIN13 error recovery mode. This bit defines the error recovery mode of the PIN13 pin.
 *
 * Values:
 * 1 - The PIN13 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC
 * 0 - Nothing is done to the PIN13 pin following a display error detection
 */

#define BP_IPU_DI0_SSC_DI0_PIN13_ERM      19
#define BM_IPU_DI0_SSC_DI0_PIN13_ERM      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SSC_DI0_PIN13_ERM(v)   ((((reg32_t) v) << 19) & BM_IPU_DI0_SSC_DI0_PIN13_ERM)
#else
#define BF_IPU_DI0_SSC_DI0_PIN13_ERM(v)   (((v) << 19) & BM_IPU_DI0_SSC_DI0_PIN13_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PIN13_ERM field to a new value.
#define BW_IPU_DI0_SSC_DI0_PIN13_ERM(v)   BF_CS1(IPU_DI0_SSC, DI0_PIN13_ERM, v)
#endif


/* --- Register HW_IPU_DI0_SSC, field DI0_PIN14_ERM (RW)
 *
 * DI0 PIN14 error recovery mode. This bit defines the error recovery mode of the PIN14 pin.
 *
 * Values:
 * 1 - The PIN14 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC
 * 0 - Nothing is done to the PIN14 pin following a display error detection
 */

#define BP_IPU_DI0_SSC_DI0_PIN14_ERM      20
#define BM_IPU_DI0_SSC_DI0_PIN14_ERM      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SSC_DI0_PIN14_ERM(v)   ((((reg32_t) v) << 20) & BM_IPU_DI0_SSC_DI0_PIN14_ERM)
#else
#define BF_IPU_DI0_SSC_DI0_PIN14_ERM(v)   (((v) << 20) & BM_IPU_DI0_SSC_DI0_PIN14_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PIN14_ERM field to a new value.
#define BW_IPU_DI0_SSC_DI0_PIN14_ERM(v)   BF_CS1(IPU_DI0_SSC, DI0_PIN14_ERM, v)
#endif


/* --- Register HW_IPU_DI0_SSC, field DI0_PIN15_ERM (RW)
 *
 * DI0 PIN15 error recovery mode. This bit defines the error recovery mode of the PIN15 pin.
 *
 * Values:
 * 1 - The PIN15 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC
 * 0 - Nothing is done to the PIN15 pin following a display error detection
 */

#define BP_IPU_DI0_SSC_DI0_PIN15_ERM      21
#define BM_IPU_DI0_SSC_DI0_PIN15_ERM      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SSC_DI0_PIN15_ERM(v)   ((((reg32_t) v) << 21) & BM_IPU_DI0_SSC_DI0_PIN15_ERM)
#else
#define BF_IPU_DI0_SSC_DI0_PIN15_ERM(v)   (((v) << 21) & BM_IPU_DI0_SSC_DI0_PIN15_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PIN15_ERM field to a new value.
#define BW_IPU_DI0_SSC_DI0_PIN15_ERM(v)   BF_CS1(IPU_DI0_SSC, DI0_PIN15_ERM, v)
#endif


/* --- Register HW_IPU_DI0_SSC, field DI0_PIN16_ERM (RW)
 *
 * DI0 PIN16 error recovery mode. This bit defines the error recovery mode of the PIN16 pin.
 *
 * Values:
 * 1 - The PIN16 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC
 * 0 - Nothing is done to the PIN16 pin following a display error detection
 */

#define BP_IPU_DI0_SSC_DI0_PIN16_ERM      22
#define BM_IPU_DI0_SSC_DI0_PIN16_ERM      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SSC_DI0_PIN16_ERM(v)   ((((reg32_t) v) << 22) & BM_IPU_DI0_SSC_DI0_PIN16_ERM)
#else
#define BF_IPU_DI0_SSC_DI0_PIN16_ERM(v)   (((v) << 22) & BM_IPU_DI0_SSC_DI0_PIN16_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PIN16_ERM field to a new value.
#define BW_IPU_DI0_SSC_DI0_PIN16_ERM(v)   BF_CS1(IPU_DI0_SSC, DI0_PIN16_ERM, v)
#endif


/* --- Register HW_IPU_DI0_SSC, field DI0_PIN17_ERM (RW)
 *
 * DI0 PIN17 error recovery mode. This bit defines the error recovery mode of the PIN17 pin.
 *
 * Values:
 * 1 - The PIN17 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC
 * 0 - Nothing is done to the PIN17 pin following a display error detection
 */

#define BP_IPU_DI0_SSC_DI0_PIN17_ERM      23
#define BM_IPU_DI0_SSC_DI0_PIN17_ERM      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SSC_DI0_PIN17_ERM(v)   ((((reg32_t) v) << 23) & BM_IPU_DI0_SSC_DI0_PIN17_ERM)
#else
#define BF_IPU_DI0_SSC_DI0_PIN17_ERM(v)   (((v) << 23) & BM_IPU_DI0_SSC_DI0_PIN17_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_PIN17_ERM field to a new value.
#define BW_IPU_DI0_SSC_DI0_PIN17_ERM(v)   BF_CS1(IPU_DI0_SSC, DI0_PIN17_ERM, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_POL - DI0 Polarity Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_DRDY_POLARITY_ : 7; //!< DI0 output dynamic pin's polarity for synchronous access This bits define the polarity of each of the DI's outputs when synchronous display access is asserted The pins' default polarity is the same as defined in the di0_drdy_polarity_[17:11] bits
        unsigned DI0_DRDY_DATA_POLARITY : 1; //!< Data Polarity associated with DRDY
        unsigned DI0_CS0_POLARITY_ : 7; //!< DI0 output pin's polarity for CS1 This bits define the polarity of each of the DI's outputs when CS1 is asserted
        unsigned DI0_CS0_DATA_POLARITY : 1; //!< Data Polarity associated with CS0
        unsigned DI0_CS1_POLARITY_ : 7; //!< DI0 output pin's polarity for CS1 This bits define the polarity of each of the DI's outputs when CS1 is asserted
        unsigned DI0_CS1_DATA_POLARITY : 1; //!< Data Polarity associated with CS1
        unsigned DI0_CS0_BYTE_EN_POLARITY : 1; //!< Byte Enable associated with CS0 polarity This bit defines the polarity of the byte enable signals to the display
        unsigned DI0_CS1_BYTE_EN_POLARITY : 1; //!< Byte Enable associated with CS1 polarity This bit defines the polarity of the byte enable signals to the display
        unsigned DI0_WAIT_POLARITY : 1; //!< WAIT polarity This bit defines the polarity of the wait signal input coming from the displa1
        unsigned RESERVED0 : 5; //!< Reserved.
    } B;
} hw_ipu_di0_pol_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_POL register
 */
#define HW_IPU_DI0_POL_ADDR(x)      (REGS_IPU_BASE(x) + 0x40164)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_POL(x)           (*(volatile hw_ipu_di0_pol_t *) HW_IPU_DI0_POL_ADDR(x))
#define HW_IPU_DI0_POL_RD(x)        (HW_IPU_DI0_POL(x).U)
#define HW_IPU_DI0_POL_WR(x, v)     (HW_IPU_DI0_POL(x).U = (v))
#define HW_IPU_DI0_POL_SET(x, v)    (HW_IPU_DI0_POL_WR(x, HW_IPU_DI0_POL_RD(x) |  (v)))
#define HW_IPU_DI0_POL_CLR(x, v)    (HW_IPU_DI0_POL_WR(x, HW_IPU_DI0_POL_RD(x) & ~(v)))
#define HW_IPU_DI0_POL_TOG(x, v)    (HW_IPU_DI0_POL_WR(x, HW_IPU_DI0_POL_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_POL bitfields
 */

/* --- Register HW_IPU_DI0_POL, field DI0_DRDY_POLARITY_ (RW)
 *
 * DI0 output dynamic pin's polarity for synchronous access This bits define the polarity of each of
 * the DI's outputs when synchronous display access is asserted The pins' default polarity is the
 * same as defined in the di0_drdy_polarity_[17:11] bits
 *
 * Values:
 * 0 - The output pin is active low
 * 1 - The output pin is active high
 */

#define BP_IPU_DI0_POL_DI0_DRDY_POLARITY_      0
#define BM_IPU_DI0_POL_DI0_DRDY_POLARITY_      0x0000007f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_POL_DI0_DRDY_POLARITY_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_POL_DI0_DRDY_POLARITY_)
#else
#define BF_IPU_DI0_POL_DI0_DRDY_POLARITY_(v)   (((v) << 0) & BM_IPU_DI0_POL_DI0_DRDY_POLARITY_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DRDY_POLARITY_ field to a new value.
#define BW_IPU_DI0_POL_DI0_DRDY_POLARITY_(v)   BF_CS1(IPU_DI0_POL, DI0_DRDY_POLARITY_, v)
#endif


/* --- Register HW_IPU_DI0_POL, field DI0_DRDY_DATA_POLARITY (RW)
 *
 * Data Polarity associated with DRDY
 */

#define BP_IPU_DI0_POL_DI0_DRDY_DATA_POLARITY      7
#define BM_IPU_DI0_POL_DI0_DRDY_DATA_POLARITY      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_POL_DI0_DRDY_DATA_POLARITY(v)   ((((reg32_t) v) << 7) & BM_IPU_DI0_POL_DI0_DRDY_DATA_POLARITY)
#else
#define BF_IPU_DI0_POL_DI0_DRDY_DATA_POLARITY(v)   (((v) << 7) & BM_IPU_DI0_POL_DI0_DRDY_DATA_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_DRDY_DATA_POLARITY field to a new value.
#define BW_IPU_DI0_POL_DI0_DRDY_DATA_POLARITY(v)   BF_CS1(IPU_DI0_POL, DI0_DRDY_DATA_POLARITY, v)
#endif

/* --- Register HW_IPU_DI0_POL, field DI0_CS0_POLARITY_ (RW)
 *
 * DI0 output pin's polarity for CS1 This bits define the polarity of each of the DI's outputs when
 * CS1 is asserted
 *
 * Values:
 * 0 - The output pin is active low
 * 1 - The output pin is active high
 */

#define BP_IPU_DI0_POL_DI0_CS0_POLARITY_      8
#define BM_IPU_DI0_POL_DI0_CS0_POLARITY_      0x00007f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_POL_DI0_CS0_POLARITY_(v)   ((((reg32_t) v) << 8) & BM_IPU_DI0_POL_DI0_CS0_POLARITY_)
#else
#define BF_IPU_DI0_POL_DI0_CS0_POLARITY_(v)   (((v) << 8) & BM_IPU_DI0_POL_DI0_CS0_POLARITY_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CS0_POLARITY_ field to a new value.
#define BW_IPU_DI0_POL_DI0_CS0_POLARITY_(v)   BF_CS1(IPU_DI0_POL, DI0_CS0_POLARITY_, v)
#endif


/* --- Register HW_IPU_DI0_POL, field DI0_CS0_DATA_POLARITY (RW)
 *
 * Data Polarity associated with CS0
 */

#define BP_IPU_DI0_POL_DI0_CS0_DATA_POLARITY      15
#define BM_IPU_DI0_POL_DI0_CS0_DATA_POLARITY      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_POL_DI0_CS0_DATA_POLARITY(v)   ((((reg32_t) v) << 15) & BM_IPU_DI0_POL_DI0_CS0_DATA_POLARITY)
#else
#define BF_IPU_DI0_POL_DI0_CS0_DATA_POLARITY(v)   (((v) << 15) & BM_IPU_DI0_POL_DI0_CS0_DATA_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CS0_DATA_POLARITY field to a new value.
#define BW_IPU_DI0_POL_DI0_CS0_DATA_POLARITY(v)   BF_CS1(IPU_DI0_POL, DI0_CS0_DATA_POLARITY, v)
#endif

/* --- Register HW_IPU_DI0_POL, field DI0_CS1_POLARITY_ (RW)
 *
 * DI0 output pin's polarity for CS1 This bits define the polarity of each of the DI's outputs when
 * CS1 is asserted
 *
 * Values:
 * 0 - The output pin is active low
 * 1 - The output pin is active high
 */

#define BP_IPU_DI0_POL_DI0_CS1_POLARITY_      16
#define BM_IPU_DI0_POL_DI0_CS1_POLARITY_      0x007f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_POL_DI0_CS1_POLARITY_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_POL_DI0_CS1_POLARITY_)
#else
#define BF_IPU_DI0_POL_DI0_CS1_POLARITY_(v)   (((v) << 16) & BM_IPU_DI0_POL_DI0_CS1_POLARITY_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CS1_POLARITY_ field to a new value.
#define BW_IPU_DI0_POL_DI0_CS1_POLARITY_(v)   BF_CS1(IPU_DI0_POL, DI0_CS1_POLARITY_, v)
#endif


/* --- Register HW_IPU_DI0_POL, field DI0_CS1_DATA_POLARITY (RW)
 *
 * Data Polarity associated with CS1
 */

#define BP_IPU_DI0_POL_DI0_CS1_DATA_POLARITY      23
#define BM_IPU_DI0_POL_DI0_CS1_DATA_POLARITY      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_POL_DI0_CS1_DATA_POLARITY(v)   ((((reg32_t) v) << 23) & BM_IPU_DI0_POL_DI0_CS1_DATA_POLARITY)
#else
#define BF_IPU_DI0_POL_DI0_CS1_DATA_POLARITY(v)   (((v) << 23) & BM_IPU_DI0_POL_DI0_CS1_DATA_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CS1_DATA_POLARITY field to a new value.
#define BW_IPU_DI0_POL_DI0_CS1_DATA_POLARITY(v)   BF_CS1(IPU_DI0_POL, DI0_CS1_DATA_POLARITY, v)
#endif

/* --- Register HW_IPU_DI0_POL, field DI0_CS0_BYTE_EN_POLARITY (RW)
 *
 * Byte Enable associated with CS0 polarity This bit defines the polarity of the byte enable signals
 * to the display
 *
 * Values:
 * 1 - active high
 * 0 - active low
 */

#define BP_IPU_DI0_POL_DI0_CS0_BYTE_EN_POLARITY      24
#define BM_IPU_DI0_POL_DI0_CS0_BYTE_EN_POLARITY      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_POL_DI0_CS0_BYTE_EN_POLARITY(v)   ((((reg32_t) v) << 24) & BM_IPU_DI0_POL_DI0_CS0_BYTE_EN_POLARITY)
#else
#define BF_IPU_DI0_POL_DI0_CS0_BYTE_EN_POLARITY(v)   (((v) << 24) & BM_IPU_DI0_POL_DI0_CS0_BYTE_EN_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CS0_BYTE_EN_POLARITY field to a new value.
#define BW_IPU_DI0_POL_DI0_CS0_BYTE_EN_POLARITY(v)   BF_CS1(IPU_DI0_POL, DI0_CS0_BYTE_EN_POLARITY, v)
#endif


/* --- Register HW_IPU_DI0_POL, field DI0_CS1_BYTE_EN_POLARITY (RW)
 *
 * Byte Enable associated with CS1 polarity This bit defines the polarity of the byte enable signals
 * to the display
 *
 * Values:
 * 1 - active high
 * 0 - active low
 */

#define BP_IPU_DI0_POL_DI0_CS1_BYTE_EN_POLARITY      25
#define BM_IPU_DI0_POL_DI0_CS1_BYTE_EN_POLARITY      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_POL_DI0_CS1_BYTE_EN_POLARITY(v)   ((((reg32_t) v) << 25) & BM_IPU_DI0_POL_DI0_CS1_BYTE_EN_POLARITY)
#else
#define BF_IPU_DI0_POL_DI0_CS1_BYTE_EN_POLARITY(v)   (((v) << 25) & BM_IPU_DI0_POL_DI0_CS1_BYTE_EN_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_CS1_BYTE_EN_POLARITY field to a new value.
#define BW_IPU_DI0_POL_DI0_CS1_BYTE_EN_POLARITY(v)   BF_CS1(IPU_DI0_POL, DI0_CS1_BYTE_EN_POLARITY, v)
#endif


/* --- Register HW_IPU_DI0_POL, field DI0_WAIT_POLARITY (RW)
 *
 * WAIT polarity This bit defines the polarity of the wait signal input coming from the displa1
 *
 * Values:
 * 1 - active high
 * 0 - active low
 */

#define BP_IPU_DI0_POL_DI0_WAIT_POLARITY      26
#define BM_IPU_DI0_POL_DI0_WAIT_POLARITY      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_POL_DI0_WAIT_POLARITY(v)   ((((reg32_t) v) << 26) & BM_IPU_DI0_POL_DI0_WAIT_POLARITY)
#else
#define BF_IPU_DI0_POL_DI0_WAIT_POLARITY(v)   (((v) << 26) & BM_IPU_DI0_POL_DI0_WAIT_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_WAIT_POLARITY field to a new value.
#define BW_IPU_DI0_POL_DI0_WAIT_POLARITY(v)   BF_CS1(IPU_DI0_POL, DI0_WAIT_POLARITY, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_AW0 - DI0 Active Window 0 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_AW_HSTART : 12; //!< This field defines the horizontal start of the active window DI0_AW_HSTART < DI0_AW_HEND
        unsigned DI0_AW_HCOUNT_SEL : 4; //!< GM: This field selects the counter that counts the horizontal position of the display's active window
        unsigned DI0_AW_HEND : 12; //!< This field defines the horizontal end of the active window
        unsigned DI0_AW_TRIG_SEL : 4; //!< This field selects the trigger for sending data during the display's active window
    } B;
} hw_ipu_di0_aw0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_AW0 register
 */
#define HW_IPU_DI0_AW0_ADDR(x)      (REGS_IPU_BASE(x) + 0x40168)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_AW0(x)           (*(volatile hw_ipu_di0_aw0_t *) HW_IPU_DI0_AW0_ADDR(x))
#define HW_IPU_DI0_AW0_RD(x)        (HW_IPU_DI0_AW0(x).U)
#define HW_IPU_DI0_AW0_WR(x, v)     (HW_IPU_DI0_AW0(x).U = (v))
#define HW_IPU_DI0_AW0_SET(x, v)    (HW_IPU_DI0_AW0_WR(x, HW_IPU_DI0_AW0_RD(x) |  (v)))
#define HW_IPU_DI0_AW0_CLR(x, v)    (HW_IPU_DI0_AW0_WR(x, HW_IPU_DI0_AW0_RD(x) & ~(v)))
#define HW_IPU_DI0_AW0_TOG(x, v)    (HW_IPU_DI0_AW0_WR(x, HW_IPU_DI0_AW0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_AW0 bitfields
 */

/* --- Register HW_IPU_DI0_AW0, field DI0_AW_HSTART (RW)
 *
 * This field defines the horizontal start of the active window DI0_AW_HSTART < DI0_AW_HEND
 */

#define BP_IPU_DI0_AW0_DI0_AW_HSTART      0
#define BM_IPU_DI0_AW0_DI0_AW_HSTART      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_AW0_DI0_AW_HSTART(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_AW0_DI0_AW_HSTART)
#else
#define BF_IPU_DI0_AW0_DI0_AW_HSTART(v)   (((v) << 0) & BM_IPU_DI0_AW0_DI0_AW_HSTART)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_AW_HSTART field to a new value.
#define BW_IPU_DI0_AW0_DI0_AW_HSTART(v)   BF_CS1(IPU_DI0_AW0, DI0_AW_HSTART, v)
#endif

/* --- Register HW_IPU_DI0_AW0, field DI0_AW_HCOUNT_SEL (RW)
 *
 * GM: This field selects the counter that counts the horizontal position of the display's active
 * window
 *
 * Values:
 * 0000 - disabled
 * 0001 - reserved
 * 0010 - The counter is counter #1
 * 0011 - The counter is counter #2
 * 0100 - The counter is counter #3
 * 0101 - The counter is counter #4
 * 0110 - The counter is counter #5
 * 1001 - The counter is counter #8
 */

#define BP_IPU_DI0_AW0_DI0_AW_HCOUNT_SEL      12
#define BM_IPU_DI0_AW0_DI0_AW_HCOUNT_SEL      0x0000f000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_AW0_DI0_AW_HCOUNT_SEL(v)   ((((reg32_t) v) << 12) & BM_IPU_DI0_AW0_DI0_AW_HCOUNT_SEL)
#else
#define BF_IPU_DI0_AW0_DI0_AW_HCOUNT_SEL(v)   (((v) << 12) & BM_IPU_DI0_AW0_DI0_AW_HCOUNT_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_AW_HCOUNT_SEL field to a new value.
#define BW_IPU_DI0_AW0_DI0_AW_HCOUNT_SEL(v)   BF_CS1(IPU_DI0_AW0, DI0_AW_HCOUNT_SEL, v)
#endif


/* --- Register HW_IPU_DI0_AW0, field DI0_AW_HEND (RW)
 *
 * This field defines the horizontal end of the active window
 */

#define BP_IPU_DI0_AW0_DI0_AW_HEND      16
#define BM_IPU_DI0_AW0_DI0_AW_HEND      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_AW0_DI0_AW_HEND(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_AW0_DI0_AW_HEND)
#else
#define BF_IPU_DI0_AW0_DI0_AW_HEND(v)   (((v) << 16) & BM_IPU_DI0_AW0_DI0_AW_HEND)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_AW_HEND field to a new value.
#define BW_IPU_DI0_AW0_DI0_AW_HEND(v)   BF_CS1(IPU_DI0_AW0, DI0_AW_HEND, v)
#endif

/* --- Register HW_IPU_DI0_AW0, field DI0_AW_TRIG_SEL (RW)
 *
 * This field selects the trigger for sending data during the display's active window
 *
 * Values:
 * 000 - disabled
 * 001 - The trigger is the same trigger that triggers the displays clock.
 * 010 - The trigger is counter #1
 * 011 - The trigger is counter #2
 * 100 - The trigger is counter #3
 * 101 - The trigger is counter #4
 * 110 - The trigger is counter #5
 * 111 - The trigger is always on.
 */

#define BP_IPU_DI0_AW0_DI0_AW_TRIG_SEL      28
#define BM_IPU_DI0_AW0_DI0_AW_TRIG_SEL      0xf0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_AW0_DI0_AW_TRIG_SEL(v)   ((((reg32_t) v) << 28) & BM_IPU_DI0_AW0_DI0_AW_TRIG_SEL)
#else
#define BF_IPU_DI0_AW0_DI0_AW_TRIG_SEL(v)   (((v) << 28) & BM_IPU_DI0_AW0_DI0_AW_TRIG_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_AW_TRIG_SEL field to a new value.
#define BW_IPU_DI0_AW0_DI0_AW_TRIG_SEL(v)   BF_CS1(IPU_DI0_AW0, DI0_AW_TRIG_SEL, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_AW1 - DI0 Active Window 1 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_AW_VSTART : 12; //!< This field defines the vertical start of the active window DI0_AW_VSTART < DI0_AW_VEND
        unsigned DI0_AW_VCOUNT_SEL : 4; //!< This field selects the counter that counts the vertical position of the display's active window
        unsigned DI0_AW_VEND : 12; //!< This field defines the vertical end of the active window
        unsigned RESERVED0 : 4; //!< Reserved
    } B;
} hw_ipu_di0_aw1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_AW1 register
 */
#define HW_IPU_DI0_AW1_ADDR(x)      (REGS_IPU_BASE(x) + 0x4016c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_AW1(x)           (*(volatile hw_ipu_di0_aw1_t *) HW_IPU_DI0_AW1_ADDR(x))
#define HW_IPU_DI0_AW1_RD(x)        (HW_IPU_DI0_AW1(x).U)
#define HW_IPU_DI0_AW1_WR(x, v)     (HW_IPU_DI0_AW1(x).U = (v))
#define HW_IPU_DI0_AW1_SET(x, v)    (HW_IPU_DI0_AW1_WR(x, HW_IPU_DI0_AW1_RD(x) |  (v)))
#define HW_IPU_DI0_AW1_CLR(x, v)    (HW_IPU_DI0_AW1_WR(x, HW_IPU_DI0_AW1_RD(x) & ~(v)))
#define HW_IPU_DI0_AW1_TOG(x, v)    (HW_IPU_DI0_AW1_WR(x, HW_IPU_DI0_AW1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_AW1 bitfields
 */

/* --- Register HW_IPU_DI0_AW1, field DI0_AW_VSTART (RW)
 *
 * This field defines the vertical start of the active window DI0_AW_VSTART < DI0_AW_VEND
 */

#define BP_IPU_DI0_AW1_DI0_AW_VSTART      0
#define BM_IPU_DI0_AW1_DI0_AW_VSTART      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_AW1_DI0_AW_VSTART(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_AW1_DI0_AW_VSTART)
#else
#define BF_IPU_DI0_AW1_DI0_AW_VSTART(v)   (((v) << 0) & BM_IPU_DI0_AW1_DI0_AW_VSTART)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_AW_VSTART field to a new value.
#define BW_IPU_DI0_AW1_DI0_AW_VSTART(v)   BF_CS1(IPU_DI0_AW1, DI0_AW_VSTART, v)
#endif

/* --- Register HW_IPU_DI0_AW1, field DI0_AW_VCOUNT_SEL (RW)
 *
 * This field selects the counter that counts the vertical position of the display's active window
 *
 * Values:
 * 0000 - disabled
 * 0001 - reserved
 * 0010 - The counter is counter #1
 * 0011 - The counter is counter #2
 * 0100 - The counter is counter #3
 * 0101 - The counter is counter #4
 * 0110 - The counter is counter #5
 * 1001 - The counter is counter #8
 */

#define BP_IPU_DI0_AW1_DI0_AW_VCOUNT_SEL      12
#define BM_IPU_DI0_AW1_DI0_AW_VCOUNT_SEL      0x0000f000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_AW1_DI0_AW_VCOUNT_SEL(v)   ((((reg32_t) v) << 12) & BM_IPU_DI0_AW1_DI0_AW_VCOUNT_SEL)
#else
#define BF_IPU_DI0_AW1_DI0_AW_VCOUNT_SEL(v)   (((v) << 12) & BM_IPU_DI0_AW1_DI0_AW_VCOUNT_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_AW_VCOUNT_SEL field to a new value.
#define BW_IPU_DI0_AW1_DI0_AW_VCOUNT_SEL(v)   BF_CS1(IPU_DI0_AW1, DI0_AW_VCOUNT_SEL, v)
#endif


/* --- Register HW_IPU_DI0_AW1, field DI0_AW_VEND (RW)
 *
 * This field defines the vertical end of the active window
 */

#define BP_IPU_DI0_AW1_DI0_AW_VEND      16
#define BM_IPU_DI0_AW1_DI0_AW_VEND      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_AW1_DI0_AW_VEND(v)   ((((reg32_t) v) << 16) & BM_IPU_DI0_AW1_DI0_AW_VEND)
#else
#define BF_IPU_DI0_AW1_DI0_AW_VEND(v)   (((v) << 16) & BM_IPU_DI0_AW1_DI0_AW_VEND)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_AW_VEND field to a new value.
#define BW_IPU_DI0_AW1_DI0_AW_VEND(v)   BF_CS1(IPU_DI0_AW1, DI0_AW_VEND, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_SCR_CONF - DI0 Screen Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_SCREEN_HEIGHT : 12; //!< This field defines the number of display rows (Number_of_ROWS = DI0_SCREEN_HEIGHT+1) This field is used for VSYNC calculation and for anti-tearing
        unsigned RESERVED0 : 20; //!< Reserved.
    } B;
} hw_ipu_di0_scr_conf_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_SCR_CONF register
 */
#define HW_IPU_DI0_SCR_CONF_ADDR(x)      (REGS_IPU_BASE(x) + 0x40170)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_SCR_CONF(x)           (*(volatile hw_ipu_di0_scr_conf_t *) HW_IPU_DI0_SCR_CONF_ADDR(x))
#define HW_IPU_DI0_SCR_CONF_RD(x)        (HW_IPU_DI0_SCR_CONF(x).U)
#define HW_IPU_DI0_SCR_CONF_WR(x, v)     (HW_IPU_DI0_SCR_CONF(x).U = (v))
#define HW_IPU_DI0_SCR_CONF_SET(x, v)    (HW_IPU_DI0_SCR_CONF_WR(x, HW_IPU_DI0_SCR_CONF_RD(x) |  (v)))
#define HW_IPU_DI0_SCR_CONF_CLR(x, v)    (HW_IPU_DI0_SCR_CONF_WR(x, HW_IPU_DI0_SCR_CONF_RD(x) & ~(v)))
#define HW_IPU_DI0_SCR_CONF_TOG(x, v)    (HW_IPU_DI0_SCR_CONF_WR(x, HW_IPU_DI0_SCR_CONF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI0_SCR_CONF bitfields
 */

/* --- Register HW_IPU_DI0_SCR_CONF, field DI0_SCREEN_HEIGHT (RW)
 *
 * This field defines the number of display rows (Number_of_ROWS = DI0_SCREEN_HEIGHT+1) This field
 * is used for VSYNC calculation and for anti-tearing
 */

#define BP_IPU_DI0_SCR_CONF_DI0_SCREEN_HEIGHT      0
#define BM_IPU_DI0_SCR_CONF_DI0_SCREEN_HEIGHT      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI0_SCR_CONF_DI0_SCREEN_HEIGHT(v)   ((((reg32_t) v) << 0) & BM_IPU_DI0_SCR_CONF_DI0_SCREEN_HEIGHT)
#else
#define BF_IPU_DI0_SCR_CONF_DI0_SCREEN_HEIGHT(v)   (((v) << 0) & BM_IPU_DI0_SCR_CONF_DI0_SCREEN_HEIGHT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI0_SCREEN_HEIGHT field to a new value.
#define BW_IPU_DI0_SCR_CONF_DI0_SCREEN_HEIGHT(v)   BF_CS1(IPU_DI0_SCR_CONF, DI0_SCREEN_HEIGHT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI0_STAT - DI0 Status Register (RO)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI0_READ_FIFO_EMPTY : 1; //!< This bit indicates an empty state of the DI0 FIFO when performing a read. This FIFO is part of the DI0 synchronizer.
        unsigned DI0_READ_FIFO_FULL : 1; //!< This bit indicates a full state of the DI0 FIFO when performing a read. This FIFO is part of the DI0 synchronizer.
        unsigned DI0_READ_CNTR_EMPTY : 1; //!< This bit indicates an empty state of the DI0 FIFO. This FIFO is part of the DI0 synchronizer.
        unsigned DI0_CNTR_FIFO_FULL : 1; //!< This bit indicates a full state of the DI0 FIFO. This FIFO is part of the DI0 synchronizer.
        unsigned RESERVED0 : 28; //!< Reserved
    } B;
} hw_ipu_di0_stat_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI0_STAT register
 */
#define HW_IPU_DI0_STAT_ADDR(x)      (REGS_IPU_BASE(x) + 0x40174)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI0_STAT(x)           (*(volatile hw_ipu_di0_stat_t *) HW_IPU_DI0_STAT_ADDR(x))
#define HW_IPU_DI0_STAT_RD(x)        (HW_IPU_DI0_STAT(x).U)
#endif

/*
 * constants & macros for individual IPU_DI0_STAT bitfields
 */

/* --- Register HW_IPU_DI0_STAT, field DI0_READ_FIFO_EMPTY (RO)
 *
 * This bit indicates an empty state of the DI0 FIFO when performing a read. This FIFO is part of
 * the DI0 synchronizer.
 */

#define BP_IPU_DI0_STAT_DI0_READ_FIFO_EMPTY      0
#define BM_IPU_DI0_STAT_DI0_READ_FIFO_EMPTY      0x00000001

/* --- Register HW_IPU_DI0_STAT, field DI0_READ_FIFO_FULL (RO)
 *
 * This bit indicates a full state of the DI0 FIFO when performing a read. This FIFO is part of the
 * DI0 synchronizer.
 */

#define BP_IPU_DI0_STAT_DI0_READ_FIFO_FULL      1
#define BM_IPU_DI0_STAT_DI0_READ_FIFO_FULL      0x00000002

/* --- Register HW_IPU_DI0_STAT, field DI0_READ_CNTR_EMPTY (RO)
 *
 * This bit indicates an empty state of the DI0 FIFO. This FIFO is part of the DI0 synchronizer.
 */

#define BP_IPU_DI0_STAT_DI0_READ_CNTR_EMPTY      2
#define BM_IPU_DI0_STAT_DI0_READ_CNTR_EMPTY      0x00000004

/* --- Register HW_IPU_DI0_STAT, field DI0_CNTR_FIFO_FULL (RO)
 *
 * This bit indicates a full state of the DI0 FIFO. This FIFO is part of the DI0 synchronizer.
 */

#define BP_IPU_DI0_STAT_DI0_CNTR_FIFO_FULL      3
#define BM_IPU_DI0_STAT_DI0_CNTR_FIFO_FULL      0x00000008

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_GENERAL - DI1General Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_POLARITY_ : 8; //!< DI1 output pin's polarity This bits define the polarity of each of the DI's outputs.
        unsigned DI1_POLARITY_CS0 : 1; //!< DI1 Chip Select's 0 polarity This bits define the polarity of the DI's CS0.
        unsigned DI1_POLARITY_CS1 : 1; //!< DI1 Chip Select's 1 polarity This bits define the polarity of the DI's CS1.
        unsigned DI1_ERM_VSYNC_SEL : 1; //!< DI1 error recovery module's VSYNC source select The error recovery block detect a case where the DI's VSYNC is asserted before the EOF. This bit selects the source of the VSYNC signal monitored by this mechanism.
        unsigned DI1_ERR_TREATMENT : 1; //!< In case of synchronous flow error there are 2 ways to handle the display
        unsigned DI1_SYNC_COUNT_SEL : 4; //!< For synchronous flow error: selects synchronous flow synchronization counter in DI:
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_POLARITY_DISP_CLK : 1; //!< DI1 Output Clock's polarity This bits define the polarity of the DI's clock.
        unsigned DI1_WATCHDOG_MODE : 2; //!< DI1 watchdog mode In case of a display error where the DI clock is stopped (defined at di0_err_treatment). An internal watchdog counts DI clocks. If this timer reached its pre defined value the DI will skip the current frame and restart on the frame. This 2 bits define the number of DI clock cycles that the timer counts.
        unsigned DI1_CLK_EXT : 1; //!< DI1 External Clock. This bit selects the source of the DI's clock
        unsigned DI1_VSYNC_EXT : 1; //!< DI1 External VSYNC. This bit selects the source of the VSYNC signal
        unsigned DI1_MASK_SEL : 1; //!< DI1 Mask select. IPP_PIN_2 output of the DI that functions as MASK signal can come from 2 sources: counter #2 or extracted from the MASK data coming from the memory.
        unsigned DI1_DISP_CLOCK_INIT : 1; //!< Display clock's initial mode For synchronization error conditions the display clock can be stopped on the next VSYNC
        unsigned DI1_CLOCK_STOP_MODE : 4; //!< DI clock stop mode When performing a clock change. The DI stops the clock to the display. These field defines when the clock will be stopped Stopping at EOL/EOF is supported for the case where the data is coming from the IDMAC (DMA access). In case that only direct accesses is performed, the user should set this field to 0000 0001-1001 stop at the next event of one of the counters (counter #1 to counter #9)
        unsigned DI1_DISP_Y_SEL : 3; //!< DI1 Display Vertical coordinate (Y) select. This field defines which one of the 8 counters will be used as a display's line counter.
        unsigned DI1_PIN8_PIN15_SEL : 1; //!< Reserved. This bit routes PIN8 over PIN15
    } B;
} hw_ipu_di1_general_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_GENERAL register
 */
#define HW_IPU_DI1_GENERAL_ADDR(x)      (REGS_IPU_BASE(x) + 0x48000)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_GENERAL(x)           (*(volatile hw_ipu_di1_general_t *) HW_IPU_DI1_GENERAL_ADDR(x))
#define HW_IPU_DI1_GENERAL_RD(x)        (HW_IPU_DI1_GENERAL(x).U)
#define HW_IPU_DI1_GENERAL_WR(x, v)     (HW_IPU_DI1_GENERAL(x).U = (v))
#define HW_IPU_DI1_GENERAL_SET(x, v)    (HW_IPU_DI1_GENERAL_WR(x, HW_IPU_DI1_GENERAL_RD(x) |  (v)))
#define HW_IPU_DI1_GENERAL_CLR(x, v)    (HW_IPU_DI1_GENERAL_WR(x, HW_IPU_DI1_GENERAL_RD(x) & ~(v)))
#define HW_IPU_DI1_GENERAL_TOG(x, v)    (HW_IPU_DI1_GENERAL_WR(x, HW_IPU_DI1_GENERAL_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_GENERAL bitfields
 */

/* --- Register HW_IPU_DI1_GENERAL, field DI1_POLARITY_ (RW)
 *
 * DI1 output pin's polarity This bits define the polarity of each of the DI's outputs.
 *
 * Values:
 * 0 - The output pin is active low
 * 1 - The output pin is active high
 */

#define BP_IPU_DI1_GENERAL_DI1_POLARITY_      0
#define BM_IPU_DI1_GENERAL_DI1_POLARITY_      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_POLARITY_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_GENERAL_DI1_POLARITY_)
#else
#define BF_IPU_DI1_GENERAL_DI1_POLARITY_(v)   (((v) << 0) & BM_IPU_DI1_GENERAL_DI1_POLARITY_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_POLARITY_ field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_POLARITY_(v)   BF_CS1(IPU_DI1_GENERAL, DI1_POLARITY_, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_POLARITY_CS0 (RW)
 *
 * DI1 Chip Select's 0 polarity This bits define the polarity of the DI's CS0.
 *
 * Values:
 * 1 - The CS0 is active high
 * 0 - The CS0 is active low
 */

#define BP_IPU_DI1_GENERAL_DI1_POLARITY_CS0      8
#define BM_IPU_DI1_GENERAL_DI1_POLARITY_CS0      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_POLARITY_CS0(v)   ((((reg32_t) v) << 8) & BM_IPU_DI1_GENERAL_DI1_POLARITY_CS0)
#else
#define BF_IPU_DI1_GENERAL_DI1_POLARITY_CS0(v)   (((v) << 8) & BM_IPU_DI1_GENERAL_DI1_POLARITY_CS0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_POLARITY_CS0 field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_POLARITY_CS0(v)   BF_CS1(IPU_DI1_GENERAL, DI1_POLARITY_CS0, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_POLARITY_CS1 (RW)
 *
 * DI1 Chip Select's 1 polarity This bits define the polarity of the DI's CS1.
 *
 * Values:
 * 1 - The CS1 is active high
 * 0 - The CS1 is active low
 */

#define BP_IPU_DI1_GENERAL_DI1_POLARITY_CS1      9
#define BM_IPU_DI1_GENERAL_DI1_POLARITY_CS1      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_POLARITY_CS1(v)   ((((reg32_t) v) << 9) & BM_IPU_DI1_GENERAL_DI1_POLARITY_CS1)
#else
#define BF_IPU_DI1_GENERAL_DI1_POLARITY_CS1(v)   (((v) << 9) & BM_IPU_DI1_GENERAL_DI1_POLARITY_CS1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_POLARITY_CS1 field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_POLARITY_CS1(v)   BF_CS1(IPU_DI1_GENERAL, DI1_POLARITY_CS1, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_ERM_VSYNC_SEL (RW)
 *
 * DI1 error recovery module's VSYNC source select The error recovery block detect a case where the
 * DI's VSYNC is asserted before the EOF. This bit selects the source of the VSYNC signal monitored
 * by this mechanism.
 *
 * Values:
 * 1 - vsync_post - an internal VSYNC signal asserted 2 lines after the DI's VSYNC
 * 0 - vsync_pre - an internal VSYNC signal asserted 2 lines before the DI's VSYNC
 */

#define BP_IPU_DI1_GENERAL_DI1_ERM_VSYNC_SEL      10
#define BM_IPU_DI1_GENERAL_DI1_ERM_VSYNC_SEL      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_ERM_VSYNC_SEL(v)   ((((reg32_t) v) << 10) & BM_IPU_DI1_GENERAL_DI1_ERM_VSYNC_SEL)
#else
#define BF_IPU_DI1_GENERAL_DI1_ERM_VSYNC_SEL(v)   (((v) << 10) & BM_IPU_DI1_GENERAL_DI1_ERM_VSYNC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_ERM_VSYNC_SEL field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_ERM_VSYNC_SEL(v)   BF_CS1(IPU_DI1_GENERAL, DI1_ERM_VSYNC_SEL, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_ERR_TREATMENT (RW)
 *
 * In case of synchronous flow error there are 2 ways to handle the display
 *
 * Values:
 * 1 - to wait (i.e. stop clock)
 * 0 - Drive the last component
 */

#define BP_IPU_DI1_GENERAL_DI1_ERR_TREATMENT      11
#define BM_IPU_DI1_GENERAL_DI1_ERR_TREATMENT      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_ERR_TREATMENT(v)   ((((reg32_t) v) << 11) & BM_IPU_DI1_GENERAL_DI1_ERR_TREATMENT)
#else
#define BF_IPU_DI1_GENERAL_DI1_ERR_TREATMENT(v)   (((v) << 11) & BM_IPU_DI1_GENERAL_DI1_ERR_TREATMENT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_ERR_TREATMENT field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_ERR_TREATMENT(v)   BF_CS1(IPU_DI1_GENERAL, DI1_ERR_TREATMENT, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_SYNC_COUNT_SEL (RW)
 *
 * For synchronous flow error: selects synchronous flow synchronization counter in DI:
 */

#define BP_IPU_DI1_GENERAL_DI1_SYNC_COUNT_SEL      12
#define BM_IPU_DI1_GENERAL_DI1_SYNC_COUNT_SEL      0x0000f000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_SYNC_COUNT_SEL(v)   ((((reg32_t) v) << 12) & BM_IPU_DI1_GENERAL_DI1_SYNC_COUNT_SEL)
#else
#define BF_IPU_DI1_GENERAL_DI1_SYNC_COUNT_SEL(v)   (((v) << 12) & BM_IPU_DI1_GENERAL_DI1_SYNC_COUNT_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SYNC_COUNT_SEL field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_SYNC_COUNT_SEL(v)   BF_CS1(IPU_DI1_GENERAL, DI1_SYNC_COUNT_SEL, v)
#endif

/* --- Register HW_IPU_DI1_GENERAL, field DI1_POLARITY_DISP_CLK (RW)
 *
 * DI1 Output Clock's polarity This bits define the polarity of the DI's clock.
 *
 * Values:
 * 1 - The output clock is active high
 * 0 - The output clock is active low
 */

#define BP_IPU_DI1_GENERAL_DI1_POLARITY_DISP_CLK      17
#define BM_IPU_DI1_GENERAL_DI1_POLARITY_DISP_CLK      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_POLARITY_DISP_CLK(v)   ((((reg32_t) v) << 17) & BM_IPU_DI1_GENERAL_DI1_POLARITY_DISP_CLK)
#else
#define BF_IPU_DI1_GENERAL_DI1_POLARITY_DISP_CLK(v)   (((v) << 17) & BM_IPU_DI1_GENERAL_DI1_POLARITY_DISP_CLK)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_POLARITY_DISP_CLK field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_POLARITY_DISP_CLK(v)   BF_CS1(IPU_DI1_GENERAL, DI1_POLARITY_DISP_CLK, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_WATCHDOG_MODE (RW)
 *
 * DI1 watchdog mode In case of a display error where the DI clock is stopped (defined at
 * di0_err_treatment). An internal watchdog counts DI clocks. If this timer reached its pre defined
 * value the DI will skip the current frame and restart on the frame. This 2 bits define the number
 * of DI clock cycles that the timer counts.
 *
 * Values:
 * 00 - The timer counts 4 DI cycles
 * 01 - The timer counts 16 DI cycles
 * 10 - The timer counts 64 DI cycles
 * 11 - The timer counts 128 DI cycles
 */

#define BP_IPU_DI1_GENERAL_DI1_WATCHDOG_MODE      18
#define BM_IPU_DI1_GENERAL_DI1_WATCHDOG_MODE      0x000c0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_WATCHDOG_MODE(v)   ((((reg32_t) v) << 18) & BM_IPU_DI1_GENERAL_DI1_WATCHDOG_MODE)
#else
#define BF_IPU_DI1_GENERAL_DI1_WATCHDOG_MODE(v)   (((v) << 18) & BM_IPU_DI1_GENERAL_DI1_WATCHDOG_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_WATCHDOG_MODE field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_WATCHDOG_MODE(v)   BF_CS1(IPU_DI1_GENERAL, DI1_WATCHDOG_MODE, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_CLK_EXT (RW)
 *
 * DI1 External Clock. This bit selects the source of the DI's clock
 *
 * Values:
 * 1 - The source of the clock is external to the IPU
 * 0 - The clock is internally generated by the IPU
 */

#define BP_IPU_DI1_GENERAL_DI1_CLK_EXT      20
#define BM_IPU_DI1_GENERAL_DI1_CLK_EXT      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_CLK_EXT(v)   ((((reg32_t) v) << 20) & BM_IPU_DI1_GENERAL_DI1_CLK_EXT)
#else
#define BF_IPU_DI1_GENERAL_DI1_CLK_EXT(v)   (((v) << 20) & BM_IPU_DI1_GENERAL_DI1_CLK_EXT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CLK_EXT field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_CLK_EXT(v)   BF_CS1(IPU_DI1_GENERAL, DI1_CLK_EXT, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_VSYNC_EXT (RW)
 *
 * DI1 External VSYNC. This bit selects the source of the VSYNC signal
 *
 * Values:
 * 1 - External to the IPU
 * 0 - Internally generated by the IPU
 */

#define BP_IPU_DI1_GENERAL_DI1_VSYNC_EXT      21
#define BM_IPU_DI1_GENERAL_DI1_VSYNC_EXT      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_VSYNC_EXT(v)   ((((reg32_t) v) << 21) & BM_IPU_DI1_GENERAL_DI1_VSYNC_EXT)
#else
#define BF_IPU_DI1_GENERAL_DI1_VSYNC_EXT(v)   (((v) << 21) & BM_IPU_DI1_GENERAL_DI1_VSYNC_EXT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_VSYNC_EXT field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_VSYNC_EXT(v)   BF_CS1(IPU_DI1_GENERAL, DI1_VSYNC_EXT, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_MASK_SEL (RW)
 *
 * DI1 Mask select. IPP_PIN_2 output of the DI that functions as MASK signal can come from 2
 * sources: counter #2 or extracted from the MASK data coming from the memory.
 *
 * Values:
 * 1 - IPP_PIN_2 is coming from extracted MASK data coming from the memory
 * 0 - IPP_PIN_2 is coming from counter #2
 */

#define BP_IPU_DI1_GENERAL_DI1_MASK_SEL      22
#define BM_IPU_DI1_GENERAL_DI1_MASK_SEL      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_MASK_SEL(v)   ((((reg32_t) v) << 22) & BM_IPU_DI1_GENERAL_DI1_MASK_SEL)
#else
#define BF_IPU_DI1_GENERAL_DI1_MASK_SEL(v)   (((v) << 22) & BM_IPU_DI1_GENERAL_DI1_MASK_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_MASK_SEL field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_MASK_SEL(v)   BF_CS1(IPU_DI1_GENERAL, DI1_MASK_SEL, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_DISP_CLOCK_INIT (RW)
 *
 * Display clock's initial mode For synchronization error conditions the display clock can be
 * stopped on the next VSYNC
 *
 * Values:
 * 1 - The display's clock is running after the next VSYNC (indicating new frame)
 * 0 - The display's clock is stopped after the next VSYNC (indicating new frame)
 */

#define BP_IPU_DI1_GENERAL_DI1_DISP_CLOCK_INIT      23
#define BM_IPU_DI1_GENERAL_DI1_DISP_CLOCK_INIT      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_DISP_CLOCK_INIT(v)   ((((reg32_t) v) << 23) & BM_IPU_DI1_GENERAL_DI1_DISP_CLOCK_INIT)
#else
#define BF_IPU_DI1_GENERAL_DI1_DISP_CLOCK_INIT(v)   (((v) << 23) & BM_IPU_DI1_GENERAL_DI1_DISP_CLOCK_INIT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DISP_CLOCK_INIT field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_DISP_CLOCK_INIT(v)   BF_CS1(IPU_DI1_GENERAL, DI1_DISP_CLOCK_INIT, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_CLOCK_STOP_MODE (RW)
 *
 * DI clock stop mode When performing a clock change. The DI stops the clock to the display. These
 * field defines when the clock will be stopped Stopping at EOL/EOF is supported for the case where
 * the data is coming from the IDMAC (DMA access). In case that only direct accesses is performed,
 * the user should set this field to 0000 0001-1001 stop at the next event of one of the counters
 * (counter #1 to counter #9)
 *
 * Values:
 * 0000 - stop at the next edge of the display clock
 * 1100 - stop at EOL (end of a line), but if stop request is during blanking interval, stop now
 * 1101 - stop at EOF (end of a frame), but if stop request is during blanking interval, stop now
 * 1110 - stop at EOL (end of a line), but if stop request is during blanking interval, stop at the end of the
 *     next line
 * 1111 - stop at EOF (end of a frame), but if stop request is during blanking interval, stop at the end of
 *     the next frame
 */

#define BP_IPU_DI1_GENERAL_DI1_CLOCK_STOP_MODE      24
#define BM_IPU_DI1_GENERAL_DI1_CLOCK_STOP_MODE      0x0f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_CLOCK_STOP_MODE(v)   ((((reg32_t) v) << 24) & BM_IPU_DI1_GENERAL_DI1_CLOCK_STOP_MODE)
#else
#define BF_IPU_DI1_GENERAL_DI1_CLOCK_STOP_MODE(v)   (((v) << 24) & BM_IPU_DI1_GENERAL_DI1_CLOCK_STOP_MODE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CLOCK_STOP_MODE field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_CLOCK_STOP_MODE(v)   BF_CS1(IPU_DI1_GENERAL, DI1_CLOCK_STOP_MODE, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_DISP_Y_SEL (RW)
 *
 * DI1 Display Vertical coordinate (Y) select. This field defines which one of the 8 counters will
 * be used as a display's line counter.
 *
 * Values:
 * 000 - counter #1 is selected
 * 111 - counter #8 is selected
 */

#define BP_IPU_DI1_GENERAL_DI1_DISP_Y_SEL      28
#define BM_IPU_DI1_GENERAL_DI1_DISP_Y_SEL      0x70000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_DISP_Y_SEL(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_GENERAL_DI1_DISP_Y_SEL)
#else
#define BF_IPU_DI1_GENERAL_DI1_DISP_Y_SEL(v)   (((v) << 28) & BM_IPU_DI1_GENERAL_DI1_DISP_Y_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DISP_Y_SEL field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_DISP_Y_SEL(v)   BF_CS1(IPU_DI1_GENERAL, DI1_DISP_Y_SEL, v)
#endif


/* --- Register HW_IPU_DI1_GENERAL, field DI1_PIN8_PIN15_SEL (RW)
 *
 * Reserved. This bit routes PIN8 over PIN15
 *
 * Values:
 * 1 - PIN8 is routed to PIN15, PIN8 is also routed to PIN8
 * 0 - PIN15 is routed to PIN15, PIN8 is routed to PIN8
 */

#define BP_IPU_DI1_GENERAL_DI1_PIN8_PIN15_SEL      31
#define BM_IPU_DI1_GENERAL_DI1_PIN8_PIN15_SEL      0x80000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_GENERAL_DI1_PIN8_PIN15_SEL(v)   ((((reg32_t) v) << 31) & BM_IPU_DI1_GENERAL_DI1_PIN8_PIN15_SEL)
#else
#define BF_IPU_DI1_GENERAL_DI1_PIN8_PIN15_SEL(v)   (((v) << 31) & BM_IPU_DI1_GENERAL_DI1_PIN8_PIN15_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PIN8_PIN15_SEL field to a new value.
#define BW_IPU_DI1_GENERAL_DI1_PIN8_PIN15_SEL(v)   BF_CS1(IPU_DI1_GENERAL, DI1_PIN8_PIN15_SEL, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_BS_CLKGEN0 - DI1 Base Sync Clock Gen 0 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_DISP_CLK_PERIOD : 12; //!< DI1 Display Clock Period This field defines the Display interface clock period for display write access. This parameter contains an integer part (bits 11:4) and a fractional part (bits 3:0). It defines a fractional division ratio of the HSP_CLK clock for generation of the display's interface clock.
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned DI1_DISP_CLK_OFFSET : 9; //!< DI1 Display Clock Offset The DI has the ability to delay the display's clock This field defines the amount of IPU's clock cycles added as delay on this clock.
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_di1_bs_clkgen0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_BS_CLKGEN0 register
 */
#define HW_IPU_DI1_BS_CLKGEN0_ADDR(x)      (REGS_IPU_BASE(x) + 0x48004)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_BS_CLKGEN0(x)           (*(volatile hw_ipu_di1_bs_clkgen0_t *) HW_IPU_DI1_BS_CLKGEN0_ADDR(x))
#define HW_IPU_DI1_BS_CLKGEN0_RD(x)        (HW_IPU_DI1_BS_CLKGEN0(x).U)
#define HW_IPU_DI1_BS_CLKGEN0_WR(x, v)     (HW_IPU_DI1_BS_CLKGEN0(x).U = (v))
#define HW_IPU_DI1_BS_CLKGEN0_SET(x, v)    (HW_IPU_DI1_BS_CLKGEN0_WR(x, HW_IPU_DI1_BS_CLKGEN0_RD(x) |  (v)))
#define HW_IPU_DI1_BS_CLKGEN0_CLR(x, v)    (HW_IPU_DI1_BS_CLKGEN0_WR(x, HW_IPU_DI1_BS_CLKGEN0_RD(x) & ~(v)))
#define HW_IPU_DI1_BS_CLKGEN0_TOG(x, v)    (HW_IPU_DI1_BS_CLKGEN0_WR(x, HW_IPU_DI1_BS_CLKGEN0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_BS_CLKGEN0 bitfields
 */

/* --- Register HW_IPU_DI1_BS_CLKGEN0, field DI1_DISP_CLK_PERIOD (RW)
 *
 * DI1 Display Clock Period This field defines the Display interface clock period for display write
 * access. This parameter contains an integer part (bits 11:4) and a fractional part (bits 3:0). It
 * defines a fractional division ratio of the HSP_CLK clock for generation of the display's
 * interface clock.
 */

#define BP_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_PERIOD      0
#define BM_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_PERIOD      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_PERIOD(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_PERIOD)
#else
#define BF_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_PERIOD(v)   (((v) << 0) & BM_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_PERIOD)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DISP_CLK_PERIOD field to a new value.
#define BW_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_PERIOD(v)   BF_CS1(IPU_DI1_BS_CLKGEN0, DI1_DISP_CLK_PERIOD, v)
#endif

/* --- Register HW_IPU_DI1_BS_CLKGEN0, field DI1_DISP_CLK_OFFSET (RW)
 *
 * DI1 Display Clock Offset The DI has the ability to delay the display's clock This field defines
 * the amount of IPU's clock cycles added as delay on this clock.
 */

#define BP_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_OFFSET      16
#define BM_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_OFFSET      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_OFFSET(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_OFFSET)
#else
#define BF_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_OFFSET(v)   (((v) << 16) & BM_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_OFFSET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DISP_CLK_OFFSET field to a new value.
#define BW_IPU_DI1_BS_CLKGEN0_DI1_DISP_CLK_OFFSET(v)   BF_CS1(IPU_DI1_BS_CLKGEN0, DI1_DISP_CLK_OFFSET, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_BS_CLKGEN1 - DI1 Base Sync Clock Gen 1 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_DISP_CLK_UP : 9; //!< DI1 display clock rising edge position This parameter contains an integer part (bits 8:1) and a fractional part (bit 0). The position value is a time interval between display's access start point and display 's interface clock rising edge.
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DI1_DISP_CLK_DOWN : 9; //!< DI1 display clock falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is a time interval between display's access start point and display 's interface clock falling edge.
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_di1_bs_clkgen1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_BS_CLKGEN1 register
 */
#define HW_IPU_DI1_BS_CLKGEN1_ADDR(x)      (REGS_IPU_BASE(x) + 0x48008)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_BS_CLKGEN1(x)           (*(volatile hw_ipu_di1_bs_clkgen1_t *) HW_IPU_DI1_BS_CLKGEN1_ADDR(x))
#define HW_IPU_DI1_BS_CLKGEN1_RD(x)        (HW_IPU_DI1_BS_CLKGEN1(x).U)
#define HW_IPU_DI1_BS_CLKGEN1_WR(x, v)     (HW_IPU_DI1_BS_CLKGEN1(x).U = (v))
#define HW_IPU_DI1_BS_CLKGEN1_SET(x, v)    (HW_IPU_DI1_BS_CLKGEN1_WR(x, HW_IPU_DI1_BS_CLKGEN1_RD(x) |  (v)))
#define HW_IPU_DI1_BS_CLKGEN1_CLR(x, v)    (HW_IPU_DI1_BS_CLKGEN1_WR(x, HW_IPU_DI1_BS_CLKGEN1_RD(x) & ~(v)))
#define HW_IPU_DI1_BS_CLKGEN1_TOG(x, v)    (HW_IPU_DI1_BS_CLKGEN1_WR(x, HW_IPU_DI1_BS_CLKGEN1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_BS_CLKGEN1 bitfields
 */

/* --- Register HW_IPU_DI1_BS_CLKGEN1, field DI1_DISP_CLK_UP (RW)
 *
 * DI1 display clock rising edge position This parameter contains an integer part (bits 8:1) and a
 * fractional part (bit 0). The position value is a time interval between display's access start
 * point and display 's interface clock rising edge.
 */

#define BP_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_UP      0
#define BM_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_UP      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_UP(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_UP)
#else
#define BF_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_UP(v)   (((v) << 0) & BM_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_UP)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DISP_CLK_UP field to a new value.
#define BW_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_UP(v)   BF_CS1(IPU_DI1_BS_CLKGEN1, DI1_DISP_CLK_UP, v)
#endif

/* --- Register HW_IPU_DI1_BS_CLKGEN1, field DI1_DISP_CLK_DOWN (RW)
 *
 * DI1 display clock falling edge position This parameter contains an integer part (bits 24:17) and
 * a fractional part (bit 16). The position value is a time interval between display's access start
 * point and display 's interface clock falling edge.
 */

#define BP_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_DOWN      16
#define BM_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_DOWN      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_DOWN(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_DOWN)
#else
#define BF_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_DOWN(v)   (((v) << 16) & BM_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_DOWN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DISP_CLK_DOWN field to a new value.
#define BW_IPU_DI1_BS_CLKGEN1_DI1_DISP_CLK_DOWN(v)   BF_CS1(IPU_DI1_BS_CLKGEN1, DI1_DISP_CLK_DOWN, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN0_1 - DI1 Sync Wave Gen 1 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_OFFSET_RESOLUTION_1 : 3; //!< DI1 counter #1 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI1_OFFSET_VALUE_1 : 12; //!< DI1 counter #1 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_RUN_RESOLUTION_1 : 3; //!< DI1 counter #1 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI1_RUN_VALUE_M1_1 : 12; //!< DI1 counter #1 pre defined value This fields defines the counter #1 pre defines value. When the counter is auto reload mode (di1_cnt_auto_reload_1 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di1_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen0_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN0_1 register
 */
#define HW_IPU_DI1_SW_GEN0_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x4800c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN0_1(x)           (*(volatile hw_ipu_di1_sw_gen0_1_t *) HW_IPU_DI1_SW_GEN0_1_ADDR(x))
#define HW_IPU_DI1_SW_GEN0_1_RD(x)        (HW_IPU_DI1_SW_GEN0_1(x).U)
#define HW_IPU_DI1_SW_GEN0_1_WR(x, v)     (HW_IPU_DI1_SW_GEN0_1(x).U = (v))
#define HW_IPU_DI1_SW_GEN0_1_SET(x, v)    (HW_IPU_DI1_SW_GEN0_1_WR(x, HW_IPU_DI1_SW_GEN0_1_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN0_1_CLR(x, v)    (HW_IPU_DI1_SW_GEN0_1_WR(x, HW_IPU_DI1_SW_GEN0_1_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN0_1_TOG(x, v)    (HW_IPU_DI1_SW_GEN0_1_WR(x, HW_IPU_DI1_SW_GEN0_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN0_1 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN0_1, field DI1_OFFSET_RESOLUTION_1 (RW)
 *
 * DI1 counter #1 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - NA
 * 011 - NA
 * 100 - NA
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_1_DI1_OFFSET_RESOLUTION_1      0
#define BM_IPU_DI1_SW_GEN0_1_DI1_OFFSET_RESOLUTION_1      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_1_DI1_OFFSET_RESOLUTION_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN0_1_DI1_OFFSET_RESOLUTION_1)
#else
#define BF_IPU_DI1_SW_GEN0_1_DI1_OFFSET_RESOLUTION_1(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN0_1_DI1_OFFSET_RESOLUTION_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_RESOLUTION_1 field to a new value.
#define BW_IPU_DI1_SW_GEN0_1_DI1_OFFSET_RESOLUTION_1(v)   BF_CS1(IPU_DI1_SW_GEN0_1, DI1_OFFSET_RESOLUTION_1, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_1, field DI1_OFFSET_VALUE_1 (RW)
 *
 * DI1 counter #1 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI1_SW_GEN0_1_DI1_OFFSET_VALUE_1      3
#define BM_IPU_DI1_SW_GEN0_1_DI1_OFFSET_VALUE_1      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_1_DI1_OFFSET_VALUE_1(v)   ((((reg32_t) v) << 3) & BM_IPU_DI1_SW_GEN0_1_DI1_OFFSET_VALUE_1)
#else
#define BF_IPU_DI1_SW_GEN0_1_DI1_OFFSET_VALUE_1(v)   (((v) << 3) & BM_IPU_DI1_SW_GEN0_1_DI1_OFFSET_VALUE_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_VALUE_1 field to a new value.
#define BW_IPU_DI1_SW_GEN0_1_DI1_OFFSET_VALUE_1(v)   BF_CS1(IPU_DI1_SW_GEN0_1, DI1_OFFSET_VALUE_1, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN0_1, field DI1_RUN_RESOLUTION_1 (RW)
 *
 * DI1 counter #1 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - NA
 * 011 - NA
 * 100 - NA
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_1_DI1_RUN_RESOLUTION_1      16
#define BM_IPU_DI1_SW_GEN0_1_DI1_RUN_RESOLUTION_1      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_1_DI1_RUN_RESOLUTION_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN0_1_DI1_RUN_RESOLUTION_1)
#else
#define BF_IPU_DI1_SW_GEN0_1_DI1_RUN_RESOLUTION_1(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN0_1_DI1_RUN_RESOLUTION_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_RESOLUTION_1 field to a new value.
#define BW_IPU_DI1_SW_GEN0_1_DI1_RUN_RESOLUTION_1(v)   BF_CS1(IPU_DI1_SW_GEN0_1, DI1_RUN_RESOLUTION_1, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_1, field DI1_RUN_VALUE_M1_1 (RW)
 *
 * DI1 counter #1 pre defined value This fields defines the counter #1 pre defines value. When the
 * counter is auto reload mode (di1_cnt_auto_reload_1 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di1_step_repeat field.
 */

#define BP_IPU_DI1_SW_GEN0_1_DI1_RUN_VALUE_M1_1      19
#define BM_IPU_DI1_SW_GEN0_1_DI1_RUN_VALUE_M1_1      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_1_DI1_RUN_VALUE_M1_1(v)   ((((reg32_t) v) << 19) & BM_IPU_DI1_SW_GEN0_1_DI1_RUN_VALUE_M1_1)
#else
#define BF_IPU_DI1_SW_GEN0_1_DI1_RUN_VALUE_M1_1(v)   (((v) << 19) & BM_IPU_DI1_SW_GEN0_1_DI1_RUN_VALUE_M1_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_VALUE_M1_1 field to a new value.
#define BW_IPU_DI1_SW_GEN0_1_DI1_RUN_VALUE_M1_1(v)   BF_CS1(IPU_DI1_SW_GEN0_1, DI1_RUN_VALUE_M1_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN0_2 - DI1 Sync Wave Gen 2 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_OFFSET_RESOLUTION_2 : 3; //!< DI1 counter #2 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI1_OFFSET_VALUE_2 : 12; //!< DI1 counter #2 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_RUN_RESOLUTION_2 : 3; //!< DI1 counter #2 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI1_RUN_VALUE_M1_2 : 12; //!< DI1 counter #2 pre defined value This fields defines the counter #2 pre defines value. When the counter is auto reload mode (di1_cnt_auto_reload_2 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di1_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen0_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN0_2 register
 */
#define HW_IPU_DI1_SW_GEN0_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x48010)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN0_2(x)           (*(volatile hw_ipu_di1_sw_gen0_2_t *) HW_IPU_DI1_SW_GEN0_2_ADDR(x))
#define HW_IPU_DI1_SW_GEN0_2_RD(x)        (HW_IPU_DI1_SW_GEN0_2(x).U)
#define HW_IPU_DI1_SW_GEN0_2_WR(x, v)     (HW_IPU_DI1_SW_GEN0_2(x).U = (v))
#define HW_IPU_DI1_SW_GEN0_2_SET(x, v)    (HW_IPU_DI1_SW_GEN0_2_WR(x, HW_IPU_DI1_SW_GEN0_2_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN0_2_CLR(x, v)    (HW_IPU_DI1_SW_GEN0_2_WR(x, HW_IPU_DI1_SW_GEN0_2_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN0_2_TOG(x, v)    (HW_IPU_DI1_SW_GEN0_2_WR(x, HW_IPU_DI1_SW_GEN0_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN0_2 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN0_2, field DI1_OFFSET_RESOLUTION_2 (RW)
 *
 * DI1 counter #2 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - NA
 * 100 - NA
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_2_DI1_OFFSET_RESOLUTION_2      0
#define BM_IPU_DI1_SW_GEN0_2_DI1_OFFSET_RESOLUTION_2      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_2_DI1_OFFSET_RESOLUTION_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN0_2_DI1_OFFSET_RESOLUTION_2)
#else
#define BF_IPU_DI1_SW_GEN0_2_DI1_OFFSET_RESOLUTION_2(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN0_2_DI1_OFFSET_RESOLUTION_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_RESOLUTION_2 field to a new value.
#define BW_IPU_DI1_SW_GEN0_2_DI1_OFFSET_RESOLUTION_2(v)   BF_CS1(IPU_DI1_SW_GEN0_2, DI1_OFFSET_RESOLUTION_2, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_2, field DI1_OFFSET_VALUE_2 (RW)
 *
 * DI1 counter #2 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI1_SW_GEN0_2_DI1_OFFSET_VALUE_2      3
#define BM_IPU_DI1_SW_GEN0_2_DI1_OFFSET_VALUE_2      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_2_DI1_OFFSET_VALUE_2(v)   ((((reg32_t) v) << 3) & BM_IPU_DI1_SW_GEN0_2_DI1_OFFSET_VALUE_2)
#else
#define BF_IPU_DI1_SW_GEN0_2_DI1_OFFSET_VALUE_2(v)   (((v) << 3) & BM_IPU_DI1_SW_GEN0_2_DI1_OFFSET_VALUE_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_VALUE_2 field to a new value.
#define BW_IPU_DI1_SW_GEN0_2_DI1_OFFSET_VALUE_2(v)   BF_CS1(IPU_DI1_SW_GEN0_2, DI1_OFFSET_VALUE_2, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN0_2, field DI1_RUN_RESOLUTION_2 (RW)
 *
 * DI1 counter #2 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - NA
 * 100 - NA
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_2_DI1_RUN_RESOLUTION_2      16
#define BM_IPU_DI1_SW_GEN0_2_DI1_RUN_RESOLUTION_2      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_2_DI1_RUN_RESOLUTION_2(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN0_2_DI1_RUN_RESOLUTION_2)
#else
#define BF_IPU_DI1_SW_GEN0_2_DI1_RUN_RESOLUTION_2(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN0_2_DI1_RUN_RESOLUTION_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_RESOLUTION_2 field to a new value.
#define BW_IPU_DI1_SW_GEN0_2_DI1_RUN_RESOLUTION_2(v)   BF_CS1(IPU_DI1_SW_GEN0_2, DI1_RUN_RESOLUTION_2, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_2, field DI1_RUN_VALUE_M1_2 (RW)
 *
 * DI1 counter #2 pre defined value This fields defines the counter #2 pre defines value. When the
 * counter is auto reload mode (di1_cnt_auto_reload_2 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di1_step_repeat field.
 */

#define BP_IPU_DI1_SW_GEN0_2_DI1_RUN_VALUE_M1_2      19
#define BM_IPU_DI1_SW_GEN0_2_DI1_RUN_VALUE_M1_2      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_2_DI1_RUN_VALUE_M1_2(v)   ((((reg32_t) v) << 19) & BM_IPU_DI1_SW_GEN0_2_DI1_RUN_VALUE_M1_2)
#else
#define BF_IPU_DI1_SW_GEN0_2_DI1_RUN_VALUE_M1_2(v)   (((v) << 19) & BM_IPU_DI1_SW_GEN0_2_DI1_RUN_VALUE_M1_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_VALUE_M1_2 field to a new value.
#define BW_IPU_DI1_SW_GEN0_2_DI1_RUN_VALUE_M1_2(v)   BF_CS1(IPU_DI1_SW_GEN0_2, DI1_RUN_VALUE_M1_2, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN0_3 - DI1 Sync Wave Gen 3 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_OFFSET_RESOLUTION_3 : 3; //!< DI1 counter #3 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI1_OFFSET_VALUE_3 : 12; //!< DI1 counter #3 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_RUN_RESOLUTION_3 : 3; //!< DI1 counter #3 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI1_RUN_VALUE_M1_3 : 12; //!< DI1 counter #3 pre defined value This fields defines the counter #3 pre defines value. When the counter is auto reload mode (di1_cnt_auto_reload_3 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di1_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen0_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN0_3 register
 */
#define HW_IPU_DI1_SW_GEN0_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x48014)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN0_3(x)           (*(volatile hw_ipu_di1_sw_gen0_3_t *) HW_IPU_DI1_SW_GEN0_3_ADDR(x))
#define HW_IPU_DI1_SW_GEN0_3_RD(x)        (HW_IPU_DI1_SW_GEN0_3(x).U)
#define HW_IPU_DI1_SW_GEN0_3_WR(x, v)     (HW_IPU_DI1_SW_GEN0_3(x).U = (v))
#define HW_IPU_DI1_SW_GEN0_3_SET(x, v)    (HW_IPU_DI1_SW_GEN0_3_WR(x, HW_IPU_DI1_SW_GEN0_3_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN0_3_CLR(x, v)    (HW_IPU_DI1_SW_GEN0_3_WR(x, HW_IPU_DI1_SW_GEN0_3_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN0_3_TOG(x, v)    (HW_IPU_DI1_SW_GEN0_3_WR(x, HW_IPU_DI1_SW_GEN0_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN0_3 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN0_3, field DI1_OFFSET_RESOLUTION_3 (RW)
 *
 * DI1 counter #3 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - NA
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_3_DI1_OFFSET_RESOLUTION_3      0
#define BM_IPU_DI1_SW_GEN0_3_DI1_OFFSET_RESOLUTION_3      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_3_DI1_OFFSET_RESOLUTION_3(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN0_3_DI1_OFFSET_RESOLUTION_3)
#else
#define BF_IPU_DI1_SW_GEN0_3_DI1_OFFSET_RESOLUTION_3(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN0_3_DI1_OFFSET_RESOLUTION_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_RESOLUTION_3 field to a new value.
#define BW_IPU_DI1_SW_GEN0_3_DI1_OFFSET_RESOLUTION_3(v)   BF_CS1(IPU_DI1_SW_GEN0_3, DI1_OFFSET_RESOLUTION_3, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_3, field DI1_OFFSET_VALUE_3 (RW)
 *
 * DI1 counter #3 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI1_SW_GEN0_3_DI1_OFFSET_VALUE_3      3
#define BM_IPU_DI1_SW_GEN0_3_DI1_OFFSET_VALUE_3      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_3_DI1_OFFSET_VALUE_3(v)   ((((reg32_t) v) << 3) & BM_IPU_DI1_SW_GEN0_3_DI1_OFFSET_VALUE_3)
#else
#define BF_IPU_DI1_SW_GEN0_3_DI1_OFFSET_VALUE_3(v)   (((v) << 3) & BM_IPU_DI1_SW_GEN0_3_DI1_OFFSET_VALUE_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_VALUE_3 field to a new value.
#define BW_IPU_DI1_SW_GEN0_3_DI1_OFFSET_VALUE_3(v)   BF_CS1(IPU_DI1_SW_GEN0_3, DI1_OFFSET_VALUE_3, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN0_3, field DI1_RUN_RESOLUTION_3 (RW)
 *
 * DI1 counter #3 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - NA
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_3_DI1_RUN_RESOLUTION_3      16
#define BM_IPU_DI1_SW_GEN0_3_DI1_RUN_RESOLUTION_3      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_3_DI1_RUN_RESOLUTION_3(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN0_3_DI1_RUN_RESOLUTION_3)
#else
#define BF_IPU_DI1_SW_GEN0_3_DI1_RUN_RESOLUTION_3(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN0_3_DI1_RUN_RESOLUTION_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_RESOLUTION_3 field to a new value.
#define BW_IPU_DI1_SW_GEN0_3_DI1_RUN_RESOLUTION_3(v)   BF_CS1(IPU_DI1_SW_GEN0_3, DI1_RUN_RESOLUTION_3, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_3, field DI1_RUN_VALUE_M1_3 (RW)
 *
 * DI1 counter #3 pre defined value This fields defines the counter #3 pre defines value. When the
 * counter is auto reload mode (di1_cnt_auto_reload_3 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di1_step_repeat field.
 */

#define BP_IPU_DI1_SW_GEN0_3_DI1_RUN_VALUE_M1_3      19
#define BM_IPU_DI1_SW_GEN0_3_DI1_RUN_VALUE_M1_3      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_3_DI1_RUN_VALUE_M1_3(v)   ((((reg32_t) v) << 19) & BM_IPU_DI1_SW_GEN0_3_DI1_RUN_VALUE_M1_3)
#else
#define BF_IPU_DI1_SW_GEN0_3_DI1_RUN_VALUE_M1_3(v)   (((v) << 19) & BM_IPU_DI1_SW_GEN0_3_DI1_RUN_VALUE_M1_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_VALUE_M1_3 field to a new value.
#define BW_IPU_DI1_SW_GEN0_3_DI1_RUN_VALUE_M1_3(v)   BF_CS1(IPU_DI1_SW_GEN0_3, DI1_RUN_VALUE_M1_3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN0_4 - DI1 Sync Wave Gen 4 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_OFFSET_RESOLUTION_4 : 3; //!< DI1 counter #4 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI1_OFFSET_VALUE_4 : 12; //!< DI1 counter #4 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_RUN_RESOLUTION_4 : 3; //!< DI1 counter #4 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI1_RUN_VALUE_M1_4 : 12; //!< DI1 counter #4 pre defined value This fields defines the counter #4 pre defines value. When the counter is auto reload mode (di1_cnt_auto_reload_4 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di1_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen0_4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN0_4 register
 */
#define HW_IPU_DI1_SW_GEN0_4_ADDR(x)      (REGS_IPU_BASE(x) + 0x48018)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN0_4(x)           (*(volatile hw_ipu_di1_sw_gen0_4_t *) HW_IPU_DI1_SW_GEN0_4_ADDR(x))
#define HW_IPU_DI1_SW_GEN0_4_RD(x)        (HW_IPU_DI1_SW_GEN0_4(x).U)
#define HW_IPU_DI1_SW_GEN0_4_WR(x, v)     (HW_IPU_DI1_SW_GEN0_4(x).U = (v))
#define HW_IPU_DI1_SW_GEN0_4_SET(x, v)    (HW_IPU_DI1_SW_GEN0_4_WR(x, HW_IPU_DI1_SW_GEN0_4_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN0_4_CLR(x, v)    (HW_IPU_DI1_SW_GEN0_4_WR(x, HW_IPU_DI1_SW_GEN0_4_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN0_4_TOG(x, v)    (HW_IPU_DI1_SW_GEN0_4_WR(x, HW_IPU_DI1_SW_GEN0_4_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN0_4 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN0_4, field DI1_OFFSET_RESOLUTION_4 (RW)
 *
 * DI1 counter #4 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_4_DI1_OFFSET_RESOLUTION_4      0
#define BM_IPU_DI1_SW_GEN0_4_DI1_OFFSET_RESOLUTION_4      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_4_DI1_OFFSET_RESOLUTION_4(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN0_4_DI1_OFFSET_RESOLUTION_4)
#else
#define BF_IPU_DI1_SW_GEN0_4_DI1_OFFSET_RESOLUTION_4(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN0_4_DI1_OFFSET_RESOLUTION_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_RESOLUTION_4 field to a new value.
#define BW_IPU_DI1_SW_GEN0_4_DI1_OFFSET_RESOLUTION_4(v)   BF_CS1(IPU_DI1_SW_GEN0_4, DI1_OFFSET_RESOLUTION_4, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_4, field DI1_OFFSET_VALUE_4 (RW)
 *
 * DI1 counter #4 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI1_SW_GEN0_4_DI1_OFFSET_VALUE_4      3
#define BM_IPU_DI1_SW_GEN0_4_DI1_OFFSET_VALUE_4      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_4_DI1_OFFSET_VALUE_4(v)   ((((reg32_t) v) << 3) & BM_IPU_DI1_SW_GEN0_4_DI1_OFFSET_VALUE_4)
#else
#define BF_IPU_DI1_SW_GEN0_4_DI1_OFFSET_VALUE_4(v)   (((v) << 3) & BM_IPU_DI1_SW_GEN0_4_DI1_OFFSET_VALUE_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_VALUE_4 field to a new value.
#define BW_IPU_DI1_SW_GEN0_4_DI1_OFFSET_VALUE_4(v)   BF_CS1(IPU_DI1_SW_GEN0_4, DI1_OFFSET_VALUE_4, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN0_4, field DI1_RUN_RESOLUTION_4 (RW)
 *
 * DI1 counter #4 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_4_DI1_RUN_RESOLUTION_4      16
#define BM_IPU_DI1_SW_GEN0_4_DI1_RUN_RESOLUTION_4      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_4_DI1_RUN_RESOLUTION_4(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN0_4_DI1_RUN_RESOLUTION_4)
#else
#define BF_IPU_DI1_SW_GEN0_4_DI1_RUN_RESOLUTION_4(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN0_4_DI1_RUN_RESOLUTION_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_RESOLUTION_4 field to a new value.
#define BW_IPU_DI1_SW_GEN0_4_DI1_RUN_RESOLUTION_4(v)   BF_CS1(IPU_DI1_SW_GEN0_4, DI1_RUN_RESOLUTION_4, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_4, field DI1_RUN_VALUE_M1_4 (RW)
 *
 * DI1 counter #4 pre defined value This fields defines the counter #4 pre defines value. When the
 * counter is auto reload mode (di1_cnt_auto_reload_4 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di1_step_repeat field.
 */

#define BP_IPU_DI1_SW_GEN0_4_DI1_RUN_VALUE_M1_4      19
#define BM_IPU_DI1_SW_GEN0_4_DI1_RUN_VALUE_M1_4      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_4_DI1_RUN_VALUE_M1_4(v)   ((((reg32_t) v) << 19) & BM_IPU_DI1_SW_GEN0_4_DI1_RUN_VALUE_M1_4)
#else
#define BF_IPU_DI1_SW_GEN0_4_DI1_RUN_VALUE_M1_4(v)   (((v) << 19) & BM_IPU_DI1_SW_GEN0_4_DI1_RUN_VALUE_M1_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_VALUE_M1_4 field to a new value.
#define BW_IPU_DI1_SW_GEN0_4_DI1_RUN_VALUE_M1_4(v)   BF_CS1(IPU_DI1_SW_GEN0_4, DI1_RUN_VALUE_M1_4, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN0_5 - DI1 Sync Wave Gen 5 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_OFFSET_RESOLUTION_5 : 3; //!< DI1 counter #5 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI1_OFFSET_VALUE_5 : 12; //!< DI1 counter #5 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_RUN_RESOLUTION_5 : 3; //!< DI1 counter #5 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI1_RUN_VALUE_M1_5 : 12; //!< DI1 counter #5 pre defined value This fields defines the counter #5 pre defines value. When the counter is auto reload mode (di1_cnt_auto_reload_5 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di1_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved
    } B;
} hw_ipu_di1_sw_gen0_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN0_5 register
 */
#define HW_IPU_DI1_SW_GEN0_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x4801c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN0_5(x)           (*(volatile hw_ipu_di1_sw_gen0_5_t *) HW_IPU_DI1_SW_GEN0_5_ADDR(x))
#define HW_IPU_DI1_SW_GEN0_5_RD(x)        (HW_IPU_DI1_SW_GEN0_5(x).U)
#define HW_IPU_DI1_SW_GEN0_5_WR(x, v)     (HW_IPU_DI1_SW_GEN0_5(x).U = (v))
#define HW_IPU_DI1_SW_GEN0_5_SET(x, v)    (HW_IPU_DI1_SW_GEN0_5_WR(x, HW_IPU_DI1_SW_GEN0_5_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN0_5_CLR(x, v)    (HW_IPU_DI1_SW_GEN0_5_WR(x, HW_IPU_DI1_SW_GEN0_5_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN0_5_TOG(x, v)    (HW_IPU_DI1_SW_GEN0_5_WR(x, HW_IPU_DI1_SW_GEN0_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN0_5 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN0_5, field DI1_OFFSET_RESOLUTION_5 (RW)
 *
 * DI1 counter #5 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - -The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_5_DI1_OFFSET_RESOLUTION_5      0
#define BM_IPU_DI1_SW_GEN0_5_DI1_OFFSET_RESOLUTION_5      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_5_DI1_OFFSET_RESOLUTION_5(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN0_5_DI1_OFFSET_RESOLUTION_5)
#else
#define BF_IPU_DI1_SW_GEN0_5_DI1_OFFSET_RESOLUTION_5(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN0_5_DI1_OFFSET_RESOLUTION_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_RESOLUTION_5 field to a new value.
#define BW_IPU_DI1_SW_GEN0_5_DI1_OFFSET_RESOLUTION_5(v)   BF_CS1(IPU_DI1_SW_GEN0_5, DI1_OFFSET_RESOLUTION_5, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_5, field DI1_OFFSET_VALUE_5 (RW)
 *
 * DI1 counter #5 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI1_SW_GEN0_5_DI1_OFFSET_VALUE_5      3
#define BM_IPU_DI1_SW_GEN0_5_DI1_OFFSET_VALUE_5      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_5_DI1_OFFSET_VALUE_5(v)   ((((reg32_t) v) << 3) & BM_IPU_DI1_SW_GEN0_5_DI1_OFFSET_VALUE_5)
#else
#define BF_IPU_DI1_SW_GEN0_5_DI1_OFFSET_VALUE_5(v)   (((v) << 3) & BM_IPU_DI1_SW_GEN0_5_DI1_OFFSET_VALUE_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_VALUE_5 field to a new value.
#define BW_IPU_DI1_SW_GEN0_5_DI1_OFFSET_VALUE_5(v)   BF_CS1(IPU_DI1_SW_GEN0_5, DI1_OFFSET_VALUE_5, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN0_5, field DI1_RUN_RESOLUTION_5 (RW)
 *
 * DI1 counter #5 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_5_DI1_RUN_RESOLUTION_5      16
#define BM_IPU_DI1_SW_GEN0_5_DI1_RUN_RESOLUTION_5      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_5_DI1_RUN_RESOLUTION_5(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN0_5_DI1_RUN_RESOLUTION_5)
#else
#define BF_IPU_DI1_SW_GEN0_5_DI1_RUN_RESOLUTION_5(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN0_5_DI1_RUN_RESOLUTION_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_RESOLUTION_5 field to a new value.
#define BW_IPU_DI1_SW_GEN0_5_DI1_RUN_RESOLUTION_5(v)   BF_CS1(IPU_DI1_SW_GEN0_5, DI1_RUN_RESOLUTION_5, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_5, field DI1_RUN_VALUE_M1_5 (RW)
 *
 * DI1 counter #5 pre defined value This fields defines the counter #5 pre defines value. When the
 * counter is auto reload mode (di1_cnt_auto_reload_5 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di1_step_repeat field.
 */

#define BP_IPU_DI1_SW_GEN0_5_DI1_RUN_VALUE_M1_5      19
#define BM_IPU_DI1_SW_GEN0_5_DI1_RUN_VALUE_M1_5      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_5_DI1_RUN_VALUE_M1_5(v)   ((((reg32_t) v) << 19) & BM_IPU_DI1_SW_GEN0_5_DI1_RUN_VALUE_M1_5)
#else
#define BF_IPU_DI1_SW_GEN0_5_DI1_RUN_VALUE_M1_5(v)   (((v) << 19) & BM_IPU_DI1_SW_GEN0_5_DI1_RUN_VALUE_M1_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_VALUE_M1_5 field to a new value.
#define BW_IPU_DI1_SW_GEN0_5_DI1_RUN_VALUE_M1_5(v)   BF_CS1(IPU_DI1_SW_GEN0_5, DI1_RUN_VALUE_M1_5, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN0_6 - DI1 Sync Wave Gen 6 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_OFFSET_RESOLUTION_6 : 3; //!< DI1 counter #6 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI1_OFFSET_VALUE_6 : 12; //!< DI1 counter #6 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_RUN_RESOLUTION_6 : 3; //!< DI1 counter #6 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI1_RUN_VALUE_M1_6 : 12; //!< DI1 counter #6 pre defined value This fields defines the counter #6 pre defines value. When the counter is auto reload mode (di1_cnt_auto_reload_6 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di1_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen0_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN0_6 register
 */
#define HW_IPU_DI1_SW_GEN0_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x48020)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN0_6(x)           (*(volatile hw_ipu_di1_sw_gen0_6_t *) HW_IPU_DI1_SW_GEN0_6_ADDR(x))
#define HW_IPU_DI1_SW_GEN0_6_RD(x)        (HW_IPU_DI1_SW_GEN0_6(x).U)
#define HW_IPU_DI1_SW_GEN0_6_WR(x, v)     (HW_IPU_DI1_SW_GEN0_6(x).U = (v))
#define HW_IPU_DI1_SW_GEN0_6_SET(x, v)    (HW_IPU_DI1_SW_GEN0_6_WR(x, HW_IPU_DI1_SW_GEN0_6_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN0_6_CLR(x, v)    (HW_IPU_DI1_SW_GEN0_6_WR(x, HW_IPU_DI1_SW_GEN0_6_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN0_6_TOG(x, v)    (HW_IPU_DI1_SW_GEN0_6_WR(x, HW_IPU_DI1_SW_GEN0_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN0_6 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN0_6, field DI1_OFFSET_RESOLUTION_6 (RW)
 *
 * DI1 counter #6 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_6_DI1_OFFSET_RESOLUTION_6      0
#define BM_IPU_DI1_SW_GEN0_6_DI1_OFFSET_RESOLUTION_6      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_6_DI1_OFFSET_RESOLUTION_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN0_6_DI1_OFFSET_RESOLUTION_6)
#else
#define BF_IPU_DI1_SW_GEN0_6_DI1_OFFSET_RESOLUTION_6(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN0_6_DI1_OFFSET_RESOLUTION_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_RESOLUTION_6 field to a new value.
#define BW_IPU_DI1_SW_GEN0_6_DI1_OFFSET_RESOLUTION_6(v)   BF_CS1(IPU_DI1_SW_GEN0_6, DI1_OFFSET_RESOLUTION_6, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_6, field DI1_OFFSET_VALUE_6 (RW)
 *
 * DI1 counter #6 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI1_SW_GEN0_6_DI1_OFFSET_VALUE_6      3
#define BM_IPU_DI1_SW_GEN0_6_DI1_OFFSET_VALUE_6      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_6_DI1_OFFSET_VALUE_6(v)   ((((reg32_t) v) << 3) & BM_IPU_DI1_SW_GEN0_6_DI1_OFFSET_VALUE_6)
#else
#define BF_IPU_DI1_SW_GEN0_6_DI1_OFFSET_VALUE_6(v)   (((v) << 3) & BM_IPU_DI1_SW_GEN0_6_DI1_OFFSET_VALUE_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_VALUE_6 field to a new value.
#define BW_IPU_DI1_SW_GEN0_6_DI1_OFFSET_VALUE_6(v)   BF_CS1(IPU_DI1_SW_GEN0_6, DI1_OFFSET_VALUE_6, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN0_6, field DI1_RUN_RESOLUTION_6 (RW)
 *
 * DI1 counter #6 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_6_DI1_RUN_RESOLUTION_6      16
#define BM_IPU_DI1_SW_GEN0_6_DI1_RUN_RESOLUTION_6      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_6_DI1_RUN_RESOLUTION_6(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN0_6_DI1_RUN_RESOLUTION_6)
#else
#define BF_IPU_DI1_SW_GEN0_6_DI1_RUN_RESOLUTION_6(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN0_6_DI1_RUN_RESOLUTION_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_RESOLUTION_6 field to a new value.
#define BW_IPU_DI1_SW_GEN0_6_DI1_RUN_RESOLUTION_6(v)   BF_CS1(IPU_DI1_SW_GEN0_6, DI1_RUN_RESOLUTION_6, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_6, field DI1_RUN_VALUE_M1_6 (RW)
 *
 * DI1 counter #6 pre defined value This fields defines the counter #6 pre defines value. When the
 * counter is auto reload mode (di1_cnt_auto_reload_6 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di1_step_repeat field.
 */

#define BP_IPU_DI1_SW_GEN0_6_DI1_RUN_VALUE_M1_6      19
#define BM_IPU_DI1_SW_GEN0_6_DI1_RUN_VALUE_M1_6      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_6_DI1_RUN_VALUE_M1_6(v)   ((((reg32_t) v) << 19) & BM_IPU_DI1_SW_GEN0_6_DI1_RUN_VALUE_M1_6)
#else
#define BF_IPU_DI1_SW_GEN0_6_DI1_RUN_VALUE_M1_6(v)   (((v) << 19) & BM_IPU_DI1_SW_GEN0_6_DI1_RUN_VALUE_M1_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_VALUE_M1_6 field to a new value.
#define BW_IPU_DI1_SW_GEN0_6_DI1_RUN_VALUE_M1_6(v)   BF_CS1(IPU_DI1_SW_GEN0_6, DI1_RUN_VALUE_M1_6, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN0_7 - DI1 Sync Wave Gen 7 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_OFFSET_RESOLUTION_1 : 3; //!< DI1 counter #7 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI1_OFFSET_VALUE_7 : 12; //!< DI1 counter #7 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_RUN_RESOLUTION_7 : 3; //!< DI1 counter #1 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI1_RUN_VALUE_M1_7 : 12; //!< DI1 counter #7 pre defined value This fields defines the counter #7 pre defines value. When the counter is auto reload mode (di1_cnt_auto_reload_7 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di1_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen0_7_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN0_7 register
 */
#define HW_IPU_DI1_SW_GEN0_7_ADDR(x)      (REGS_IPU_BASE(x) + 0x48024)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN0_7(x)           (*(volatile hw_ipu_di1_sw_gen0_7_t *) HW_IPU_DI1_SW_GEN0_7_ADDR(x))
#define HW_IPU_DI1_SW_GEN0_7_RD(x)        (HW_IPU_DI1_SW_GEN0_7(x).U)
#define HW_IPU_DI1_SW_GEN0_7_WR(x, v)     (HW_IPU_DI1_SW_GEN0_7(x).U = (v))
#define HW_IPU_DI1_SW_GEN0_7_SET(x, v)    (HW_IPU_DI1_SW_GEN0_7_WR(x, HW_IPU_DI1_SW_GEN0_7_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN0_7_CLR(x, v)    (HW_IPU_DI1_SW_GEN0_7_WR(x, HW_IPU_DI1_SW_GEN0_7_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN0_7_TOG(x, v)    (HW_IPU_DI1_SW_GEN0_7_WR(x, HW_IPU_DI1_SW_GEN0_7_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN0_7 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN0_7, field DI1_OFFSET_RESOLUTION_1 (RW)
 *
 * DI1 counter #7 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_7_DI1_OFFSET_RESOLUTION_1      0
#define BM_IPU_DI1_SW_GEN0_7_DI1_OFFSET_RESOLUTION_1      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_7_DI1_OFFSET_RESOLUTION_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN0_7_DI1_OFFSET_RESOLUTION_1)
#else
#define BF_IPU_DI1_SW_GEN0_7_DI1_OFFSET_RESOLUTION_1(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN0_7_DI1_OFFSET_RESOLUTION_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_RESOLUTION_1 field to a new value.
#define BW_IPU_DI1_SW_GEN0_7_DI1_OFFSET_RESOLUTION_1(v)   BF_CS1(IPU_DI1_SW_GEN0_7, DI1_OFFSET_RESOLUTION_1, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_7, field DI1_OFFSET_VALUE_7 (RW)
 *
 * DI1 counter #7 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI1_SW_GEN0_7_DI1_OFFSET_VALUE_7      3
#define BM_IPU_DI1_SW_GEN0_7_DI1_OFFSET_VALUE_7      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_7_DI1_OFFSET_VALUE_7(v)   ((((reg32_t) v) << 3) & BM_IPU_DI1_SW_GEN0_7_DI1_OFFSET_VALUE_7)
#else
#define BF_IPU_DI1_SW_GEN0_7_DI1_OFFSET_VALUE_7(v)   (((v) << 3) & BM_IPU_DI1_SW_GEN0_7_DI1_OFFSET_VALUE_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_VALUE_7 field to a new value.
#define BW_IPU_DI1_SW_GEN0_7_DI1_OFFSET_VALUE_7(v)   BF_CS1(IPU_DI1_SW_GEN0_7, DI1_OFFSET_VALUE_7, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN0_7, field DI1_RUN_RESOLUTION_7 (RW)
 *
 * DI1 counter #1 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_7_DI1_RUN_RESOLUTION_7      16
#define BM_IPU_DI1_SW_GEN0_7_DI1_RUN_RESOLUTION_7      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_7_DI1_RUN_RESOLUTION_7(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN0_7_DI1_RUN_RESOLUTION_7)
#else
#define BF_IPU_DI1_SW_GEN0_7_DI1_RUN_RESOLUTION_7(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN0_7_DI1_RUN_RESOLUTION_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_RESOLUTION_7 field to a new value.
#define BW_IPU_DI1_SW_GEN0_7_DI1_RUN_RESOLUTION_7(v)   BF_CS1(IPU_DI1_SW_GEN0_7, DI1_RUN_RESOLUTION_7, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_7, field DI1_RUN_VALUE_M1_7 (RW)
 *
 * DI1 counter #7 pre defined value This fields defines the counter #7 pre defines value. When the
 * counter is auto reload mode (di1_cnt_auto_reload_7 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di1_step_repeat field.
 */

#define BP_IPU_DI1_SW_GEN0_7_DI1_RUN_VALUE_M1_7      19
#define BM_IPU_DI1_SW_GEN0_7_DI1_RUN_VALUE_M1_7      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_7_DI1_RUN_VALUE_M1_7(v)   ((((reg32_t) v) << 19) & BM_IPU_DI1_SW_GEN0_7_DI1_RUN_VALUE_M1_7)
#else
#define BF_IPU_DI1_SW_GEN0_7_DI1_RUN_VALUE_M1_7(v)   (((v) << 19) & BM_IPU_DI1_SW_GEN0_7_DI1_RUN_VALUE_M1_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_VALUE_M1_7 field to a new value.
#define BW_IPU_DI1_SW_GEN0_7_DI1_RUN_VALUE_M1_7(v)   BF_CS1(IPU_DI1_SW_GEN0_7, DI1_RUN_VALUE_M1_7, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN0_8 - DI1 Sync Wave Gen 8 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_OFFSET_RESOLUTION_8 : 3; //!< DI1 counter #8 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI1_OFFSET_VALUE_8 : 12; //!< DI1 counter #8 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_RUN_RESOLUTION_8 : 3; //!< DI1 counter #8 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI1_RUN_VALUE_M1_8 : 12; //!< DI1 counter #8 pre defined value This fields defines the counter #8 pre defines value. When the counter is auto reload mode (di1_cnt_auto_reload_8 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di1_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen0_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN0_8 register
 */
#define HW_IPU_DI1_SW_GEN0_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x48028)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN0_8(x)           (*(volatile hw_ipu_di1_sw_gen0_8_t *) HW_IPU_DI1_SW_GEN0_8_ADDR(x))
#define HW_IPU_DI1_SW_GEN0_8_RD(x)        (HW_IPU_DI1_SW_GEN0_8(x).U)
#define HW_IPU_DI1_SW_GEN0_8_WR(x, v)     (HW_IPU_DI1_SW_GEN0_8(x).U = (v))
#define HW_IPU_DI1_SW_GEN0_8_SET(x, v)    (HW_IPU_DI1_SW_GEN0_8_WR(x, HW_IPU_DI1_SW_GEN0_8_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN0_8_CLR(x, v)    (HW_IPU_DI1_SW_GEN0_8_WR(x, HW_IPU_DI1_SW_GEN0_8_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN0_8_TOG(x, v)    (HW_IPU_DI1_SW_GEN0_8_WR(x, HW_IPU_DI1_SW_GEN0_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN0_8 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN0_8, field DI1_OFFSET_RESOLUTION_8 (RW)
 *
 * DI1 counter #8 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_8_DI1_OFFSET_RESOLUTION_8      0
#define BM_IPU_DI1_SW_GEN0_8_DI1_OFFSET_RESOLUTION_8      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_8_DI1_OFFSET_RESOLUTION_8(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN0_8_DI1_OFFSET_RESOLUTION_8)
#else
#define BF_IPU_DI1_SW_GEN0_8_DI1_OFFSET_RESOLUTION_8(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN0_8_DI1_OFFSET_RESOLUTION_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_RESOLUTION_8 field to a new value.
#define BW_IPU_DI1_SW_GEN0_8_DI1_OFFSET_RESOLUTION_8(v)   BF_CS1(IPU_DI1_SW_GEN0_8, DI1_OFFSET_RESOLUTION_8, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_8, field DI1_OFFSET_VALUE_8 (RW)
 *
 * DI1 counter #8 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI1_SW_GEN0_8_DI1_OFFSET_VALUE_8      3
#define BM_IPU_DI1_SW_GEN0_8_DI1_OFFSET_VALUE_8      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_8_DI1_OFFSET_VALUE_8(v)   ((((reg32_t) v) << 3) & BM_IPU_DI1_SW_GEN0_8_DI1_OFFSET_VALUE_8)
#else
#define BF_IPU_DI1_SW_GEN0_8_DI1_OFFSET_VALUE_8(v)   (((v) << 3) & BM_IPU_DI1_SW_GEN0_8_DI1_OFFSET_VALUE_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_VALUE_8 field to a new value.
#define BW_IPU_DI1_SW_GEN0_8_DI1_OFFSET_VALUE_8(v)   BF_CS1(IPU_DI1_SW_GEN0_8, DI1_OFFSET_VALUE_8, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN0_8, field DI1_RUN_RESOLUTION_8 (RW)
 *
 * DI1 counter #8 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_8_DI1_RUN_RESOLUTION_8      16
#define BM_IPU_DI1_SW_GEN0_8_DI1_RUN_RESOLUTION_8      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_8_DI1_RUN_RESOLUTION_8(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN0_8_DI1_RUN_RESOLUTION_8)
#else
#define BF_IPU_DI1_SW_GEN0_8_DI1_RUN_RESOLUTION_8(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN0_8_DI1_RUN_RESOLUTION_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_RESOLUTION_8 field to a new value.
#define BW_IPU_DI1_SW_GEN0_8_DI1_RUN_RESOLUTION_8(v)   BF_CS1(IPU_DI1_SW_GEN0_8, DI1_RUN_RESOLUTION_8, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_8, field DI1_RUN_VALUE_M1_8 (RW)
 *
 * DI1 counter #8 pre defined value This fields defines the counter #8 pre defines value. When the
 * counter is auto reload mode (di1_cnt_auto_reload_8 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di1_step_repeat field.
 */

#define BP_IPU_DI1_SW_GEN0_8_DI1_RUN_VALUE_M1_8      19
#define BM_IPU_DI1_SW_GEN0_8_DI1_RUN_VALUE_M1_8      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_8_DI1_RUN_VALUE_M1_8(v)   ((((reg32_t) v) << 19) & BM_IPU_DI1_SW_GEN0_8_DI1_RUN_VALUE_M1_8)
#else
#define BF_IPU_DI1_SW_GEN0_8_DI1_RUN_VALUE_M1_8(v)   (((v) << 19) & BM_IPU_DI1_SW_GEN0_8_DI1_RUN_VALUE_M1_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_VALUE_M1_8 field to a new value.
#define BW_IPU_DI1_SW_GEN0_8_DI1_RUN_VALUE_M1_8(v)   BF_CS1(IPU_DI1_SW_GEN0_8, DI1_RUN_VALUE_M1_8, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN0_9 - DI1Sync Wave Gen 9 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_OFFSET_RESOLUTION_9 : 3; //!< DI1 counter #9 offset Resolution This field defines the trigger causing the offset counter to increment
        unsigned DI1_OFFSET_VALUE_9 : 12; //!< DI1 counter #9 offset value The counter can start counting after a pre defined delay This field defines the amount of cycles that the counter will be delayed by
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_RUN_RESOLUTION_9 : 3; //!< DI1 counter #9 Run Resolution This field defines the trigger causing the counter to increment.
        unsigned DI1_RUN_VALUE_M1_9 : 12; //!< DI1 counter #9 pre defined value This fields defines the counter #9 pre defines value. When the counter is auto reload mode (di1_cnt_auto_reload_9 bit is set), the counter automatically restarts. otherwise the counter restarts for the amount of time defined on the corresponding di1_step_repeat field.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen0_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN0_9 register
 */
#define HW_IPU_DI1_SW_GEN0_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x4802c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN0_9(x)           (*(volatile hw_ipu_di1_sw_gen0_9_t *) HW_IPU_DI1_SW_GEN0_9_ADDR(x))
#define HW_IPU_DI1_SW_GEN0_9_RD(x)        (HW_IPU_DI1_SW_GEN0_9(x).U)
#define HW_IPU_DI1_SW_GEN0_9_WR(x, v)     (HW_IPU_DI1_SW_GEN0_9(x).U = (v))
#define HW_IPU_DI1_SW_GEN0_9_SET(x, v)    (HW_IPU_DI1_SW_GEN0_9_WR(x, HW_IPU_DI1_SW_GEN0_9_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN0_9_CLR(x, v)    (HW_IPU_DI1_SW_GEN0_9_WR(x, HW_IPU_DI1_SW_GEN0_9_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN0_9_TOG(x, v)    (HW_IPU_DI1_SW_GEN0_9_WR(x, HW_IPU_DI1_SW_GEN0_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN0_9 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN0_9, field DI1_OFFSET_RESOLUTION_9 (RW)
 *
 * DI1 counter #9 offset Resolution This field defines the trigger causing the offset counter to
 * increment
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_9_DI1_OFFSET_RESOLUTION_9      0
#define BM_IPU_DI1_SW_GEN0_9_DI1_OFFSET_RESOLUTION_9      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_9_DI1_OFFSET_RESOLUTION_9(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN0_9_DI1_OFFSET_RESOLUTION_9)
#else
#define BF_IPU_DI1_SW_GEN0_9_DI1_OFFSET_RESOLUTION_9(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN0_9_DI1_OFFSET_RESOLUTION_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_RESOLUTION_9 field to a new value.
#define BW_IPU_DI1_SW_GEN0_9_DI1_OFFSET_RESOLUTION_9(v)   BF_CS1(IPU_DI1_SW_GEN0_9, DI1_OFFSET_RESOLUTION_9, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_9, field DI1_OFFSET_VALUE_9 (RW)
 *
 * DI1 counter #9 offset value The counter can start counting after a pre defined delay This field
 * defines the amount of cycles that the counter will be delayed by
 */

#define BP_IPU_DI1_SW_GEN0_9_DI1_OFFSET_VALUE_9      3
#define BM_IPU_DI1_SW_GEN0_9_DI1_OFFSET_VALUE_9      0x00007ff8

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_9_DI1_OFFSET_VALUE_9(v)   ((((reg32_t) v) << 3) & BM_IPU_DI1_SW_GEN0_9_DI1_OFFSET_VALUE_9)
#else
#define BF_IPU_DI1_SW_GEN0_9_DI1_OFFSET_VALUE_9(v)   (((v) << 3) & BM_IPU_DI1_SW_GEN0_9_DI1_OFFSET_VALUE_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_OFFSET_VALUE_9 field to a new value.
#define BW_IPU_DI1_SW_GEN0_9_DI1_OFFSET_VALUE_9(v)   BF_CS1(IPU_DI1_SW_GEN0_9, DI1_OFFSET_VALUE_9, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN0_9, field DI1_RUN_RESOLUTION_9 (RW)
 *
 * DI1 counter #9 Run Resolution This field defines the trigger causing the counter to increment.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN0_9_DI1_RUN_RESOLUTION_9      16
#define BM_IPU_DI1_SW_GEN0_9_DI1_RUN_RESOLUTION_9      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_9_DI1_RUN_RESOLUTION_9(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN0_9_DI1_RUN_RESOLUTION_9)
#else
#define BF_IPU_DI1_SW_GEN0_9_DI1_RUN_RESOLUTION_9(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN0_9_DI1_RUN_RESOLUTION_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_RESOLUTION_9 field to a new value.
#define BW_IPU_DI1_SW_GEN0_9_DI1_RUN_RESOLUTION_9(v)   BF_CS1(IPU_DI1_SW_GEN0_9, DI1_RUN_RESOLUTION_9, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN0_9, field DI1_RUN_VALUE_M1_9 (RW)
 *
 * DI1 counter #9 pre defined value This fields defines the counter #9 pre defines value. When the
 * counter is auto reload mode (di1_cnt_auto_reload_9 bit is set), the counter automatically
 * restarts. otherwise the counter restarts for the amount of time defined on the corresponding
 * di1_step_repeat field.
 */

#define BP_IPU_DI1_SW_GEN0_9_DI1_RUN_VALUE_M1_9      19
#define BM_IPU_DI1_SW_GEN0_9_DI1_RUN_VALUE_M1_9      0x7ff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN0_9_DI1_RUN_VALUE_M1_9(v)   ((((reg32_t) v) << 19) & BM_IPU_DI1_SW_GEN0_9_DI1_RUN_VALUE_M1_9)
#else
#define BF_IPU_DI1_SW_GEN0_9_DI1_RUN_VALUE_M1_9(v)   (((v) << 19) & BM_IPU_DI1_SW_GEN0_9_DI1_RUN_VALUE_M1_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_RUN_VALUE_M1_9 field to a new value.
#define BW_IPU_DI1_SW_GEN0_9_DI1_RUN_VALUE_M1_9(v)   BF_CS1(IPU_DI1_SW_GEN0_9, DI1_RUN_VALUE_M1_9, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN1_1 - DI1 Sync Wave Gen 1 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_CNT_UP_1 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI1_CNT_POLARITY_CLR_SEL_1 : 3; //!< DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI1_CNT_POLARITY_TRIGGER_SEL_1 : 3; //!< DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_CNT_DOWN_1 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI1_CNT_CLR_SEL_1 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI1_CNT_AUTO_RELOAD_1 : 1; //!< Counter auto reload mode
        unsigned DI1_CNT_POLARITY_GEN_EN_1 : 2; //!< DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen1_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN1_1 register
 */
#define HW_IPU_DI1_SW_GEN1_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x48030)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN1_1(x)           (*(volatile hw_ipu_di1_sw_gen1_1_t *) HW_IPU_DI1_SW_GEN1_1_ADDR(x))
#define HW_IPU_DI1_SW_GEN1_1_RD(x)        (HW_IPU_DI1_SW_GEN1_1(x).U)
#define HW_IPU_DI1_SW_GEN1_1_WR(x, v)     (HW_IPU_DI1_SW_GEN1_1(x).U = (v))
#define HW_IPU_DI1_SW_GEN1_1_SET(x, v)    (HW_IPU_DI1_SW_GEN1_1_WR(x, HW_IPU_DI1_SW_GEN1_1_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN1_1_CLR(x, v)    (HW_IPU_DI1_SW_GEN1_1_WR(x, HW_IPU_DI1_SW_GEN1_1_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN1_1_TOG(x, v)    (HW_IPU_DI1_SW_GEN1_1_WR(x, HW_IPU_DI1_SW_GEN1_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN1_1 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN1_1, field DI1_CNT_UP_1 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI1_SW_GEN1_1_DI1_CNT_UP_1      0
#define BM_IPU_DI1_SW_GEN1_1_DI1_CNT_UP_1      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_UP_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_UP_1)
#else
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_UP_1(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_UP_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_UP_1 field to a new value.
#define BW_IPU_DI1_SW_GEN1_1_DI1_CNT_UP_1(v)   BF_CS1(IPU_DI1_SW_GEN1_1, DI1_CNT_UP_1, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_1, field DI1_CNT_POLARITY_CLR_SEL_1 (RW)
 *
 * DI1 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Reserved
 * 011 - Reserved
 * 100 - Reserved
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_CLR_SEL_1      9
#define BM_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_CLR_SEL_1      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_CLR_SEL_1(v)   ((((reg32_t) v) << 9) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_CLR_SEL_1)
#else
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_CLR_SEL_1(v)   (((v) << 9) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_CLR_SEL_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_CLR_SEL_1 field to a new value.
#define BW_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_CLR_SEL_1(v)   BF_CS1(IPU_DI1_SW_GEN1_1, DI1_CNT_POLARITY_CLR_SEL_1, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_1, field DI1_CNT_POLARITY_TRIGGER_SEL_1 (RW)
 *
 * DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - Reserved
 * 011 - Reserved
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_TRIGGER_SEL_1      12
#define BM_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_TRIGGER_SEL_1      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_TRIGGER_SEL_1(v)   ((((reg32_t) v) << 12) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_TRIGGER_SEL_1)
#else
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_TRIGGER_SEL_1(v)   (((v) << 12) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_TRIGGER_SEL_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_TRIGGER_SEL_1 field to a new value.
#define BW_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_TRIGGER_SEL_1(v)   BF_CS1(IPU_DI1_SW_GEN1_1, DI1_CNT_POLARITY_TRIGGER_SEL_1, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_1, field DI1_CNT_DOWN_1 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI1_SW_GEN1_1_DI1_CNT_DOWN_1      16
#define BM_IPU_DI1_SW_GEN1_1_DI1_CNT_DOWN_1      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_DOWN_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_DOWN_1)
#else
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_DOWN_1(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_DOWN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_DOWN_1 field to a new value.
#define BW_IPU_DI1_SW_GEN1_1_DI1_CNT_DOWN_1(v)   BF_CS1(IPU_DI1_SW_GEN1_1, DI1_CNT_DOWN_1, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_1, field DI1_CNT_CLR_SEL_1 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - Reserved
 * 011 - Reserved
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_1_DI1_CNT_CLR_SEL_1      25
#define BM_IPU_DI1_SW_GEN1_1_DI1_CNT_CLR_SEL_1      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_CLR_SEL_1(v)   ((((reg32_t) v) << 25) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_CLR_SEL_1)
#else
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_CLR_SEL_1(v)   (((v) << 25) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_CLR_SEL_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_CLR_SEL_1 field to a new value.
#define BW_IPU_DI1_SW_GEN1_1_DI1_CNT_CLR_SEL_1(v)   BF_CS1(IPU_DI1_SW_GEN1_1, DI1_CNT_CLR_SEL_1, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_1, field DI1_CNT_AUTO_RELOAD_1 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di1_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di1_step_repeat_1 field
 */

#define BP_IPU_DI1_SW_GEN1_1_DI1_CNT_AUTO_RELOAD_1      28
#define BM_IPU_DI1_SW_GEN1_1_DI1_CNT_AUTO_RELOAD_1      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_AUTO_RELOAD_1(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_AUTO_RELOAD_1)
#else
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_AUTO_RELOAD_1(v)   (((v) << 28) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_AUTO_RELOAD_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_AUTO_RELOAD_1 field to a new value.
#define BW_IPU_DI1_SW_GEN1_1_DI1_CNT_AUTO_RELOAD_1(v)   BF_CS1(IPU_DI1_SW_GEN1_1, DI1_CNT_AUTO_RELOAD_1, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_1, field DI1_CNT_POLARITY_GEN_EN_1 (RW)
 *
 * DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_GEN_EN_1      29
#define BM_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_GEN_EN_1      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_GEN_EN_1(v)   ((((reg32_t) v) << 29) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_GEN_EN_1)
#else
#define BF_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_GEN_EN_1(v)   (((v) << 29) & BM_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_GEN_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_GEN_EN_1 field to a new value.
#define BW_IPU_DI1_SW_GEN1_1_DI1_CNT_POLARITY_GEN_EN_1(v)   BF_CS1(IPU_DI1_SW_GEN1_1, DI1_CNT_POLARITY_GEN_EN_1, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN1_2 - DI1 Sync Wave Gen 2 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_CNT_UP_2 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI1_CNT_POLARITY_CLR_SEL_2 : 3; //!< DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI1_CNT_POLARITY_TRIGGER_SEL_2 : 3; //!< DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_CNT_DOWN_2 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI1_CNT_CLR_SEL_2 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI1_CNT_AUTO_RELOAD_2 : 1; //!< Counter auto reload mode
        unsigned DI1_CNT_POLARITY_GEN_EN_2 : 2; //!< DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen1_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN1_2 register
 */
#define HW_IPU_DI1_SW_GEN1_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x48034)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN1_2(x)           (*(volatile hw_ipu_di1_sw_gen1_2_t *) HW_IPU_DI1_SW_GEN1_2_ADDR(x))
#define HW_IPU_DI1_SW_GEN1_2_RD(x)        (HW_IPU_DI1_SW_GEN1_2(x).U)
#define HW_IPU_DI1_SW_GEN1_2_WR(x, v)     (HW_IPU_DI1_SW_GEN1_2(x).U = (v))
#define HW_IPU_DI1_SW_GEN1_2_SET(x, v)    (HW_IPU_DI1_SW_GEN1_2_WR(x, HW_IPU_DI1_SW_GEN1_2_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN1_2_CLR(x, v)    (HW_IPU_DI1_SW_GEN1_2_WR(x, HW_IPU_DI1_SW_GEN1_2_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN1_2_TOG(x, v)    (HW_IPU_DI1_SW_GEN1_2_WR(x, HW_IPU_DI1_SW_GEN1_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN1_2 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN1_2, field DI1_CNT_UP_2 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI1_SW_GEN1_2_DI1_CNT_UP_2      0
#define BM_IPU_DI1_SW_GEN1_2_DI1_CNT_UP_2      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_UP_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_UP_2)
#else
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_UP_2(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_UP_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_UP_2 field to a new value.
#define BW_IPU_DI1_SW_GEN1_2_DI1_CNT_UP_2(v)   BF_CS1(IPU_DI1_SW_GEN1_2, DI1_CNT_UP_2, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_2, field DI1_CNT_POLARITY_CLR_SEL_2 (RW)
 *
 * DI1 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Reserved
 * 011 - Reserved
 * 100 - Reserved
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_CLR_SEL_2      9
#define BM_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_CLR_SEL_2      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_CLR_SEL_2(v)   ((((reg32_t) v) << 9) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_CLR_SEL_2)
#else
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_CLR_SEL_2(v)   (((v) << 9) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_CLR_SEL_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_CLR_SEL_2 field to a new value.
#define BW_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_CLR_SEL_2(v)   BF_CS1(IPU_DI1_SW_GEN1_2, DI1_CNT_POLARITY_CLR_SEL_2, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_2, field DI1_CNT_POLARITY_TRIGGER_SEL_2 (RW)
 *
 * DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - Reserved
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_TRIGGER_SEL_2      12
#define BM_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_TRIGGER_SEL_2      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_TRIGGER_SEL_2(v)   ((((reg32_t) v) << 12) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_TRIGGER_SEL_2)
#else
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_TRIGGER_SEL_2(v)   (((v) << 12) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_TRIGGER_SEL_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_TRIGGER_SEL_2 field to a new value.
#define BW_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_TRIGGER_SEL_2(v)   BF_CS1(IPU_DI1_SW_GEN1_2, DI1_CNT_POLARITY_TRIGGER_SEL_2, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_2, field DI1_CNT_DOWN_2 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI1_SW_GEN1_2_DI1_CNT_DOWN_2      16
#define BM_IPU_DI1_SW_GEN1_2_DI1_CNT_DOWN_2      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_DOWN_2(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_DOWN_2)
#else
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_DOWN_2(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_DOWN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_DOWN_2 field to a new value.
#define BW_IPU_DI1_SW_GEN1_2_DI1_CNT_DOWN_2(v)   BF_CS1(IPU_DI1_SW_GEN1_2, DI1_CNT_DOWN_2, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_2, field DI1_CNT_CLR_SEL_2 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - Reserved
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_2_DI1_CNT_CLR_SEL_2      25
#define BM_IPU_DI1_SW_GEN1_2_DI1_CNT_CLR_SEL_2      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_CLR_SEL_2(v)   ((((reg32_t) v) << 25) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_CLR_SEL_2)
#else
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_CLR_SEL_2(v)   (((v) << 25) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_CLR_SEL_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_CLR_SEL_2 field to a new value.
#define BW_IPU_DI1_SW_GEN1_2_DI1_CNT_CLR_SEL_2(v)   BF_CS1(IPU_DI1_SW_GEN1_2, DI1_CNT_CLR_SEL_2, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_2, field DI1_CNT_AUTO_RELOAD_2 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di1_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di1_step_repeat_<i> field
 */

#define BP_IPU_DI1_SW_GEN1_2_DI1_CNT_AUTO_RELOAD_2      28
#define BM_IPU_DI1_SW_GEN1_2_DI1_CNT_AUTO_RELOAD_2      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_AUTO_RELOAD_2(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_AUTO_RELOAD_2)
#else
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_AUTO_RELOAD_2(v)   (((v) << 28) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_AUTO_RELOAD_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_AUTO_RELOAD_2 field to a new value.
#define BW_IPU_DI1_SW_GEN1_2_DI1_CNT_AUTO_RELOAD_2(v)   BF_CS1(IPU_DI1_SW_GEN1_2, DI1_CNT_AUTO_RELOAD_2, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_2, field DI1_CNT_POLARITY_GEN_EN_2 (RW)
 *
 * DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_GEN_EN_2      29
#define BM_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_GEN_EN_2      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_GEN_EN_2(v)   ((((reg32_t) v) << 29) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_GEN_EN_2)
#else
#define BF_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_GEN_EN_2(v)   (((v) << 29) & BM_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_GEN_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_GEN_EN_2 field to a new value.
#define BW_IPU_DI1_SW_GEN1_2_DI1_CNT_POLARITY_GEN_EN_2(v)   BF_CS1(IPU_DI1_SW_GEN1_2, DI1_CNT_POLARITY_GEN_EN_2, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN1_3 - DI1 Sync Wave Gen 3 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_CNT_UP_3 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI1_CNT_POLARITY_CLR_SEL_3 : 3; //!< DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI1_CNT_POLARITY_TRIGGER_SEL_3 : 3; //!< DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_CNT_DOWN_3 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI1_CNT_CLR_SEL_3 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI1_CNT_AUTO_RELOAD_3 : 1; //!< Counter auto reload mode
        unsigned DI1_CNT_POLARITY_GEN_EN_3 : 2; //!< DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen1_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN1_3 register
 */
#define HW_IPU_DI1_SW_GEN1_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x48038)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN1_3(x)           (*(volatile hw_ipu_di1_sw_gen1_3_t *) HW_IPU_DI1_SW_GEN1_3_ADDR(x))
#define HW_IPU_DI1_SW_GEN1_3_RD(x)        (HW_IPU_DI1_SW_GEN1_3(x).U)
#define HW_IPU_DI1_SW_GEN1_3_WR(x, v)     (HW_IPU_DI1_SW_GEN1_3(x).U = (v))
#define HW_IPU_DI1_SW_GEN1_3_SET(x, v)    (HW_IPU_DI1_SW_GEN1_3_WR(x, HW_IPU_DI1_SW_GEN1_3_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN1_3_CLR(x, v)    (HW_IPU_DI1_SW_GEN1_3_WR(x, HW_IPU_DI1_SW_GEN1_3_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN1_3_TOG(x, v)    (HW_IPU_DI1_SW_GEN1_3_WR(x, HW_IPU_DI1_SW_GEN1_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN1_3 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN1_3, field DI1_CNT_UP_3 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI1_SW_GEN1_3_DI1_CNT_UP_3      0
#define BM_IPU_DI1_SW_GEN1_3_DI1_CNT_UP_3      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_UP_3(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_UP_3)
#else
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_UP_3(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_UP_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_UP_3 field to a new value.
#define BW_IPU_DI1_SW_GEN1_3_DI1_CNT_UP_3(v)   BF_CS1(IPU_DI1_SW_GEN1_3, DI1_CNT_UP_3, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_3, field DI1_CNT_POLARITY_CLR_SEL_3 (RW)
 *
 * DI1 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Output is inverted if the output of counter #1 is set
 * 011 - Output is inverted if the output of counter #2 is set
 * 100 - Reserved
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_CLR_SEL_3      9
#define BM_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_CLR_SEL_3      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_CLR_SEL_3(v)   ((((reg32_t) v) << 9) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_CLR_SEL_3)
#else
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_CLR_SEL_3(v)   (((v) << 9) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_CLR_SEL_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_CLR_SEL_3 field to a new value.
#define BW_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_CLR_SEL_3(v)   BF_CS1(IPU_DI1_SW_GEN1_3, DI1_CNT_POLARITY_CLR_SEL_3, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_3, field DI1_CNT_POLARITY_TRIGGER_SEL_3 (RW)
 *
 * DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_TRIGGER_SEL_3      12
#define BM_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_TRIGGER_SEL_3      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_TRIGGER_SEL_3(v)   ((((reg32_t) v) << 12) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_TRIGGER_SEL_3)
#else
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_TRIGGER_SEL_3(v)   (((v) << 12) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_TRIGGER_SEL_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_TRIGGER_SEL_3 field to a new value.
#define BW_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_TRIGGER_SEL_3(v)   BF_CS1(IPU_DI1_SW_GEN1_3, DI1_CNT_POLARITY_TRIGGER_SEL_3, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_3, field DI1_CNT_DOWN_3 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI1_SW_GEN1_3_DI1_CNT_DOWN_3      16
#define BM_IPU_DI1_SW_GEN1_3_DI1_CNT_DOWN_3      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_DOWN_3(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_DOWN_3)
#else
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_DOWN_3(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_DOWN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_DOWN_3 field to a new value.
#define BW_IPU_DI1_SW_GEN1_3_DI1_CNT_DOWN_3(v)   BF_CS1(IPU_DI1_SW_GEN1_3, DI1_CNT_DOWN_3, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_3, field DI1_CNT_CLR_SEL_3 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - Reserved
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_3_DI1_CNT_CLR_SEL_3      25
#define BM_IPU_DI1_SW_GEN1_3_DI1_CNT_CLR_SEL_3      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_CLR_SEL_3(v)   ((((reg32_t) v) << 25) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_CLR_SEL_3)
#else
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_CLR_SEL_3(v)   (((v) << 25) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_CLR_SEL_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_CLR_SEL_3 field to a new value.
#define BW_IPU_DI1_SW_GEN1_3_DI1_CNT_CLR_SEL_3(v)   BF_CS1(IPU_DI1_SW_GEN1_3, DI1_CNT_CLR_SEL_3, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_3, field DI1_CNT_AUTO_RELOAD_3 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di1_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di1_step_repeat_<i> field
 */

#define BP_IPU_DI1_SW_GEN1_3_DI1_CNT_AUTO_RELOAD_3      28
#define BM_IPU_DI1_SW_GEN1_3_DI1_CNT_AUTO_RELOAD_3      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_AUTO_RELOAD_3(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_AUTO_RELOAD_3)
#else
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_AUTO_RELOAD_3(v)   (((v) << 28) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_AUTO_RELOAD_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_AUTO_RELOAD_3 field to a new value.
#define BW_IPU_DI1_SW_GEN1_3_DI1_CNT_AUTO_RELOAD_3(v)   BF_CS1(IPU_DI1_SW_GEN1_3, DI1_CNT_AUTO_RELOAD_3, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_3, field DI1_CNT_POLARITY_GEN_EN_3 (RW)
 *
 * DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_GEN_EN_3      29
#define BM_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_GEN_EN_3      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_GEN_EN_3(v)   ((((reg32_t) v) << 29) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_GEN_EN_3)
#else
#define BF_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_GEN_EN_3(v)   (((v) << 29) & BM_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_GEN_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_GEN_EN_3 field to a new value.
#define BW_IPU_DI1_SW_GEN1_3_DI1_CNT_POLARITY_GEN_EN_3(v)   BF_CS1(IPU_DI1_SW_GEN1_3, DI1_CNT_POLARITY_GEN_EN_3, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN1_4 - DI1 Sync Wave Gen 4 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_CNT_UP_4 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI1_CNT_POLARITY_CLR_SEL_4 : 3; //!< DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI1_CNT_POLARITY_TRIGGER_SEL_4 : 3; //!< DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_CNT_DOWN_4 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI1_CNT_CLR_SEL_4 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI1_CNT_AUTO_RELOAD_4 : 1; //!< Counter auto reload mode
        unsigned DI1_CNT_POLARITY_GEN_EN_4 : 2; //!< DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen1_4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN1_4 register
 */
#define HW_IPU_DI1_SW_GEN1_4_ADDR(x)      (REGS_IPU_BASE(x) + 0x4803c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN1_4(x)           (*(volatile hw_ipu_di1_sw_gen1_4_t *) HW_IPU_DI1_SW_GEN1_4_ADDR(x))
#define HW_IPU_DI1_SW_GEN1_4_RD(x)        (HW_IPU_DI1_SW_GEN1_4(x).U)
#define HW_IPU_DI1_SW_GEN1_4_WR(x, v)     (HW_IPU_DI1_SW_GEN1_4(x).U = (v))
#define HW_IPU_DI1_SW_GEN1_4_SET(x, v)    (HW_IPU_DI1_SW_GEN1_4_WR(x, HW_IPU_DI1_SW_GEN1_4_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN1_4_CLR(x, v)    (HW_IPU_DI1_SW_GEN1_4_WR(x, HW_IPU_DI1_SW_GEN1_4_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN1_4_TOG(x, v)    (HW_IPU_DI1_SW_GEN1_4_WR(x, HW_IPU_DI1_SW_GEN1_4_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN1_4 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN1_4, field DI1_CNT_UP_4 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI1_SW_GEN1_4_DI1_CNT_UP_4      0
#define BM_IPU_DI1_SW_GEN1_4_DI1_CNT_UP_4      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_UP_4(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_UP_4)
#else
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_UP_4(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_UP_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_UP_4 field to a new value.
#define BW_IPU_DI1_SW_GEN1_4_DI1_CNT_UP_4(v)   BF_CS1(IPU_DI1_SW_GEN1_4, DI1_CNT_UP_4, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_4, field DI1_CNT_POLARITY_CLR_SEL_4 (RW)
 *
 * DI1 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Output is inverted if the output of counter #1 is set
 * 011 - Output is inverted if the output of counter #2 is set
 * 100 - Output is inverted if the output of counter #3 is set
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_CLR_SEL_4      9
#define BM_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_CLR_SEL_4      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_CLR_SEL_4(v)   ((((reg32_t) v) << 9) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_CLR_SEL_4)
#else
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_CLR_SEL_4(v)   (((v) << 9) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_CLR_SEL_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_CLR_SEL_4 field to a new value.
#define BW_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_CLR_SEL_4(v)   BF_CS1(IPU_DI1_SW_GEN1_4, DI1_CNT_POLARITY_CLR_SEL_4, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_4, field DI1_CNT_POLARITY_TRIGGER_SEL_4 (RW)
 *
 * DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - - Counter is disabled
 * 001 - - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - - The Counter is triggered by counter #1
 * 011 - - The Counter is triggered by counter #2
 * 100 - - The Counter is triggered by counter #3
 * 101 - - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST
 *     bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_TRIGGER_SEL_4      12
#define BM_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_TRIGGER_SEL_4      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_TRIGGER_SEL_4(v)   ((((reg32_t) v) << 12) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_TRIGGER_SEL_4)
#else
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_TRIGGER_SEL_4(v)   (((v) << 12) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_TRIGGER_SEL_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_TRIGGER_SEL_4 field to a new value.
#define BW_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_TRIGGER_SEL_4(v)   BF_CS1(IPU_DI1_SW_GEN1_4, DI1_CNT_POLARITY_TRIGGER_SEL_4, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_4, field DI1_CNT_DOWN_4 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI1_SW_GEN1_4_DI1_CNT_DOWN_4      16
#define BM_IPU_DI1_SW_GEN1_4_DI1_CNT_DOWN_4      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_DOWN_4(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_DOWN_4)
#else
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_DOWN_4(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_DOWN_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_DOWN_4 field to a new value.
#define BW_IPU_DI1_SW_GEN1_4_DI1_CNT_DOWN_4(v)   BF_CS1(IPU_DI1_SW_GEN1_4, DI1_CNT_DOWN_4, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_4, field DI1_CNT_CLR_SEL_4 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - CSI VSYNC. The VSYNC is a trigger coming from one of the CSI's according to the CSI_VSYNC_DEST bit.
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_4_DI1_CNT_CLR_SEL_4      25
#define BM_IPU_DI1_SW_GEN1_4_DI1_CNT_CLR_SEL_4      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_CLR_SEL_4(v)   ((((reg32_t) v) << 25) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_CLR_SEL_4)
#else
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_CLR_SEL_4(v)   (((v) << 25) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_CLR_SEL_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_CLR_SEL_4 field to a new value.
#define BW_IPU_DI1_SW_GEN1_4_DI1_CNT_CLR_SEL_4(v)   BF_CS1(IPU_DI1_SW_GEN1_4, DI1_CNT_CLR_SEL_4, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_4, field DI1_CNT_AUTO_RELOAD_4 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di1_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di1_step_repeat_<i> field
 */

#define BP_IPU_DI1_SW_GEN1_4_DI1_CNT_AUTO_RELOAD_4      28
#define BM_IPU_DI1_SW_GEN1_4_DI1_CNT_AUTO_RELOAD_4      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_AUTO_RELOAD_4(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_AUTO_RELOAD_4)
#else
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_AUTO_RELOAD_4(v)   (((v) << 28) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_AUTO_RELOAD_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_AUTO_RELOAD_4 field to a new value.
#define BW_IPU_DI1_SW_GEN1_4_DI1_CNT_AUTO_RELOAD_4(v)   BF_CS1(IPU_DI1_SW_GEN1_4, DI1_CNT_AUTO_RELOAD_4, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_4, field DI1_CNT_POLARITY_GEN_EN_4 (RW)
 *
 * DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_GEN_EN_4      29
#define BM_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_GEN_EN_4      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_GEN_EN_4(v)   ((((reg32_t) v) << 29) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_GEN_EN_4)
#else
#define BF_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_GEN_EN_4(v)   (((v) << 29) & BM_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_GEN_EN_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_GEN_EN_4 field to a new value.
#define BW_IPU_DI1_SW_GEN1_4_DI1_CNT_POLARITY_GEN_EN_4(v)   BF_CS1(IPU_DI1_SW_GEN1_4, DI1_CNT_POLARITY_GEN_EN_4, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN1_5 - DI1 Sync Wave Gen 5 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_CNT_UP_5 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI1_CNT_POLARITY_CLR_SEL_5 : 3; //!< DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI1_CNT_POLARITY_TRIGGER_SEL_5 : 3; //!< DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_CNT_DOWN_5 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI1_CNT_CLR_SEL_5 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI1_CNT_AUTO_RELOAD_5 : 1; //!< Counter auto reload mode
        unsigned DI1_CNT_POLARITY_GEN_EN_5 : 2; //!< DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen1_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN1_5 register
 */
#define HW_IPU_DI1_SW_GEN1_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x48040)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN1_5(x)           (*(volatile hw_ipu_di1_sw_gen1_5_t *) HW_IPU_DI1_SW_GEN1_5_ADDR(x))
#define HW_IPU_DI1_SW_GEN1_5_RD(x)        (HW_IPU_DI1_SW_GEN1_5(x).U)
#define HW_IPU_DI1_SW_GEN1_5_WR(x, v)     (HW_IPU_DI1_SW_GEN1_5(x).U = (v))
#define HW_IPU_DI1_SW_GEN1_5_SET(x, v)    (HW_IPU_DI1_SW_GEN1_5_WR(x, HW_IPU_DI1_SW_GEN1_5_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN1_5_CLR(x, v)    (HW_IPU_DI1_SW_GEN1_5_WR(x, HW_IPU_DI1_SW_GEN1_5_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN1_5_TOG(x, v)    (HW_IPU_DI1_SW_GEN1_5_WR(x, HW_IPU_DI1_SW_GEN1_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN1_5 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN1_5, field DI1_CNT_UP_5 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI1_SW_GEN1_5_DI1_CNT_UP_5      0
#define BM_IPU_DI1_SW_GEN1_5_DI1_CNT_UP_5      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_UP_5(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_UP_5)
#else
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_UP_5(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_UP_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_UP_5 field to a new value.
#define BW_IPU_DI1_SW_GEN1_5_DI1_CNT_UP_5(v)   BF_CS1(IPU_DI1_SW_GEN1_5, DI1_CNT_UP_5, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_5, field DI1_CNT_POLARITY_CLR_SEL_5 (RW)
 *
 * DI1 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Output is inverted if the output of counter #1 is set
 * 011 - Output is inverted if the output of counter #2 is set
 * 100 - Output is inverted if the output of counter #3 is set
 * 101 - Output is inverted if the output of counter #4 is set
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_CLR_SEL_5      9
#define BM_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_CLR_SEL_5      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_CLR_SEL_5(v)   ((((reg32_t) v) << 9) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_CLR_SEL_5)
#else
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_CLR_SEL_5(v)   (((v) << 9) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_CLR_SEL_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_CLR_SEL_5 field to a new value.
#define BW_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_CLR_SEL_5(v)   BF_CS1(IPU_DI1_SW_GEN1_5, DI1_CNT_POLARITY_CLR_SEL_5, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_5, field DI1_CNT_POLARITY_TRIGGER_SEL_5 (RW)
 *
 * DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_TRIGGER_SEL_5      12
#define BM_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_TRIGGER_SEL_5      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_TRIGGER_SEL_5(v)   ((((reg32_t) v) << 12) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_TRIGGER_SEL_5)
#else
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_TRIGGER_SEL_5(v)   (((v) << 12) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_TRIGGER_SEL_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_TRIGGER_SEL_5 field to a new value.
#define BW_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_TRIGGER_SEL_5(v)   BF_CS1(IPU_DI1_SW_GEN1_5, DI1_CNT_POLARITY_TRIGGER_SEL_5, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_5, field DI1_CNT_DOWN_5 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI1_SW_GEN1_5_DI1_CNT_DOWN_5      16
#define BM_IPU_DI1_SW_GEN1_5_DI1_CNT_DOWN_5      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_DOWN_5(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_DOWN_5)
#else
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_DOWN_5(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_DOWN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_DOWN_5 field to a new value.
#define BW_IPU_DI1_SW_GEN1_5_DI1_CNT_DOWN_5(v)   BF_CS1(IPU_DI1_SW_GEN1_5, DI1_CNT_DOWN_5, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_5, field DI1_CNT_CLR_SEL_5 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - External VSYNC
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_5_DI1_CNT_CLR_SEL_5      25
#define BM_IPU_DI1_SW_GEN1_5_DI1_CNT_CLR_SEL_5      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_CLR_SEL_5(v)   ((((reg32_t) v) << 25) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_CLR_SEL_5)
#else
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_CLR_SEL_5(v)   (((v) << 25) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_CLR_SEL_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_CLR_SEL_5 field to a new value.
#define BW_IPU_DI1_SW_GEN1_5_DI1_CNT_CLR_SEL_5(v)   BF_CS1(IPU_DI1_SW_GEN1_5, DI1_CNT_CLR_SEL_5, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_5, field DI1_CNT_AUTO_RELOAD_5 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di1_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di1_step_repeat_<i> field
 */

#define BP_IPU_DI1_SW_GEN1_5_DI1_CNT_AUTO_RELOAD_5      28
#define BM_IPU_DI1_SW_GEN1_5_DI1_CNT_AUTO_RELOAD_5      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_AUTO_RELOAD_5(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_AUTO_RELOAD_5)
#else
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_AUTO_RELOAD_5(v)   (((v) << 28) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_AUTO_RELOAD_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_AUTO_RELOAD_5 field to a new value.
#define BW_IPU_DI1_SW_GEN1_5_DI1_CNT_AUTO_RELOAD_5(v)   BF_CS1(IPU_DI1_SW_GEN1_5, DI1_CNT_AUTO_RELOAD_5, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_5, field DI1_CNT_POLARITY_GEN_EN_5 (RW)
 *
 * DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_GEN_EN_5      29
#define BM_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_GEN_EN_5      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_GEN_EN_5(v)   ((((reg32_t) v) << 29) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_GEN_EN_5)
#else
#define BF_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_GEN_EN_5(v)   (((v) << 29) & BM_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_GEN_EN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_GEN_EN_5 field to a new value.
#define BW_IPU_DI1_SW_GEN1_5_DI1_CNT_POLARITY_GEN_EN_5(v)   BF_CS1(IPU_DI1_SW_GEN1_5, DI1_CNT_POLARITY_GEN_EN_5, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN1_6 - DI1 Sync Wave Gen 6 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_CNT_UP_6 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI1_CNT_POLARITY_CLR_SEL_6 : 3; //!< DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI1_CNT_POLARITY_TRIGGER_SEL_6 : 3; //!< DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_CNT_DOWN_6 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI1_CNT_CLR_SEL_6 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI1_CNT_AUTO_RELOAD_6 : 1; //!< Counter auto reload mode
        unsigned DI1_CNT_POLARITY_GEN_EN_6 : 2; //!< DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen1_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN1_6 register
 */
#define HW_IPU_DI1_SW_GEN1_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x48044)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN1_6(x)           (*(volatile hw_ipu_di1_sw_gen1_6_t *) HW_IPU_DI1_SW_GEN1_6_ADDR(x))
#define HW_IPU_DI1_SW_GEN1_6_RD(x)        (HW_IPU_DI1_SW_GEN1_6(x).U)
#define HW_IPU_DI1_SW_GEN1_6_WR(x, v)     (HW_IPU_DI1_SW_GEN1_6(x).U = (v))
#define HW_IPU_DI1_SW_GEN1_6_SET(x, v)    (HW_IPU_DI1_SW_GEN1_6_WR(x, HW_IPU_DI1_SW_GEN1_6_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN1_6_CLR(x, v)    (HW_IPU_DI1_SW_GEN1_6_WR(x, HW_IPU_DI1_SW_GEN1_6_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN1_6_TOG(x, v)    (HW_IPU_DI1_SW_GEN1_6_WR(x, HW_IPU_DI1_SW_GEN1_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN1_6 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN1_6, field DI1_CNT_UP_6 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI1_SW_GEN1_6_DI1_CNT_UP_6      0
#define BM_IPU_DI1_SW_GEN1_6_DI1_CNT_UP_6      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_UP_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_UP_6)
#else
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_UP_6(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_UP_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_UP_6 field to a new value.
#define BW_IPU_DI1_SW_GEN1_6_DI1_CNT_UP_6(v)   BF_CS1(IPU_DI1_SW_GEN1_6, DI1_CNT_UP_6, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_6, field DI1_CNT_POLARITY_CLR_SEL_6 (RW)
 *
 * DI1 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Output is inverted if the output of counter #1 is set
 * 011 - Output is inverted if the output of counter #2 is set
 * 100 - Output is inverted if the output of counter #3 is set
 * 101 - Output is inverted if the output of counter #4 is set
 * 110 - Output is inverted if the output of counter #5 is set
 * 111 - Reserved
 */

#define BP_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_CLR_SEL_6      9
#define BM_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_CLR_SEL_6      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_CLR_SEL_6(v)   ((((reg32_t) v) << 9) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_CLR_SEL_6)
#else
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_CLR_SEL_6(v)   (((v) << 9) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_CLR_SEL_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_CLR_SEL_6 field to a new value.
#define BW_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_CLR_SEL_6(v)   BF_CS1(IPU_DI1_SW_GEN1_6, DI1_CNT_POLARITY_CLR_SEL_6, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_6, field DI1_CNT_POLARITY_TRIGGER_SEL_6 (RW)
 *
 * DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_TRIGGER_SEL_6      12
#define BM_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_TRIGGER_SEL_6      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_TRIGGER_SEL_6(v)   ((((reg32_t) v) << 12) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_TRIGGER_SEL_6)
#else
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_TRIGGER_SEL_6(v)   (((v) << 12) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_TRIGGER_SEL_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_TRIGGER_SEL_6 field to a new value.
#define BW_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_TRIGGER_SEL_6(v)   BF_CS1(IPU_DI1_SW_GEN1_6, DI1_CNT_POLARITY_TRIGGER_SEL_6, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_6, field DI1_CNT_DOWN_6 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI1_SW_GEN1_6_DI1_CNT_DOWN_6      16
#define BM_IPU_DI1_SW_GEN1_6_DI1_CNT_DOWN_6      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_DOWN_6(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_DOWN_6)
#else
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_DOWN_6(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_DOWN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_DOWN_6 field to a new value.
#define BW_IPU_DI1_SW_GEN1_6_DI1_CNT_DOWN_6(v)   BF_CS1(IPU_DI1_SW_GEN1_6, DI1_CNT_DOWN_6, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_6, field DI1_CNT_CLR_SEL_6 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_6_DI1_CNT_CLR_SEL_6      25
#define BM_IPU_DI1_SW_GEN1_6_DI1_CNT_CLR_SEL_6      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_CLR_SEL_6(v)   ((((reg32_t) v) << 25) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_CLR_SEL_6)
#else
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_CLR_SEL_6(v)   (((v) << 25) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_CLR_SEL_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_CLR_SEL_6 field to a new value.
#define BW_IPU_DI1_SW_GEN1_6_DI1_CNT_CLR_SEL_6(v)   BF_CS1(IPU_DI1_SW_GEN1_6, DI1_CNT_CLR_SEL_6, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_6, field DI1_CNT_AUTO_RELOAD_6 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di1_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di1_step_repeat_<i> field
 */

#define BP_IPU_DI1_SW_GEN1_6_DI1_CNT_AUTO_RELOAD_6      28
#define BM_IPU_DI1_SW_GEN1_6_DI1_CNT_AUTO_RELOAD_6      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_AUTO_RELOAD_6(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_AUTO_RELOAD_6)
#else
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_AUTO_RELOAD_6(v)   (((v) << 28) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_AUTO_RELOAD_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_AUTO_RELOAD_6 field to a new value.
#define BW_IPU_DI1_SW_GEN1_6_DI1_CNT_AUTO_RELOAD_6(v)   BF_CS1(IPU_DI1_SW_GEN1_6, DI1_CNT_AUTO_RELOAD_6, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_6, field DI1_CNT_POLARITY_GEN_EN_6 (RW)
 *
 * DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_GEN_EN_6      29
#define BM_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_GEN_EN_6      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_GEN_EN_6(v)   ((((reg32_t) v) << 29) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_GEN_EN_6)
#else
#define BF_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_GEN_EN_6(v)   (((v) << 29) & BM_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_GEN_EN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_GEN_EN_6 field to a new value.
#define BW_IPU_DI1_SW_GEN1_6_DI1_CNT_POLARITY_GEN_EN_6(v)   BF_CS1(IPU_DI1_SW_GEN1_6, DI1_CNT_POLARITY_GEN_EN_6, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN1_7 - DI1Sync Wave Gen 7 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_CNT_UP_7 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI1_CNT_POLARITY_CLR_SEL_7 : 3; //!< DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI1_CNT_POLARITY_TRIGGER_SEL_7 : 3; //!< DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_CNT_DOWN_7 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI1_CNT_CLR_SEL_7 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI1_CNT_AUTO_RELOAD_7 : 1; //!< Counter auto reload mode
        unsigned DI1_CNT_POLARITY_GEN_EN_7 : 2; //!< DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen1_7_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN1_7 register
 */
#define HW_IPU_DI1_SW_GEN1_7_ADDR(x)      (REGS_IPU_BASE(x) + 0x48048)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN1_7(x)           (*(volatile hw_ipu_di1_sw_gen1_7_t *) HW_IPU_DI1_SW_GEN1_7_ADDR(x))
#define HW_IPU_DI1_SW_GEN1_7_RD(x)        (HW_IPU_DI1_SW_GEN1_7(x).U)
#define HW_IPU_DI1_SW_GEN1_7_WR(x, v)     (HW_IPU_DI1_SW_GEN1_7(x).U = (v))
#define HW_IPU_DI1_SW_GEN1_7_SET(x, v)    (HW_IPU_DI1_SW_GEN1_7_WR(x, HW_IPU_DI1_SW_GEN1_7_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN1_7_CLR(x, v)    (HW_IPU_DI1_SW_GEN1_7_WR(x, HW_IPU_DI1_SW_GEN1_7_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN1_7_TOG(x, v)    (HW_IPU_DI1_SW_GEN1_7_WR(x, HW_IPU_DI1_SW_GEN1_7_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN1_7 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN1_7, field DI1_CNT_UP_7 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI1_SW_GEN1_7_DI1_CNT_UP_7      0
#define BM_IPU_DI1_SW_GEN1_7_DI1_CNT_UP_7      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_UP_7(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_UP_7)
#else
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_UP_7(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_UP_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_UP_7 field to a new value.
#define BW_IPU_DI1_SW_GEN1_7_DI1_CNT_UP_7(v)   BF_CS1(IPU_DI1_SW_GEN1_7, DI1_CNT_UP_7, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_7, field DI1_CNT_POLARITY_CLR_SEL_7 (RW)
 *
 * DI1 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Output is inverted if the output of counter #1 is set
 * 011 - Output is inverted if the output of counter #2 is set
 * 100 - Output is inverted if the output of counter #3 is set
 * 101 - Output is inverted if the output of counter #4 is set
 * 110 - Output is inverted if the output of counter #5 is set
 * 111 - Output is inverted if the output of counter #6 is set
 */

#define BP_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_CLR_SEL_7      9
#define BM_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_CLR_SEL_7      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_CLR_SEL_7(v)   ((((reg32_t) v) << 9) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_CLR_SEL_7)
#else
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_CLR_SEL_7(v)   (((v) << 9) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_CLR_SEL_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_CLR_SEL_7 field to a new value.
#define BW_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_CLR_SEL_7(v)   BF_CS1(IPU_DI1_SW_GEN1_7, DI1_CNT_POLARITY_CLR_SEL_7, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_7, field DI1_CNT_POLARITY_TRIGGER_SEL_7 (RW)
 *
 * DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_TRIGGER_SEL_7      12
#define BM_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_TRIGGER_SEL_7      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_TRIGGER_SEL_7(v)   ((((reg32_t) v) << 12) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_TRIGGER_SEL_7)
#else
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_TRIGGER_SEL_7(v)   (((v) << 12) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_TRIGGER_SEL_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_TRIGGER_SEL_7 field to a new value.
#define BW_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_TRIGGER_SEL_7(v)   BF_CS1(IPU_DI1_SW_GEN1_7, DI1_CNT_POLARITY_TRIGGER_SEL_7, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_7, field DI1_CNT_DOWN_7 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI1_SW_GEN1_7_DI1_CNT_DOWN_7      16
#define BM_IPU_DI1_SW_GEN1_7_DI1_CNT_DOWN_7      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_DOWN_7(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_DOWN_7)
#else
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_DOWN_7(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_DOWN_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_DOWN_7 field to a new value.
#define BW_IPU_DI1_SW_GEN1_7_DI1_CNT_DOWN_7(v)   BF_CS1(IPU_DI1_SW_GEN1_7, DI1_CNT_DOWN_7, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_7, field DI1_CNT_CLR_SEL_7 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_7_DI1_CNT_CLR_SEL_7      25
#define BM_IPU_DI1_SW_GEN1_7_DI1_CNT_CLR_SEL_7      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_CLR_SEL_7(v)   ((((reg32_t) v) << 25) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_CLR_SEL_7)
#else
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_CLR_SEL_7(v)   (((v) << 25) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_CLR_SEL_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_CLR_SEL_7 field to a new value.
#define BW_IPU_DI1_SW_GEN1_7_DI1_CNT_CLR_SEL_7(v)   BF_CS1(IPU_DI1_SW_GEN1_7, DI1_CNT_CLR_SEL_7, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_7, field DI1_CNT_AUTO_RELOAD_7 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di1_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di1_step_repeat_<i> field
 */

#define BP_IPU_DI1_SW_GEN1_7_DI1_CNT_AUTO_RELOAD_7      28
#define BM_IPU_DI1_SW_GEN1_7_DI1_CNT_AUTO_RELOAD_7      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_AUTO_RELOAD_7(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_AUTO_RELOAD_7)
#else
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_AUTO_RELOAD_7(v)   (((v) << 28) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_AUTO_RELOAD_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_AUTO_RELOAD_7 field to a new value.
#define BW_IPU_DI1_SW_GEN1_7_DI1_CNT_AUTO_RELOAD_7(v)   BF_CS1(IPU_DI1_SW_GEN1_7, DI1_CNT_AUTO_RELOAD_7, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_7, field DI1_CNT_POLARITY_GEN_EN_7 (RW)
 *
 * DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_GEN_EN_7      29
#define BM_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_GEN_EN_7      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_GEN_EN_7(v)   ((((reg32_t) v) << 29) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_GEN_EN_7)
#else
#define BF_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_GEN_EN_7(v)   (((v) << 29) & BM_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_GEN_EN_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_GEN_EN_7 field to a new value.
#define BW_IPU_DI1_SW_GEN1_7_DI1_CNT_POLARITY_GEN_EN_7(v)   BF_CS1(IPU_DI1_SW_GEN1_7, DI1_CNT_POLARITY_GEN_EN_7, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN1_8 - DI1 Sync Wave Gen 8 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_CNT_UP_8 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned DI1_CNT_POLARITY_CLR_SEL_8 : 3; //!< DI1 counter's polarity Clear select This field selects the input to the counter telling the counter wether to invert the output
        unsigned DI1_CNT_POLARITY_TRIGGER_SEL_8 : 3; //!< DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output to toggle
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DI1_CNT_DOWN_8 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI1_CNT_CLR_SEL_8 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI1_CNT_AUTO_RELOAD_8 : 1; //!< Counter auto reload mode 1 The counter will automatically be reloaded forever, ignoring the value of the di1_step_repeat_<i> field 0 The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times defined on the di1_step_repeat_<i> field
        unsigned DI1_CNT_POLARITY_GEN_EN_8 : 2; //!< DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_di1_sw_gen1_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN1_8 register
 */
#define HW_IPU_DI1_SW_GEN1_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x4804c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN1_8(x)           (*(volatile hw_ipu_di1_sw_gen1_8_t *) HW_IPU_DI1_SW_GEN1_8_ADDR(x))
#define HW_IPU_DI1_SW_GEN1_8_RD(x)        (HW_IPU_DI1_SW_GEN1_8(x).U)
#define HW_IPU_DI1_SW_GEN1_8_WR(x, v)     (HW_IPU_DI1_SW_GEN1_8(x).U = (v))
#define HW_IPU_DI1_SW_GEN1_8_SET(x, v)    (HW_IPU_DI1_SW_GEN1_8_WR(x, HW_IPU_DI1_SW_GEN1_8_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN1_8_CLR(x, v)    (HW_IPU_DI1_SW_GEN1_8_WR(x, HW_IPU_DI1_SW_GEN1_8_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN1_8_TOG(x, v)    (HW_IPU_DI1_SW_GEN1_8_WR(x, HW_IPU_DI1_SW_GEN1_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN1_8 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN1_8, field DI1_CNT_UP_8 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI1_SW_GEN1_8_DI1_CNT_UP_8      0
#define BM_IPU_DI1_SW_GEN1_8_DI1_CNT_UP_8      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_UP_8(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_UP_8)
#else
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_UP_8(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_UP_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_UP_8 field to a new value.
#define BW_IPU_DI1_SW_GEN1_8_DI1_CNT_UP_8(v)   BF_CS1(IPU_DI1_SW_GEN1_8, DI1_CNT_UP_8, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_8, field DI1_CNT_POLARITY_CLR_SEL_8 (RW)
 *
 * DI1 counter's polarity Clear select This field selects the input to the counter telling the
 * counter wether to invert the output
 *
 * Values:
 * 000 - Output is always inverted
 * 001 - Output is kept the same (no inversion)
 * 010 - Output is inverted if the output of counter #1 is set
 * 011 - Output is inverted if the output of counter #2 is set
 * 100 - Output is inverted if the output of counter #3 is set
 * 101 - Output is inverted if the output of counter #4 is set
 * 110 - Output is inverted if the output of counter #5 is set
 * 111 - Output is inverted if the output of counter #6 is set
 */

#define BP_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_CLR_SEL_8      9
#define BM_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_CLR_SEL_8      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_CLR_SEL_8(v)   ((((reg32_t) v) << 9) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_CLR_SEL_8)
#else
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_CLR_SEL_8(v)   (((v) << 9) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_CLR_SEL_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_CLR_SEL_8 field to a new value.
#define BW_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_CLR_SEL_8(v)   BF_CS1(IPU_DI1_SW_GEN1_8, DI1_CNT_POLARITY_CLR_SEL_8, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_8, field DI1_CNT_POLARITY_TRIGGER_SEL_8 (RW)
 *
 * DI1 Counter's toggling trigger select This field selects the counter's trigger causing the output
 * to toggle
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_TRIGGER_SEL_8      12
#define BM_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_TRIGGER_SEL_8      0x00007000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_TRIGGER_SEL_8(v)   ((((reg32_t) v) << 12) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_TRIGGER_SEL_8)
#else
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_TRIGGER_SEL_8(v)   (((v) << 12) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_TRIGGER_SEL_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_TRIGGER_SEL_8 field to a new value.
#define BW_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_TRIGGER_SEL_8(v)   BF_CS1(IPU_DI1_SW_GEN1_8, DI1_CNT_POLARITY_TRIGGER_SEL_8, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_8, field DI1_CNT_DOWN_8 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI1_SW_GEN1_8_DI1_CNT_DOWN_8      16
#define BM_IPU_DI1_SW_GEN1_8_DI1_CNT_DOWN_8      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_DOWN_8(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_DOWN_8)
#else
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_DOWN_8(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_DOWN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_DOWN_8 field to a new value.
#define BW_IPU_DI1_SW_GEN1_8_DI1_CNT_DOWN_8(v)   BF_CS1(IPU_DI1_SW_GEN1_8, DI1_CNT_DOWN_8, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_8, field DI1_CNT_CLR_SEL_8 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_8_DI1_CNT_CLR_SEL_8      25
#define BM_IPU_DI1_SW_GEN1_8_DI1_CNT_CLR_SEL_8      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_CLR_SEL_8(v)   ((((reg32_t) v) << 25) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_CLR_SEL_8)
#else
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_CLR_SEL_8(v)   (((v) << 25) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_CLR_SEL_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_CLR_SEL_8 field to a new value.
#define BW_IPU_DI1_SW_GEN1_8_DI1_CNT_CLR_SEL_8(v)   BF_CS1(IPU_DI1_SW_GEN1_8, DI1_CNT_CLR_SEL_8, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_8, field DI1_CNT_AUTO_RELOAD_8 (RW)
 *
 * Counter auto reload mode 1 The counter will automatically be reloaded forever, ignoring the value
 * of the di1_step_repeat_<i> field 0 The counter will not be automatically reloaded, It will be
 * reloaded for the amount of repeat times defined on the di1_step_repeat_<i> field
 */

#define BP_IPU_DI1_SW_GEN1_8_DI1_CNT_AUTO_RELOAD_8      28
#define BM_IPU_DI1_SW_GEN1_8_DI1_CNT_AUTO_RELOAD_8      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_AUTO_RELOAD_8(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_AUTO_RELOAD_8)
#else
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_AUTO_RELOAD_8(v)   (((v) << 28) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_AUTO_RELOAD_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_AUTO_RELOAD_8 field to a new value.
#define BW_IPU_DI1_SW_GEN1_8_DI1_CNT_AUTO_RELOAD_8(v)   BF_CS1(IPU_DI1_SW_GEN1_8, DI1_CNT_AUTO_RELOAD_8, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_8, field DI1_CNT_POLARITY_GEN_EN_8 (RW)
 *
 * DI1 Counter polarity generator enable The counter's output polarity can be changed on the fly.
 *
 * Values:
 * 00 - Dynamic polarity change is disabled
 * 01 - The counters UP and DOWN value are calculated according to the trigger selected by
 *     cnt_polarity_trigger_sel field. When selecting this mode the UP and DOWN values has to be a
 *     multiple of 2.
 * 10 - Dynamic polarity change is enabled
 * 11 - Outputs polarity is dynamically changed every time the counter reaches its pre defined value
 */

#define BP_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_GEN_EN_8      29
#define BM_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_GEN_EN_8      0x60000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_GEN_EN_8(v)   ((((reg32_t) v) << 29) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_GEN_EN_8)
#else
#define BF_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_GEN_EN_8(v)   (((v) << 29) & BM_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_GEN_EN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_POLARITY_GEN_EN_8 field to a new value.
#define BW_IPU_DI1_SW_GEN1_8_DI1_CNT_POLARITY_GEN_EN_8(v)   BF_CS1(IPU_DI1_SW_GEN1_8, DI1_CNT_POLARITY_GEN_EN_8, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SW_GEN1_9 - DI1 Sync Wave Gen 9 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_CNT_UP_9 : 9; //!< Counter rising edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's rising edge.
        unsigned RESERVED0 : 6; //!< Reserved
        unsigned DI1_TAG_SEL_9 : 1; //!< Counter #9 can send a synchronous tag when counter #9 reach its predefined value or when it's triggering counter reaches its pre defined value.
        unsigned DI1_CNT_DOWN_9 : 9; //!< Counter falling edge position This parameter contains an integer part (bits 24:17) and a fractional part (bit 16). The position value is the amount of cycles between the trigger's start point and the waveform's falling edge.
        unsigned DI1_CNT_CLR_SEL_9 : 3; //!< Counter Clear select This field defines the source of the signals that clears the counter.
        unsigned DI1_CNT_AUTO_RELOAD_9 : 1; //!< Counter auto reload mode
        unsigned DI1_GENTIME_SEL_9 : 3; //!< Counter #9 main waveform select This field defines the counter that counter #9's auxiliary waveform will be attached too.
    } B;
} hw_ipu_di1_sw_gen1_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SW_GEN1_9 register
 */
#define HW_IPU_DI1_SW_GEN1_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x48050)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SW_GEN1_9(x)           (*(volatile hw_ipu_di1_sw_gen1_9_t *) HW_IPU_DI1_SW_GEN1_9_ADDR(x))
#define HW_IPU_DI1_SW_GEN1_9_RD(x)        (HW_IPU_DI1_SW_GEN1_9(x).U)
#define HW_IPU_DI1_SW_GEN1_9_WR(x, v)     (HW_IPU_DI1_SW_GEN1_9(x).U = (v))
#define HW_IPU_DI1_SW_GEN1_9_SET(x, v)    (HW_IPU_DI1_SW_GEN1_9_WR(x, HW_IPU_DI1_SW_GEN1_9_RD(x) |  (v)))
#define HW_IPU_DI1_SW_GEN1_9_CLR(x, v)    (HW_IPU_DI1_SW_GEN1_9_WR(x, HW_IPU_DI1_SW_GEN1_9_RD(x) & ~(v)))
#define HW_IPU_DI1_SW_GEN1_9_TOG(x, v)    (HW_IPU_DI1_SW_GEN1_9_WR(x, HW_IPU_DI1_SW_GEN1_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SW_GEN1_9 bitfields
 */

/* --- Register HW_IPU_DI1_SW_GEN1_9, field DI1_CNT_UP_9 (RW)
 *
 * Counter rising edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's rising edge.
 */

#define BP_IPU_DI1_SW_GEN1_9_DI1_CNT_UP_9      0
#define BM_IPU_DI1_SW_GEN1_9_DI1_CNT_UP_9      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_9_DI1_CNT_UP_9(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SW_GEN1_9_DI1_CNT_UP_9)
#else
#define BF_IPU_DI1_SW_GEN1_9_DI1_CNT_UP_9(v)   (((v) << 0) & BM_IPU_DI1_SW_GEN1_9_DI1_CNT_UP_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_UP_9 field to a new value.
#define BW_IPU_DI1_SW_GEN1_9_DI1_CNT_UP_9(v)   BF_CS1(IPU_DI1_SW_GEN1_9, DI1_CNT_UP_9, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_9, field DI1_TAG_SEL_9 (RW)
 *
 * Counter #9 can send a synchronous tag when counter #9 reach its predefined value or when it's
 * triggering counter reaches its pre defined value.
 *
 * Values:
 * 1 - tag source is counter #9
 * 0 - Tag's source is the triggering counter.
 */

#define BP_IPU_DI1_SW_GEN1_9_DI1_TAG_SEL_9      15
#define BM_IPU_DI1_SW_GEN1_9_DI1_TAG_SEL_9      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_9_DI1_TAG_SEL_9(v)   ((((reg32_t) v) << 15) & BM_IPU_DI1_SW_GEN1_9_DI1_TAG_SEL_9)
#else
#define BF_IPU_DI1_SW_GEN1_9_DI1_TAG_SEL_9(v)   (((v) << 15) & BM_IPU_DI1_SW_GEN1_9_DI1_TAG_SEL_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_TAG_SEL_9 field to a new value.
#define BW_IPU_DI1_SW_GEN1_9_DI1_TAG_SEL_9(v)   BF_CS1(IPU_DI1_SW_GEN1_9, DI1_TAG_SEL_9, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_9, field DI1_CNT_DOWN_9 (RW)
 *
 * Counter falling edge position This parameter contains an integer part (bits 24:17) and a
 * fractional part (bit 16). The position value is the amount of cycles between the trigger's start
 * point and the waveform's falling edge.
 */

#define BP_IPU_DI1_SW_GEN1_9_DI1_CNT_DOWN_9      16
#define BM_IPU_DI1_SW_GEN1_9_DI1_CNT_DOWN_9      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_9_DI1_CNT_DOWN_9(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SW_GEN1_9_DI1_CNT_DOWN_9)
#else
#define BF_IPU_DI1_SW_GEN1_9_DI1_CNT_DOWN_9(v)   (((v) << 16) & BM_IPU_DI1_SW_GEN1_9_DI1_CNT_DOWN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_DOWN_9 field to a new value.
#define BW_IPU_DI1_SW_GEN1_9_DI1_CNT_DOWN_9(v)   BF_CS1(IPU_DI1_SW_GEN1_9, DI1_CNT_DOWN_9, v)
#endif

/* --- Register HW_IPU_DI1_SW_GEN1_9, field DI1_CNT_CLR_SEL_9 (RW)
 *
 * Counter Clear select This field defines the source of the signals that clears the counter.
 *
 * Values:
 * 000 - Counter is disabled
 * 001 - The counter is triggered by the same trigger that triggers the displays clock.
 * 010 - The Counter is triggered by counter #1
 * 011 - The Counter is triggered by counter #2
 * 100 - The Counter is triggered by counter #3
 * 101 - The Counter is triggered by counter #4
 * 110 - The Counter is triggered by counter #5
 * 111 - Counter is always on.
 */

#define BP_IPU_DI1_SW_GEN1_9_DI1_CNT_CLR_SEL_9      25
#define BM_IPU_DI1_SW_GEN1_9_DI1_CNT_CLR_SEL_9      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_9_DI1_CNT_CLR_SEL_9(v)   ((((reg32_t) v) << 25) & BM_IPU_DI1_SW_GEN1_9_DI1_CNT_CLR_SEL_9)
#else
#define BF_IPU_DI1_SW_GEN1_9_DI1_CNT_CLR_SEL_9(v)   (((v) << 25) & BM_IPU_DI1_SW_GEN1_9_DI1_CNT_CLR_SEL_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_CLR_SEL_9 field to a new value.
#define BW_IPU_DI1_SW_GEN1_9_DI1_CNT_CLR_SEL_9(v)   BF_CS1(IPU_DI1_SW_GEN1_9, DI1_CNT_CLR_SEL_9, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_9, field DI1_CNT_AUTO_RELOAD_9 (RW)
 *
 * Counter auto reload mode
 *
 * Values:
 * 1 - The counter will automatically be reloaded forever, ignoring the value of the di1_step_repeat_<i>
 *     field
 * 0 - The counter will not be automatically reloaded, It will be reloaded for the amount of repeat times
 *     defined on the di1_step_repeat_<i> field
 */

#define BP_IPU_DI1_SW_GEN1_9_DI1_CNT_AUTO_RELOAD_9      28
#define BM_IPU_DI1_SW_GEN1_9_DI1_CNT_AUTO_RELOAD_9      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_9_DI1_CNT_AUTO_RELOAD_9(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_SW_GEN1_9_DI1_CNT_AUTO_RELOAD_9)
#else
#define BF_IPU_DI1_SW_GEN1_9_DI1_CNT_AUTO_RELOAD_9(v)   (((v) << 28) & BM_IPU_DI1_SW_GEN1_9_DI1_CNT_AUTO_RELOAD_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CNT_AUTO_RELOAD_9 field to a new value.
#define BW_IPU_DI1_SW_GEN1_9_DI1_CNT_AUTO_RELOAD_9(v)   BF_CS1(IPU_DI1_SW_GEN1_9, DI1_CNT_AUTO_RELOAD_9, v)
#endif


/* --- Register HW_IPU_DI1_SW_GEN1_9, field DI1_GENTIME_SEL_9 (RW)
 *
 * Counter #9 main waveform select This field defines the counter that counter #9's auxiliary
 * waveform will be attached too.
 *
 * Values:
 * 000 - Counter #9's waveform is attached to counter #1's waveform
 * 001 - Counter #9's waveform is attached to counter #2's waveform
 * 010 - Counter #9's waveform is attached to counter #3's waveform
 * 011 - Counter #9's waveform is attached to counter #4's waveform
 * 100 - Counter #9's waveform is attached to counter #5's waveform
 * 101 - Counter #9's waveform is attached to counter #6's waveform
 * 110 - Counter #9's waveform is attached to counter #7's waveform
 * 111 - Counter #9's waveform is attached to counter #8's waveform
 */

#define BP_IPU_DI1_SW_GEN1_9_DI1_GENTIME_SEL_9      29
#define BM_IPU_DI1_SW_GEN1_9_DI1_GENTIME_SEL_9      0xe0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SW_GEN1_9_DI1_GENTIME_SEL_9(v)   ((((reg32_t) v) << 29) & BM_IPU_DI1_SW_GEN1_9_DI1_GENTIME_SEL_9)
#else
#define BF_IPU_DI1_SW_GEN1_9_DI1_GENTIME_SEL_9(v)   (((v) << 29) & BM_IPU_DI1_SW_GEN1_9_DI1_GENTIME_SEL_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_GENTIME_SEL_9 field to a new value.
#define BW_IPU_DI1_SW_GEN1_9_DI1_GENTIME_SEL_9(v)   BF_CS1(IPU_DI1_SW_GEN1_9, DI1_GENTIME_SEL_9, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SYNC_AS_GEN - DI1 Sync Assistance Gen Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_SYNC_START : 12; //!< DI1 Sync start This field defines the number of low (including blanking rows) on the which the DI1 starts preparing the data for the next frame.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned DI1_VSYNC_SEL : 3; //!< VSYNC select This field defines which of the counters functions as VSYNC signal
        unsigned RESERVED1 : 12; //!< Reserved.
        unsigned DI1_SYNC_START_EN : 1; //!< di1_sync_start_en
        unsigned RESERVED2 : 3; //!< Reserve
    } B;
} hw_ipu_di1_sync_as_gen_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SYNC_AS_GEN register
 */
#define HW_IPU_DI1_SYNC_AS_GEN_ADDR(x)      (REGS_IPU_BASE(x) + 0x48054)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SYNC_AS_GEN(x)           (*(volatile hw_ipu_di1_sync_as_gen_t *) HW_IPU_DI1_SYNC_AS_GEN_ADDR(x))
#define HW_IPU_DI1_SYNC_AS_GEN_RD(x)        (HW_IPU_DI1_SYNC_AS_GEN(x).U)
#define HW_IPU_DI1_SYNC_AS_GEN_WR(x, v)     (HW_IPU_DI1_SYNC_AS_GEN(x).U = (v))
#define HW_IPU_DI1_SYNC_AS_GEN_SET(x, v)    (HW_IPU_DI1_SYNC_AS_GEN_WR(x, HW_IPU_DI1_SYNC_AS_GEN_RD(x) |  (v)))
#define HW_IPU_DI1_SYNC_AS_GEN_CLR(x, v)    (HW_IPU_DI1_SYNC_AS_GEN_WR(x, HW_IPU_DI1_SYNC_AS_GEN_RD(x) & ~(v)))
#define HW_IPU_DI1_SYNC_AS_GEN_TOG(x, v)    (HW_IPU_DI1_SYNC_AS_GEN_WR(x, HW_IPU_DI1_SYNC_AS_GEN_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SYNC_AS_GEN bitfields
 */

/* --- Register HW_IPU_DI1_SYNC_AS_GEN, field DI1_SYNC_START (RW)
 *
 * DI1 Sync start This field defines the number of low (including blanking rows) on the which the
 * DI1 starts preparing the data for the next frame.
 */

#define BP_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START      0
#define BM_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START)
#else
#define BF_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START(v)   (((v) << 0) & BM_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SYNC_START field to a new value.
#define BW_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START(v)   BF_CS1(IPU_DI1_SYNC_AS_GEN, DI1_SYNC_START, v)
#endif

/* --- Register HW_IPU_DI1_SYNC_AS_GEN, field DI1_VSYNC_SEL (RW)
 *
 * VSYNC select This field defines which of the counters functions as VSYNC signal
 *
 * Values:
 * 000 - VSYNC is coming from counter #1
 * 001 - VSYNC is coming from counter #2
 * 111 - VSYNC is coming from counter #8
 */

#define BP_IPU_DI1_SYNC_AS_GEN_DI1_VSYNC_SEL      13
#define BM_IPU_DI1_SYNC_AS_GEN_DI1_VSYNC_SEL      0x0000e000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SYNC_AS_GEN_DI1_VSYNC_SEL(v)   ((((reg32_t) v) << 13) & BM_IPU_DI1_SYNC_AS_GEN_DI1_VSYNC_SEL)
#else
#define BF_IPU_DI1_SYNC_AS_GEN_DI1_VSYNC_SEL(v)   (((v) << 13) & BM_IPU_DI1_SYNC_AS_GEN_DI1_VSYNC_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_VSYNC_SEL field to a new value.
#define BW_IPU_DI1_SYNC_AS_GEN_DI1_VSYNC_SEL(v)   BF_CS1(IPU_DI1_SYNC_AS_GEN, DI1_VSYNC_SEL, v)
#endif


/* --- Register HW_IPU_DI1_SYNC_AS_GEN, field DI1_SYNC_START_EN (RW)
 *
 * di1_sync_start_en
 */

#define BP_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START_EN      28
#define BM_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START_EN      0x10000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START_EN(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START_EN)
#else
#define BF_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START_EN(v)   (((v) << 28) & BM_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SYNC_START_EN field to a new value.
#define BW_IPU_DI1_SYNC_AS_GEN_DI1_SYNC_START_EN(v)   BF_CS1(IPU_DI1_SYNC_AS_GEN, DI1_SYNC_START_EN, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_DW_GEN_I - DI1 Data Wave Gen <i> Register (RW)
 *
 * The DI1_DW_GEN_<i> register holds pointers for the waveform generators.  These registers have
 * different bit arrangements for parallel and serial display. When using a parallel display VDI
 * Plane Size Register 4 is applicable. When using a serial interface VDI Plane Size Register 4 is
 * applicable.   Register Field Descriptions for Serial display       Field  Description      31-24
 * di1_serial_period_<i>  DI1 Serial Period <i> This field defines the period of the time base
 * serial display clock. The units are the internal DI clock    23-16 di1_start_period_<i>  DI1
 * start period This field defines the amount of cycles between the point where the access is ready
 * to be launched to the actual point where the time base serial display clock restarts. The units
 * are the internal DI clock.    15-14 di1_cst_<i>  DI1 Chip Select pointer for waveform <i> This
 * field points to a register that defines the waveform of the CS pin. For serial displays the down
 * value as defined on DI1_DW_SET*_<i> is measured from the assertion of the last serial display
 * time base clock. 00 The waveform is defined according to the settings on DI1_DW_SET0_<i> 01 The
 * waveform is defined according to the settings on DI1_DW_SET1_<i> 10 The waveform is defined
 * according to the settings on DI1_DW_SET2_<i> 11 The waveform is defined according to the settings
 * on DI1_DW_SET3_<i>    13-9  Reserved    8-4 di1_serial_valid_bits_<i>  DI1 Serial valid bits.
 * This field defines the amount of valid bits to be transmitted within the 32 bits internal word
 * aligned to bit[0]. The actual amount of valid bits is di1_serial_valid_bits_<i> + 1    3-2
 * di1_serial_rs_<i>  DI1 Serial RS This field points to a register that defines the waveform of the
 * RS pin. For serial displays the down value as defined on DI1_DW_SET*_<i> is measured from the
 * assertion of the last serial display time base clock. 00 The waveform is defined according to the
 * settings on DI1_DW_SET0_<i> 01 The waveform is defined according to the settings on
 * DI1_DW_SET1_<i> 10 The waveform is defined according to the settings on DI1_DW_SET2_<i> 11 The
 * waveform is defined according to the settings on DI1_DW_SET3_<i>    1-0 di1_serial_clk_<i>  DI1
 * serial clock<i> This field points to a register that defines the waveform of the Serial clock
 * pin. 00 The waveform is defined according to the settings on DI1_DW_SET0_<i> 01 The waveform is
 * defined according to the settings on DI1_DW_SET1_<i> 10 The waveform is defined according to the
 * settings on DI1_DW_SET2_<i> 11 The waveform is defined according to the settings on
 * DI1_DW_SET3_<i>
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_PT_0_ : 2; //!< DI1 PIN_11 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_11 pin.
        unsigned DI1_PT_1_ : 2; //!< DI1 PIN_12 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_12 pin.
        unsigned DI1_PT_2_ : 2; //!< DI1 PIN_13 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_13 pin.
        unsigned DI1_PT_3_ : 2; //!< DI1 PIN_14 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_14 pin.
        unsigned DI1_PT_4_ : 2; //!< DI1 PIN_15 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_15 pin.
        unsigned DI1_PT_5_ : 2; //!< DI1 PIN_16 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_16 pin.
        unsigned DI1_PT_6_ : 2; //!< DI1 PIN_17 pointer for waveform <i> This field points to a register that defines the waveform of the PIN_17 pin.
        unsigned DI1_CST_ : 2; //!< DI1 Chip Select pointer for waveform <i> This field points to a register that defines the waveform of the CS pin. The CS is automatically mapped to a specific display
        unsigned DI1_COMPONNENT_SIZE_ : 8; //!< DI1 component Size This field defines the amount of IPU cycles between any 2 components
        unsigned DI1_ACCESS_SIZE_ : 8; //!< DI1 Access Size <i> This field defines the amount of IPU cycles between any 2 accesses (an access may be a pixel or generic data that may have more one component)
    } B;
} hw_ipu_di1_dw_gen_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_DW_GEN_I register
 */
#define HW_IPU_DI1_DW_GEN_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x48058)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_DW_GEN_I(x)           (*(volatile hw_ipu_di1_dw_gen_i_t *) HW_IPU_DI1_DW_GEN_I_ADDR(x))
#define HW_IPU_DI1_DW_GEN_I_RD(x)        (HW_IPU_DI1_DW_GEN_I(x).U)
#define HW_IPU_DI1_DW_GEN_I_WR(x, v)     (HW_IPU_DI1_DW_GEN_I(x).U = (v))
#define HW_IPU_DI1_DW_GEN_I_SET(x, v)    (HW_IPU_DI1_DW_GEN_I_WR(x, HW_IPU_DI1_DW_GEN_I_RD(x) |  (v)))
#define HW_IPU_DI1_DW_GEN_I_CLR(x, v)    (HW_IPU_DI1_DW_GEN_I_WR(x, HW_IPU_DI1_DW_GEN_I_RD(x) & ~(v)))
#define HW_IPU_DI1_DW_GEN_I_TOG(x, v)    (HW_IPU_DI1_DW_GEN_I_WR(x, HW_IPU_DI1_DW_GEN_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_DW_GEN_I bitfields
 */

/* --- Register HW_IPU_DI1_DW_GEN_I, field DI1_PT_0_ (RW)
 *
 * DI1 PIN_11 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_11 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI1_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI1_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI1_DW_SET2_<i>
 * 11 - - The waveform is defined according to the settings on DI1_DW_SET3_<i>
 */

#define BP_IPU_DI1_DW_GEN_I_DI1_PT_0_      0
#define BM_IPU_DI1_DW_GEN_I_DI1_PT_0_      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_0_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_DW_GEN_I_DI1_PT_0_)
#else
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_0_(v)   (((v) << 0) & BM_IPU_DI1_DW_GEN_I_DI1_PT_0_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PT_0_ field to a new value.
#define BW_IPU_DI1_DW_GEN_I_DI1_PT_0_(v)   BF_CS1(IPU_DI1_DW_GEN_I, DI1_PT_0_, v)
#endif


/* --- Register HW_IPU_DI1_DW_GEN_I, field DI1_PT_1_ (RW)
 *
 * DI1 PIN_12 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_12 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI1_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI1_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI1_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI1_DW_SET3_<i>
 */

#define BP_IPU_DI1_DW_GEN_I_DI1_PT_1_      2
#define BM_IPU_DI1_DW_GEN_I_DI1_PT_1_      0x0000000c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_1_(v)   ((((reg32_t) v) << 2) & BM_IPU_DI1_DW_GEN_I_DI1_PT_1_)
#else
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_1_(v)   (((v) << 2) & BM_IPU_DI1_DW_GEN_I_DI1_PT_1_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PT_1_ field to a new value.
#define BW_IPU_DI1_DW_GEN_I_DI1_PT_1_(v)   BF_CS1(IPU_DI1_DW_GEN_I, DI1_PT_1_, v)
#endif


/* --- Register HW_IPU_DI1_DW_GEN_I, field DI1_PT_2_ (RW)
 *
 * DI1 PIN_13 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_13 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI1_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI1_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI1_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI1_DW_SET3_<i>
 */

#define BP_IPU_DI1_DW_GEN_I_DI1_PT_2_      4
#define BM_IPU_DI1_DW_GEN_I_DI1_PT_2_      0x00000030

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_2_(v)   ((((reg32_t) v) << 4) & BM_IPU_DI1_DW_GEN_I_DI1_PT_2_)
#else
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_2_(v)   (((v) << 4) & BM_IPU_DI1_DW_GEN_I_DI1_PT_2_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PT_2_ field to a new value.
#define BW_IPU_DI1_DW_GEN_I_DI1_PT_2_(v)   BF_CS1(IPU_DI1_DW_GEN_I, DI1_PT_2_, v)
#endif


/* --- Register HW_IPU_DI1_DW_GEN_I, field DI1_PT_3_ (RW)
 *
 * DI1 PIN_14 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_14 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI1_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI1_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI1_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI1_DW_SET3_<i>
 */

#define BP_IPU_DI1_DW_GEN_I_DI1_PT_3_      6
#define BM_IPU_DI1_DW_GEN_I_DI1_PT_3_      0x000000c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_3_(v)   ((((reg32_t) v) << 6) & BM_IPU_DI1_DW_GEN_I_DI1_PT_3_)
#else
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_3_(v)   (((v) << 6) & BM_IPU_DI1_DW_GEN_I_DI1_PT_3_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PT_3_ field to a new value.
#define BW_IPU_DI1_DW_GEN_I_DI1_PT_3_(v)   BF_CS1(IPU_DI1_DW_GEN_I, DI1_PT_3_, v)
#endif


/* --- Register HW_IPU_DI1_DW_GEN_I, field DI1_PT_4_ (RW)
 *
 * DI1 PIN_15 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_15 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI1_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI1_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI1_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI1_DW_SET3_<i>
 */

#define BP_IPU_DI1_DW_GEN_I_DI1_PT_4_      8
#define BM_IPU_DI1_DW_GEN_I_DI1_PT_4_      0x00000300

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_4_(v)   ((((reg32_t) v) << 8) & BM_IPU_DI1_DW_GEN_I_DI1_PT_4_)
#else
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_4_(v)   (((v) << 8) & BM_IPU_DI1_DW_GEN_I_DI1_PT_4_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PT_4_ field to a new value.
#define BW_IPU_DI1_DW_GEN_I_DI1_PT_4_(v)   BF_CS1(IPU_DI1_DW_GEN_I, DI1_PT_4_, v)
#endif


/* --- Register HW_IPU_DI1_DW_GEN_I, field DI1_PT_5_ (RW)
 *
 * DI1 PIN_16 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_16 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI1_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI1_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI1_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI1_DW_SET3_<i>
 */

#define BP_IPU_DI1_DW_GEN_I_DI1_PT_5_      10
#define BM_IPU_DI1_DW_GEN_I_DI1_PT_5_      0x00000c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_5_(v)   ((((reg32_t) v) << 10) & BM_IPU_DI1_DW_GEN_I_DI1_PT_5_)
#else
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_5_(v)   (((v) << 10) & BM_IPU_DI1_DW_GEN_I_DI1_PT_5_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PT_5_ field to a new value.
#define BW_IPU_DI1_DW_GEN_I_DI1_PT_5_(v)   BF_CS1(IPU_DI1_DW_GEN_I, DI1_PT_5_, v)
#endif


/* --- Register HW_IPU_DI1_DW_GEN_I, field DI1_PT_6_ (RW)
 *
 * DI1 PIN_17 pointer for waveform <i> This field points to a register that defines the waveform of
 * the PIN_17 pin.
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI1_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI1_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI1_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI1_DW_SET3_<i>
 */

#define BP_IPU_DI1_DW_GEN_I_DI1_PT_6_      12
#define BM_IPU_DI1_DW_GEN_I_DI1_PT_6_      0x00003000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_6_(v)   ((((reg32_t) v) << 12) & BM_IPU_DI1_DW_GEN_I_DI1_PT_6_)
#else
#define BF_IPU_DI1_DW_GEN_I_DI1_PT_6_(v)   (((v) << 12) & BM_IPU_DI1_DW_GEN_I_DI1_PT_6_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PT_6_ field to a new value.
#define BW_IPU_DI1_DW_GEN_I_DI1_PT_6_(v)   BF_CS1(IPU_DI1_DW_GEN_I, DI1_PT_6_, v)
#endif


/* --- Register HW_IPU_DI1_DW_GEN_I, field DI1_CST_ (RW)
 *
 * DI1 Chip Select pointer for waveform <i> This field points to a register that defines the
 * waveform of the CS pin. The CS is automatically mapped to a specific display
 *
 * Values:
 * 00 - The waveform is defined according to the settings on DI1_DW_SET0_<i>
 * 01 - The waveform is defined according to the settings on DI1_DW_SET1_<i>
 * 10 - The waveform is defined according to the settings on DI1_DW_SET2_<i>
 * 11 - The waveform is defined according to the settings on DI1_DW_SET3_<i>
 */

#define BP_IPU_DI1_DW_GEN_I_DI1_CST_      14
#define BM_IPU_DI1_DW_GEN_I_DI1_CST_      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_GEN_I_DI1_CST_(v)   ((((reg32_t) v) << 14) & BM_IPU_DI1_DW_GEN_I_DI1_CST_)
#else
#define BF_IPU_DI1_DW_GEN_I_DI1_CST_(v)   (((v) << 14) & BM_IPU_DI1_DW_GEN_I_DI1_CST_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CST_ field to a new value.
#define BW_IPU_DI1_DW_GEN_I_DI1_CST_(v)   BF_CS1(IPU_DI1_DW_GEN_I, DI1_CST_, v)
#endif


/* --- Register HW_IPU_DI1_DW_GEN_I, field DI1_COMPONNENT_SIZE_ (RW)
 *
 * DI1 component Size This field defines the amount of IPU cycles between any 2 components
 */

#define BP_IPU_DI1_DW_GEN_I_DI1_COMPONNENT_SIZE_      16
#define BM_IPU_DI1_DW_GEN_I_DI1_COMPONNENT_SIZE_      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_GEN_I_DI1_COMPONNENT_SIZE_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_DW_GEN_I_DI1_COMPONNENT_SIZE_)
#else
#define BF_IPU_DI1_DW_GEN_I_DI1_COMPONNENT_SIZE_(v)   (((v) << 16) & BM_IPU_DI1_DW_GEN_I_DI1_COMPONNENT_SIZE_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_COMPONNENT_SIZE_ field to a new value.
#define BW_IPU_DI1_DW_GEN_I_DI1_COMPONNENT_SIZE_(v)   BF_CS1(IPU_DI1_DW_GEN_I, DI1_COMPONNENT_SIZE_, v)
#endif

/* --- Register HW_IPU_DI1_DW_GEN_I, field DI1_ACCESS_SIZE_ (RW)
 *
 * DI1 Access Size <i> This field defines the amount of IPU cycles between any 2 accesses (an access
 * may be a pixel or generic data that may have more one component)
 */

#define BP_IPU_DI1_DW_GEN_I_DI1_ACCESS_SIZE_      24
#define BM_IPU_DI1_DW_GEN_I_DI1_ACCESS_SIZE_      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_GEN_I_DI1_ACCESS_SIZE_(v)   ((((reg32_t) v) << 24) & BM_IPU_DI1_DW_GEN_I_DI1_ACCESS_SIZE_)
#else
#define BF_IPU_DI1_DW_GEN_I_DI1_ACCESS_SIZE_(v)   (((v) << 24) & BM_IPU_DI1_DW_GEN_I_DI1_ACCESS_SIZE_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_ACCESS_SIZE_ field to a new value.
#define BW_IPU_DI1_DW_GEN_I_DI1_ACCESS_SIZE_(v)   BF_CS1(IPU_DI1_DW_GEN_I, DI1_ACCESS_SIZE_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_DW_SET0_I - DI1 Data Wave Set 0 <i> Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_DATA_CNT_UP0_ : 9; //!< Waveform's rising edge position. This field defines the Waveform's rising edge position. The Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DI1_DATA_CNT_DOWN0_ : 9; //!< Waveform's falling edge position. This field defines the Waveform's falling edge position. The Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_di1_dw_set0_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_DW_SET0_I register
 */
#define HW_IPU_DI1_DW_SET0_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x48088)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_DW_SET0_I(x)           (*(volatile hw_ipu_di1_dw_set0_i_t *) HW_IPU_DI1_DW_SET0_I_ADDR(x))
#define HW_IPU_DI1_DW_SET0_I_RD(x)        (HW_IPU_DI1_DW_SET0_I(x).U)
#define HW_IPU_DI1_DW_SET0_I_WR(x, v)     (HW_IPU_DI1_DW_SET0_I(x).U = (v))
#define HW_IPU_DI1_DW_SET0_I_SET(x, v)    (HW_IPU_DI1_DW_SET0_I_WR(x, HW_IPU_DI1_DW_SET0_I_RD(x) |  (v)))
#define HW_IPU_DI1_DW_SET0_I_CLR(x, v)    (HW_IPU_DI1_DW_SET0_I_WR(x, HW_IPU_DI1_DW_SET0_I_RD(x) & ~(v)))
#define HW_IPU_DI1_DW_SET0_I_TOG(x, v)    (HW_IPU_DI1_DW_SET0_I_WR(x, HW_IPU_DI1_DW_SET0_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_DW_SET0_I bitfields
 */

/* --- Register HW_IPU_DI1_DW_SET0_I, field DI1_DATA_CNT_UP0_ (RW)
 *
 * Waveform's rising edge position. This field defines the Waveform's rising edge position. The
 * Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
 */

#define BP_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_UP0_      0
#define BM_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_UP0_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_UP0_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_UP0_)
#else
#define BF_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_UP0_(v)   (((v) << 0) & BM_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_UP0_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DATA_CNT_UP0_ field to a new value.
#define BW_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_UP0_(v)   BF_CS1(IPU_DI1_DW_SET0_I, DI1_DATA_CNT_UP0_, v)
#endif

/* --- Register HW_IPU_DI1_DW_SET0_I, field DI1_DATA_CNT_DOWN0_ (RW)
 *
 * Waveform's falling edge position. This field defines the Waveform's falling edge position. The
 * Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
 */

#define BP_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_DOWN0_      16
#define BM_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_DOWN0_      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_DOWN0_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_DOWN0_)
#else
#define BF_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_DOWN0_(v)   (((v) << 16) & BM_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_DOWN0_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DATA_CNT_DOWN0_ field to a new value.
#define BW_IPU_DI1_DW_SET0_I_DI1_DATA_CNT_DOWN0_(v)   BF_CS1(IPU_DI1_DW_SET0_I, DI1_DATA_CNT_DOWN0_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_DW_SET1_I - DI1 Data Wave Set 1 <i> Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_DATA_CNT_UP1_ : 9; //!< Waveform's rising edge position. This field defines the Waveform's rising edge position. The Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DI1_DATA_CNT_DOWN1_ : 9; //!< Waveform's falling edge position. This field defines the Waveform's falling edge position. The Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_di1_dw_set1_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_DW_SET1_I register
 */
#define HW_IPU_DI1_DW_SET1_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x480b8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_DW_SET1_I(x)           (*(volatile hw_ipu_di1_dw_set1_i_t *) HW_IPU_DI1_DW_SET1_I_ADDR(x))
#define HW_IPU_DI1_DW_SET1_I_RD(x)        (HW_IPU_DI1_DW_SET1_I(x).U)
#define HW_IPU_DI1_DW_SET1_I_WR(x, v)     (HW_IPU_DI1_DW_SET1_I(x).U = (v))
#define HW_IPU_DI1_DW_SET1_I_SET(x, v)    (HW_IPU_DI1_DW_SET1_I_WR(x, HW_IPU_DI1_DW_SET1_I_RD(x) |  (v)))
#define HW_IPU_DI1_DW_SET1_I_CLR(x, v)    (HW_IPU_DI1_DW_SET1_I_WR(x, HW_IPU_DI1_DW_SET1_I_RD(x) & ~(v)))
#define HW_IPU_DI1_DW_SET1_I_TOG(x, v)    (HW_IPU_DI1_DW_SET1_I_WR(x, HW_IPU_DI1_DW_SET1_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_DW_SET1_I bitfields
 */

/* --- Register HW_IPU_DI1_DW_SET1_I, field DI1_DATA_CNT_UP1_ (RW)
 *
 * Waveform's rising edge position. This field defines the Waveform's rising edge position. The
 * Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
 */

#define BP_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_UP1_      0
#define BM_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_UP1_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_UP1_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_UP1_)
#else
#define BF_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_UP1_(v)   (((v) << 0) & BM_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_UP1_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DATA_CNT_UP1_ field to a new value.
#define BW_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_UP1_(v)   BF_CS1(IPU_DI1_DW_SET1_I, DI1_DATA_CNT_UP1_, v)
#endif

/* --- Register HW_IPU_DI1_DW_SET1_I, field DI1_DATA_CNT_DOWN1_ (RW)
 *
 * Waveform's falling edge position. This field defines the Waveform's falling edge position. The
 * Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
 */

#define BP_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_DOWN1_      16
#define BM_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_DOWN1_      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_DOWN1_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_DOWN1_)
#else
#define BF_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_DOWN1_(v)   (((v) << 16) & BM_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_DOWN1_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DATA_CNT_DOWN1_ field to a new value.
#define BW_IPU_DI1_DW_SET1_I_DI1_DATA_CNT_DOWN1_(v)   BF_CS1(IPU_DI1_DW_SET1_I, DI1_DATA_CNT_DOWN1_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_DW_SET2_I - DI1 Data Wave Set 2 <i> Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_DATA_CNT_UP2_ : 9; //!< Waveform's rising edge position. This field defines the Waveform's rising edge position. The Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DI1_DATA_CNT_DOWN2_ : 9; //!< Waveform's falling edge position. This field defines the Waveform's falling edge position. The Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_di1_dw_set2_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_DW_SET2_I register
 */
#define HW_IPU_DI1_DW_SET2_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x480e8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_DW_SET2_I(x)           (*(volatile hw_ipu_di1_dw_set2_i_t *) HW_IPU_DI1_DW_SET2_I_ADDR(x))
#define HW_IPU_DI1_DW_SET2_I_RD(x)        (HW_IPU_DI1_DW_SET2_I(x).U)
#define HW_IPU_DI1_DW_SET2_I_WR(x, v)     (HW_IPU_DI1_DW_SET2_I(x).U = (v))
#define HW_IPU_DI1_DW_SET2_I_SET(x, v)    (HW_IPU_DI1_DW_SET2_I_WR(x, HW_IPU_DI1_DW_SET2_I_RD(x) |  (v)))
#define HW_IPU_DI1_DW_SET2_I_CLR(x, v)    (HW_IPU_DI1_DW_SET2_I_WR(x, HW_IPU_DI1_DW_SET2_I_RD(x) & ~(v)))
#define HW_IPU_DI1_DW_SET2_I_TOG(x, v)    (HW_IPU_DI1_DW_SET2_I_WR(x, HW_IPU_DI1_DW_SET2_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_DW_SET2_I bitfields
 */

/* --- Register HW_IPU_DI1_DW_SET2_I, field DI1_DATA_CNT_UP2_ (RW)
 *
 * Waveform's rising edge position. This field defines the Waveform's rising edge position. The
 * Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
 */

#define BP_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_UP2_      0
#define BM_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_UP2_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_UP2_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_UP2_)
#else
#define BF_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_UP2_(v)   (((v) << 0) & BM_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_UP2_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DATA_CNT_UP2_ field to a new value.
#define BW_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_UP2_(v)   BF_CS1(IPU_DI1_DW_SET2_I, DI1_DATA_CNT_UP2_, v)
#endif

/* --- Register HW_IPU_DI1_DW_SET2_I, field DI1_DATA_CNT_DOWN2_ (RW)
 *
 * Waveform's falling edge position. This field defines the Waveform's falling edge position. The
 * Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
 */

#define BP_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_DOWN2_      16
#define BM_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_DOWN2_      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_DOWN2_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_DOWN2_)
#else
#define BF_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_DOWN2_(v)   (((v) << 16) & BM_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_DOWN2_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DATA_CNT_DOWN2_ field to a new value.
#define BW_IPU_DI1_DW_SET2_I_DI1_DATA_CNT_DOWN2_(v)   BF_CS1(IPU_DI1_DW_SET2_I, DI1_DATA_CNT_DOWN2_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_DW_SET3_I - DI1 Data Wave Set 3 <i> Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_DATA_CNT_UP3_ : 9; //!< Waveform's rising edge position. This field defines the Waveform's rising edge position. The Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DI1_DATA_CNT_DOWN3_ : 9; //!< Waveform's falling edge position. This field defines the Waveform's falling edge position. The Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_di1_dw_set3_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_DW_SET3_I register
 */
#define HW_IPU_DI1_DW_SET3_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x48118)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_DW_SET3_I(x)           (*(volatile hw_ipu_di1_dw_set3_i_t *) HW_IPU_DI1_DW_SET3_I_ADDR(x))
#define HW_IPU_DI1_DW_SET3_I_RD(x)        (HW_IPU_DI1_DW_SET3_I(x).U)
#define HW_IPU_DI1_DW_SET3_I_WR(x, v)     (HW_IPU_DI1_DW_SET3_I(x).U = (v))
#define HW_IPU_DI1_DW_SET3_I_SET(x, v)    (HW_IPU_DI1_DW_SET3_I_WR(x, HW_IPU_DI1_DW_SET3_I_RD(x) |  (v)))
#define HW_IPU_DI1_DW_SET3_I_CLR(x, v)    (HW_IPU_DI1_DW_SET3_I_WR(x, HW_IPU_DI1_DW_SET3_I_RD(x) & ~(v)))
#define HW_IPU_DI1_DW_SET3_I_TOG(x, v)    (HW_IPU_DI1_DW_SET3_I_WR(x, HW_IPU_DI1_DW_SET3_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_DW_SET3_I bitfields
 */

/* --- Register HW_IPU_DI1_DW_SET3_I, field DI1_DATA_CNT_UP3_ (RW)
 *
 * Waveform's rising edge position. This field defines the Waveform's rising edge position. The
 * Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
 */

#define BP_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_UP3_      0
#define BM_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_UP3_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_UP3_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_UP3_)
#else
#define BF_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_UP3_(v)   (((v) << 0) & BM_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_UP3_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DATA_CNT_UP3_ field to a new value.
#define BW_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_UP3_(v)   BF_CS1(IPU_DI1_DW_SET3_I, DI1_DATA_CNT_UP3_, v)
#endif

/* --- Register HW_IPU_DI1_DW_SET3_I, field DI1_DATA_CNT_DOWN3_ (RW)
 *
 * Waveform's falling edge position. This field defines the Waveform's falling edge position. The
 * Waveform is mapped to a pint according to the corresponding di1_pt_*_<i>
 */

#define BP_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_DOWN3_      16
#define BM_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_DOWN3_      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_DOWN3_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_DOWN3_)
#else
#define BF_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_DOWN3_(v)   (((v) << 16) & BM_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_DOWN3_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DATA_CNT_DOWN3_ field to a new value.
#define BW_IPU_DI1_DW_SET3_I_DI1_DATA_CNT_DOWN3_(v)   BF_CS1(IPU_DI1_DW_SET3_I, DI1_DATA_CNT_DOWN3_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_D1_STP_REP_I - DI1 Step Repeat <i> Registers (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_STEP_REPEAT_ : 12; //!< Step Repeat <i> This fields defines the amount of repetitions that will be performed by the counter <i>
        unsigned RESERVED0 : 4; //!< Reserved
        unsigned DI1_STEP_REPEAT_1 : 12; //!< Step Repeat <i> This fields defines the amount of repetitions that will be performed by the counter <i>
        unsigned RESERVED1 : 4; //!< Reserved
    } B;
} hw_ipu_d1_stp_rep_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_D1_STP_REP_I register
 */
#define HW_IPU_D1_STP_REP_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x48148)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_D1_STP_REP_I(x)           (*(volatile hw_ipu_d1_stp_rep_i_t *) HW_IPU_D1_STP_REP_I_ADDR(x))
#define HW_IPU_D1_STP_REP_I_RD(x)        (HW_IPU_D1_STP_REP_I(x).U)
#define HW_IPU_D1_STP_REP_I_WR(x, v)     (HW_IPU_D1_STP_REP_I(x).U = (v))
#define HW_IPU_D1_STP_REP_I_SET(x, v)    (HW_IPU_D1_STP_REP_I_WR(x, HW_IPU_D1_STP_REP_I_RD(x) |  (v)))
#define HW_IPU_D1_STP_REP_I_CLR(x, v)    (HW_IPU_D1_STP_REP_I_WR(x, HW_IPU_D1_STP_REP_I_RD(x) & ~(v)))
#define HW_IPU_D1_STP_REP_I_TOG(x, v)    (HW_IPU_D1_STP_REP_I_WR(x, HW_IPU_D1_STP_REP_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_D1_STP_REP_I bitfields
 */

/* --- Register HW_IPU_D1_STP_REP_I, field DI1_STEP_REPEAT_ (RW)
 *
 * Step Repeat <i> This fields defines the amount of repetitions that will be performed by the
 * counter <i>
 */

#define BP_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_      0
#define BM_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_(v)   ((((reg32_t) v) << 0) & BM_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_)
#else
#define BF_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_(v)   (((v) << 0) & BM_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_STEP_REPEAT_ field to a new value.
#define BW_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_(v)   BF_CS1(IPU_D1_STP_REP_I, DI1_STEP_REPEAT_, v)
#endif

/* --- Register HW_IPU_D1_STP_REP_I, field DI1_STEP_REPEAT_ (RW)
 *
 * Step Repeat <i> This fields defines the amount of repetitions that will be performed by the
 * counter <i>
 */

#define BP_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_      16
#define BM_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_(v)   ((((reg32_t) v) << 16) & BM_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_)
#else
#define BF_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_(v)   (((v) << 16) & BM_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_STEP_REPEAT_ field to a new value.
#define BW_IPU_D1_STP_REP_I_DI1_STEP_REPEAT_(v)   BF_CS1(IPU_D1_STP_REP_I, DI1_STEP_REPEAT_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_STP_REP_9 - DI1Step Repeat 9 Registers (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_STEP_REPEAT_9 : 12; //!< Step Repeat 9 This fields defines the amount of repetitions that will be performed by the counter 9.
        unsigned RESERVED0 : 20; //!< Reserved
    } B;
} hw_ipu_di1_stp_rep_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_STP_REP_9 register
 */
#define HW_IPU_DI1_STP_REP_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x48158)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_STP_REP_9(x)           (*(volatile hw_ipu_di1_stp_rep_9_t *) HW_IPU_DI1_STP_REP_9_ADDR(x))
#define HW_IPU_DI1_STP_REP_9_RD(x)        (HW_IPU_DI1_STP_REP_9(x).U)
#define HW_IPU_DI1_STP_REP_9_WR(x, v)     (HW_IPU_DI1_STP_REP_9(x).U = (v))
#define HW_IPU_DI1_STP_REP_9_SET(x, v)    (HW_IPU_DI1_STP_REP_9_WR(x, HW_IPU_DI1_STP_REP_9_RD(x) |  (v)))
#define HW_IPU_DI1_STP_REP_9_CLR(x, v)    (HW_IPU_DI1_STP_REP_9_WR(x, HW_IPU_DI1_STP_REP_9_RD(x) & ~(v)))
#define HW_IPU_DI1_STP_REP_9_TOG(x, v)    (HW_IPU_DI1_STP_REP_9_WR(x, HW_IPU_DI1_STP_REP_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_STP_REP_9 bitfields
 */

/* --- Register HW_IPU_DI1_STP_REP_9, field DI1_STEP_REPEAT_9 (RW)
 *
 * Step Repeat 9 This fields defines the amount of repetitions that will be performed by the counter
 * 9.
 */

#define BP_IPU_DI1_STP_REP_9_DI1_STEP_REPEAT_9      0
#define BM_IPU_DI1_STP_REP_9_DI1_STEP_REPEAT_9      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_STP_REP_9_DI1_STEP_REPEAT_9(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_STP_REP_9_DI1_STEP_REPEAT_9)
#else
#define BF_IPU_DI1_STP_REP_9_DI1_STEP_REPEAT_9(v)   (((v) << 0) & BM_IPU_DI1_STP_REP_9_DI1_STEP_REPEAT_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_STEP_REPEAT_9 field to a new value.
#define BW_IPU_DI1_STP_REP_9_DI1_STEP_REPEAT_9(v)   BF_CS1(IPU_DI1_STP_REP_9, DI1_STEP_REPEAT_9, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SER_CONF - DI1 Serial Display Control Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_WAIT4SERIAL : 1; //!< Wait for Serial When the parallel display share pins with the serial port. Accessing the parallel port is not allowed till the serial port completes its access.
        unsigned DI1_SERIAL_CS_POLARITY : 1; //!< Serial Chip Select Polarity The output polarity of the SER_CS pin
        unsigned DI1_SERIAL_RS_POLARITY : 1; //!< Serial RS Polarity The output polarity of the SER_RS pin
        unsigned DI1_SERIAL_DATA_POLARITY : 1; //!< Serial Data Polarity The output polarity of the SER_DATA pin
        unsigned DI1_SER_CLK_POLARITY : 1; //!< Serial Clock Polarity The output polarity of the SER_CLK pin
        unsigned DI1_LLA_SER_ACCESS : 1; //!< Direct Low Level Access to Serial display
        unsigned RESERVED0 : 2; //!< Reserved
        unsigned DI1_SERIAL_LATCH : 8; //!< DI1 Serial Latch This field defines how many cycles to insert between serial read accesses start to data sampling in the
        unsigned DI1_SERIAL_LLA_PNTR_RS_W_0 : 4; //!< RS 0 waveform pointer for write low level access This pointer defines which waveform set will be chosen when the write low level access is targeted to RS group 0.
        unsigned DI1_SERIAL_LLA_PNTR_RS_W_1 : 4; //!< RS 1 waveform pointer for write low level access This pointer defines which waveform set will be chosen when the write low level access is targeted to RS group 1.
        unsigned DI1_SERIAL_LLA_PNTR_RS_R_0 : 4; //!< RS 2 waveform pointer for low level access This pointer defines which waveform set will be chosen when the read low level access is targeted to RS group 0.
        unsigned DI1_SERIAL_LLA_PNTR_RS_R_1 : 4; //!< RS 3 waveform pointer for read low level access This pointer defines which waveform set will be chosen when the read low level access is targeted to RS group 1.
    } B;
} hw_ipu_di1_ser_conf_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SER_CONF register
 */
#define HW_IPU_DI1_SER_CONF_ADDR(x)      (REGS_IPU_BASE(x) + 0x4815c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SER_CONF(x)           (*(volatile hw_ipu_di1_ser_conf_t *) HW_IPU_DI1_SER_CONF_ADDR(x))
#define HW_IPU_DI1_SER_CONF_RD(x)        (HW_IPU_DI1_SER_CONF(x).U)
#define HW_IPU_DI1_SER_CONF_WR(x, v)     (HW_IPU_DI1_SER_CONF(x).U = (v))
#define HW_IPU_DI1_SER_CONF_SET(x, v)    (HW_IPU_DI1_SER_CONF_WR(x, HW_IPU_DI1_SER_CONF_RD(x) |  (v)))
#define HW_IPU_DI1_SER_CONF_CLR(x, v)    (HW_IPU_DI1_SER_CONF_WR(x, HW_IPU_DI1_SER_CONF_RD(x) & ~(v)))
#define HW_IPU_DI1_SER_CONF_TOG(x, v)    (HW_IPU_DI1_SER_CONF_WR(x, HW_IPU_DI1_SER_CONF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SER_CONF bitfields
 */

/* --- Register HW_IPU_DI1_SER_CONF, field DI1_WAIT4SERIAL (RW)
 *
 * Wait for Serial When the parallel display share pins with the serial port. Accessing the parallel
 * port is not allowed till the serial port completes its access.
 *
 * Values:
 * 1 - The parallel port should wait to the serial port as the pins are shared
 * 0 - The parallel port should not wait to the serial port as the pins are not shared
 */

#define BP_IPU_DI1_SER_CONF_DI1_WAIT4SERIAL      0
#define BM_IPU_DI1_SER_CONF_DI1_WAIT4SERIAL      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SER_CONF_DI1_WAIT4SERIAL(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SER_CONF_DI1_WAIT4SERIAL)
#else
#define BF_IPU_DI1_SER_CONF_DI1_WAIT4SERIAL(v)   (((v) << 0) & BM_IPU_DI1_SER_CONF_DI1_WAIT4SERIAL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_WAIT4SERIAL field to a new value.
#define BW_IPU_DI1_SER_CONF_DI1_WAIT4SERIAL(v)   BF_CS1(IPU_DI1_SER_CONF, DI1_WAIT4SERIAL, v)
#endif


/* --- Register HW_IPU_DI1_SER_CONF, field DI1_SERIAL_CS_POLARITY (RW)
 *
 * Serial Chip Select Polarity The output polarity of the SER_CS pin
 *
 * Values:
 * 1 - The CS is inverted
 * 0 - The CS is not inverted
 */

#define BP_IPU_DI1_SER_CONF_DI1_SERIAL_CS_POLARITY      1
#define BM_IPU_DI1_SER_CONF_DI1_SERIAL_CS_POLARITY      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_CS_POLARITY(v)   ((((reg32_t) v) << 1) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_CS_POLARITY)
#else
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_CS_POLARITY(v)   (((v) << 1) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_CS_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SERIAL_CS_POLARITY field to a new value.
#define BW_IPU_DI1_SER_CONF_DI1_SERIAL_CS_POLARITY(v)   BF_CS1(IPU_DI1_SER_CONF, DI1_SERIAL_CS_POLARITY, v)
#endif


/* --- Register HW_IPU_DI1_SER_CONF, field DI1_SERIAL_RS_POLARITY (RW)
 *
 * Serial RS Polarity The output polarity of the SER_RS pin
 *
 * Values:
 * 1 - The RS is inverted
 * 0 - The RS is not inverted
 */

#define BP_IPU_DI1_SER_CONF_DI1_SERIAL_RS_POLARITY      2
#define BM_IPU_DI1_SER_CONF_DI1_SERIAL_RS_POLARITY      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_RS_POLARITY(v)   ((((reg32_t) v) << 2) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_RS_POLARITY)
#else
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_RS_POLARITY(v)   (((v) << 2) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_RS_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SERIAL_RS_POLARITY field to a new value.
#define BW_IPU_DI1_SER_CONF_DI1_SERIAL_RS_POLARITY(v)   BF_CS1(IPU_DI1_SER_CONF, DI1_SERIAL_RS_POLARITY, v)
#endif


/* --- Register HW_IPU_DI1_SER_CONF, field DI1_SERIAL_DATA_POLARITY (RW)
 *
 * Serial Data Polarity The output polarity of the SER_DATA pin
 *
 * Values:
 * 1 - The data is inverted
 * 0 - The data is not inverted
 */

#define BP_IPU_DI1_SER_CONF_DI1_SERIAL_DATA_POLARITY      3
#define BM_IPU_DI1_SER_CONF_DI1_SERIAL_DATA_POLARITY      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_DATA_POLARITY(v)   ((((reg32_t) v) << 3) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_DATA_POLARITY)
#else
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_DATA_POLARITY(v)   (((v) << 3) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_DATA_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SERIAL_DATA_POLARITY field to a new value.
#define BW_IPU_DI1_SER_CONF_DI1_SERIAL_DATA_POLARITY(v)   BF_CS1(IPU_DI1_SER_CONF, DI1_SERIAL_DATA_POLARITY, v)
#endif


/* --- Register HW_IPU_DI1_SER_CONF, field DI1_SER_CLK_POLARITY (RW)
 *
 * Serial Clock Polarity The output polarity of the SER_CLK pin
 *
 * Values:
 * 1 - The clock is inverted
 * 0 - The clock is not inverted
 */

#define BP_IPU_DI1_SER_CONF_DI1_SER_CLK_POLARITY      4
#define BM_IPU_DI1_SER_CONF_DI1_SER_CLK_POLARITY      0x00000010

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SER_CONF_DI1_SER_CLK_POLARITY(v)   ((((reg32_t) v) << 4) & BM_IPU_DI1_SER_CONF_DI1_SER_CLK_POLARITY)
#else
#define BF_IPU_DI1_SER_CONF_DI1_SER_CLK_POLARITY(v)   (((v) << 4) & BM_IPU_DI1_SER_CONF_DI1_SER_CLK_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SER_CLK_POLARITY field to a new value.
#define BW_IPU_DI1_SER_CONF_DI1_SER_CLK_POLARITY(v)   BF_CS1(IPU_DI1_SER_CONF, DI1_SER_CLK_POLARITY, v)
#endif


/* --- Register HW_IPU_DI1_SER_CONF, field DI1_LLA_SER_ACCESS (RW)
 *
 * Direct Low Level Access to Serial display
 *
 * Values:
 * 1 - ARM platform access is performed via a direct path to the serial display in LLA mode, in this mode
 *     only the ARM platform in LLA mode can access the serial port
 * 0 - ARM platform access to the serial display port is not done directly, hence other source are allowed
 *     to access the serial port. The arbitration is done automatically
 */

#define BP_IPU_DI1_SER_CONF_DI1_LLA_SER_ACCESS      5
#define BM_IPU_DI1_SER_CONF_DI1_LLA_SER_ACCESS      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SER_CONF_DI1_LLA_SER_ACCESS(v)   ((((reg32_t) v) << 5) & BM_IPU_DI1_SER_CONF_DI1_LLA_SER_ACCESS)
#else
#define BF_IPU_DI1_SER_CONF_DI1_LLA_SER_ACCESS(v)   (((v) << 5) & BM_IPU_DI1_SER_CONF_DI1_LLA_SER_ACCESS)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_LLA_SER_ACCESS field to a new value.
#define BW_IPU_DI1_SER_CONF_DI1_LLA_SER_ACCESS(v)   BF_CS1(IPU_DI1_SER_CONF, DI1_LLA_SER_ACCESS, v)
#endif


/* --- Register HW_IPU_DI1_SER_CONF, field DI1_SERIAL_LATCH (RW)
 *
 * DI1 Serial Latch This field defines how many cycles to insert between serial read accesses start
 * to data sampling in the
 */

#define BP_IPU_DI1_SER_CONF_DI1_SERIAL_LATCH      8
#define BM_IPU_DI1_SER_CONF_DI1_SERIAL_LATCH      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_LATCH(v)   ((((reg32_t) v) << 8) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_LATCH)
#else
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_LATCH(v)   (((v) << 8) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_LATCH)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SERIAL_LATCH field to a new value.
#define BW_IPU_DI1_SER_CONF_DI1_SERIAL_LATCH(v)   BF_CS1(IPU_DI1_SER_CONF, DI1_SERIAL_LATCH, v)
#endif

/* --- Register HW_IPU_DI1_SER_CONF, field DI1_SERIAL_LLA_PNTR_RS_W_0 (RW)
 *
 * RS 0 waveform pointer for write low level access This pointer defines which waveform set will be
 * chosen when the write low level access is targeted to RS group 0.
 *
 * Values:
 * 0000 - Waveform set #1
 * 0001 - Waveform set #2
 * 1011 - Waveform set #12
 * 1100 - Reserved
 * 1101 - Reserved
 * 1100 - Reserved
 */

#define BP_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_0      16
#define BM_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_0      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_0(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_0)
#else
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_0(v)   (((v) << 16) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SERIAL_LLA_PNTR_RS_W_0 field to a new value.
#define BW_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_0(v)   BF_CS1(IPU_DI1_SER_CONF, DI1_SERIAL_LLA_PNTR_RS_W_0, v)
#endif


/* --- Register HW_IPU_DI1_SER_CONF, field DI1_SERIAL_LLA_PNTR_RS_W_1 (RW)
 *
 * RS 1 waveform pointer for write low level access This pointer defines which waveform set will be
 * chosen when the write low level access is targeted to RS group 1.
 *
 * Values:
 * 0000 - Waveform set #1
 * 0001 - Waveform set #2
 * 1011 - Waveform set #12
 * 1100 - Reserved
 * 1101 - Reserved
 * 1100 - Reserved
 */

#define BP_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_1      20
#define BM_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_1      0x00f00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_1(v)   ((((reg32_t) v) << 20) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_1)
#else
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_1(v)   (((v) << 20) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SERIAL_LLA_PNTR_RS_W_1 field to a new value.
#define BW_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_W_1(v)   BF_CS1(IPU_DI1_SER_CONF, DI1_SERIAL_LLA_PNTR_RS_W_1, v)
#endif


/* --- Register HW_IPU_DI1_SER_CONF, field DI1_SERIAL_LLA_PNTR_RS_R_0 (RW)
 *
 * RS 2 waveform pointer for low level access This pointer defines which waveform set will be chosen
 * when the read low level access is targeted to RS group 0.
 *
 * Values:
 * 0000 - Waveform set #1
 * 0001 - Waveform set #2
 * 1011 - Waveform set #12
 * 1100 - Reserved
 * 1101 - Reserved
 * 1100 - Reserved
 */

#define BP_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_0      24
#define BM_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_0      0x0f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_0(v)   ((((reg32_t) v) << 24) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_0)
#else
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_0(v)   (((v) << 24) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SERIAL_LLA_PNTR_RS_R_0 field to a new value.
#define BW_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_0(v)   BF_CS1(IPU_DI1_SER_CONF, DI1_SERIAL_LLA_PNTR_RS_R_0, v)
#endif


/* --- Register HW_IPU_DI1_SER_CONF, field DI1_SERIAL_LLA_PNTR_RS_R_1 (RW)
 *
 * RS 3 waveform pointer for read low level access This pointer defines which waveform set will be
 * chosen when the read low level access is targeted to RS group 1.
 *
 * Values:
 * 0000 - Waveform set #1
 * 0001 - Waveform set #2
 * 1011 - Waveform set #12
 * 1100 - Reserved
 * 1101 - Reserved
 * 1100 - Reserved
 */

#define BP_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_1      28
#define BM_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_1      0xf0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_1(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_1)
#else
#define BF_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_1(v)   (((v) << 28) & BM_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SERIAL_LLA_PNTR_RS_R_1 field to a new value.
#define BW_IPU_DI1_SER_CONF_DI1_SERIAL_LLA_PNTR_RS_R_1(v)   BF_CS1(IPU_DI1_SER_CONF, DI1_SERIAL_LLA_PNTR_RS_R_1, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SSC - DI1 Special Signals Control Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_BYTE_EN_PNTR : 3; //!< Byte Enable Pointer This pointer selects the pin asserted along with the byte enables signals
        unsigned DI1_BYTE_EN_RD_IN : 1; //!< Byte Enable Read In This bit selects the source of the byte enable pins
        unsigned DI1_BYTE_EN_POLARITY : 1; //!< Byte Enable polarity This bit defines the polarity of the byte enable signals to the display.
        unsigned DI1_WAIT_ON : 1; //!< Wait On This field defines the DC's response to WAIT signal
        unsigned RESERVED0 : 10; //!< Reserved.
        unsigned DI1_CS_ERM : 1; //!< DI1 GLUELOGIC error recovery mode. This bit defines the error recovery mode of the GLUELOGIC.
        unsigned DI1_PIN11_ERM : 1; //!< DI1 PIN11 error recovery mode. This bit defines the error recovery mode of the PIN11 pin.
        unsigned DI1_PIN12_ERM : 1; //!< DI1 PIN12 error recovery mode. This bit defines the error recovery mode of the PIN12 pin.
        unsigned DI1_PIN13_ERM : 1; //!< DI1 PIN13 error recovery mode. This bit defines the error recovery mode of the PIN13 pin.
        unsigned DI1_PIN14_ERM : 1; //!< DI1 PIN14 error recovery mode. This bit defines the error recovery mode of the PIN14 pin.
        unsigned DI1_PIN15_ERM : 1; //!< DI1 PIN15 error recovery mode. This bit defines the error recovery mode of the PIN15 pin.
        unsigned DI1_PIN16_ERM : 1; //!< DI1 PIN16 error recovery mode. This bit defines the error recovery mode of the PIN16 pin.
        unsigned DI1_PIN17_ERM : 1; //!< DI1 PIN17 error recovery mode. This bit defines the error recovery mode of the PIN17 pin.
        unsigned RESERVED1 : 8; //!< Reserved.
    } B;
} hw_ipu_di1_ssc_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SSC register
 */
#define HW_IPU_DI1_SSC_ADDR(x)      (REGS_IPU_BASE(x) + 0x48160)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SSC(x)           (*(volatile hw_ipu_di1_ssc_t *) HW_IPU_DI1_SSC_ADDR(x))
#define HW_IPU_DI1_SSC_RD(x)        (HW_IPU_DI1_SSC(x).U)
#define HW_IPU_DI1_SSC_WR(x, v)     (HW_IPU_DI1_SSC(x).U = (v))
#define HW_IPU_DI1_SSC_SET(x, v)    (HW_IPU_DI1_SSC_WR(x, HW_IPU_DI1_SSC_RD(x) |  (v)))
#define HW_IPU_DI1_SSC_CLR(x, v)    (HW_IPU_DI1_SSC_WR(x, HW_IPU_DI1_SSC_RD(x) & ~(v)))
#define HW_IPU_DI1_SSC_TOG(x, v)    (HW_IPU_DI1_SSC_WR(x, HW_IPU_DI1_SSC_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SSC bitfields
 */

/* --- Register HW_IPU_DI1_SSC, field DI1_BYTE_EN_PNTR (RW)
 *
 * Byte Enable Pointer This pointer selects the pin asserted along with the byte enables signals
 *
 * Values:
 * 000 - wave form of byte enable as pin_11
 * 001 - wave form of byte enable as pin_12
 * 111 - wave form of byte enable as suitable CS pin
 */

#define BP_IPU_DI1_SSC_DI1_BYTE_EN_PNTR      0
#define BM_IPU_DI1_SSC_DI1_BYTE_EN_PNTR      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SSC_DI1_BYTE_EN_PNTR(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SSC_DI1_BYTE_EN_PNTR)
#else
#define BF_IPU_DI1_SSC_DI1_BYTE_EN_PNTR(v)   (((v) << 0) & BM_IPU_DI1_SSC_DI1_BYTE_EN_PNTR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_BYTE_EN_PNTR field to a new value.
#define BW_IPU_DI1_SSC_DI1_BYTE_EN_PNTR(v)   BF_CS1(IPU_DI1_SSC, DI1_BYTE_EN_PNTR, v)
#endif


/* --- Register HW_IPU_DI1_SSC, field DI1_BYTE_EN_RD_IN (RW)
 *
 * Byte Enable Read In This bit selects the source of the byte enable pins
 *
 * Values:
 * 1 - The write byte enable signals are routed via bits [17:16] of the display's data, The read byte
 *     enable signals are routed via bits [19:18 of the display's data
 * 0 - The byte enable signals are routed via bits [17:16] of the display's data for both read and write
 */

#define BP_IPU_DI1_SSC_DI1_BYTE_EN_RD_IN      3
#define BM_IPU_DI1_SSC_DI1_BYTE_EN_RD_IN      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SSC_DI1_BYTE_EN_RD_IN(v)   ((((reg32_t) v) << 3) & BM_IPU_DI1_SSC_DI1_BYTE_EN_RD_IN)
#else
#define BF_IPU_DI1_SSC_DI1_BYTE_EN_RD_IN(v)   (((v) << 3) & BM_IPU_DI1_SSC_DI1_BYTE_EN_RD_IN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_BYTE_EN_RD_IN field to a new value.
#define BW_IPU_DI1_SSC_DI1_BYTE_EN_RD_IN(v)   BF_CS1(IPU_DI1_SSC, DI1_BYTE_EN_RD_IN, v)
#endif


/* --- Register HW_IPU_DI1_SSC, field DI1_BYTE_EN_POLARITY (RW)
 *
 * Byte Enable polarity This bit defines the polarity of the byte enable signals to the display.
 *
 * Values:
 * 1 - active high.
 * 0 - active low.
 */

#define BP_IPU_DI1_SSC_DI1_BYTE_EN_POLARITY      4
#define BM_IPU_DI1_SSC_DI1_BYTE_EN_POLARITY      0x00000010

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SSC_DI1_BYTE_EN_POLARITY(v)   ((((reg32_t) v) << 4) & BM_IPU_DI1_SSC_DI1_BYTE_EN_POLARITY)
#else
#define BF_IPU_DI1_SSC_DI1_BYTE_EN_POLARITY(v)   (((v) << 4) & BM_IPU_DI1_SSC_DI1_BYTE_EN_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_BYTE_EN_POLARITY field to a new value.
#define BW_IPU_DI1_SSC_DI1_BYTE_EN_POLARITY(v)   BF_CS1(IPU_DI1_SSC, DI1_BYTE_EN_POLARITY, v)
#endif


/* --- Register HW_IPU_DI1_SSC, field DI1_WAIT_ON (RW)
 *
 * Wait On This field defines the DC's response to WAIT signal
 *
 * Values:
 * 1 - The DC holds the flow as long as WAIT is asserted.
 * 0 - The DC continues the flow regardless the WAIT signal.
 */

#define BP_IPU_DI1_SSC_DI1_WAIT_ON      5
#define BM_IPU_DI1_SSC_DI1_WAIT_ON      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SSC_DI1_WAIT_ON(v)   ((((reg32_t) v) << 5) & BM_IPU_DI1_SSC_DI1_WAIT_ON)
#else
#define BF_IPU_DI1_SSC_DI1_WAIT_ON(v)   (((v) << 5) & BM_IPU_DI1_SSC_DI1_WAIT_ON)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_WAIT_ON field to a new value.
#define BW_IPU_DI1_SSC_DI1_WAIT_ON(v)   BF_CS1(IPU_DI1_SSC, DI1_WAIT_ON, v)
#endif


/* --- Register HW_IPU_DI1_SSC, field DI1_CS_ERM (RW)
 *
 * DI1 GLUELOGIC error recovery mode. This bit defines the error recovery mode of the GLUELOGIC.
 *
 * Values:
 * 1 - The GLUELOGIC is release in case of a synchronous display error. The release will be done on the
 *     next VSYNC.
 * 0 - Nothing is done to the GLUELOGIC following a display error detection.
 */

#define BP_IPU_DI1_SSC_DI1_CS_ERM      16
#define BM_IPU_DI1_SSC_DI1_CS_ERM      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SSC_DI1_CS_ERM(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_SSC_DI1_CS_ERM)
#else
#define BF_IPU_DI1_SSC_DI1_CS_ERM(v)   (((v) << 16) & BM_IPU_DI1_SSC_DI1_CS_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CS_ERM field to a new value.
#define BW_IPU_DI1_SSC_DI1_CS_ERM(v)   BF_CS1(IPU_DI1_SSC, DI1_CS_ERM, v)
#endif


/* --- Register HW_IPU_DI1_SSC, field DI1_PIN11_ERM (RW)
 *
 * DI1 PIN11 error recovery mode. This bit defines the error recovery mode of the PIN11 pin.
 *
 * Values:
 * 1 - The PIN11 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC.
 * 0 - Nothing is done to the PIN11 pin following a display error detection.
 */

#define BP_IPU_DI1_SSC_DI1_PIN11_ERM      17
#define BM_IPU_DI1_SSC_DI1_PIN11_ERM      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SSC_DI1_PIN11_ERM(v)   ((((reg32_t) v) << 17) & BM_IPU_DI1_SSC_DI1_PIN11_ERM)
#else
#define BF_IPU_DI1_SSC_DI1_PIN11_ERM(v)   (((v) << 17) & BM_IPU_DI1_SSC_DI1_PIN11_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PIN11_ERM field to a new value.
#define BW_IPU_DI1_SSC_DI1_PIN11_ERM(v)   BF_CS1(IPU_DI1_SSC, DI1_PIN11_ERM, v)
#endif


/* --- Register HW_IPU_DI1_SSC, field DI1_PIN12_ERM (RW)
 *
 * DI1 PIN12 error recovery mode. This bit defines the error recovery mode of the PIN12 pin.
 *
 * Values:
 * 1 - The PIN12 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC.
 * 0 - Nothing is done to the PIN12 pin following a display error detection.
 */

#define BP_IPU_DI1_SSC_DI1_PIN12_ERM      18
#define BM_IPU_DI1_SSC_DI1_PIN12_ERM      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SSC_DI1_PIN12_ERM(v)   ((((reg32_t) v) << 18) & BM_IPU_DI1_SSC_DI1_PIN12_ERM)
#else
#define BF_IPU_DI1_SSC_DI1_PIN12_ERM(v)   (((v) << 18) & BM_IPU_DI1_SSC_DI1_PIN12_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PIN12_ERM field to a new value.
#define BW_IPU_DI1_SSC_DI1_PIN12_ERM(v)   BF_CS1(IPU_DI1_SSC, DI1_PIN12_ERM, v)
#endif


/* --- Register HW_IPU_DI1_SSC, field DI1_PIN13_ERM (RW)
 *
 * DI1 PIN13 error recovery mode. This bit defines the error recovery mode of the PIN13 pin.
 *
 * Values:
 * 1 - The PIN13 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC.
 * 0 - Nothing is done to the PIN13 pin following a display error detection.
 */

#define BP_IPU_DI1_SSC_DI1_PIN13_ERM      19
#define BM_IPU_DI1_SSC_DI1_PIN13_ERM      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SSC_DI1_PIN13_ERM(v)   ((((reg32_t) v) << 19) & BM_IPU_DI1_SSC_DI1_PIN13_ERM)
#else
#define BF_IPU_DI1_SSC_DI1_PIN13_ERM(v)   (((v) << 19) & BM_IPU_DI1_SSC_DI1_PIN13_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PIN13_ERM field to a new value.
#define BW_IPU_DI1_SSC_DI1_PIN13_ERM(v)   BF_CS1(IPU_DI1_SSC, DI1_PIN13_ERM, v)
#endif


/* --- Register HW_IPU_DI1_SSC, field DI1_PIN14_ERM (RW)
 *
 * DI1 PIN14 error recovery mode. This bit defines the error recovery mode of the PIN14 pin.
 *
 * Values:
 * 1 - The PIN14 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC.
 * 0 - Nothing is done to the PIN14 pin following a display error detection.
 */

#define BP_IPU_DI1_SSC_DI1_PIN14_ERM      20
#define BM_IPU_DI1_SSC_DI1_PIN14_ERM      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SSC_DI1_PIN14_ERM(v)   ((((reg32_t) v) << 20) & BM_IPU_DI1_SSC_DI1_PIN14_ERM)
#else
#define BF_IPU_DI1_SSC_DI1_PIN14_ERM(v)   (((v) << 20) & BM_IPU_DI1_SSC_DI1_PIN14_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PIN14_ERM field to a new value.
#define BW_IPU_DI1_SSC_DI1_PIN14_ERM(v)   BF_CS1(IPU_DI1_SSC, DI1_PIN14_ERM, v)
#endif


/* --- Register HW_IPU_DI1_SSC, field DI1_PIN15_ERM (RW)
 *
 * DI1 PIN15 error recovery mode. This bit defines the error recovery mode of the PIN15 pin.
 *
 * Values:
 * 1 - The PIN15 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC.
 * 0 - Nothing is done to the PIN15 pin following a display error detection.
 */

#define BP_IPU_DI1_SSC_DI1_PIN15_ERM      21
#define BM_IPU_DI1_SSC_DI1_PIN15_ERM      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SSC_DI1_PIN15_ERM(v)   ((((reg32_t) v) << 21) & BM_IPU_DI1_SSC_DI1_PIN15_ERM)
#else
#define BF_IPU_DI1_SSC_DI1_PIN15_ERM(v)   (((v) << 21) & BM_IPU_DI1_SSC_DI1_PIN15_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PIN15_ERM field to a new value.
#define BW_IPU_DI1_SSC_DI1_PIN15_ERM(v)   BF_CS1(IPU_DI1_SSC, DI1_PIN15_ERM, v)
#endif


/* --- Register HW_IPU_DI1_SSC, field DI1_PIN16_ERM (RW)
 *
 * DI1 PIN16 error recovery mode. This bit defines the error recovery mode of the PIN16 pin.
 *
 * Values:
 * 1 - The PIN16 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC.
 * 0 - Nothing is done to the PIN16 pin following a display error detection.
 */

#define BP_IPU_DI1_SSC_DI1_PIN16_ERM      22
#define BM_IPU_DI1_SSC_DI1_PIN16_ERM      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SSC_DI1_PIN16_ERM(v)   ((((reg32_t) v) << 22) & BM_IPU_DI1_SSC_DI1_PIN16_ERM)
#else
#define BF_IPU_DI1_SSC_DI1_PIN16_ERM(v)   (((v) << 22) & BM_IPU_DI1_SSC_DI1_PIN16_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PIN16_ERM field to a new value.
#define BW_IPU_DI1_SSC_DI1_PIN16_ERM(v)   BF_CS1(IPU_DI1_SSC, DI1_PIN16_ERM, v)
#endif


/* --- Register HW_IPU_DI1_SSC, field DI1_PIN17_ERM (RW)
 *
 * DI1 PIN17 error recovery mode. This bit defines the error recovery mode of the PIN17 pin.
 *
 * Values:
 * 1 - The PIN17 pin is cleared in case of a synchronous display error. The clear will be done on the next
 *     VSYNC.
 * 0 - Nothing is done to the PIN17 pin following a display error detection.
 */

#define BP_IPU_DI1_SSC_DI1_PIN17_ERM      23
#define BM_IPU_DI1_SSC_DI1_PIN17_ERM      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SSC_DI1_PIN17_ERM(v)   ((((reg32_t) v) << 23) & BM_IPU_DI1_SSC_DI1_PIN17_ERM)
#else
#define BF_IPU_DI1_SSC_DI1_PIN17_ERM(v)   (((v) << 23) & BM_IPU_DI1_SSC_DI1_PIN17_ERM)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_PIN17_ERM field to a new value.
#define BW_IPU_DI1_SSC_DI1_PIN17_ERM(v)   BF_CS1(IPU_DI1_SSC, DI1_PIN17_ERM, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_POL - DI1 Polarity Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_DRDY_POLARITY_ : 7; //!< DI1 output dynamic pin's polarity for synchronous access This bits define the polarity of each of the DI's outputs when synchronous display access is asserted The pins' default polarity is the same as defined in the di0_drdy_polarity_[17:11] bits
        unsigned DI1_DRDY_DATA_POLARITY : 1; //!< Data Polarity associated with DRDY
        unsigned DI1_CS0_POLARITY_ : 7; //!< DI1 output pin's polarity for CS1 This bits define the polarity of each of the DI's outputs when CS1 is asserted
        unsigned DI1_CS0_DATA_POLARITY : 1; //!< Data Polarity associated with CS0
        unsigned DI1_CS1_POLARITY_ : 7; //!< DI1 output pin's polarity for CS1 This bits define the polarity of each of the DI's outputs when CS1 is asserted
        unsigned DI1_CS1_DATA_POLARITY : 1; //!< Data Polarity associated with CS1
        unsigned DI1_CS0_BYTE_EN_POLARITY : 1; //!< Byte Enable associated with CS0 polarity This bit defines the polarity of the byte enable signals to the display
        unsigned DI1_CS1_BYTE_EN_POLARITY : 1; //!< Byte Enable associated with CS1 polarity This bit defines the polarity of the byte enable signals to the display
        unsigned DI1_WAIT_POLARITY : 1; //!< WAIT polarity This bit defines the polarity of the wait signal input coming from the displa1
        unsigned RESERVED0 : 5; //!< Reserved.
    } B;
} hw_ipu_di1_pol_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_POL register
 */
#define HW_IPU_DI1_POL_ADDR(x)      (REGS_IPU_BASE(x) + 0x48164)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_POL(x)           (*(volatile hw_ipu_di1_pol_t *) HW_IPU_DI1_POL_ADDR(x))
#define HW_IPU_DI1_POL_RD(x)        (HW_IPU_DI1_POL(x).U)
#define HW_IPU_DI1_POL_WR(x, v)     (HW_IPU_DI1_POL(x).U = (v))
#define HW_IPU_DI1_POL_SET(x, v)    (HW_IPU_DI1_POL_WR(x, HW_IPU_DI1_POL_RD(x) |  (v)))
#define HW_IPU_DI1_POL_CLR(x, v)    (HW_IPU_DI1_POL_WR(x, HW_IPU_DI1_POL_RD(x) & ~(v)))
#define HW_IPU_DI1_POL_TOG(x, v)    (HW_IPU_DI1_POL_WR(x, HW_IPU_DI1_POL_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_POL bitfields
 */

/* --- Register HW_IPU_DI1_POL, field DI1_DRDY_POLARITY_ (RW)
 *
 * DI1 output dynamic pin's polarity for synchronous access This bits define the polarity of each of
 * the DI's outputs when synchronous display access is asserted The pins' default polarity is the
 * same as defined in the di0_drdy_polarity_[17:11] bits
 *
 * Values:
 * 0 - The output pin is active low
 * 1 - The output pin is active high
 */

#define BP_IPU_DI1_POL_DI1_DRDY_POLARITY_      0
#define BM_IPU_DI1_POL_DI1_DRDY_POLARITY_      0x0000007f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_POL_DI1_DRDY_POLARITY_(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_POL_DI1_DRDY_POLARITY_)
#else
#define BF_IPU_DI1_POL_DI1_DRDY_POLARITY_(v)   (((v) << 0) & BM_IPU_DI1_POL_DI1_DRDY_POLARITY_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DRDY_POLARITY_ field to a new value.
#define BW_IPU_DI1_POL_DI1_DRDY_POLARITY_(v)   BF_CS1(IPU_DI1_POL, DI1_DRDY_POLARITY_, v)
#endif


/* --- Register HW_IPU_DI1_POL, field DI1_DRDY_DATA_POLARITY (RW)
 *
 * Data Polarity associated with DRDY
 */

#define BP_IPU_DI1_POL_DI1_DRDY_DATA_POLARITY      7
#define BM_IPU_DI1_POL_DI1_DRDY_DATA_POLARITY      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_POL_DI1_DRDY_DATA_POLARITY(v)   ((((reg32_t) v) << 7) & BM_IPU_DI1_POL_DI1_DRDY_DATA_POLARITY)
#else
#define BF_IPU_DI1_POL_DI1_DRDY_DATA_POLARITY(v)   (((v) << 7) & BM_IPU_DI1_POL_DI1_DRDY_DATA_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_DRDY_DATA_POLARITY field to a new value.
#define BW_IPU_DI1_POL_DI1_DRDY_DATA_POLARITY(v)   BF_CS1(IPU_DI1_POL, DI1_DRDY_DATA_POLARITY, v)
#endif

/* --- Register HW_IPU_DI1_POL, field DI1_CS0_POLARITY_ (RW)
 *
 * DI1 output pin's polarity for CS1 This bits define the polarity of each of the DI's outputs when
 * CS1 is asserted
 *
 * Values:
 * 0 - The output pin is active low
 * 1 - The output pin is active high
 */

#define BP_IPU_DI1_POL_DI1_CS0_POLARITY_      8
#define BM_IPU_DI1_POL_DI1_CS0_POLARITY_      0x00007f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_POL_DI1_CS0_POLARITY_(v)   ((((reg32_t) v) << 8) & BM_IPU_DI1_POL_DI1_CS0_POLARITY_)
#else
#define BF_IPU_DI1_POL_DI1_CS0_POLARITY_(v)   (((v) << 8) & BM_IPU_DI1_POL_DI1_CS0_POLARITY_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CS0_POLARITY_ field to a new value.
#define BW_IPU_DI1_POL_DI1_CS0_POLARITY_(v)   BF_CS1(IPU_DI1_POL, DI1_CS0_POLARITY_, v)
#endif


/* --- Register HW_IPU_DI1_POL, field DI1_CS0_DATA_POLARITY (RW)
 *
 * Data Polarity associated with CS0
 */

#define BP_IPU_DI1_POL_DI1_CS0_DATA_POLARITY      15
#define BM_IPU_DI1_POL_DI1_CS0_DATA_POLARITY      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_POL_DI1_CS0_DATA_POLARITY(v)   ((((reg32_t) v) << 15) & BM_IPU_DI1_POL_DI1_CS0_DATA_POLARITY)
#else
#define BF_IPU_DI1_POL_DI1_CS0_DATA_POLARITY(v)   (((v) << 15) & BM_IPU_DI1_POL_DI1_CS0_DATA_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CS0_DATA_POLARITY field to a new value.
#define BW_IPU_DI1_POL_DI1_CS0_DATA_POLARITY(v)   BF_CS1(IPU_DI1_POL, DI1_CS0_DATA_POLARITY, v)
#endif

/* --- Register HW_IPU_DI1_POL, field DI1_CS1_POLARITY_ (RW)
 *
 * DI1 output pin's polarity for CS1 This bits define the polarity of each of the DI's outputs when
 * CS1 is asserted
 *
 * Values:
 * 0 - The output pin is active low
 * 1 - The output pin is active high
 */

#define BP_IPU_DI1_POL_DI1_CS1_POLARITY_      16
#define BM_IPU_DI1_POL_DI1_CS1_POLARITY_      0x007f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_POL_DI1_CS1_POLARITY_(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_POL_DI1_CS1_POLARITY_)
#else
#define BF_IPU_DI1_POL_DI1_CS1_POLARITY_(v)   (((v) << 16) & BM_IPU_DI1_POL_DI1_CS1_POLARITY_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CS1_POLARITY_ field to a new value.
#define BW_IPU_DI1_POL_DI1_CS1_POLARITY_(v)   BF_CS1(IPU_DI1_POL, DI1_CS1_POLARITY_, v)
#endif


/* --- Register HW_IPU_DI1_POL, field DI1_CS1_DATA_POLARITY (RW)
 *
 * Data Polarity associated with CS1
 */

#define BP_IPU_DI1_POL_DI1_CS1_DATA_POLARITY      23
#define BM_IPU_DI1_POL_DI1_CS1_DATA_POLARITY      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_POL_DI1_CS1_DATA_POLARITY(v)   ((((reg32_t) v) << 23) & BM_IPU_DI1_POL_DI1_CS1_DATA_POLARITY)
#else
#define BF_IPU_DI1_POL_DI1_CS1_DATA_POLARITY(v)   (((v) << 23) & BM_IPU_DI1_POL_DI1_CS1_DATA_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CS1_DATA_POLARITY field to a new value.
#define BW_IPU_DI1_POL_DI1_CS1_DATA_POLARITY(v)   BF_CS1(IPU_DI1_POL, DI1_CS1_DATA_POLARITY, v)
#endif

/* --- Register HW_IPU_DI1_POL, field DI1_CS0_BYTE_EN_POLARITY (RW)
 *
 * Byte Enable associated with CS0 polarity This bit defines the polarity of the byte enable signals
 * to the display
 *
 * Values:
 * 1 - active high
 * 0 - active low
 */

#define BP_IPU_DI1_POL_DI1_CS0_BYTE_EN_POLARITY      24
#define BM_IPU_DI1_POL_DI1_CS0_BYTE_EN_POLARITY      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_POL_DI1_CS0_BYTE_EN_POLARITY(v)   ((((reg32_t) v) << 24) & BM_IPU_DI1_POL_DI1_CS0_BYTE_EN_POLARITY)
#else
#define BF_IPU_DI1_POL_DI1_CS0_BYTE_EN_POLARITY(v)   (((v) << 24) & BM_IPU_DI1_POL_DI1_CS0_BYTE_EN_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CS0_BYTE_EN_POLARITY field to a new value.
#define BW_IPU_DI1_POL_DI1_CS0_BYTE_EN_POLARITY(v)   BF_CS1(IPU_DI1_POL, DI1_CS0_BYTE_EN_POLARITY, v)
#endif


/* --- Register HW_IPU_DI1_POL, field DI1_CS1_BYTE_EN_POLARITY (RW)
 *
 * Byte Enable associated with CS1 polarity This bit defines the polarity of the byte enable signals
 * to the display
 *
 * Values:
 * 1 - active high
 * 0 - active low
 */

#define BP_IPU_DI1_POL_DI1_CS1_BYTE_EN_POLARITY      25
#define BM_IPU_DI1_POL_DI1_CS1_BYTE_EN_POLARITY      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_POL_DI1_CS1_BYTE_EN_POLARITY(v)   ((((reg32_t) v) << 25) & BM_IPU_DI1_POL_DI1_CS1_BYTE_EN_POLARITY)
#else
#define BF_IPU_DI1_POL_DI1_CS1_BYTE_EN_POLARITY(v)   (((v) << 25) & BM_IPU_DI1_POL_DI1_CS1_BYTE_EN_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_CS1_BYTE_EN_POLARITY field to a new value.
#define BW_IPU_DI1_POL_DI1_CS1_BYTE_EN_POLARITY(v)   BF_CS1(IPU_DI1_POL, DI1_CS1_BYTE_EN_POLARITY, v)
#endif


/* --- Register HW_IPU_DI1_POL, field DI1_WAIT_POLARITY (RW)
 *
 * WAIT polarity This bit defines the polarity of the wait signal input coming from the displa1
 *
 * Values:
 * 1 - active high
 * 0 - active low
 */

#define BP_IPU_DI1_POL_DI1_WAIT_POLARITY      26
#define BM_IPU_DI1_POL_DI1_WAIT_POLARITY      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_POL_DI1_WAIT_POLARITY(v)   ((((reg32_t) v) << 26) & BM_IPU_DI1_POL_DI1_WAIT_POLARITY)
#else
#define BF_IPU_DI1_POL_DI1_WAIT_POLARITY(v)   (((v) << 26) & BM_IPU_DI1_POL_DI1_WAIT_POLARITY)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_WAIT_POLARITY field to a new value.
#define BW_IPU_DI1_POL_DI1_WAIT_POLARITY(v)   BF_CS1(IPU_DI1_POL, DI1_WAIT_POLARITY, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_AW0 - DI1Active Window 0 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_AW_HSTART : 12; //!< This field defines the horizontal start of the active window DI1_AW_HSTART < DI1_AW_HEND
        unsigned DI1_AW_HCOUNT_SEL : 4; //!< This field selects the counter that counts the horizontal position of the display's active window
        unsigned DI1_AW_HEND : 12; //!< This field defines the horizontal end of the active window
        unsigned DI1_AW_TRIG_SEL : 4; //!< This field selects the trigger for sending data during the display's active window
    } B;
} hw_ipu_di1_aw0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_AW0 register
 */
#define HW_IPU_DI1_AW0_ADDR(x)      (REGS_IPU_BASE(x) + 0x48168)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_AW0(x)           (*(volatile hw_ipu_di1_aw0_t *) HW_IPU_DI1_AW0_ADDR(x))
#define HW_IPU_DI1_AW0_RD(x)        (HW_IPU_DI1_AW0(x).U)
#define HW_IPU_DI1_AW0_WR(x, v)     (HW_IPU_DI1_AW0(x).U = (v))
#define HW_IPU_DI1_AW0_SET(x, v)    (HW_IPU_DI1_AW0_WR(x, HW_IPU_DI1_AW0_RD(x) |  (v)))
#define HW_IPU_DI1_AW0_CLR(x, v)    (HW_IPU_DI1_AW0_WR(x, HW_IPU_DI1_AW0_RD(x) & ~(v)))
#define HW_IPU_DI1_AW0_TOG(x, v)    (HW_IPU_DI1_AW0_WR(x, HW_IPU_DI1_AW0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_AW0 bitfields
 */

/* --- Register HW_IPU_DI1_AW0, field DI1_AW_HSTART (RW)
 *
 * This field defines the horizontal start of the active window DI1_AW_HSTART < DI1_AW_HEND
 */

#define BP_IPU_DI1_AW0_DI1_AW_HSTART      0
#define BM_IPU_DI1_AW0_DI1_AW_HSTART      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_AW0_DI1_AW_HSTART(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_AW0_DI1_AW_HSTART)
#else
#define BF_IPU_DI1_AW0_DI1_AW_HSTART(v)   (((v) << 0) & BM_IPU_DI1_AW0_DI1_AW_HSTART)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_AW_HSTART field to a new value.
#define BW_IPU_DI1_AW0_DI1_AW_HSTART(v)   BF_CS1(IPU_DI1_AW0, DI1_AW_HSTART, v)
#endif

/* --- Register HW_IPU_DI1_AW0, field DI1_AW_HCOUNT_SEL (RW)
 *
 * This field selects the counter that counts the horizontal position of the display's active window
 *
 * Values:
 * 0000 - disabled
 * 0001 - reserved
 * 0010 - The counter is counter #1
 * 0011 - The counter is counter #2
 * 0100 - The counter is counter #3
 * 0101 - The counter is counter #4
 * 0110 - The counter is counter #5
 * 1001 - The counter is counter #8
 */

#define BP_IPU_DI1_AW0_DI1_AW_HCOUNT_SEL      12
#define BM_IPU_DI1_AW0_DI1_AW_HCOUNT_SEL      0x0000f000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_AW0_DI1_AW_HCOUNT_SEL(v)   ((((reg32_t) v) << 12) & BM_IPU_DI1_AW0_DI1_AW_HCOUNT_SEL)
#else
#define BF_IPU_DI1_AW0_DI1_AW_HCOUNT_SEL(v)   (((v) << 12) & BM_IPU_DI1_AW0_DI1_AW_HCOUNT_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_AW_HCOUNT_SEL field to a new value.
#define BW_IPU_DI1_AW0_DI1_AW_HCOUNT_SEL(v)   BF_CS1(IPU_DI1_AW0, DI1_AW_HCOUNT_SEL, v)
#endif


/* --- Register HW_IPU_DI1_AW0, field DI1_AW_HEND (RW)
 *
 * This field defines the horizontal end of the active window
 */

#define BP_IPU_DI1_AW0_DI1_AW_HEND      16
#define BM_IPU_DI1_AW0_DI1_AW_HEND      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_AW0_DI1_AW_HEND(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_AW0_DI1_AW_HEND)
#else
#define BF_IPU_DI1_AW0_DI1_AW_HEND(v)   (((v) << 16) & BM_IPU_DI1_AW0_DI1_AW_HEND)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_AW_HEND field to a new value.
#define BW_IPU_DI1_AW0_DI1_AW_HEND(v)   BF_CS1(IPU_DI1_AW0, DI1_AW_HEND, v)
#endif

/* --- Register HW_IPU_DI1_AW0, field DI1_AW_TRIG_SEL (RW)
 *
 * This field selects the trigger for sending data during the display's active window
 *
 * Values:
 * 000 - disabled
 * 001 - The trigger is the same trigger that triggers the displays clock.
 * 010 - The trigger is counter #1
 * 011 - The trigger is counter #2
 * 100 - The trigger is counter #3
 * 101 - The trigger is counter #4
 * 110 - The trigger is counter #5
 * 111 - The trigger is always on.
 */

#define BP_IPU_DI1_AW0_DI1_AW_TRIG_SEL      28
#define BM_IPU_DI1_AW0_DI1_AW_TRIG_SEL      0xf0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_AW0_DI1_AW_TRIG_SEL(v)   ((((reg32_t) v) << 28) & BM_IPU_DI1_AW0_DI1_AW_TRIG_SEL)
#else
#define BF_IPU_DI1_AW0_DI1_AW_TRIG_SEL(v)   (((v) << 28) & BM_IPU_DI1_AW0_DI1_AW_TRIG_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_AW_TRIG_SEL field to a new value.
#define BW_IPU_DI1_AW0_DI1_AW_TRIG_SEL(v)   BF_CS1(IPU_DI1_AW0, DI1_AW_TRIG_SEL, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_AW1 - DI1 Active Window 1 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_AW_VSTART : 12; //!< This field defines the vertical start of the active window DI1_AW_VSTART < DI1_AW_VEND
        unsigned DI1_AW_VCOUNT_SEL : 4; //!< This field selects the counter that counts the vertical position of the display's active window
        unsigned DI1_AW_VEND : 12; //!< This field defines the vertical end of the active window
        unsigned RESERVED0 : 4; //!< Reserved
    } B;
} hw_ipu_di1_aw1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_AW1 register
 */
#define HW_IPU_DI1_AW1_ADDR(x)      (REGS_IPU_BASE(x) + 0x4816c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_AW1(x)           (*(volatile hw_ipu_di1_aw1_t *) HW_IPU_DI1_AW1_ADDR(x))
#define HW_IPU_DI1_AW1_RD(x)        (HW_IPU_DI1_AW1(x).U)
#define HW_IPU_DI1_AW1_WR(x, v)     (HW_IPU_DI1_AW1(x).U = (v))
#define HW_IPU_DI1_AW1_SET(x, v)    (HW_IPU_DI1_AW1_WR(x, HW_IPU_DI1_AW1_RD(x) |  (v)))
#define HW_IPU_DI1_AW1_CLR(x, v)    (HW_IPU_DI1_AW1_WR(x, HW_IPU_DI1_AW1_RD(x) & ~(v)))
#define HW_IPU_DI1_AW1_TOG(x, v)    (HW_IPU_DI1_AW1_WR(x, HW_IPU_DI1_AW1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_AW1 bitfields
 */

/* --- Register HW_IPU_DI1_AW1, field DI1_AW_VSTART (RW)
 *
 * This field defines the vertical start of the active window DI1_AW_VSTART < DI1_AW_VEND
 */

#define BP_IPU_DI1_AW1_DI1_AW_VSTART      0
#define BM_IPU_DI1_AW1_DI1_AW_VSTART      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_AW1_DI1_AW_VSTART(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_AW1_DI1_AW_VSTART)
#else
#define BF_IPU_DI1_AW1_DI1_AW_VSTART(v)   (((v) << 0) & BM_IPU_DI1_AW1_DI1_AW_VSTART)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_AW_VSTART field to a new value.
#define BW_IPU_DI1_AW1_DI1_AW_VSTART(v)   BF_CS1(IPU_DI1_AW1, DI1_AW_VSTART, v)
#endif

/* --- Register HW_IPU_DI1_AW1, field DI1_AW_VCOUNT_SEL (RW)
 *
 * This field selects the counter that counts the vertical position of the display's active window
 *
 * Values:
 * 0000 - disabled
 * 0001 - reserved
 * 0010 - The counter is counter #1
 * 0011 - The counter is counter #2
 * 0100 - The counter is counter #3
 * 0101 - The counter is counter #4
 * 0110 - The counter is counter #5
 * 1001 - The counter is counter #8
 */

#define BP_IPU_DI1_AW1_DI1_AW_VCOUNT_SEL      12
#define BM_IPU_DI1_AW1_DI1_AW_VCOUNT_SEL      0x0000f000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_AW1_DI1_AW_VCOUNT_SEL(v)   ((((reg32_t) v) << 12) & BM_IPU_DI1_AW1_DI1_AW_VCOUNT_SEL)
#else
#define BF_IPU_DI1_AW1_DI1_AW_VCOUNT_SEL(v)   (((v) << 12) & BM_IPU_DI1_AW1_DI1_AW_VCOUNT_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_AW_VCOUNT_SEL field to a new value.
#define BW_IPU_DI1_AW1_DI1_AW_VCOUNT_SEL(v)   BF_CS1(IPU_DI1_AW1, DI1_AW_VCOUNT_SEL, v)
#endif


/* --- Register HW_IPU_DI1_AW1, field DI1_AW_VEND (RW)
 *
 * This field defines the vertical end of the active window
 */

#define BP_IPU_DI1_AW1_DI1_AW_VEND      16
#define BM_IPU_DI1_AW1_DI1_AW_VEND      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_AW1_DI1_AW_VEND(v)   ((((reg32_t) v) << 16) & BM_IPU_DI1_AW1_DI1_AW_VEND)
#else
#define BF_IPU_DI1_AW1_DI1_AW_VEND(v)   (((v) << 16) & BM_IPU_DI1_AW1_DI1_AW_VEND)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_AW_VEND field to a new value.
#define BW_IPU_DI1_AW1_DI1_AW_VEND(v)   BF_CS1(IPU_DI1_AW1, DI1_AW_VEND, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_SCR_CONF - DI1 Screen Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_SCREEN_HEIGHT : 12; //!< This field defines the number of display rows (Number_of_ROWS = DI1_SCREEN_HEIGHT+1) This field is used for VSYNC calculation and for anti-tearing
        unsigned RESERVED0 : 20; //!< Reserved.
    } B;
} hw_ipu_di1_scr_conf_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_SCR_CONF register
 */
#define HW_IPU_DI1_SCR_CONF_ADDR(x)      (REGS_IPU_BASE(x) + 0x48170)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_SCR_CONF(x)           (*(volatile hw_ipu_di1_scr_conf_t *) HW_IPU_DI1_SCR_CONF_ADDR(x))
#define HW_IPU_DI1_SCR_CONF_RD(x)        (HW_IPU_DI1_SCR_CONF(x).U)
#define HW_IPU_DI1_SCR_CONF_WR(x, v)     (HW_IPU_DI1_SCR_CONF(x).U = (v))
#define HW_IPU_DI1_SCR_CONF_SET(x, v)    (HW_IPU_DI1_SCR_CONF_WR(x, HW_IPU_DI1_SCR_CONF_RD(x) |  (v)))
#define HW_IPU_DI1_SCR_CONF_CLR(x, v)    (HW_IPU_DI1_SCR_CONF_WR(x, HW_IPU_DI1_SCR_CONF_RD(x) & ~(v)))
#define HW_IPU_DI1_SCR_CONF_TOG(x, v)    (HW_IPU_DI1_SCR_CONF_WR(x, HW_IPU_DI1_SCR_CONF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DI1_SCR_CONF bitfields
 */

/* --- Register HW_IPU_DI1_SCR_CONF, field DI1_SCREEN_HEIGHT (RW)
 *
 * This field defines the number of display rows (Number_of_ROWS = DI1_SCREEN_HEIGHT+1) This field
 * is used for VSYNC calculation and for anti-tearing
 */

#define BP_IPU_DI1_SCR_CONF_DI1_SCREEN_HEIGHT      0
#define BM_IPU_DI1_SCR_CONF_DI1_SCREEN_HEIGHT      0x00000fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DI1_SCR_CONF_DI1_SCREEN_HEIGHT(v)   ((((reg32_t) v) << 0) & BM_IPU_DI1_SCR_CONF_DI1_SCREEN_HEIGHT)
#else
#define BF_IPU_DI1_SCR_CONF_DI1_SCREEN_HEIGHT(v)   (((v) << 0) & BM_IPU_DI1_SCR_CONF_DI1_SCREEN_HEIGHT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI1_SCREEN_HEIGHT field to a new value.
#define BW_IPU_DI1_SCR_CONF_DI1_SCREEN_HEIGHT(v)   BF_CS1(IPU_DI1_SCR_CONF, DI1_SCREEN_HEIGHT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DI1_STAT - DI1 Status Register (RO)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI1_READ_FIFO_EMPTY : 1; //!< This bit indicates an empty state of the DI1 FIFO when performing a read. This FIFO is part of the DI1 synchronizer.
        unsigned DI1_READ_FIFO_FULL : 1; //!< This bit indicates a full state of the DI1 FIFO when performing a read. This FIFO is part of the DI1 synchronizer.
        unsigned DI1_CNTR_FIFO_EMPTY : 1; //!< This bit indicates an empty state of the DI1 FIFO. This FIFO is part of the DI1 synchronizer.
        unsigned DI1_CNTR_FIFO_FULL : 1; //!< This bit indicates a full state of the DI1 FIFO. This FIFO is part of the DI1 synchronizer.
        unsigned RESERVED0 : 28; //!< Reserved
    } B;
} hw_ipu_di1_stat_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DI1_STAT register
 */
#define HW_IPU_DI1_STAT_ADDR(x)      (REGS_IPU_BASE(x) + 0x48174)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DI1_STAT(x)           (*(volatile hw_ipu_di1_stat_t *) HW_IPU_DI1_STAT_ADDR(x))
#define HW_IPU_DI1_STAT_RD(x)        (HW_IPU_DI1_STAT(x).U)
#endif

/*
 * constants & macros for individual IPU_DI1_STAT bitfields
 */

/* --- Register HW_IPU_DI1_STAT, field DI1_READ_FIFO_EMPTY (RO)
 *
 * This bit indicates an empty state of the DI1 FIFO when performing a read. This FIFO is part of
 * the DI1 synchronizer.
 */

#define BP_IPU_DI1_STAT_DI1_READ_FIFO_EMPTY      0
#define BM_IPU_DI1_STAT_DI1_READ_FIFO_EMPTY      0x00000001

/* --- Register HW_IPU_DI1_STAT, field DI1_READ_FIFO_FULL (RO)
 *
 * This bit indicates a full state of the DI1 FIFO when performing a read. This FIFO is part of the
 * DI1 synchronizer.
 */

#define BP_IPU_DI1_STAT_DI1_READ_FIFO_FULL      1
#define BM_IPU_DI1_STAT_DI1_READ_FIFO_FULL      0x00000002

/* --- Register HW_IPU_DI1_STAT, field DI1_CNTR_FIFO_EMPTY (RO)
 *
 * This bit indicates an empty state of the DI1 FIFO. This FIFO is part of the DI1 synchronizer.
 */

#define BP_IPU_DI1_STAT_DI1_CNTR_FIFO_EMPTY      2
#define BM_IPU_DI1_STAT_DI1_CNTR_FIFO_EMPTY      0x00000004

/* --- Register HW_IPU_DI1_STAT, field DI1_CNTR_FIFO_FULL (RO)
 *
 * This bit indicates a full state of the DI1 FIFO. This FIFO is part of the DI1 synchronizer.
 */

#define BP_IPU_DI1_STAT_DI1_CNTR_FIFO_FULL      3
#define BM_IPU_DI1_STAT_DI1_CNTR_FIFO_FULL      0x00000008

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SMFC_MAP - SMFC Mapping Register (RW)
 *
 * The purpose of this register is to map CSI frames to IDMAC channels.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAP_CH0 : 3; //!< DMASMFC channel 0 mapping bits.
        unsigned MAP_CH1 : 3; //!< DMASMFC channel 1 mapping bits.
        unsigned MAP_CH2 : 3; //!< DMASMFC channel 2 mapping bits.
        unsigned MAP_CH3 : 3; //!< DMASMFC channel 3mapping bits.
        unsigned RESERVED0 : 20; //!< Reserved.
    } B;
} hw_ipu_smfc_map_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SMFC_MAP register
 */
#define HW_IPU_SMFC_MAP_ADDR(x)      (REGS_IPU_BASE(x) + 0x50000)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SMFC_MAP(x)           (*(volatile hw_ipu_smfc_map_t *) HW_IPU_SMFC_MAP_ADDR(x))
#define HW_IPU_SMFC_MAP_RD(x)        (HW_IPU_SMFC_MAP(x).U)
#define HW_IPU_SMFC_MAP_WR(x, v)     (HW_IPU_SMFC_MAP(x).U = (v))
#define HW_IPU_SMFC_MAP_SET(x, v)    (HW_IPU_SMFC_MAP_WR(x, HW_IPU_SMFC_MAP_RD(x) |  (v)))
#define HW_IPU_SMFC_MAP_CLR(x, v)    (HW_IPU_SMFC_MAP_WR(x, HW_IPU_SMFC_MAP_RD(x) & ~(v)))
#define HW_IPU_SMFC_MAP_TOG(x, v)    (HW_IPU_SMFC_MAP_WR(x, HW_IPU_SMFC_MAP_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SMFC_MAP bitfields
 */

/* --- Register HW_IPU_SMFC_MAP, field MAP_CH0 (RW)
 *
 * DMASMFC channel 0 mapping bits.
 *
 * Values:
 * 000 - CSI0, ID=0 mapped to DMASMFC channel 0.
 * 001 - CSI0, ID=1 mapped to DMASMFC channel 0.
 * 010 - CSI0, ID=2 mapped to DMASMFC channel 0.
 * 011 - CSI0, ID=3 mapped to DMASMFC channel 0.
 * 100 - CSI1, ID=0 mapped to DMASMFC channel 0.
 * 101 - CSI1, ID=1 mapped to DMASMFC channel 0.
 * 110 - CSI1, ID=2 mapped to DMASMFC channel 0.
 * 111 - CSI1, ID=3 mapped to DMASMFC channel 0.
 */

#define BP_IPU_SMFC_MAP_MAP_CH0      0
#define BM_IPU_SMFC_MAP_MAP_CH0      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_MAP_MAP_CH0(v)   ((((reg32_t) v) << 0) & BM_IPU_SMFC_MAP_MAP_CH0)
#else
#define BF_IPU_SMFC_MAP_MAP_CH0(v)   (((v) << 0) & BM_IPU_SMFC_MAP_MAP_CH0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAP_CH0 field to a new value.
#define BW_IPU_SMFC_MAP_MAP_CH0(v)   BF_CS1(IPU_SMFC_MAP, MAP_CH0, v)
#endif


/* --- Register HW_IPU_SMFC_MAP, field MAP_CH1 (RW)
 *
 * DMASMFC channel 1 mapping bits.
 *
 * Values:
 * 000 - CSI0, ID=0 mapped to DMASMFC channel 1.
 * 001 - CSI0, ID=1 mapped to DMASMFC channel 1.
 * 010 - CSI0, ID=2 mapped to DMASMFC channel 1.
 * 011 - CSI0, ID=3 mapped to DMASMFC channel 1.
 * 100 - CSI1, ID=0 mapped to DMASMFC channel 1.
 * 101 - CSI1, ID=1 mapped to DMASMFC channel 1.
 * 110 - CSI1, ID=2 mapped to DMASMFC channel 1.
 * 111 - CSI1, ID=3 mapped to DMASMFC channel 1.
 */

#define BP_IPU_SMFC_MAP_MAP_CH1      3
#define BM_IPU_SMFC_MAP_MAP_CH1      0x00000038

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_MAP_MAP_CH1(v)   ((((reg32_t) v) << 3) & BM_IPU_SMFC_MAP_MAP_CH1)
#else
#define BF_IPU_SMFC_MAP_MAP_CH1(v)   (((v) << 3) & BM_IPU_SMFC_MAP_MAP_CH1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAP_CH1 field to a new value.
#define BW_IPU_SMFC_MAP_MAP_CH1(v)   BF_CS1(IPU_SMFC_MAP, MAP_CH1, v)
#endif


/* --- Register HW_IPU_SMFC_MAP, field MAP_CH2 (RW)
 *
 * DMASMFC channel 2 mapping bits.
 *
 * Values:
 * 000 - CSI0, ID=0 mapped to DMASMFC channel 2.
 * 001 - CSI0, ID=1 mapped to DMASMFC channel 2.
 * 010 - CSI0, ID=2 mapped to DMASMFC channel 2.
 * 011 - CSI0, ID=3 mapped to DMASMFC channel 2.
 * 100 - CSI1, ID=0 mapped to DMASMFC channel 2.
 * 101 - CSI1, ID=1 mapped to DMASMFC channel 2.
 * 110 - CSI1, ID=2 mapped to DMASMFC channel 2.
 * 111 - CSI1, ID=3 mapped to DMASMFC channel 2.
 */

#define BP_IPU_SMFC_MAP_MAP_CH2      6
#define BM_IPU_SMFC_MAP_MAP_CH2      0x000001c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_MAP_MAP_CH2(v)   ((((reg32_t) v) << 6) & BM_IPU_SMFC_MAP_MAP_CH2)
#else
#define BF_IPU_SMFC_MAP_MAP_CH2(v)   (((v) << 6) & BM_IPU_SMFC_MAP_MAP_CH2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAP_CH2 field to a new value.
#define BW_IPU_SMFC_MAP_MAP_CH2(v)   BF_CS1(IPU_SMFC_MAP, MAP_CH2, v)
#endif


/* --- Register HW_IPU_SMFC_MAP, field MAP_CH3 (RW)
 *
 * DMASMFC channel 3mapping bits.
 *
 * Values:
 * 000 - CSI0, ID=0 mapped to DMASMFC channel 3.
 * 001 - CSI0, ID=1 mapped to DMASMFC channel 3.
 * 010 - CSI0, ID=2 mapped to DMASMFC channel 3.
 * 011 - CSI0, ID=3 mapped to DMASMFC channel 3.
 * 100 - CSI1, ID=0 mapped to DMASMFC channel 3.
 * 101 - CSI1, ID=1 mapped to DMASMFC channel 3.
 * 110 - CSI1, ID=2 mapped to DMASMFC channel 3.
 * 111 - CSI1, ID=3 mapped to DMASMFC channel 3.
 */

#define BP_IPU_SMFC_MAP_MAP_CH3      9
#define BM_IPU_SMFC_MAP_MAP_CH3      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_MAP_MAP_CH3(v)   ((((reg32_t) v) << 9) & BM_IPU_SMFC_MAP_MAP_CH3)
#else
#define BF_IPU_SMFC_MAP_MAP_CH3(v)   (((v) << 9) & BM_IPU_SMFC_MAP_MAP_CH3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAP_CH3 field to a new value.
#define BW_IPU_SMFC_MAP_MAP_CH3(v)   BF_CS1(IPU_SMFC_MAP, MAP_CH3, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SMFC_WMC - SMFC Watermark Control Register (RW)
 *
 * The purpose of this register is to control watermarks levels of DMA channels. The bit setting
 * given relative to FIFO size and not in number of words since FIFO size depend from number of
 * enabled DMA channels.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned WM0_SET : 3; //!< Watermark "set" level of DMASMFC channel 0.
        unsigned WM0_CLR : 3; //!< Watermark "clear" level of DMASMFC channel 0.
        unsigned WM1_SET : 3; //!< Watermark "set" level of DMASMFC channel 1.
        unsigned WM1_CLR : 3; //!< Watermark "clear" level of DMASMFC channel 1.
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned WM2_SET : 3; //!< Watermark "set" level of DMASMFC channel 2.
        unsigned WM2_CLR : 3; //!< Watermark "clear" level of DMASMFC channel 2.
        unsigned WM3_SET : 3; //!< Watermark "set" level of DMASMFC channel 3
        unsigned WM3_CLR : 3; //!< Watermark "clear" level of DMASMFC channel 3.
        unsigned RESERVED1 : 4; //!< Reserved.
    } B;
} hw_ipu_smfc_wmc_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SMFC_WMC register
 */
#define HW_IPU_SMFC_WMC_ADDR(x)      (REGS_IPU_BASE(x) + 0x50004)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SMFC_WMC(x)           (*(volatile hw_ipu_smfc_wmc_t *) HW_IPU_SMFC_WMC_ADDR(x))
#define HW_IPU_SMFC_WMC_RD(x)        (HW_IPU_SMFC_WMC(x).U)
#define HW_IPU_SMFC_WMC_WR(x, v)     (HW_IPU_SMFC_WMC(x).U = (v))
#define HW_IPU_SMFC_WMC_SET(x, v)    (HW_IPU_SMFC_WMC_WR(x, HW_IPU_SMFC_WMC_RD(x) |  (v)))
#define HW_IPU_SMFC_WMC_CLR(x, v)    (HW_IPU_SMFC_WMC_WR(x, HW_IPU_SMFC_WMC_RD(x) & ~(v)))
#define HW_IPU_SMFC_WMC_TOG(x, v)    (HW_IPU_SMFC_WMC_WR(x, HW_IPU_SMFC_WMC_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SMFC_WMC bitfields
 */

/* --- Register HW_IPU_SMFC_WMC, field WM0_SET (RW)
 *
 * Watermark "set" level of DMASMFC channel 0.
 *
 * Values:
 * 000 - set watermark level when FIFO is full on 1/8 of their size.
 * 001 - set watermark level when FIFO is full on 2/8 of their size.
 * 110 - set watermark level when FIFO is full on 7/8 of their size.
 * 111 - set watermark level when FIFO is full.
 */

#define BP_IPU_SMFC_WMC_WM0_SET      0
#define BM_IPU_SMFC_WMC_WM0_SET      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_WMC_WM0_SET(v)   ((((reg32_t) v) << 0) & BM_IPU_SMFC_WMC_WM0_SET)
#else
#define BF_IPU_SMFC_WMC_WM0_SET(v)   (((v) << 0) & BM_IPU_SMFC_WMC_WM0_SET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WM0_SET field to a new value.
#define BW_IPU_SMFC_WMC_WM0_SET(v)   BF_CS1(IPU_SMFC_WMC, WM0_SET, v)
#endif


/* --- Register HW_IPU_SMFC_WMC, field WM0_CLR (RW)
 *
 * Watermark "clear" level of DMASMFC channel 0.
 *
 * Values:
 * 000 - clear watermark level when FIFO is full on 1/8 of their size.
 * 001 - clear watermark level when FIFO is full on 2/8 of their size.
 * 110 - clear watermark level when FIFO is full on 7/8 of their size.
 * 111 - clear watermark level when FIFO is full.
 */

#define BP_IPU_SMFC_WMC_WM0_CLR      3
#define BM_IPU_SMFC_WMC_WM0_CLR      0x00000038

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_WMC_WM0_CLR(v)   ((((reg32_t) v) << 3) & BM_IPU_SMFC_WMC_WM0_CLR)
#else
#define BF_IPU_SMFC_WMC_WM0_CLR(v)   (((v) << 3) & BM_IPU_SMFC_WMC_WM0_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WM0_CLR field to a new value.
#define BW_IPU_SMFC_WMC_WM0_CLR(v)   BF_CS1(IPU_SMFC_WMC, WM0_CLR, v)
#endif


/* --- Register HW_IPU_SMFC_WMC, field WM1_SET (RW)
 *
 * Watermark "set" level of DMASMFC channel 1.
 *
 * Values:
 * 000 - set watermark level when FIFO is full on 1/8 of their size.
 * 001 - set watermark level when FIFO is full on 2/8 of their size.
 * 110 - set watermark level when FIFO is full on 7/8 of their size.
 * 111 - set watermark level when FIFO is full.
 */

#define BP_IPU_SMFC_WMC_WM1_SET      6
#define BM_IPU_SMFC_WMC_WM1_SET      0x000001c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_WMC_WM1_SET(v)   ((((reg32_t) v) << 6) & BM_IPU_SMFC_WMC_WM1_SET)
#else
#define BF_IPU_SMFC_WMC_WM1_SET(v)   (((v) << 6) & BM_IPU_SMFC_WMC_WM1_SET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WM1_SET field to a new value.
#define BW_IPU_SMFC_WMC_WM1_SET(v)   BF_CS1(IPU_SMFC_WMC, WM1_SET, v)
#endif


/* --- Register HW_IPU_SMFC_WMC, field WM1_CLR (RW)
 *
 * Watermark "clear" level of DMASMFC channel 1.
 *
 * Values:
 * 000 - clear watermark level when FIFO is full on 1/8 of their size.
 * 001 - clear watermark level when FIFO is full on 2/8 of their size.
 * 110 - clear watermark level when FIFO is full on 7/8 of their size.
 * 111 - clear watermark level when FIFO is full.
 */

#define BP_IPU_SMFC_WMC_WM1_CLR      9
#define BM_IPU_SMFC_WMC_WM1_CLR      0x00000e00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_WMC_WM1_CLR(v)   ((((reg32_t) v) << 9) & BM_IPU_SMFC_WMC_WM1_CLR)
#else
#define BF_IPU_SMFC_WMC_WM1_CLR(v)   (((v) << 9) & BM_IPU_SMFC_WMC_WM1_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WM1_CLR field to a new value.
#define BW_IPU_SMFC_WMC_WM1_CLR(v)   BF_CS1(IPU_SMFC_WMC, WM1_CLR, v)
#endif


/* --- Register HW_IPU_SMFC_WMC, field WM2_SET (RW)
 *
 * Watermark "set" level of DMASMFC channel 2.
 *
 * Values:
 * 000 - set watermark level when FIFO is full on 1/8 of their size.
 * 001 - set watermark level when FIFO is full on 2/8 of their size.
 * 110 - set watermark level when FIFO is full on 7/8 of their size.
 * 111 - set watermark level when FIFO is full.
 */

#define BP_IPU_SMFC_WMC_WM2_SET      16
#define BM_IPU_SMFC_WMC_WM2_SET      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_WMC_WM2_SET(v)   ((((reg32_t) v) << 16) & BM_IPU_SMFC_WMC_WM2_SET)
#else
#define BF_IPU_SMFC_WMC_WM2_SET(v)   (((v) << 16) & BM_IPU_SMFC_WMC_WM2_SET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WM2_SET field to a new value.
#define BW_IPU_SMFC_WMC_WM2_SET(v)   BF_CS1(IPU_SMFC_WMC, WM2_SET, v)
#endif


/* --- Register HW_IPU_SMFC_WMC, field WM2_CLR (RW)
 *
 * Watermark "clear" level of DMASMFC channel 2.
 *
 * Values:
 * 000 - clear watermark level when FIFO is full on 1/8 of their size.
 * 001 - clear watermark level when FIFO is full on 2/8 of their size.
 * 110 - clear watermark level when FIFO is full on 7/8 of their size.
 * 111 - clear watermark level when FIFO is full.
 */

#define BP_IPU_SMFC_WMC_WM2_CLR      19
#define BM_IPU_SMFC_WMC_WM2_CLR      0x00380000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_WMC_WM2_CLR(v)   ((((reg32_t) v) << 19) & BM_IPU_SMFC_WMC_WM2_CLR)
#else
#define BF_IPU_SMFC_WMC_WM2_CLR(v)   (((v) << 19) & BM_IPU_SMFC_WMC_WM2_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WM2_CLR field to a new value.
#define BW_IPU_SMFC_WMC_WM2_CLR(v)   BF_CS1(IPU_SMFC_WMC, WM2_CLR, v)
#endif


/* --- Register HW_IPU_SMFC_WMC, field WM3_SET (RW)
 *
 * Watermark "set" level of DMASMFC channel 3
 *
 * Values:
 * 000 - set watermark level when FIFO is full on 1/8 of their size.
 * 001 - set watermark level when FIFO is full on 2/8 of their size.
 * 110 - set watermark level when FIFO is full on 7/8 of their size.
 * 111 - set watermark level when FIFO is full.
 */

#define BP_IPU_SMFC_WMC_WM3_SET      22
#define BM_IPU_SMFC_WMC_WM3_SET      0x01c00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_WMC_WM3_SET(v)   ((((reg32_t) v) << 22) & BM_IPU_SMFC_WMC_WM3_SET)
#else
#define BF_IPU_SMFC_WMC_WM3_SET(v)   (((v) << 22) & BM_IPU_SMFC_WMC_WM3_SET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WM3_SET field to a new value.
#define BW_IPU_SMFC_WMC_WM3_SET(v)   BF_CS1(IPU_SMFC_WMC, WM3_SET, v)
#endif


/* --- Register HW_IPU_SMFC_WMC, field WM3_CLR (RW)
 *
 * Watermark "clear" level of DMASMFC channel 3.
 *
 * Values:
 * 000 - clear watermark level when FIFO is full on 1/8 of their size.
 * 001 - clear watermark level when FIFO is full on 2/8 of their size.
 * 110 - clear watermark level when FIFO is full on 7/8 of their size.
 * 111 - clear watermark level when FIFO is full.
 */

#define BP_IPU_SMFC_WMC_WM3_CLR      25
#define BM_IPU_SMFC_WMC_WM3_CLR      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_WMC_WM3_CLR(v)   ((((reg32_t) v) << 25) & BM_IPU_SMFC_WMC_WM3_CLR)
#else
#define BF_IPU_SMFC_WMC_WM3_CLR(v)   (((v) << 25) & BM_IPU_SMFC_WMC_WM3_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WM3_CLR field to a new value.
#define BW_IPU_SMFC_WMC_WM3_CLR(v)   BF_CS1(IPU_SMFC_WMC, WM3_CLR, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_SMFC_BS - SMFC Burst Size Register (RW)
 *
 * This register holds the burst size value for each DMASMFC channel. The burst size is the number
 * of IDMAC's active accesses that will done for each IDMAC's burst. This number is a function of
 * PFS, BPP & NPB parameters in the IDMAC's CPMEM. These are the parameters corresponding to the
 * IDMAC's channel used. The table below describes what should be the burst size according to PFS,
 * BPP & NPB settings   SMFC Burst Size        BPP  PFS  BURST_SIZE      8  6  NPB[6:4]    16  6
 * NPB[6:4]    All other  All other  NPB[6:2]
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned BURST0_SIZE : 4; //!< Burst Size of SMFCDMA channel 0. The value programed here should be BURST_SIZE-1 (for example: for a burst size of 1, write 0 to these bits)
        unsigned BURST1_SIZE : 4; //!< Burst Size of SMFCDMA channel 1. The value programed here should be BURST_SIZE-1 (for example: for a burst size of 1, write 0 to these bits)
        unsigned BURST2_SIZE : 4; //!< Burst Size of SMFCDMA channel 2. The value programed here should be BURST_SIZE-1 (for example: for a burst size of 1, write 0 to these bits)
        unsigned BURST3_SIZE : 4; //!< Burst Size of SMFCDMA channel 3. The value programed here should be BURST_SIZE-1 (for example: for a burst size of 1, write 0 to these bits)
        unsigned RESERVED0 : 16; //!< Reserved.
    } B;
} hw_ipu_smfc_bs_t;
#endif

/*
 * constants & macros for entire multi-block IPU_SMFC_BS register
 */
#define HW_IPU_SMFC_BS_ADDR(x)      (REGS_IPU_BASE(x) + 0x50008)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_SMFC_BS(x)           (*(volatile hw_ipu_smfc_bs_t *) HW_IPU_SMFC_BS_ADDR(x))
#define HW_IPU_SMFC_BS_RD(x)        (HW_IPU_SMFC_BS(x).U)
#define HW_IPU_SMFC_BS_WR(x, v)     (HW_IPU_SMFC_BS(x).U = (v))
#define HW_IPU_SMFC_BS_SET(x, v)    (HW_IPU_SMFC_BS_WR(x, HW_IPU_SMFC_BS_RD(x) |  (v)))
#define HW_IPU_SMFC_BS_CLR(x, v)    (HW_IPU_SMFC_BS_WR(x, HW_IPU_SMFC_BS_RD(x) & ~(v)))
#define HW_IPU_SMFC_BS_TOG(x, v)    (HW_IPU_SMFC_BS_WR(x, HW_IPU_SMFC_BS_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_SMFC_BS bitfields
 */

/* --- Register HW_IPU_SMFC_BS, field BURST0_SIZE (RW)
 *
 * Burst Size of SMFCDMA channel 0. The value programed here should be BURST_SIZE-1 (for example:
 * for a burst size of 1, write 0 to these bits)
 */

#define BP_IPU_SMFC_BS_BURST0_SIZE      0
#define BM_IPU_SMFC_BS_BURST0_SIZE      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_BS_BURST0_SIZE(v)   ((((reg32_t) v) << 0) & BM_IPU_SMFC_BS_BURST0_SIZE)
#else
#define BF_IPU_SMFC_BS_BURST0_SIZE(v)   (((v) << 0) & BM_IPU_SMFC_BS_BURST0_SIZE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the BURST0_SIZE field to a new value.
#define BW_IPU_SMFC_BS_BURST0_SIZE(v)   BF_CS1(IPU_SMFC_BS, BURST0_SIZE, v)
#endif

/* --- Register HW_IPU_SMFC_BS, field BURST1_SIZE (RW)
 *
 * Burst Size of SMFCDMA channel 1. The value programed here should be BURST_SIZE-1 (for example:
 * for a burst size of 1, write 0 to these bits)
 */

#define BP_IPU_SMFC_BS_BURST1_SIZE      4
#define BM_IPU_SMFC_BS_BURST1_SIZE      0x000000f0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_BS_BURST1_SIZE(v)   ((((reg32_t) v) << 4) & BM_IPU_SMFC_BS_BURST1_SIZE)
#else
#define BF_IPU_SMFC_BS_BURST1_SIZE(v)   (((v) << 4) & BM_IPU_SMFC_BS_BURST1_SIZE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the BURST1_SIZE field to a new value.
#define BW_IPU_SMFC_BS_BURST1_SIZE(v)   BF_CS1(IPU_SMFC_BS, BURST1_SIZE, v)
#endif

/* --- Register HW_IPU_SMFC_BS, field BURST2_SIZE (RW)
 *
 * Burst Size of SMFCDMA channel 2. The value programed here should be BURST_SIZE-1 (for example:
 * for a burst size of 1, write 0 to these bits)
 */

#define BP_IPU_SMFC_BS_BURST2_SIZE      8
#define BM_IPU_SMFC_BS_BURST2_SIZE      0x00000f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_BS_BURST2_SIZE(v)   ((((reg32_t) v) << 8) & BM_IPU_SMFC_BS_BURST2_SIZE)
#else
#define BF_IPU_SMFC_BS_BURST2_SIZE(v)   (((v) << 8) & BM_IPU_SMFC_BS_BURST2_SIZE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the BURST2_SIZE field to a new value.
#define BW_IPU_SMFC_BS_BURST2_SIZE(v)   BF_CS1(IPU_SMFC_BS, BURST2_SIZE, v)
#endif

/* --- Register HW_IPU_SMFC_BS, field BURST3_SIZE (RW)
 *
 * Burst Size of SMFCDMA channel 3. The value programed here should be BURST_SIZE-1 (for example:
 * for a burst size of 1, write 0 to these bits)
 */

#define BP_IPU_SMFC_BS_BURST3_SIZE      12
#define BM_IPU_SMFC_BS_BURST3_SIZE      0x0000f000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_SMFC_BS_BURST3_SIZE(v)   ((((reg32_t) v) << 12) & BM_IPU_SMFC_BS_BURST3_SIZE)
#else
#define BF_IPU_SMFC_BS_BURST3_SIZE(v)   (((v) << 12) & BM_IPU_SMFC_BS_BURST3_SIZE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the BURST3_SIZE field to a new value.
#define BW_IPU_SMFC_BS_BURST3_SIZE(v)   BF_CS1(IPU_SMFC_BS, BURST3_SIZE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_READ_CH_CONF - DC Read Channel Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RD_CHANNEL_EN : 1; //!< This bit enables the read channel.
        unsigned PROG_DI_ID_0 : 1; //!< This bit select the DI which a read transaction can be performed through
        unsigned PROG_DISP_ID_0 : 2; //!< The field defines which one of the 4 displays can be read.
        unsigned W_SIZE_0 : 2; //!< Word Size The data coming from the IDMAC is 32bit wide. This field defines the size of the word used by the DC
        unsigned CHAN_MASK_DEFAULT_0 : 1; //!< Event mask bit for the read channel When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned CS_ID_0 : 1; //!< This bit maps an asynchronous display to a chip select
        unsigned CS_ID_1 : 1; //!< This bit maps an asynchronous display to a chip select
        unsigned CS_ID_2 : 1; //!< This bit maps an asynchronous display to a chip select
        unsigned CS_ID_3 : 1; //!< This bit maps an asynchronous display to a chip select
        unsigned RESERVED1 : 4; //!< Reserved
        unsigned TIME_OUT_VALUE : 16; //!< Time out value. In case of a error during read accesses to the display, where no response from the display was received. A time-out counter will terminate the current access and perform the next commend defined in the microcode. This field defines the amount of the hsp_clk cycles counted before the time-out event is issued. This event is tied to the interrupt controller and can generate an error interrupt.
    } B;
} hw_ipu_dc_read_ch_conf_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_READ_CH_CONF register
 */
#define HW_IPU_DC_READ_CH_CONF_ADDR(x)      (REGS_IPU_BASE(x) + 0x58000)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_READ_CH_CONF(x)           (*(volatile hw_ipu_dc_read_ch_conf_t *) HW_IPU_DC_READ_CH_CONF_ADDR(x))
#define HW_IPU_DC_READ_CH_CONF_RD(x)        (HW_IPU_DC_READ_CH_CONF(x).U)
#define HW_IPU_DC_READ_CH_CONF_WR(x, v)     (HW_IPU_DC_READ_CH_CONF(x).U = (v))
#define HW_IPU_DC_READ_CH_CONF_SET(x, v)    (HW_IPU_DC_READ_CH_CONF_WR(x, HW_IPU_DC_READ_CH_CONF_RD(x) |  (v)))
#define HW_IPU_DC_READ_CH_CONF_CLR(x, v)    (HW_IPU_DC_READ_CH_CONF_WR(x, HW_IPU_DC_READ_CH_CONF_RD(x) & ~(v)))
#define HW_IPU_DC_READ_CH_CONF_TOG(x, v)    (HW_IPU_DC_READ_CH_CONF_WR(x, HW_IPU_DC_READ_CH_CONF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_READ_CH_CONF bitfields
 */

/* --- Register HW_IPU_DC_READ_CH_CONF, field RD_CHANNEL_EN (RW)
 *
 * This bit enables the read channel.
 *
 * Values:
 * 1 - The Read channel is enabled
 * 0 - The Read channel is disabled
 */

#define BP_IPU_DC_READ_CH_CONF_RD_CHANNEL_EN      0
#define BM_IPU_DC_READ_CH_CONF_RD_CHANNEL_EN      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_READ_CH_CONF_RD_CHANNEL_EN(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_READ_CH_CONF_RD_CHANNEL_EN)
#else
#define BF_IPU_DC_READ_CH_CONF_RD_CHANNEL_EN(v)   (((v) << 0) & BM_IPU_DC_READ_CH_CONF_RD_CHANNEL_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the RD_CHANNEL_EN field to a new value.
#define BW_IPU_DC_READ_CH_CONF_RD_CHANNEL_EN(v)   BF_CS1(IPU_DC_READ_CH_CONF, RD_CHANNEL_EN, v)
#endif


/* --- Register HW_IPU_DC_READ_CH_CONF, field PROG_DI_ID_0 (RW)
 *
 * This bit select the DI which a read transaction can be performed through
 *
 * Values:
 * 1 - DI #1
 * 0 - DI #0
 */

#define BP_IPU_DC_READ_CH_CONF_PROG_DI_ID_0      1
#define BM_IPU_DC_READ_CH_CONF_PROG_DI_ID_0      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_READ_CH_CONF_PROG_DI_ID_0(v)   ((((reg32_t) v) << 1) & BM_IPU_DC_READ_CH_CONF_PROG_DI_ID_0)
#else
#define BF_IPU_DC_READ_CH_CONF_PROG_DI_ID_0(v)   (((v) << 1) & BM_IPU_DC_READ_CH_CONF_PROG_DI_ID_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_DI_ID_0 field to a new value.
#define BW_IPU_DC_READ_CH_CONF_PROG_DI_ID_0(v)   BF_CS1(IPU_DC_READ_CH_CONF, PROG_DI_ID_0, v)
#endif


/* --- Register HW_IPU_DC_READ_CH_CONF, field PROG_DISP_ID_0 (RW)
 *
 * The field defines which one of the 4 displays can be read.
 *
 * Values:
 * 00 - display #0
 * 01 - display #1
 * 10 - display #2
 * 11 - display #3
 */

#define BP_IPU_DC_READ_CH_CONF_PROG_DISP_ID_0      2
#define BM_IPU_DC_READ_CH_CONF_PROG_DISP_ID_0      0x0000000c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_READ_CH_CONF_PROG_DISP_ID_0(v)   ((((reg32_t) v) << 2) & BM_IPU_DC_READ_CH_CONF_PROG_DISP_ID_0)
#else
#define BF_IPU_DC_READ_CH_CONF_PROG_DISP_ID_0(v)   (((v) << 2) & BM_IPU_DC_READ_CH_CONF_PROG_DISP_ID_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_DISP_ID_0 field to a new value.
#define BW_IPU_DC_READ_CH_CONF_PROG_DISP_ID_0(v)   BF_CS1(IPU_DC_READ_CH_CONF, PROG_DISP_ID_0, v)
#endif


/* --- Register HW_IPU_DC_READ_CH_CONF, field W_SIZE_0 (RW)
 *
 * Word Size The data coming from the IDMAC is 32bit wide. This field defines the size of the word
 * used by the DC
 *
 * Values:
 * 00 - 8 bits are used - a 32 bit words includes 4X8bit valid words.
 * 01 - 16 LSB bits - a 32 bit words includes 2 X16bit valid words.
 * 10 - 24 MSB bits are used (RGB) - 8 LSB bits are ignored by the DC
 * 11 - 32 bits are used
 */

#define BP_IPU_DC_READ_CH_CONF_W_SIZE_0      4
#define BM_IPU_DC_READ_CH_CONF_W_SIZE_0      0x00000030

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_READ_CH_CONF_W_SIZE_0(v)   ((((reg32_t) v) << 4) & BM_IPU_DC_READ_CH_CONF_W_SIZE_0)
#else
#define BF_IPU_DC_READ_CH_CONF_W_SIZE_0(v)   (((v) << 4) & BM_IPU_DC_READ_CH_CONF_W_SIZE_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the W_SIZE_0 field to a new value.
#define BW_IPU_DC_READ_CH_CONF_W_SIZE_0(v)   BF_CS1(IPU_DC_READ_CH_CONF, W_SIZE_0, v)
#endif


/* --- Register HW_IPU_DC_READ_CH_CONF, field CHAN_MASK_DEFAULT_0 (RW)
 *
 * Event mask bit for the read channel When more then one event is used during a flow (EOF, EOL, NL,
 * NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority
 * event
 *
 * Values:
 * 1 - All the events are used - no mask
 * 0 - Only the highest priority event is used, the rest are masked
 */

#define BP_IPU_DC_READ_CH_CONF_CHAN_MASK_DEFAULT_0      6
#define BM_IPU_DC_READ_CH_CONF_CHAN_MASK_DEFAULT_0      0x00000040

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_READ_CH_CONF_CHAN_MASK_DEFAULT_0(v)   ((((reg32_t) v) << 6) & BM_IPU_DC_READ_CH_CONF_CHAN_MASK_DEFAULT_0)
#else
#define BF_IPU_DC_READ_CH_CONF_CHAN_MASK_DEFAULT_0(v)   (((v) << 6) & BM_IPU_DC_READ_CH_CONF_CHAN_MASK_DEFAULT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CHAN_MASK_DEFAULT_0 field to a new value.
#define BW_IPU_DC_READ_CH_CONF_CHAN_MASK_DEFAULT_0(v)   BF_CS1(IPU_DC_READ_CH_CONF, CHAN_MASK_DEFAULT_0, v)
#endif


/* --- Register HW_IPU_DC_READ_CH_CONF, field CS_ID_0 (RW)
 *
 * This bit maps an asynchronous display to a chip select
 *
 * Values:
 * 1 - display #0 is connected to CS1
 * 0 - display #0 is connected to CS0
 */

#define BP_IPU_DC_READ_CH_CONF_CS_ID_0      8
#define BM_IPU_DC_READ_CH_CONF_CS_ID_0      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_READ_CH_CONF_CS_ID_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_READ_CH_CONF_CS_ID_0)
#else
#define BF_IPU_DC_READ_CH_CONF_CS_ID_0(v)   (((v) << 8) & BM_IPU_DC_READ_CH_CONF_CS_ID_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CS_ID_0 field to a new value.
#define BW_IPU_DC_READ_CH_CONF_CS_ID_0(v)   BF_CS1(IPU_DC_READ_CH_CONF, CS_ID_0, v)
#endif


/* --- Register HW_IPU_DC_READ_CH_CONF, field CS_ID_1 (RW)
 *
 * This bit maps an asynchronous display to a chip select
 *
 * Values:
 * 1 - display #1 is connected to CS1
 * 0 - display #1 is connected to CS0
 */

#define BP_IPU_DC_READ_CH_CONF_CS_ID_1      9
#define BM_IPU_DC_READ_CH_CONF_CS_ID_1      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_READ_CH_CONF_CS_ID_1(v)   ((((reg32_t) v) << 9) & BM_IPU_DC_READ_CH_CONF_CS_ID_1)
#else
#define BF_IPU_DC_READ_CH_CONF_CS_ID_1(v)   (((v) << 9) & BM_IPU_DC_READ_CH_CONF_CS_ID_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CS_ID_1 field to a new value.
#define BW_IPU_DC_READ_CH_CONF_CS_ID_1(v)   BF_CS1(IPU_DC_READ_CH_CONF, CS_ID_1, v)
#endif


/* --- Register HW_IPU_DC_READ_CH_CONF, field CS_ID_2 (RW)
 *
 * This bit maps an asynchronous display to a chip select
 *
 * Values:
 * 1 - display #2 is connected to CS1
 * 0 - display #2 is connected to CS0
 */

#define BP_IPU_DC_READ_CH_CONF_CS_ID_2      10
#define BM_IPU_DC_READ_CH_CONF_CS_ID_2      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_READ_CH_CONF_CS_ID_2(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_READ_CH_CONF_CS_ID_2)
#else
#define BF_IPU_DC_READ_CH_CONF_CS_ID_2(v)   (((v) << 10) & BM_IPU_DC_READ_CH_CONF_CS_ID_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CS_ID_2 field to a new value.
#define BW_IPU_DC_READ_CH_CONF_CS_ID_2(v)   BF_CS1(IPU_DC_READ_CH_CONF, CS_ID_2, v)
#endif


/* --- Register HW_IPU_DC_READ_CH_CONF, field CS_ID_3 (RW)
 *
 * This bit maps an asynchronous display to a chip select
 *
 * Values:
 * 1 - display #3 is connected to CS1
 * 0 - display #3 is connected to CS0
 */

#define BP_IPU_DC_READ_CH_CONF_CS_ID_3      11
#define BM_IPU_DC_READ_CH_CONF_CS_ID_3      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_READ_CH_CONF_CS_ID_3(v)   ((((reg32_t) v) << 11) & BM_IPU_DC_READ_CH_CONF_CS_ID_3)
#else
#define BF_IPU_DC_READ_CH_CONF_CS_ID_3(v)   (((v) << 11) & BM_IPU_DC_READ_CH_CONF_CS_ID_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CS_ID_3 field to a new value.
#define BW_IPU_DC_READ_CH_CONF_CS_ID_3(v)   BF_CS1(IPU_DC_READ_CH_CONF, CS_ID_3, v)
#endif


/* --- Register HW_IPU_DC_READ_CH_CONF, field TIME_OUT_VALUE (RW)
 *
 * Time out value. In case of a error during read accesses to the display, where no response from
 * the display was received. A time-out counter will terminate the current access and perform the
 * next commend defined in the microcode. This field defines the amount of the hsp_clk cycles
 * counted before the time-out event is issued. This event is tied to the interrupt controller and
 * can generate an error interrupt.
 */

#define BP_IPU_DC_READ_CH_CONF_TIME_OUT_VALUE      16
#define BM_IPU_DC_READ_CH_CONF_TIME_OUT_VALUE      0xffff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_READ_CH_CONF_TIME_OUT_VALUE(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_READ_CH_CONF_TIME_OUT_VALUE)
#else
#define BF_IPU_DC_READ_CH_CONF_TIME_OUT_VALUE(v)   (((v) << 16) & BM_IPU_DC_READ_CH_CONF_TIME_OUT_VALUE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the TIME_OUT_VALUE field to a new value.
#define BW_IPU_DC_READ_CH_CONF_TIME_OUT_VALUE(v)   BF_CS1(IPU_DC_READ_CH_CONF, TIME_OUT_VALUE, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_READ_SH_ADDR - DC Read Channel Start Address Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned ST_ADDR_0 : 29; //!< This field defines the start address within the display's memory space where the read transactions will be done from.
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_read_sh_addr_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_READ_SH_ADDR register
 */
#define HW_IPU_DC_READ_SH_ADDR_ADDR(x)      (REGS_IPU_BASE(x) + 0x58004)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_READ_SH_ADDR(x)           (*(volatile hw_ipu_dc_read_sh_addr_t *) HW_IPU_DC_READ_SH_ADDR_ADDR(x))
#define HW_IPU_DC_READ_SH_ADDR_RD(x)        (HW_IPU_DC_READ_SH_ADDR(x).U)
#define HW_IPU_DC_READ_SH_ADDR_WR(x, v)     (HW_IPU_DC_READ_SH_ADDR(x).U = (v))
#define HW_IPU_DC_READ_SH_ADDR_SET(x, v)    (HW_IPU_DC_READ_SH_ADDR_WR(x, HW_IPU_DC_READ_SH_ADDR_RD(x) |  (v)))
#define HW_IPU_DC_READ_SH_ADDR_CLR(x, v)    (HW_IPU_DC_READ_SH_ADDR_WR(x, HW_IPU_DC_READ_SH_ADDR_RD(x) & ~(v)))
#define HW_IPU_DC_READ_SH_ADDR_TOG(x, v)    (HW_IPU_DC_READ_SH_ADDR_WR(x, HW_IPU_DC_READ_SH_ADDR_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_READ_SH_ADDR bitfields
 */

/* --- Register HW_IPU_DC_READ_SH_ADDR, field ST_ADDR_0 (RW)
 *
 * This field defines the start address within the display's memory space where the read
 * transactions will be done from.
 */

#define BP_IPU_DC_READ_SH_ADDR_ST_ADDR_0      0
#define BM_IPU_DC_READ_SH_ADDR_ST_ADDR_0      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_READ_SH_ADDR_ST_ADDR_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_READ_SH_ADDR_ST_ADDR_0)
#else
#define BF_IPU_DC_READ_SH_ADDR_ST_ADDR_0(v)   (((v) << 0) & BM_IPU_DC_READ_SH_ADDR_ST_ADDR_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ST_ADDR_0 field to a new value.
#define BW_IPU_DC_READ_SH_ADDR_ST_ADDR_0(v)   BF_CS1(IPU_DC_READ_SH_ADDR, ST_ADDR_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL0_CH_0 - DC Routine Link Register 0 Channel 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NF_PRIORITY_CHAN_0 : 4; //!< This field defines the priority of the new frame (NF) event The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NF_START_CHAN_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new Frame event (NF) resides
        unsigned COD_NL_PRIORITY_CHAN_0 : 4; //!< This field defines the priority of the new line (NL) event The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NL_START_CHAN_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new line event (NL) resides
    } B;
} hw_ipu_dc_rl0_ch_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL0_CH_0 register
 */
#define HW_IPU_DC_RL0_CH_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x58008)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL0_CH_0(x)           (*(volatile hw_ipu_dc_rl0_ch_0_t *) HW_IPU_DC_RL0_CH_0_ADDR(x))
#define HW_IPU_DC_RL0_CH_0_RD(x)        (HW_IPU_DC_RL0_CH_0(x).U)
#define HW_IPU_DC_RL0_CH_0_WR(x, v)     (HW_IPU_DC_RL0_CH_0(x).U = (v))
#define HW_IPU_DC_RL0_CH_0_SET(x, v)    (HW_IPU_DC_RL0_CH_0_WR(x, HW_IPU_DC_RL0_CH_0_RD(x) |  (v)))
#define HW_IPU_DC_RL0_CH_0_CLR(x, v)    (HW_IPU_DC_RL0_CH_0_WR(x, HW_IPU_DC_RL0_CH_0_RD(x) & ~(v)))
#define HW_IPU_DC_RL0_CH_0_TOG(x, v)    (HW_IPU_DC_RL0_CH_0_WR(x, HW_IPU_DC_RL0_CH_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL0_CH_0 bitfields
 */

/* --- Register HW_IPU_DC_RL0_CH_0, field COD_NF_PRIORITY_CHAN_0 (RW)
 *
 * This field defines the priority of the new frame (NF) event The priority between the events
 * should be set to a unique value. i.e. two events must not have the same priority (except 0000 -
 * disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL0_CH_0_COD_NF_PRIORITY_CHAN_0      0
#define BM_IPU_DC_RL0_CH_0_COD_NF_PRIORITY_CHAN_0      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_0_COD_NF_PRIORITY_CHAN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL0_CH_0_COD_NF_PRIORITY_CHAN_0)
#else
#define BF_IPU_DC_RL0_CH_0_COD_NF_PRIORITY_CHAN_0(v)   (((v) << 0) & BM_IPU_DC_RL0_CH_0_COD_NF_PRIORITY_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NF_PRIORITY_CHAN_0 field to a new value.
#define BW_IPU_DC_RL0_CH_0_COD_NF_PRIORITY_CHAN_0(v)   BF_CS1(IPU_DC_RL0_CH_0, COD_NF_PRIORITY_CHAN_0, v)
#endif


/* --- Register HW_IPU_DC_RL0_CH_0, field COD_NF_START_CHAN_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new Frame event (NF) resides
 */

#define BP_IPU_DC_RL0_CH_0_COD_NF_START_CHAN_0      8
#define BM_IPU_DC_RL0_CH_0_COD_NF_START_CHAN_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_0_COD_NF_START_CHAN_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL0_CH_0_COD_NF_START_CHAN_0)
#else
#define BF_IPU_DC_RL0_CH_0_COD_NF_START_CHAN_0(v)   (((v) << 8) & BM_IPU_DC_RL0_CH_0_COD_NF_START_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NF_START_CHAN_0 field to a new value.
#define BW_IPU_DC_RL0_CH_0_COD_NF_START_CHAN_0(v)   BF_CS1(IPU_DC_RL0_CH_0, COD_NF_START_CHAN_0, v)
#endif

/* --- Register HW_IPU_DC_RL0_CH_0, field COD_NL_PRIORITY_CHAN_0 (RW)
 *
 * This field defines the priority of the new line (NL) event The priority between the events should
 * be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL0_CH_0_COD_NL_PRIORITY_CHAN_0      16
#define BM_IPU_DC_RL0_CH_0_COD_NL_PRIORITY_CHAN_0      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_0_COD_NL_PRIORITY_CHAN_0(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL0_CH_0_COD_NL_PRIORITY_CHAN_0)
#else
#define BF_IPU_DC_RL0_CH_0_COD_NL_PRIORITY_CHAN_0(v)   (((v) << 16) & BM_IPU_DC_RL0_CH_0_COD_NL_PRIORITY_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NL_PRIORITY_CHAN_0 field to a new value.
#define BW_IPU_DC_RL0_CH_0_COD_NL_PRIORITY_CHAN_0(v)   BF_CS1(IPU_DC_RL0_CH_0, COD_NL_PRIORITY_CHAN_0, v)
#endif


/* --- Register HW_IPU_DC_RL0_CH_0, field COD_NL_START_CHAN_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new line event (NL) resides
 */

#define BP_IPU_DC_RL0_CH_0_COD_NL_START_CHAN_0      24
#define BM_IPU_DC_RL0_CH_0_COD_NL_START_CHAN_0      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_0_COD_NL_START_CHAN_0(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL0_CH_0_COD_NL_START_CHAN_0)
#else
#define BF_IPU_DC_RL0_CH_0_COD_NL_START_CHAN_0(v)   (((v) << 24) & BM_IPU_DC_RL0_CH_0_COD_NL_START_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NL_START_CHAN_0 field to a new value.
#define BW_IPU_DC_RL0_CH_0_COD_NL_START_CHAN_0(v)   BF_CS1(IPU_DC_RL0_CH_0, COD_NL_START_CHAN_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL1_CH_0 - DC Routine Link Register 1 Channel 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_EOF_PRIORITY_CHAN_0 : 4; //!< This field defines the priority of the end-of-frame event (EOF) event The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_EOF_START_CHAN_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end-of-frame event (EOF) resides
        unsigned COD_NFIELD_PRIORITY_CHAN_0 : 4; //!< This field defines the priority of the new field event The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NFIELD_START_CHAN_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new field event resides
    } B;
} hw_ipu_dc_rl1_ch_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL1_CH_0 register
 */
#define HW_IPU_DC_RL1_CH_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x5800c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL1_CH_0(x)           (*(volatile hw_ipu_dc_rl1_ch_0_t *) HW_IPU_DC_RL1_CH_0_ADDR(x))
#define HW_IPU_DC_RL1_CH_0_RD(x)        (HW_IPU_DC_RL1_CH_0(x).U)
#define HW_IPU_DC_RL1_CH_0_WR(x, v)     (HW_IPU_DC_RL1_CH_0(x).U = (v))
#define HW_IPU_DC_RL1_CH_0_SET(x, v)    (HW_IPU_DC_RL1_CH_0_WR(x, HW_IPU_DC_RL1_CH_0_RD(x) |  (v)))
#define HW_IPU_DC_RL1_CH_0_CLR(x, v)    (HW_IPU_DC_RL1_CH_0_WR(x, HW_IPU_DC_RL1_CH_0_RD(x) & ~(v)))
#define HW_IPU_DC_RL1_CH_0_TOG(x, v)    (HW_IPU_DC_RL1_CH_0_WR(x, HW_IPU_DC_RL1_CH_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL1_CH_0 bitfields
 */

/* --- Register HW_IPU_DC_RL1_CH_0, field COD_EOF_PRIORITY_CHAN_0 (RW)
 *
 * This field defines the priority of the end-of-frame event (EOF) event The priority between the
 * events should be set to a unique value. i.e. two events must not have the same priority (except
 * 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL1_CH_0_COD_EOF_PRIORITY_CHAN_0      0
#define BM_IPU_DC_RL1_CH_0_COD_EOF_PRIORITY_CHAN_0      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_0_COD_EOF_PRIORITY_CHAN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL1_CH_0_COD_EOF_PRIORITY_CHAN_0)
#else
#define BF_IPU_DC_RL1_CH_0_COD_EOF_PRIORITY_CHAN_0(v)   (((v) << 0) & BM_IPU_DC_RL1_CH_0_COD_EOF_PRIORITY_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOF_PRIORITY_CHAN_0 field to a new value.
#define BW_IPU_DC_RL1_CH_0_COD_EOF_PRIORITY_CHAN_0(v)   BF_CS1(IPU_DC_RL1_CH_0, COD_EOF_PRIORITY_CHAN_0, v)
#endif


/* --- Register HW_IPU_DC_RL1_CH_0, field COD_EOF_START_CHAN_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end-of-frame event (EOF) resides
 */

#define BP_IPU_DC_RL1_CH_0_COD_EOF_START_CHAN_0      8
#define BM_IPU_DC_RL1_CH_0_COD_EOF_START_CHAN_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_0_COD_EOF_START_CHAN_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL1_CH_0_COD_EOF_START_CHAN_0)
#else
#define BF_IPU_DC_RL1_CH_0_COD_EOF_START_CHAN_0(v)   (((v) << 8) & BM_IPU_DC_RL1_CH_0_COD_EOF_START_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOF_START_CHAN_0 field to a new value.
#define BW_IPU_DC_RL1_CH_0_COD_EOF_START_CHAN_0(v)   BF_CS1(IPU_DC_RL1_CH_0, COD_EOF_START_CHAN_0, v)
#endif

/* --- Register HW_IPU_DC_RL1_CH_0, field COD_NFIELD_PRIORITY_CHAN_0 (RW)
 *
 * This field defines the priority of the new field event The priority between the events should be
 * set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL1_CH_0_COD_NFIELD_PRIORITY_CHAN_0      16
#define BM_IPU_DC_RL1_CH_0_COD_NFIELD_PRIORITY_CHAN_0      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_0_COD_NFIELD_PRIORITY_CHAN_0(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL1_CH_0_COD_NFIELD_PRIORITY_CHAN_0)
#else
#define BF_IPU_DC_RL1_CH_0_COD_NFIELD_PRIORITY_CHAN_0(v)   (((v) << 16) & BM_IPU_DC_RL1_CH_0_COD_NFIELD_PRIORITY_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NFIELD_PRIORITY_CHAN_0 field to a new value.
#define BW_IPU_DC_RL1_CH_0_COD_NFIELD_PRIORITY_CHAN_0(v)   BF_CS1(IPU_DC_RL1_CH_0, COD_NFIELD_PRIORITY_CHAN_0, v)
#endif


/* --- Register HW_IPU_DC_RL1_CH_0, field COD_NFIELD_START_CHAN_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new field event resides
 */

#define BP_IPU_DC_RL1_CH_0_COD_NFIELD_START_CHAN_0      24
#define BM_IPU_DC_RL1_CH_0_COD_NFIELD_START_CHAN_0      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_0_COD_NFIELD_START_CHAN_0(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL1_CH_0_COD_NFIELD_START_CHAN_0)
#else
#define BF_IPU_DC_RL1_CH_0_COD_NFIELD_START_CHAN_0(v)   (((v) << 24) & BM_IPU_DC_RL1_CH_0_COD_NFIELD_START_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NFIELD_START_CHAN_0 field to a new value.
#define BW_IPU_DC_RL1_CH_0_COD_NFIELD_START_CHAN_0(v)   BF_CS1(IPU_DC_RL1_CH_0, COD_NFIELD_START_CHAN_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL3_CH_0 - DC Routine Link Registe3 Channel 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_ADDR_PRIORITY_CHAN_0 : 4; //!< This field defines the priority of the new address event The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides
        unsigned COD_NEW_CHAN_PRIORITY_CHAN_0 : 4; //!< This field defines the priority of the new channel event The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides
    } B;
} hw_ipu_dc_rl3_ch_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL3_CH_0 register
 */
#define HW_IPU_DC_RL3_CH_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x58014)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL3_CH_0(x)           (*(volatile hw_ipu_dc_rl3_ch_0_t *) HW_IPU_DC_RL3_CH_0_ADDR(x))
#define HW_IPU_DC_RL3_CH_0_RD(x)        (HW_IPU_DC_RL3_CH_0(x).U)
#define HW_IPU_DC_RL3_CH_0_WR(x, v)     (HW_IPU_DC_RL3_CH_0(x).U = (v))
#define HW_IPU_DC_RL3_CH_0_SET(x, v)    (HW_IPU_DC_RL3_CH_0_WR(x, HW_IPU_DC_RL3_CH_0_RD(x) |  (v)))
#define HW_IPU_DC_RL3_CH_0_CLR(x, v)    (HW_IPU_DC_RL3_CH_0_WR(x, HW_IPU_DC_RL3_CH_0_RD(x) & ~(v)))
#define HW_IPU_DC_RL3_CH_0_TOG(x, v)    (HW_IPU_DC_RL3_CH_0_WR(x, HW_IPU_DC_RL3_CH_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL3_CH_0 bitfields
 */

/* --- Register HW_IPU_DC_RL3_CH_0, field COD_NEW_ADDR_PRIORITY_CHAN_0 (RW)
 *
 * This field defines the priority of the new address event The priority between the events should
 * be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL3_CH_0_COD_NEW_ADDR_PRIORITY_CHAN_0      0
#define BM_IPU_DC_RL3_CH_0_COD_NEW_ADDR_PRIORITY_CHAN_0      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_0_COD_NEW_ADDR_PRIORITY_CHAN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL3_CH_0_COD_NEW_ADDR_PRIORITY_CHAN_0)
#else
#define BF_IPU_DC_RL3_CH_0_COD_NEW_ADDR_PRIORITY_CHAN_0(v)   (((v) << 0) & BM_IPU_DC_RL3_CH_0_COD_NEW_ADDR_PRIORITY_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_PRIORITY_CHAN_0 field to a new value.
#define BW_IPU_DC_RL3_CH_0_COD_NEW_ADDR_PRIORITY_CHAN_0(v)   BF_CS1(IPU_DC_RL3_CH_0, COD_NEW_ADDR_PRIORITY_CHAN_0, v)
#endif


/* --- Register HW_IPU_DC_RL3_CH_0, field COD_NEW_ADDR_START_CHAN_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides
 */

#define BP_IPU_DC_RL3_CH_0_COD_NEW_ADDR_START_CHAN_0      8
#define BM_IPU_DC_RL3_CH_0_COD_NEW_ADDR_START_CHAN_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_0_COD_NEW_ADDR_START_CHAN_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL3_CH_0_COD_NEW_ADDR_START_CHAN_0)
#else
#define BF_IPU_DC_RL3_CH_0_COD_NEW_ADDR_START_CHAN_0(v)   (((v) << 8) & BM_IPU_DC_RL3_CH_0_COD_NEW_ADDR_START_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_0 field to a new value.
#define BW_IPU_DC_RL3_CH_0_COD_NEW_ADDR_START_CHAN_0(v)   BF_CS1(IPU_DC_RL3_CH_0, COD_NEW_ADDR_START_CHAN_0, v)
#endif

/* --- Register HW_IPU_DC_RL3_CH_0, field COD_NEW_CHAN_PRIORITY_CHAN_0 (RW)
 *
 * This field defines the priority of the new channel event The priority between the events should
 * be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL3_CH_0_COD_NEW_CHAN_PRIORITY_CHAN_0      16
#define BM_IPU_DC_RL3_CH_0_COD_NEW_CHAN_PRIORITY_CHAN_0      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_0_COD_NEW_CHAN_PRIORITY_CHAN_0(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL3_CH_0_COD_NEW_CHAN_PRIORITY_CHAN_0)
#else
#define BF_IPU_DC_RL3_CH_0_COD_NEW_CHAN_PRIORITY_CHAN_0(v)   (((v) << 16) & BM_IPU_DC_RL3_CH_0_COD_NEW_CHAN_PRIORITY_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_PRIORITY_CHAN_0 field to a new value.
#define BW_IPU_DC_RL3_CH_0_COD_NEW_CHAN_PRIORITY_CHAN_0(v)   BF_CS1(IPU_DC_RL3_CH_0, COD_NEW_CHAN_PRIORITY_CHAN_0, v)
#endif


/* --- Register HW_IPU_DC_RL3_CH_0, field COD_NEW_CHAN_START_CHAN_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides
 */

#define BP_IPU_DC_RL3_CH_0_COD_NEW_CHAN_START_CHAN_0      24
#define BM_IPU_DC_RL3_CH_0_COD_NEW_CHAN_START_CHAN_0      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_0_COD_NEW_CHAN_START_CHAN_0(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL3_CH_0_COD_NEW_CHAN_START_CHAN_0)
#else
#define BF_IPU_DC_RL3_CH_0_COD_NEW_CHAN_START_CHAN_0(v)   (((v) << 24) & BM_IPU_DC_RL3_CH_0_COD_NEW_CHAN_START_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_0 field to a new value.
#define BW_IPU_DC_RL3_CH_0_COD_NEW_CHAN_START_CHAN_0(v)   BF_CS1(IPU_DC_RL3_CH_0, COD_NEW_CHAN_START_CHAN_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL4_CH_0 - DC Routine Link Register 4 Channel 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_DATA_PRIORITY_CHAN_0 : 4; //!< This field defines the priority of the new data event The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides
        unsigned RESERVED1 : 16; //!< Reserved.
    } B;
} hw_ipu_dc_rl4_ch_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL4_CH_0 register
 */
#define HW_IPU_DC_RL4_CH_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x58018)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL4_CH_0(x)           (*(volatile hw_ipu_dc_rl4_ch_0_t *) HW_IPU_DC_RL4_CH_0_ADDR(x))
#define HW_IPU_DC_RL4_CH_0_RD(x)        (HW_IPU_DC_RL4_CH_0(x).U)
#define HW_IPU_DC_RL4_CH_0_WR(x, v)     (HW_IPU_DC_RL4_CH_0(x).U = (v))
#define HW_IPU_DC_RL4_CH_0_SET(x, v)    (HW_IPU_DC_RL4_CH_0_WR(x, HW_IPU_DC_RL4_CH_0_RD(x) |  (v)))
#define HW_IPU_DC_RL4_CH_0_CLR(x, v)    (HW_IPU_DC_RL4_CH_0_WR(x, HW_IPU_DC_RL4_CH_0_RD(x) & ~(v)))
#define HW_IPU_DC_RL4_CH_0_TOG(x, v)    (HW_IPU_DC_RL4_CH_0_WR(x, HW_IPU_DC_RL4_CH_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL4_CH_0 bitfields
 */

/* --- Register HW_IPU_DC_RL4_CH_0, field COD_NEW_DATA_PRIORITY_CHAN_0 (RW)
 *
 * This field defines the priority of the new data event The priority between the events should be
 * set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL4_CH_0_COD_NEW_DATA_PRIORITY_CHAN_0      0
#define BM_IPU_DC_RL4_CH_0_COD_NEW_DATA_PRIORITY_CHAN_0      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_0_COD_NEW_DATA_PRIORITY_CHAN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL4_CH_0_COD_NEW_DATA_PRIORITY_CHAN_0)
#else
#define BF_IPU_DC_RL4_CH_0_COD_NEW_DATA_PRIORITY_CHAN_0(v)   (((v) << 0) & BM_IPU_DC_RL4_CH_0_COD_NEW_DATA_PRIORITY_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_PRIORITY_CHAN_0 field to a new value.
#define BW_IPU_DC_RL4_CH_0_COD_NEW_DATA_PRIORITY_CHAN_0(v)   BF_CS1(IPU_DC_RL4_CH_0, COD_NEW_DATA_PRIORITY_CHAN_0, v)
#endif


/* --- Register HW_IPU_DC_RL4_CH_0, field COD_NEW_DATA_START_CHAN_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides
 */

#define BP_IPU_DC_RL4_CH_0_COD_NEW_DATA_START_CHAN_0      8
#define BM_IPU_DC_RL4_CH_0_COD_NEW_DATA_START_CHAN_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_0_COD_NEW_DATA_START_CHAN_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL4_CH_0_COD_NEW_DATA_START_CHAN_0)
#else
#define BF_IPU_DC_RL4_CH_0_COD_NEW_DATA_START_CHAN_0(v)   (((v) << 8) & BM_IPU_DC_RL4_CH_0_COD_NEW_DATA_START_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_0 field to a new value.
#define BW_IPU_DC_RL4_CH_0_COD_NEW_DATA_START_CHAN_0(v)   BF_CS1(IPU_DC_RL4_CH_0, COD_NEW_DATA_START_CHAN_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_WR_CH_CONF_1 - DC Write Channel 1 Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned W_SIZE_1 : 2; //!< Word Size associated with channel #1 The data coming from the IDMAC is 32bit wide. This field defines the size of the word used by the DC
        unsigned PROG_DI_ID_1 : 1; //!< This bit select the DI which a transaction associated with channel #1 can be performed to
        unsigned PROG_DISP_ID_1 : 2; //!< The field defines which one of the 4 displays is associated with channel #1.
        unsigned PROG_CHAN_TYP_1 : 3; //!< This field define the mode of operation of channel #1
        unsigned CHAN_MASK_DEFAULT_1 : 1; //!< Event mask bit for channel #1 When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event
        unsigned FIELD_MODE_1 : 1; //!< Field mode bit for channel #1 This bit defines if the channel works in field mode or frame mode; This bit is relevant if the flow is sync flow
        unsigned RESERVED0 : 6; //!< Reserved.
        unsigned PROG_START_TIME_1 : 11; //!< This field defines the delay between display 's vertical synchronization pulse and the start time point of DC's channel 1 window. The delay is defined in pairs of rows. It is used for tearing elimination
        unsigned RESERVED1 : 5; //!< Reserved.
    } B;
} hw_ipu_dc_wr_ch_conf_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_WR_CH_CONF_1 register
 */
#define HW_IPU_DC_WR_CH_CONF_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x5801c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_WR_CH_CONF_1(x)           (*(volatile hw_ipu_dc_wr_ch_conf_1_t *) HW_IPU_DC_WR_CH_CONF_1_ADDR(x))
#define HW_IPU_DC_WR_CH_CONF_1_RD(x)        (HW_IPU_DC_WR_CH_CONF_1(x).U)
#define HW_IPU_DC_WR_CH_CONF_1_WR(x, v)     (HW_IPU_DC_WR_CH_CONF_1(x).U = (v))
#define HW_IPU_DC_WR_CH_CONF_1_SET(x, v)    (HW_IPU_DC_WR_CH_CONF_1_WR(x, HW_IPU_DC_WR_CH_CONF_1_RD(x) |  (v)))
#define HW_IPU_DC_WR_CH_CONF_1_CLR(x, v)    (HW_IPU_DC_WR_CH_CONF_1_WR(x, HW_IPU_DC_WR_CH_CONF_1_RD(x) & ~(v)))
#define HW_IPU_DC_WR_CH_CONF_1_TOG(x, v)    (HW_IPU_DC_WR_CH_CONF_1_WR(x, HW_IPU_DC_WR_CH_CONF_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_WR_CH_CONF_1 bitfields
 */

/* --- Register HW_IPU_DC_WR_CH_CONF_1, field W_SIZE_1 (RW)
 *
 * Word Size associated with channel #1 The data coming from the IDMAC is 32bit wide. This field
 * defines the size of the word used by the DC
 *
 * Values:
 * 00 - 8 bits are used - a 32 bit words includes 4X8bit valid words.
 * 01 - 16 LSB bits - a 32 bit words includes 2 X16bit valid words.
 * 10 - 24 MSB bits are used (RGB) - 8 LSB bits are ignored by the DC
 * 11 - 32 bits are used
 */

#define BP_IPU_DC_WR_CH_CONF_1_W_SIZE_1      0
#define BM_IPU_DC_WR_CH_CONF_1_W_SIZE_1      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_1_W_SIZE_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_WR_CH_CONF_1_W_SIZE_1)
#else
#define BF_IPU_DC_WR_CH_CONF_1_W_SIZE_1(v)   (((v) << 0) & BM_IPU_DC_WR_CH_CONF_1_W_SIZE_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the W_SIZE_1 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_1_W_SIZE_1(v)   BF_CS1(IPU_DC_WR_CH_CONF_1, W_SIZE_1, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_1, field PROG_DI_ID_1 (RW)
 *
 * This bit select the DI which a transaction associated with channel #1 can be performed to
 *
 * Values:
 * 1 - DI #1
 * 0 - DI #0
 */

#define BP_IPU_DC_WR_CH_CONF_1_PROG_DI_ID_1      2
#define BM_IPU_DC_WR_CH_CONF_1_PROG_DI_ID_1      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_1_PROG_DI_ID_1(v)   ((((reg32_t) v) << 2) & BM_IPU_DC_WR_CH_CONF_1_PROG_DI_ID_1)
#else
#define BF_IPU_DC_WR_CH_CONF_1_PROG_DI_ID_1(v)   (((v) << 2) & BM_IPU_DC_WR_CH_CONF_1_PROG_DI_ID_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_DI_ID_1 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_1_PROG_DI_ID_1(v)   BF_CS1(IPU_DC_WR_CH_CONF_1, PROG_DI_ID_1, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_1, field PROG_DISP_ID_1 (RW)
 *
 * The field defines which one of the 4 displays is associated with channel #1.
 *
 * Values:
 * 00 - display #0
 * 01 - display #1
 * 10 - display #2
 * 11 - display #3
 */

#define BP_IPU_DC_WR_CH_CONF_1_PROG_DISP_ID_1      3
#define BM_IPU_DC_WR_CH_CONF_1_PROG_DISP_ID_1      0x00000018

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_1_PROG_DISP_ID_1(v)   ((((reg32_t) v) << 3) & BM_IPU_DC_WR_CH_CONF_1_PROG_DISP_ID_1)
#else
#define BF_IPU_DC_WR_CH_CONF_1_PROG_DISP_ID_1(v)   (((v) << 3) & BM_IPU_DC_WR_CH_CONF_1_PROG_DISP_ID_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_DISP_ID_1 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_1_PROG_DISP_ID_1(v)   BF_CS1(IPU_DC_WR_CH_CONF_1, PROG_DISP_ID_1, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_1, field PROG_CHAN_TYP_1 (RW)
 *
 * This field define the mode of operation of channel #1
 *
 * Values:
 * 000 - Disable
 * 001 - Reserved
 * 010 - Reserved
 * 100 - Normal mode without anti-tearing. For sync display this is the only mode allowed
 * 101 - Normal mode with anti-tearing
 * 110 - Reserved
 * 111 - Additional command channel is added to the flow handled by DC channel #1
 */

#define BP_IPU_DC_WR_CH_CONF_1_PROG_CHAN_TYP_1      5
#define BM_IPU_DC_WR_CH_CONF_1_PROG_CHAN_TYP_1      0x000000e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_1_PROG_CHAN_TYP_1(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_WR_CH_CONF_1_PROG_CHAN_TYP_1)
#else
#define BF_IPU_DC_WR_CH_CONF_1_PROG_CHAN_TYP_1(v)   (((v) << 5) & BM_IPU_DC_WR_CH_CONF_1_PROG_CHAN_TYP_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_CHAN_TYP_1 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_1_PROG_CHAN_TYP_1(v)   BF_CS1(IPU_DC_WR_CH_CONF_1, PROG_CHAN_TYP_1, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_1, field CHAN_MASK_DEFAULT_1 (RW)
 *
 * Event mask bit for channel #1 When more then one event is used during a flow (EOF, EOL, NL, NF,
 * EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority
 * event
 *
 * Values:
 * 1 - All the events are used - no mask
 * 0 - Only the highest priority event is used, the rest are masked
 */

#define BP_IPU_DC_WR_CH_CONF_1_CHAN_MASK_DEFAULT_1      8
#define BM_IPU_DC_WR_CH_CONF_1_CHAN_MASK_DEFAULT_1      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_1_CHAN_MASK_DEFAULT_1(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_WR_CH_CONF_1_CHAN_MASK_DEFAULT_1)
#else
#define BF_IPU_DC_WR_CH_CONF_1_CHAN_MASK_DEFAULT_1(v)   (((v) << 8) & BM_IPU_DC_WR_CH_CONF_1_CHAN_MASK_DEFAULT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CHAN_MASK_DEFAULT_1 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_1_CHAN_MASK_DEFAULT_1(v)   BF_CS1(IPU_DC_WR_CH_CONF_1, CHAN_MASK_DEFAULT_1, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_1, field FIELD_MODE_1 (RW)
 *
 * Field mode bit for channel #1 This bit defines if the channel works in field mode or frame mode;
 * This bit is relevant if the flow is sync flow
 *
 * Values:
 * 1 - Field mode
 * 0 - Frame mode
 */

#define BP_IPU_DC_WR_CH_CONF_1_FIELD_MODE_1      9
#define BM_IPU_DC_WR_CH_CONF_1_FIELD_MODE_1      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_1_FIELD_MODE_1(v)   ((((reg32_t) v) << 9) & BM_IPU_DC_WR_CH_CONF_1_FIELD_MODE_1)
#else
#define BF_IPU_DC_WR_CH_CONF_1_FIELD_MODE_1(v)   (((v) << 9) & BM_IPU_DC_WR_CH_CONF_1_FIELD_MODE_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the FIELD_MODE_1 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_1_FIELD_MODE_1(v)   BF_CS1(IPU_DC_WR_CH_CONF_1, FIELD_MODE_1, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_1, field PROG_START_TIME_1 (RW)
 *
 * This field defines the delay between display 's vertical synchronization pulse and the start time
 * point of DC's channel 1 window. The delay is defined in pairs of rows. It is used for tearing
 * elimination
 */

#define BP_IPU_DC_WR_CH_CONF_1_PROG_START_TIME_1      16
#define BM_IPU_DC_WR_CH_CONF_1_PROG_START_TIME_1      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_1_PROG_START_TIME_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_WR_CH_CONF_1_PROG_START_TIME_1)
#else
#define BF_IPU_DC_WR_CH_CONF_1_PROG_START_TIME_1(v)   (((v) << 16) & BM_IPU_DC_WR_CH_CONF_1_PROG_START_TIME_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_START_TIME_1 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_1_PROG_START_TIME_1(v)   BF_CS1(IPU_DC_WR_CH_CONF_1, PROG_START_TIME_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL2_CH_0 - DC Routine Link Register2 Channel 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_EOL_PRIORITY_CHAN_0 : 4; //!< This field defines the priority of the end-of-line event (EOL) event The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_EOL_START_CHAN_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end-of-line event (EOL) resides
        unsigned COD_EOFIELD_PRIORITY_CHAN_0 : 4; //!< This field defines the priority of the end-of-field event The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_EOFIELD_START_CHAN_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end-of-field event resides
    } B;
} hw_ipu_dc_rl2_ch_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL2_CH_0 register
 */
#define HW_IPU_DC_RL2_CH_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x58020)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL2_CH_0(x)           (*(volatile hw_ipu_dc_rl2_ch_0_t *) HW_IPU_DC_RL2_CH_0_ADDR(x))
#define HW_IPU_DC_RL2_CH_0_RD(x)        (HW_IPU_DC_RL2_CH_0(x).U)
#define HW_IPU_DC_RL2_CH_0_WR(x, v)     (HW_IPU_DC_RL2_CH_0(x).U = (v))
#define HW_IPU_DC_RL2_CH_0_SET(x, v)    (HW_IPU_DC_RL2_CH_0_WR(x, HW_IPU_DC_RL2_CH_0_RD(x) |  (v)))
#define HW_IPU_DC_RL2_CH_0_CLR(x, v)    (HW_IPU_DC_RL2_CH_0_WR(x, HW_IPU_DC_RL2_CH_0_RD(x) & ~(v)))
#define HW_IPU_DC_RL2_CH_0_TOG(x, v)    (HW_IPU_DC_RL2_CH_0_WR(x, HW_IPU_DC_RL2_CH_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL2_CH_0 bitfields
 */

/* --- Register HW_IPU_DC_RL2_CH_0, field COD_EOL_PRIORITY_CHAN_0 (RW)
 *
 * This field defines the priority of the end-of-line event (EOL) event The priority between the
 * events should be set to a unique value. i.e. two events must not have the same priority (except
 * 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL2_CH_0_COD_EOL_PRIORITY_CHAN_0      0
#define BM_IPU_DC_RL2_CH_0_COD_EOL_PRIORITY_CHAN_0      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_0_COD_EOL_PRIORITY_CHAN_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL2_CH_0_COD_EOL_PRIORITY_CHAN_0)
#else
#define BF_IPU_DC_RL2_CH_0_COD_EOL_PRIORITY_CHAN_0(v)   (((v) << 0) & BM_IPU_DC_RL2_CH_0_COD_EOL_PRIORITY_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOL_PRIORITY_CHAN_0 field to a new value.
#define BW_IPU_DC_RL2_CH_0_COD_EOL_PRIORITY_CHAN_0(v)   BF_CS1(IPU_DC_RL2_CH_0, COD_EOL_PRIORITY_CHAN_0, v)
#endif


/* --- Register HW_IPU_DC_RL2_CH_0, field COD_EOL_START_CHAN_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end-of-line event (EOL) resides
 */

#define BP_IPU_DC_RL2_CH_0_COD_EOL_START_CHAN_0      8
#define BM_IPU_DC_RL2_CH_0_COD_EOL_START_CHAN_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_0_COD_EOL_START_CHAN_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL2_CH_0_COD_EOL_START_CHAN_0)
#else
#define BF_IPU_DC_RL2_CH_0_COD_EOL_START_CHAN_0(v)   (((v) << 8) & BM_IPU_DC_RL2_CH_0_COD_EOL_START_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOL_START_CHAN_0 field to a new value.
#define BW_IPU_DC_RL2_CH_0_COD_EOL_START_CHAN_0(v)   BF_CS1(IPU_DC_RL2_CH_0, COD_EOL_START_CHAN_0, v)
#endif

/* --- Register HW_IPU_DC_RL2_CH_0, field COD_EOFIELD_PRIORITY_CHAN_0 (RW)
 *
 * This field defines the priority of the end-of-field event The priority between the events should
 * be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL2_CH_0_COD_EOFIELD_PRIORITY_CHAN_0      16
#define BM_IPU_DC_RL2_CH_0_COD_EOFIELD_PRIORITY_CHAN_0      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_0_COD_EOFIELD_PRIORITY_CHAN_0(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL2_CH_0_COD_EOFIELD_PRIORITY_CHAN_0)
#else
#define BF_IPU_DC_RL2_CH_0_COD_EOFIELD_PRIORITY_CHAN_0(v)   (((v) << 16) & BM_IPU_DC_RL2_CH_0_COD_EOFIELD_PRIORITY_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOFIELD_PRIORITY_CHAN_0 field to a new value.
#define BW_IPU_DC_RL2_CH_0_COD_EOFIELD_PRIORITY_CHAN_0(v)   BF_CS1(IPU_DC_RL2_CH_0, COD_EOFIELD_PRIORITY_CHAN_0, v)
#endif


/* --- Register HW_IPU_DC_RL2_CH_0, field COD_EOFIELD_START_CHAN_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end-of-field event resides
 */

#define BP_IPU_DC_RL2_CH_0_COD_EOFIELD_START_CHAN_0      24
#define BM_IPU_DC_RL2_CH_0_COD_EOFIELD_START_CHAN_0      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_0_COD_EOFIELD_START_CHAN_0(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL2_CH_0_COD_EOFIELD_START_CHAN_0)
#else
#define BF_IPU_DC_RL2_CH_0_COD_EOFIELD_START_CHAN_0(v)   (((v) << 24) & BM_IPU_DC_RL2_CH_0_COD_EOFIELD_START_CHAN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOFIELD_START_CHAN_0 field to a new value.
#define BW_IPU_DC_RL2_CH_0_COD_EOFIELD_START_CHAN_0(v)   BF_CS1(IPU_DC_RL2_CH_0, COD_EOFIELD_START_CHAN_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL0_CH_1 - DC Routine Link Register 0 Channel 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NF_PRIORITY_CHAN_1 : 4; //!< This field defines the priority of the new frame event (associated with channel #1) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NF_START_CHAN_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new frame event resides (associated with channel #1)
        unsigned COD_NL_PRIORITY_CHAN_1 : 4; //!< This field defines the priority of the new line event (associated with channel #1) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NL_START_CHAN_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new line event resides (associated with channel #1)
    } B;
} hw_ipu_dc_rl0_ch_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL0_CH_1 register
 */
#define HW_IPU_DC_RL0_CH_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x58024)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL0_CH_1(x)           (*(volatile hw_ipu_dc_rl0_ch_1_t *) HW_IPU_DC_RL0_CH_1_ADDR(x))
#define HW_IPU_DC_RL0_CH_1_RD(x)        (HW_IPU_DC_RL0_CH_1(x).U)
#define HW_IPU_DC_RL0_CH_1_WR(x, v)     (HW_IPU_DC_RL0_CH_1(x).U = (v))
#define HW_IPU_DC_RL0_CH_1_SET(x, v)    (HW_IPU_DC_RL0_CH_1_WR(x, HW_IPU_DC_RL0_CH_1_RD(x) |  (v)))
#define HW_IPU_DC_RL0_CH_1_CLR(x, v)    (HW_IPU_DC_RL0_CH_1_WR(x, HW_IPU_DC_RL0_CH_1_RD(x) & ~(v)))
#define HW_IPU_DC_RL0_CH_1_TOG(x, v)    (HW_IPU_DC_RL0_CH_1_WR(x, HW_IPU_DC_RL0_CH_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL0_CH_1 bitfields
 */

/* --- Register HW_IPU_DC_RL0_CH_1, field COD_NF_PRIORITY_CHAN_1 (RW)
 *
 * This field defines the priority of the new frame event (associated with channel #1) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL0_CH_1_COD_NF_PRIORITY_CHAN_1      0
#define BM_IPU_DC_RL0_CH_1_COD_NF_PRIORITY_CHAN_1      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_1_COD_NF_PRIORITY_CHAN_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL0_CH_1_COD_NF_PRIORITY_CHAN_1)
#else
#define BF_IPU_DC_RL0_CH_1_COD_NF_PRIORITY_CHAN_1(v)   (((v) << 0) & BM_IPU_DC_RL0_CH_1_COD_NF_PRIORITY_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NF_PRIORITY_CHAN_1 field to a new value.
#define BW_IPU_DC_RL0_CH_1_COD_NF_PRIORITY_CHAN_1(v)   BF_CS1(IPU_DC_RL0_CH_1, COD_NF_PRIORITY_CHAN_1, v)
#endif


/* --- Register HW_IPU_DC_RL0_CH_1, field COD_NF_START_CHAN_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new frame event resides (associated with channel #1)
 */

#define BP_IPU_DC_RL0_CH_1_COD_NF_START_CHAN_1      8
#define BM_IPU_DC_RL0_CH_1_COD_NF_START_CHAN_1      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_1_COD_NF_START_CHAN_1(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL0_CH_1_COD_NF_START_CHAN_1)
#else
#define BF_IPU_DC_RL0_CH_1_COD_NF_START_CHAN_1(v)   (((v) << 8) & BM_IPU_DC_RL0_CH_1_COD_NF_START_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NF_START_CHAN_1 field to a new value.
#define BW_IPU_DC_RL0_CH_1_COD_NF_START_CHAN_1(v)   BF_CS1(IPU_DC_RL0_CH_1, COD_NF_START_CHAN_1, v)
#endif

/* --- Register HW_IPU_DC_RL0_CH_1, field COD_NL_PRIORITY_CHAN_1 (RW)
 *
 * This field defines the priority of the new line event (associated with channel #1) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL0_CH_1_COD_NL_PRIORITY_CHAN_1      16
#define BM_IPU_DC_RL0_CH_1_COD_NL_PRIORITY_CHAN_1      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_1_COD_NL_PRIORITY_CHAN_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL0_CH_1_COD_NL_PRIORITY_CHAN_1)
#else
#define BF_IPU_DC_RL0_CH_1_COD_NL_PRIORITY_CHAN_1(v)   (((v) << 16) & BM_IPU_DC_RL0_CH_1_COD_NL_PRIORITY_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NL_PRIORITY_CHAN_1 field to a new value.
#define BW_IPU_DC_RL0_CH_1_COD_NL_PRIORITY_CHAN_1(v)   BF_CS1(IPU_DC_RL0_CH_1, COD_NL_PRIORITY_CHAN_1, v)
#endif


/* --- Register HW_IPU_DC_RL0_CH_1, field COD_NL_START_CHAN_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new line event resides (associated with channel #1)
 */

#define BP_IPU_DC_RL0_CH_1_COD_NL_START_CHAN_1      24
#define BM_IPU_DC_RL0_CH_1_COD_NL_START_CHAN_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_1_COD_NL_START_CHAN_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL0_CH_1_COD_NL_START_CHAN_1)
#else
#define BF_IPU_DC_RL0_CH_1_COD_NL_START_CHAN_1(v)   (((v) << 24) & BM_IPU_DC_RL0_CH_1_COD_NL_START_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NL_START_CHAN_1 field to a new value.
#define BW_IPU_DC_RL0_CH_1_COD_NL_START_CHAN_1(v)   BF_CS1(IPU_DC_RL0_CH_1, COD_NL_START_CHAN_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL1_CH_1 - DC Routine Link Register 1 Channel 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_EOF_PRIORITY_CHAN_1 : 4; //!< This field defines the priority of the end of frame event (associated with channel #1) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_EOF_START_CHAN_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end of frame event resides (associated with channel #1)
        unsigned COD_NFIELD_PRIORITY_CHAN_1 : 4; //!< This field defines the priority of the new field event (associated with channel #1) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NFIELD_START_CHAN_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new field event resides (associated with channel #1)
    } B;
} hw_ipu_dc_rl1_ch_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL1_CH_1 register
 */
#define HW_IPU_DC_RL1_CH_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x58028)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL1_CH_1(x)           (*(volatile hw_ipu_dc_rl1_ch_1_t *) HW_IPU_DC_RL1_CH_1_ADDR(x))
#define HW_IPU_DC_RL1_CH_1_RD(x)        (HW_IPU_DC_RL1_CH_1(x).U)
#define HW_IPU_DC_RL1_CH_1_WR(x, v)     (HW_IPU_DC_RL1_CH_1(x).U = (v))
#define HW_IPU_DC_RL1_CH_1_SET(x, v)    (HW_IPU_DC_RL1_CH_1_WR(x, HW_IPU_DC_RL1_CH_1_RD(x) |  (v)))
#define HW_IPU_DC_RL1_CH_1_CLR(x, v)    (HW_IPU_DC_RL1_CH_1_WR(x, HW_IPU_DC_RL1_CH_1_RD(x) & ~(v)))
#define HW_IPU_DC_RL1_CH_1_TOG(x, v)    (HW_IPU_DC_RL1_CH_1_WR(x, HW_IPU_DC_RL1_CH_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL1_CH_1 bitfields
 */

/* --- Register HW_IPU_DC_RL1_CH_1, field COD_EOF_PRIORITY_CHAN_1 (RW)
 *
 * This field defines the priority of the end of frame event (associated with channel #1) The
 * priority between the events should be set to a unique value. i.e. two events must not have the
 * same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL1_CH_1_COD_EOF_PRIORITY_CHAN_1      0
#define BM_IPU_DC_RL1_CH_1_COD_EOF_PRIORITY_CHAN_1      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_1_COD_EOF_PRIORITY_CHAN_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL1_CH_1_COD_EOF_PRIORITY_CHAN_1)
#else
#define BF_IPU_DC_RL1_CH_1_COD_EOF_PRIORITY_CHAN_1(v)   (((v) << 0) & BM_IPU_DC_RL1_CH_1_COD_EOF_PRIORITY_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOF_PRIORITY_CHAN_1 field to a new value.
#define BW_IPU_DC_RL1_CH_1_COD_EOF_PRIORITY_CHAN_1(v)   BF_CS1(IPU_DC_RL1_CH_1, COD_EOF_PRIORITY_CHAN_1, v)
#endif


/* --- Register HW_IPU_DC_RL1_CH_1, field COD_EOF_START_CHAN_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end of frame event resides (associated with channel #1)
 */

#define BP_IPU_DC_RL1_CH_1_COD_EOF_START_CHAN_1      8
#define BM_IPU_DC_RL1_CH_1_COD_EOF_START_CHAN_1      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_1_COD_EOF_START_CHAN_1(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL1_CH_1_COD_EOF_START_CHAN_1)
#else
#define BF_IPU_DC_RL1_CH_1_COD_EOF_START_CHAN_1(v)   (((v) << 8) & BM_IPU_DC_RL1_CH_1_COD_EOF_START_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOF_START_CHAN_1 field to a new value.
#define BW_IPU_DC_RL1_CH_1_COD_EOF_START_CHAN_1(v)   BF_CS1(IPU_DC_RL1_CH_1, COD_EOF_START_CHAN_1, v)
#endif

/* --- Register HW_IPU_DC_RL1_CH_1, field COD_NFIELD_PRIORITY_CHAN_1 (RW)
 *
 * This field defines the priority of the new field event (associated with channel #1) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL1_CH_1_COD_NFIELD_PRIORITY_CHAN_1      16
#define BM_IPU_DC_RL1_CH_1_COD_NFIELD_PRIORITY_CHAN_1      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_1_COD_NFIELD_PRIORITY_CHAN_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL1_CH_1_COD_NFIELD_PRIORITY_CHAN_1)
#else
#define BF_IPU_DC_RL1_CH_1_COD_NFIELD_PRIORITY_CHAN_1(v)   (((v) << 16) & BM_IPU_DC_RL1_CH_1_COD_NFIELD_PRIORITY_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NFIELD_PRIORITY_CHAN_1 field to a new value.
#define BW_IPU_DC_RL1_CH_1_COD_NFIELD_PRIORITY_CHAN_1(v)   BF_CS1(IPU_DC_RL1_CH_1, COD_NFIELD_PRIORITY_CHAN_1, v)
#endif


/* --- Register HW_IPU_DC_RL1_CH_1, field COD_NFIELD_START_CHAN_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new field event resides (associated with channel #1)
 */

#define BP_IPU_DC_RL1_CH_1_COD_NFIELD_START_CHAN_1      24
#define BM_IPU_DC_RL1_CH_1_COD_NFIELD_START_CHAN_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_1_COD_NFIELD_START_CHAN_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL1_CH_1_COD_NFIELD_START_CHAN_1)
#else
#define BF_IPU_DC_RL1_CH_1_COD_NFIELD_START_CHAN_1(v)   (((v) << 24) & BM_IPU_DC_RL1_CH_1_COD_NFIELD_START_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NFIELD_START_CHAN_1 field to a new value.
#define BW_IPU_DC_RL1_CH_1_COD_NFIELD_START_CHAN_1(v)   BF_CS1(IPU_DC_RL1_CH_1, COD_NFIELD_START_CHAN_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL2_CH_1 - DC Routine Link Register 2 Channel 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_EOL_PRIORITY_CHAN_1 : 4; //!< This field defines the priority of the end of line event (associated with channel #1) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_EOL_START_CHAN_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end of line event resides (associated with channel #1)
        unsigned COD_EOFIELD_PRIORITY_CHAN_1 : 4; //!< This field defines the priority of the end of field event (associated with channel #1) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_EOFIELD_START_CHAN_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end of field event resides (associated with channel #1)
    } B;
} hw_ipu_dc_rl2_ch_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL2_CH_1 register
 */
#define HW_IPU_DC_RL2_CH_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x58030)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL2_CH_1(x)           (*(volatile hw_ipu_dc_rl2_ch_1_t *) HW_IPU_DC_RL2_CH_1_ADDR(x))
#define HW_IPU_DC_RL2_CH_1_RD(x)        (HW_IPU_DC_RL2_CH_1(x).U)
#define HW_IPU_DC_RL2_CH_1_WR(x, v)     (HW_IPU_DC_RL2_CH_1(x).U = (v))
#define HW_IPU_DC_RL2_CH_1_SET(x, v)    (HW_IPU_DC_RL2_CH_1_WR(x, HW_IPU_DC_RL2_CH_1_RD(x) |  (v)))
#define HW_IPU_DC_RL2_CH_1_CLR(x, v)    (HW_IPU_DC_RL2_CH_1_WR(x, HW_IPU_DC_RL2_CH_1_RD(x) & ~(v)))
#define HW_IPU_DC_RL2_CH_1_TOG(x, v)    (HW_IPU_DC_RL2_CH_1_WR(x, HW_IPU_DC_RL2_CH_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL2_CH_1 bitfields
 */

/* --- Register HW_IPU_DC_RL2_CH_1, field COD_EOL_PRIORITY_CHAN_1 (RW)
 *
 * This field defines the priority of the end of line event (associated with channel #1) The
 * priority between the events should be set to a unique value. i.e. two events must not have the
 * same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL2_CH_1_COD_EOL_PRIORITY_CHAN_1      0
#define BM_IPU_DC_RL2_CH_1_COD_EOL_PRIORITY_CHAN_1      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_1_COD_EOL_PRIORITY_CHAN_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL2_CH_1_COD_EOL_PRIORITY_CHAN_1)
#else
#define BF_IPU_DC_RL2_CH_1_COD_EOL_PRIORITY_CHAN_1(v)   (((v) << 0) & BM_IPU_DC_RL2_CH_1_COD_EOL_PRIORITY_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOL_PRIORITY_CHAN_1 field to a new value.
#define BW_IPU_DC_RL2_CH_1_COD_EOL_PRIORITY_CHAN_1(v)   BF_CS1(IPU_DC_RL2_CH_1, COD_EOL_PRIORITY_CHAN_1, v)
#endif


/* --- Register HW_IPU_DC_RL2_CH_1, field COD_EOL_START_CHAN_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end of line event resides (associated with channel #1)
 */

#define BP_IPU_DC_RL2_CH_1_COD_EOL_START_CHAN_1      8
#define BM_IPU_DC_RL2_CH_1_COD_EOL_START_CHAN_1      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_1_COD_EOL_START_CHAN_1(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL2_CH_1_COD_EOL_START_CHAN_1)
#else
#define BF_IPU_DC_RL2_CH_1_COD_EOL_START_CHAN_1(v)   (((v) << 8) & BM_IPU_DC_RL2_CH_1_COD_EOL_START_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOL_START_CHAN_1 field to a new value.
#define BW_IPU_DC_RL2_CH_1_COD_EOL_START_CHAN_1(v)   BF_CS1(IPU_DC_RL2_CH_1, COD_EOL_START_CHAN_1, v)
#endif

/* --- Register HW_IPU_DC_RL2_CH_1, field COD_EOFIELD_PRIORITY_CHAN_1 (RW)
 *
 * This field defines the priority of the end of field event (associated with channel #1) The
 * priority between the events should be set to a unique value. i.e. two events must not have the
 * same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL2_CH_1_COD_EOFIELD_PRIORITY_CHAN_1      16
#define BM_IPU_DC_RL2_CH_1_COD_EOFIELD_PRIORITY_CHAN_1      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_1_COD_EOFIELD_PRIORITY_CHAN_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL2_CH_1_COD_EOFIELD_PRIORITY_CHAN_1)
#else
#define BF_IPU_DC_RL2_CH_1_COD_EOFIELD_PRIORITY_CHAN_1(v)   (((v) << 16) & BM_IPU_DC_RL2_CH_1_COD_EOFIELD_PRIORITY_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOFIELD_PRIORITY_CHAN_1 field to a new value.
#define BW_IPU_DC_RL2_CH_1_COD_EOFIELD_PRIORITY_CHAN_1(v)   BF_CS1(IPU_DC_RL2_CH_1, COD_EOFIELD_PRIORITY_CHAN_1, v)
#endif


/* --- Register HW_IPU_DC_RL2_CH_1, field COD_EOFIELD_START_CHAN_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end of field event resides (associated with channel #1)
 */

#define BP_IPU_DC_RL2_CH_1_COD_EOFIELD_START_CHAN_1      24
#define BM_IPU_DC_RL2_CH_1_COD_EOFIELD_START_CHAN_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_1_COD_EOFIELD_START_CHAN_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL2_CH_1_COD_EOFIELD_START_CHAN_1)
#else
#define BF_IPU_DC_RL2_CH_1_COD_EOFIELD_START_CHAN_1(v)   (((v) << 24) & BM_IPU_DC_RL2_CH_1_COD_EOFIELD_START_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOFIELD_START_CHAN_1 field to a new value.
#define BW_IPU_DC_RL2_CH_1_COD_EOFIELD_START_CHAN_1(v)   BF_CS1(IPU_DC_RL2_CH_1, COD_EOFIELD_START_CHAN_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL3_CH_1 - DC Routine Link Register 3 Channel 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_ADDR_PRIORITY_CHAN_1 : 4; //!< This field defines the priority of the new address event (associated with channel #1) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #1)
        unsigned COD_NEW_CHAN_PRIORITY_CHAN_1 : 4; //!< This field defines the priority of the new channel event (associated with channel #1) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #1)
    } B;
} hw_ipu_dc_rl3_ch_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL3_CH_1 register
 */
#define HW_IPU_DC_RL3_CH_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x58032)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL3_CH_1(x)           (*(volatile hw_ipu_dc_rl3_ch_1_t *) HW_IPU_DC_RL3_CH_1_ADDR(x))
#define HW_IPU_DC_RL3_CH_1_RD(x)        (HW_IPU_DC_RL3_CH_1(x).U)
#define HW_IPU_DC_RL3_CH_1_WR(x, v)     (HW_IPU_DC_RL3_CH_1(x).U = (v))
#define HW_IPU_DC_RL3_CH_1_SET(x, v)    (HW_IPU_DC_RL3_CH_1_WR(x, HW_IPU_DC_RL3_CH_1_RD(x) |  (v)))
#define HW_IPU_DC_RL3_CH_1_CLR(x, v)    (HW_IPU_DC_RL3_CH_1_WR(x, HW_IPU_DC_RL3_CH_1_RD(x) & ~(v)))
#define HW_IPU_DC_RL3_CH_1_TOG(x, v)    (HW_IPU_DC_RL3_CH_1_WR(x, HW_IPU_DC_RL3_CH_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL3_CH_1 bitfields
 */

/* --- Register HW_IPU_DC_RL3_CH_1, field COD_NEW_ADDR_PRIORITY_CHAN_1 (RW)
 *
 * This field defines the priority of the new address event (associated with channel #1) The
 * priority between the events should be set to a unique value. i.e. two events must not have the
 * same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL3_CH_1_COD_NEW_ADDR_PRIORITY_CHAN_1      0
#define BM_IPU_DC_RL3_CH_1_COD_NEW_ADDR_PRIORITY_CHAN_1      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_1_COD_NEW_ADDR_PRIORITY_CHAN_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL3_CH_1_COD_NEW_ADDR_PRIORITY_CHAN_1)
#else
#define BF_IPU_DC_RL3_CH_1_COD_NEW_ADDR_PRIORITY_CHAN_1(v)   (((v) << 0) & BM_IPU_DC_RL3_CH_1_COD_NEW_ADDR_PRIORITY_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_PRIORITY_CHAN_1 field to a new value.
#define BW_IPU_DC_RL3_CH_1_COD_NEW_ADDR_PRIORITY_CHAN_1(v)   BF_CS1(IPU_DC_RL3_CH_1, COD_NEW_ADDR_PRIORITY_CHAN_1, v)
#endif


/* --- Register HW_IPU_DC_RL3_CH_1, field COD_NEW_ADDR_START_CHAN_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides (associated with channel #1)
 */

#define BP_IPU_DC_RL3_CH_1_COD_NEW_ADDR_START_CHAN_1      8
#define BM_IPU_DC_RL3_CH_1_COD_NEW_ADDR_START_CHAN_1      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_1_COD_NEW_ADDR_START_CHAN_1(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL3_CH_1_COD_NEW_ADDR_START_CHAN_1)
#else
#define BF_IPU_DC_RL3_CH_1_COD_NEW_ADDR_START_CHAN_1(v)   (((v) << 8) & BM_IPU_DC_RL3_CH_1_COD_NEW_ADDR_START_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_1 field to a new value.
#define BW_IPU_DC_RL3_CH_1_COD_NEW_ADDR_START_CHAN_1(v)   BF_CS1(IPU_DC_RL3_CH_1, COD_NEW_ADDR_START_CHAN_1, v)
#endif

/* --- Register HW_IPU_DC_RL3_CH_1, field COD_NEW_CHAN_PRIORITY_CHAN_1 (RW)
 *
 * This field defines the priority of the new channel event (associated with channel #1) The
 * priority between the events should be set to a unique value. i.e. two events must not have the
 * same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL3_CH_1_COD_NEW_CHAN_PRIORITY_CHAN_1      16
#define BM_IPU_DC_RL3_CH_1_COD_NEW_CHAN_PRIORITY_CHAN_1      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_1_COD_NEW_CHAN_PRIORITY_CHAN_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL3_CH_1_COD_NEW_CHAN_PRIORITY_CHAN_1)
#else
#define BF_IPU_DC_RL3_CH_1_COD_NEW_CHAN_PRIORITY_CHAN_1(v)   (((v) << 16) & BM_IPU_DC_RL3_CH_1_COD_NEW_CHAN_PRIORITY_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_PRIORITY_CHAN_1 field to a new value.
#define BW_IPU_DC_RL3_CH_1_COD_NEW_CHAN_PRIORITY_CHAN_1(v)   BF_CS1(IPU_DC_RL3_CH_1, COD_NEW_CHAN_PRIORITY_CHAN_1, v)
#endif


/* --- Register HW_IPU_DC_RL3_CH_1, field COD_NEW_CHAN_START_CHAN_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides (associated with channel #1)
 */

#define BP_IPU_DC_RL3_CH_1_COD_NEW_CHAN_START_CHAN_1      24
#define BM_IPU_DC_RL3_CH_1_COD_NEW_CHAN_START_CHAN_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_1_COD_NEW_CHAN_START_CHAN_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL3_CH_1_COD_NEW_CHAN_START_CHAN_1)
#else
#define BF_IPU_DC_RL3_CH_1_COD_NEW_CHAN_START_CHAN_1(v)   (((v) << 24) & BM_IPU_DC_RL3_CH_1_COD_NEW_CHAN_START_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_1 field to a new value.
#define BW_IPU_DC_RL3_CH_1_COD_NEW_CHAN_START_CHAN_1(v)   BF_CS1(IPU_DC_RL3_CH_1, COD_NEW_CHAN_START_CHAN_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL4_CH_1 - DC Routine Link Register 4 Channel 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_DATA_PRIORITY_CHAN_1 : 4; //!< This field defines the priority of the new data event (associated with channel #1) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #1)
        unsigned RESERVED1 : 16; //!< Reserved.
    } B;
} hw_ipu_dc_rl4_ch_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL4_CH_1 register
 */
#define HW_IPU_DC_RL4_CH_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x58034)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL4_CH_1(x)           (*(volatile hw_ipu_dc_rl4_ch_1_t *) HW_IPU_DC_RL4_CH_1_ADDR(x))
#define HW_IPU_DC_RL4_CH_1_RD(x)        (HW_IPU_DC_RL4_CH_1(x).U)
#define HW_IPU_DC_RL4_CH_1_WR(x, v)     (HW_IPU_DC_RL4_CH_1(x).U = (v))
#define HW_IPU_DC_RL4_CH_1_SET(x, v)    (HW_IPU_DC_RL4_CH_1_WR(x, HW_IPU_DC_RL4_CH_1_RD(x) |  (v)))
#define HW_IPU_DC_RL4_CH_1_CLR(x, v)    (HW_IPU_DC_RL4_CH_1_WR(x, HW_IPU_DC_RL4_CH_1_RD(x) & ~(v)))
#define HW_IPU_DC_RL4_CH_1_TOG(x, v)    (HW_IPU_DC_RL4_CH_1_WR(x, HW_IPU_DC_RL4_CH_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL4_CH_1 bitfields
 */

/* --- Register HW_IPU_DC_RL4_CH_1, field COD_NEW_DATA_PRIORITY_CHAN_1 (RW)
 *
 * This field defines the priority of the new data event (associated with channel #1) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL4_CH_1_COD_NEW_DATA_PRIORITY_CHAN_1      0
#define BM_IPU_DC_RL4_CH_1_COD_NEW_DATA_PRIORITY_CHAN_1      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_1_COD_NEW_DATA_PRIORITY_CHAN_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL4_CH_1_COD_NEW_DATA_PRIORITY_CHAN_1)
#else
#define BF_IPU_DC_RL4_CH_1_COD_NEW_DATA_PRIORITY_CHAN_1(v)   (((v) << 0) & BM_IPU_DC_RL4_CH_1_COD_NEW_DATA_PRIORITY_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_PRIORITY_CHAN_1 field to a new value.
#define BW_IPU_DC_RL4_CH_1_COD_NEW_DATA_PRIORITY_CHAN_1(v)   BF_CS1(IPU_DC_RL4_CH_1, COD_NEW_DATA_PRIORITY_CHAN_1, v)
#endif


/* --- Register HW_IPU_DC_RL4_CH_1, field COD_NEW_DATA_START_CHAN_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides (associated with channel #1)
 */

#define BP_IPU_DC_RL4_CH_1_COD_NEW_DATA_START_CHAN_1      8
#define BM_IPU_DC_RL4_CH_1_COD_NEW_DATA_START_CHAN_1      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_1_COD_NEW_DATA_START_CHAN_1(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL4_CH_1_COD_NEW_DATA_START_CHAN_1)
#else
#define BF_IPU_DC_RL4_CH_1_COD_NEW_DATA_START_CHAN_1(v)   (((v) << 8) & BM_IPU_DC_RL4_CH_1_COD_NEW_DATA_START_CHAN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_1 field to a new value.
#define BW_IPU_DC_RL4_CH_1_COD_NEW_DATA_START_CHAN_1(v)   BF_CS1(IPU_DC_RL4_CH_1, COD_NEW_DATA_START_CHAN_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_WR_CH_CONF_2 - DC Write Channel 2 Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned W_SIZE_2 : 2; //!< Word Size The data coming from the IDMAC is 32bit wide. This field defines the size of the word used by the DC
        unsigned PROG_DI_ID_2 : 1; //!< This bit select the DI which a transaction associated with channel #2 can be performed to
        unsigned PROG_DISP_ID_2 : 2; //!< The field defines which one of the 4 displays is associated with channel #2.
        unsigned PROG_CHAN_TYP_2 : 3; //!< This field define the mode of operation of channel #2
        unsigned CHAN_MASK_DEFAULT_2 : 1; //!< Event mask bit for channel #2 When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned PROG_START_TIME_2 : 11; //!< This field defines the delay between display 's vertical synchronization pulse and the start time point of DC's channel 2 window. The delay is defined in pairs of rows. It is used for tearing elimination
        unsigned RESERVED1 : 5; //!< Reserved.
    } B;
} hw_ipu_dc_wr_ch_conf_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_WR_CH_CONF_2 register
 */
#define HW_IPU_DC_WR_CH_CONF_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x58038)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_WR_CH_CONF_2(x)           (*(volatile hw_ipu_dc_wr_ch_conf_2_t *) HW_IPU_DC_WR_CH_CONF_2_ADDR(x))
#define HW_IPU_DC_WR_CH_CONF_2_RD(x)        (HW_IPU_DC_WR_CH_CONF_2(x).U)
#define HW_IPU_DC_WR_CH_CONF_2_WR(x, v)     (HW_IPU_DC_WR_CH_CONF_2(x).U = (v))
#define HW_IPU_DC_WR_CH_CONF_2_SET(x, v)    (HW_IPU_DC_WR_CH_CONF_2_WR(x, HW_IPU_DC_WR_CH_CONF_2_RD(x) |  (v)))
#define HW_IPU_DC_WR_CH_CONF_2_CLR(x, v)    (HW_IPU_DC_WR_CH_CONF_2_WR(x, HW_IPU_DC_WR_CH_CONF_2_RD(x) & ~(v)))
#define HW_IPU_DC_WR_CH_CONF_2_TOG(x, v)    (HW_IPU_DC_WR_CH_CONF_2_WR(x, HW_IPU_DC_WR_CH_CONF_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_WR_CH_CONF_2 bitfields
 */

/* --- Register HW_IPU_DC_WR_CH_CONF_2, field W_SIZE_2 (RW)
 *
 * Word Size The data coming from the IDMAC is 32bit wide. This field defines the size of the word
 * used by the DC
 *
 * Values:
 * 00 - 8 bits are used - a 32 bit words includes 4X8bit valid words.
 * 01 - 16 LSB bits - a 32 bit words includes 2 X16bit valid words.
 * 10 - 24 MSB bits are used (RGB) - 8 LSB bits are ignored by the DC
 * 11 - 32 bits are used
 */

#define BP_IPU_DC_WR_CH_CONF_2_W_SIZE_2      0
#define BM_IPU_DC_WR_CH_CONF_2_W_SIZE_2      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_2_W_SIZE_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_WR_CH_CONF_2_W_SIZE_2)
#else
#define BF_IPU_DC_WR_CH_CONF_2_W_SIZE_2(v)   (((v) << 0) & BM_IPU_DC_WR_CH_CONF_2_W_SIZE_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the W_SIZE_2 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_2_W_SIZE_2(v)   BF_CS1(IPU_DC_WR_CH_CONF_2, W_SIZE_2, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_2, field PROG_DI_ID_2 (RW)
 *
 * This bit select the DI which a transaction associated with channel #2 can be performed to
 *
 * Values:
 * 1 - DI #1
 * 0 - DI #0
 */

#define BP_IPU_DC_WR_CH_CONF_2_PROG_DI_ID_2      2
#define BM_IPU_DC_WR_CH_CONF_2_PROG_DI_ID_2      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_2_PROG_DI_ID_2(v)   ((((reg32_t) v) << 2) & BM_IPU_DC_WR_CH_CONF_2_PROG_DI_ID_2)
#else
#define BF_IPU_DC_WR_CH_CONF_2_PROG_DI_ID_2(v)   (((v) << 2) & BM_IPU_DC_WR_CH_CONF_2_PROG_DI_ID_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_DI_ID_2 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_2_PROG_DI_ID_2(v)   BF_CS1(IPU_DC_WR_CH_CONF_2, PROG_DI_ID_2, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_2, field PROG_DISP_ID_2 (RW)
 *
 * The field defines which one of the 4 displays is associated with channel #2.
 *
 * Values:
 * 00 - display #0
 * 01 - display #1
 * 10 - display #2
 * 11 - display #3
 */

#define BP_IPU_DC_WR_CH_CONF_2_PROG_DISP_ID_2      3
#define BM_IPU_DC_WR_CH_CONF_2_PROG_DISP_ID_2      0x00000018

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_2_PROG_DISP_ID_2(v)   ((((reg32_t) v) << 3) & BM_IPU_DC_WR_CH_CONF_2_PROG_DISP_ID_2)
#else
#define BF_IPU_DC_WR_CH_CONF_2_PROG_DISP_ID_2(v)   (((v) << 3) & BM_IPU_DC_WR_CH_CONF_2_PROG_DISP_ID_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_DISP_ID_2 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_2_PROG_DISP_ID_2(v)   BF_CS1(IPU_DC_WR_CH_CONF_2, PROG_DISP_ID_2, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_2, field PROG_CHAN_TYP_2 (RW)
 *
 * This field define the mode of operation of channel #2
 *
 * Values:
 * 000 - Disable
 * 001 - Reserved
 * 010 - Reserved
 * 100 - Normal mode without anti-tearing. For sync display this is the only mode allowed
 * 101 - Normal mode with anti-tearing
 * 110 - Reserved
 * 111 - Additional command channel is added to the flow handled by DC channel #2
 */

#define BP_IPU_DC_WR_CH_CONF_2_PROG_CHAN_TYP_2      5
#define BM_IPU_DC_WR_CH_CONF_2_PROG_CHAN_TYP_2      0x000000e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_2_PROG_CHAN_TYP_2(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_WR_CH_CONF_2_PROG_CHAN_TYP_2)
#else
#define BF_IPU_DC_WR_CH_CONF_2_PROG_CHAN_TYP_2(v)   (((v) << 5) & BM_IPU_DC_WR_CH_CONF_2_PROG_CHAN_TYP_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_CHAN_TYP_2 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_2_PROG_CHAN_TYP_2(v)   BF_CS1(IPU_DC_WR_CH_CONF_2, PROG_CHAN_TYP_2, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_2, field CHAN_MASK_DEFAULT_2 (RW)
 *
 * Event mask bit for channel #2 When more then one event is used during a flow (EOF, EOL, NL, NF,
 * EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority
 * event
 *
 * Values:
 * 1 - All the events are used - no mask
 * 0 - Only the highest priority event is used, the rest are masked
 */

#define BP_IPU_DC_WR_CH_CONF_2_CHAN_MASK_DEFAULT_2      8
#define BM_IPU_DC_WR_CH_CONF_2_CHAN_MASK_DEFAULT_2      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_2_CHAN_MASK_DEFAULT_2(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_WR_CH_CONF_2_CHAN_MASK_DEFAULT_2)
#else
#define BF_IPU_DC_WR_CH_CONF_2_CHAN_MASK_DEFAULT_2(v)   (((v) << 8) & BM_IPU_DC_WR_CH_CONF_2_CHAN_MASK_DEFAULT_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CHAN_MASK_DEFAULT_2 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_2_CHAN_MASK_DEFAULT_2(v)   BF_CS1(IPU_DC_WR_CH_CONF_2, CHAN_MASK_DEFAULT_2, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_2, field PROG_START_TIME_2 (RW)
 *
 * This field defines the delay between display 's vertical synchronization pulse and the start time
 * point of DC's channel 2 window. The delay is defined in pairs of rows. It is used for tearing
 * elimination
 */

#define BP_IPU_DC_WR_CH_CONF_2_PROG_START_TIME_2      16
#define BM_IPU_DC_WR_CH_CONF_2_PROG_START_TIME_2      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_2_PROG_START_TIME_2(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_WR_CH_CONF_2_PROG_START_TIME_2)
#else
#define BF_IPU_DC_WR_CH_CONF_2_PROG_START_TIME_2(v)   (((v) << 16) & BM_IPU_DC_WR_CH_CONF_2_PROG_START_TIME_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_START_TIME_2 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_2_PROG_START_TIME_2(v)   BF_CS1(IPU_DC_WR_CH_CONF_2, PROG_START_TIME_2, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_WR_CH_ADDR_2 - DC Write Channel 2 Address Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned ST_ADDR_2 : 29; //!< This field defines the start address within the display's memory space where the write transactions will be done to for channel #2.
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_wr_ch_addr_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_WR_CH_ADDR_2 register
 */
#define HW_IPU_DC_WR_CH_ADDR_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x5803c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_WR_CH_ADDR_2(x)           (*(volatile hw_ipu_dc_wr_ch_addr_2_t *) HW_IPU_DC_WR_CH_ADDR_2_ADDR(x))
#define HW_IPU_DC_WR_CH_ADDR_2_RD(x)        (HW_IPU_DC_WR_CH_ADDR_2(x).U)
#define HW_IPU_DC_WR_CH_ADDR_2_WR(x, v)     (HW_IPU_DC_WR_CH_ADDR_2(x).U = (v))
#define HW_IPU_DC_WR_CH_ADDR_2_SET(x, v)    (HW_IPU_DC_WR_CH_ADDR_2_WR(x, HW_IPU_DC_WR_CH_ADDR_2_RD(x) |  (v)))
#define HW_IPU_DC_WR_CH_ADDR_2_CLR(x, v)    (HW_IPU_DC_WR_CH_ADDR_2_WR(x, HW_IPU_DC_WR_CH_ADDR_2_RD(x) & ~(v)))
#define HW_IPU_DC_WR_CH_ADDR_2_TOG(x, v)    (HW_IPU_DC_WR_CH_ADDR_2_WR(x, HW_IPU_DC_WR_CH_ADDR_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_WR_CH_ADDR_2 bitfields
 */

/* --- Register HW_IPU_DC_WR_CH_ADDR_2, field ST_ADDR_2 (RW)
 *
 * This field defines the start address within the display's memory space where the write
 * transactions will be done to for channel #2.
 */

#define BP_IPU_DC_WR_CH_ADDR_2_ST_ADDR_2      0
#define BM_IPU_DC_WR_CH_ADDR_2_ST_ADDR_2      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_ADDR_2_ST_ADDR_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_WR_CH_ADDR_2_ST_ADDR_2)
#else
#define BF_IPU_DC_WR_CH_ADDR_2_ST_ADDR_2(v)   (((v) << 0) & BM_IPU_DC_WR_CH_ADDR_2_ST_ADDR_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ST_ADDR_2 field to a new value.
#define BW_IPU_DC_WR_CH_ADDR_2_ST_ADDR_2(v)   BF_CS1(IPU_DC_WR_CH_ADDR_2, ST_ADDR_2, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL0_CH_2 - DC Routine Link Register 0 Channel 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NF_PRIORITY_CHAN_2 : 4; //!< This field defines the priority of the new frame event (associated with channel #2) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NF_START_CHAN_2 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new frame event resides (associated with channel #2)
        unsigned COD_NL_PRIORITY_CHAN_2 : 4; //!< This field defines the priority of the new line event (associated with channel #2) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NL_START_CHAN_2 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new line event resides (associated with channel #2)
    } B;
} hw_ipu_dc_rl0_ch_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL0_CH_2 register
 */
#define HW_IPU_DC_RL0_CH_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x58040)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL0_CH_2(x)           (*(volatile hw_ipu_dc_rl0_ch_2_t *) HW_IPU_DC_RL0_CH_2_ADDR(x))
#define HW_IPU_DC_RL0_CH_2_RD(x)        (HW_IPU_DC_RL0_CH_2(x).U)
#define HW_IPU_DC_RL0_CH_2_WR(x, v)     (HW_IPU_DC_RL0_CH_2(x).U = (v))
#define HW_IPU_DC_RL0_CH_2_SET(x, v)    (HW_IPU_DC_RL0_CH_2_WR(x, HW_IPU_DC_RL0_CH_2_RD(x) |  (v)))
#define HW_IPU_DC_RL0_CH_2_CLR(x, v)    (HW_IPU_DC_RL0_CH_2_WR(x, HW_IPU_DC_RL0_CH_2_RD(x) & ~(v)))
#define HW_IPU_DC_RL0_CH_2_TOG(x, v)    (HW_IPU_DC_RL0_CH_2_WR(x, HW_IPU_DC_RL0_CH_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL0_CH_2 bitfields
 */

/* --- Register HW_IPU_DC_RL0_CH_2, field COD_NF_PRIORITY_CHAN_2 (RW)
 *
 * This field defines the priority of the new frame event (associated with channel #2) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL0_CH_2_COD_NF_PRIORITY_CHAN_2      0
#define BM_IPU_DC_RL0_CH_2_COD_NF_PRIORITY_CHAN_2      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_2_COD_NF_PRIORITY_CHAN_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL0_CH_2_COD_NF_PRIORITY_CHAN_2)
#else
#define BF_IPU_DC_RL0_CH_2_COD_NF_PRIORITY_CHAN_2(v)   (((v) << 0) & BM_IPU_DC_RL0_CH_2_COD_NF_PRIORITY_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NF_PRIORITY_CHAN_2 field to a new value.
#define BW_IPU_DC_RL0_CH_2_COD_NF_PRIORITY_CHAN_2(v)   BF_CS1(IPU_DC_RL0_CH_2, COD_NF_PRIORITY_CHAN_2, v)
#endif


/* --- Register HW_IPU_DC_RL0_CH_2, field COD_NF_START_CHAN_2 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new frame event resides (associated with channel #2)
 */

#define BP_IPU_DC_RL0_CH_2_COD_NF_START_CHAN_2      8
#define BM_IPU_DC_RL0_CH_2_COD_NF_START_CHAN_2      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_2_COD_NF_START_CHAN_2(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL0_CH_2_COD_NF_START_CHAN_2)
#else
#define BF_IPU_DC_RL0_CH_2_COD_NF_START_CHAN_2(v)   (((v) << 8) & BM_IPU_DC_RL0_CH_2_COD_NF_START_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NF_START_CHAN_2 field to a new value.
#define BW_IPU_DC_RL0_CH_2_COD_NF_START_CHAN_2(v)   BF_CS1(IPU_DC_RL0_CH_2, COD_NF_START_CHAN_2, v)
#endif

/* --- Register HW_IPU_DC_RL0_CH_2, field COD_NL_PRIORITY_CHAN_2 (RW)
 *
 * This field defines the priority of the new line event (associated with channel #2) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL0_CH_2_COD_NL_PRIORITY_CHAN_2      16
#define BM_IPU_DC_RL0_CH_2_COD_NL_PRIORITY_CHAN_2      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_2_COD_NL_PRIORITY_CHAN_2(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL0_CH_2_COD_NL_PRIORITY_CHAN_2)
#else
#define BF_IPU_DC_RL0_CH_2_COD_NL_PRIORITY_CHAN_2(v)   (((v) << 16) & BM_IPU_DC_RL0_CH_2_COD_NL_PRIORITY_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NL_PRIORITY_CHAN_2 field to a new value.
#define BW_IPU_DC_RL0_CH_2_COD_NL_PRIORITY_CHAN_2(v)   BF_CS1(IPU_DC_RL0_CH_2, COD_NL_PRIORITY_CHAN_2, v)
#endif


/* --- Register HW_IPU_DC_RL0_CH_2, field COD_NL_START_CHAN_2 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new line event resides (associated with channel #2)
 */

#define BP_IPU_DC_RL0_CH_2_COD_NL_START_CHAN_2      24
#define BM_IPU_DC_RL0_CH_2_COD_NL_START_CHAN_2      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_2_COD_NL_START_CHAN_2(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL0_CH_2_COD_NL_START_CHAN_2)
#else
#define BF_IPU_DC_RL0_CH_2_COD_NL_START_CHAN_2(v)   (((v) << 24) & BM_IPU_DC_RL0_CH_2_COD_NL_START_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NL_START_CHAN_2 field to a new value.
#define BW_IPU_DC_RL0_CH_2_COD_NL_START_CHAN_2(v)   BF_CS1(IPU_DC_RL0_CH_2, COD_NL_START_CHAN_2, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL1_CH_2 - DC Routine Link Register 1 Channel 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_EOF_PRIORITY_CHAN_2 : 4; //!< This field defines the priority of the end of frame event (associated with channel #2) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_EOF_START_CHAN_2 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end of frame event resides (associated with channel #2)
        unsigned COD_NFIELD_PRIORITY_CHAN_2 : 4; //!< This field defines the priority of the new field event (associated with channel #2) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NFIELD_START_CHAN_2 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new field event resides (associated with channel #2)
    } B;
} hw_ipu_dc_rl1_ch_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL1_CH_2 register
 */
#define HW_IPU_DC_RL1_CH_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x58044)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL1_CH_2(x)           (*(volatile hw_ipu_dc_rl1_ch_2_t *) HW_IPU_DC_RL1_CH_2_ADDR(x))
#define HW_IPU_DC_RL1_CH_2_RD(x)        (HW_IPU_DC_RL1_CH_2(x).U)
#define HW_IPU_DC_RL1_CH_2_WR(x, v)     (HW_IPU_DC_RL1_CH_2(x).U = (v))
#define HW_IPU_DC_RL1_CH_2_SET(x, v)    (HW_IPU_DC_RL1_CH_2_WR(x, HW_IPU_DC_RL1_CH_2_RD(x) |  (v)))
#define HW_IPU_DC_RL1_CH_2_CLR(x, v)    (HW_IPU_DC_RL1_CH_2_WR(x, HW_IPU_DC_RL1_CH_2_RD(x) & ~(v)))
#define HW_IPU_DC_RL1_CH_2_TOG(x, v)    (HW_IPU_DC_RL1_CH_2_WR(x, HW_IPU_DC_RL1_CH_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL1_CH_2 bitfields
 */

/* --- Register HW_IPU_DC_RL1_CH_2, field COD_EOF_PRIORITY_CHAN_2 (RW)
 *
 * This field defines the priority of the end of frame event (associated with channel #2) The
 * priority between the events should be set to a unique value. i.e. two events must not have the
 * same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL1_CH_2_COD_EOF_PRIORITY_CHAN_2      0
#define BM_IPU_DC_RL1_CH_2_COD_EOF_PRIORITY_CHAN_2      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_2_COD_EOF_PRIORITY_CHAN_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL1_CH_2_COD_EOF_PRIORITY_CHAN_2)
#else
#define BF_IPU_DC_RL1_CH_2_COD_EOF_PRIORITY_CHAN_2(v)   (((v) << 0) & BM_IPU_DC_RL1_CH_2_COD_EOF_PRIORITY_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOF_PRIORITY_CHAN_2 field to a new value.
#define BW_IPU_DC_RL1_CH_2_COD_EOF_PRIORITY_CHAN_2(v)   BF_CS1(IPU_DC_RL1_CH_2, COD_EOF_PRIORITY_CHAN_2, v)
#endif


/* --- Register HW_IPU_DC_RL1_CH_2, field COD_EOF_START_CHAN_2 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end of frame event resides (associated with channel #2)
 */

#define BP_IPU_DC_RL1_CH_2_COD_EOF_START_CHAN_2      8
#define BM_IPU_DC_RL1_CH_2_COD_EOF_START_CHAN_2      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_2_COD_EOF_START_CHAN_2(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL1_CH_2_COD_EOF_START_CHAN_2)
#else
#define BF_IPU_DC_RL1_CH_2_COD_EOF_START_CHAN_2(v)   (((v) << 8) & BM_IPU_DC_RL1_CH_2_COD_EOF_START_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOF_START_CHAN_2 field to a new value.
#define BW_IPU_DC_RL1_CH_2_COD_EOF_START_CHAN_2(v)   BF_CS1(IPU_DC_RL1_CH_2, COD_EOF_START_CHAN_2, v)
#endif

/* --- Register HW_IPU_DC_RL1_CH_2, field COD_NFIELD_PRIORITY_CHAN_2 (RW)
 *
 * This field defines the priority of the new field event (associated with channel #2) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL1_CH_2_COD_NFIELD_PRIORITY_CHAN_2      16
#define BM_IPU_DC_RL1_CH_2_COD_NFIELD_PRIORITY_CHAN_2      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_2_COD_NFIELD_PRIORITY_CHAN_2(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL1_CH_2_COD_NFIELD_PRIORITY_CHAN_2)
#else
#define BF_IPU_DC_RL1_CH_2_COD_NFIELD_PRIORITY_CHAN_2(v)   (((v) << 16) & BM_IPU_DC_RL1_CH_2_COD_NFIELD_PRIORITY_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NFIELD_PRIORITY_CHAN_2 field to a new value.
#define BW_IPU_DC_RL1_CH_2_COD_NFIELD_PRIORITY_CHAN_2(v)   BF_CS1(IPU_DC_RL1_CH_2, COD_NFIELD_PRIORITY_CHAN_2, v)
#endif


/* --- Register HW_IPU_DC_RL1_CH_2, field COD_NFIELD_START_CHAN_2 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new field event resides (associated with channel #2)
 */

#define BP_IPU_DC_RL1_CH_2_COD_NFIELD_START_CHAN_2      24
#define BM_IPU_DC_RL1_CH_2_COD_NFIELD_START_CHAN_2      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_2_COD_NFIELD_START_CHAN_2(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL1_CH_2_COD_NFIELD_START_CHAN_2)
#else
#define BF_IPU_DC_RL1_CH_2_COD_NFIELD_START_CHAN_2(v)   (((v) << 24) & BM_IPU_DC_RL1_CH_2_COD_NFIELD_START_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NFIELD_START_CHAN_2 field to a new value.
#define BW_IPU_DC_RL1_CH_2_COD_NFIELD_START_CHAN_2(v)   BF_CS1(IPU_DC_RL1_CH_2, COD_NFIELD_START_CHAN_2, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL3_CH_2 - DC Routine Link Register 3 Channel 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_ADDR_PRIORITY_CHAN_2 : 4; //!< This field defines the priority of the end of line event (associated with channel #2) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_2 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #2)
        unsigned COD_NEW_CHAN_PRIORITY_CHAN_2 : 4; //!< This field defines the priority of the end of line event (associated with channel #2) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_2 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #2)
    } B;
} hw_ipu_dc_rl3_ch_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL3_CH_2 register
 */
#define HW_IPU_DC_RL3_CH_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x5804c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL3_CH_2(x)           (*(volatile hw_ipu_dc_rl3_ch_2_t *) HW_IPU_DC_RL3_CH_2_ADDR(x))
#define HW_IPU_DC_RL3_CH_2_RD(x)        (HW_IPU_DC_RL3_CH_2(x).U)
#define HW_IPU_DC_RL3_CH_2_WR(x, v)     (HW_IPU_DC_RL3_CH_2(x).U = (v))
#define HW_IPU_DC_RL3_CH_2_SET(x, v)    (HW_IPU_DC_RL3_CH_2_WR(x, HW_IPU_DC_RL3_CH_2_RD(x) |  (v)))
#define HW_IPU_DC_RL3_CH_2_CLR(x, v)    (HW_IPU_DC_RL3_CH_2_WR(x, HW_IPU_DC_RL3_CH_2_RD(x) & ~(v)))
#define HW_IPU_DC_RL3_CH_2_TOG(x, v)    (HW_IPU_DC_RL3_CH_2_WR(x, HW_IPU_DC_RL3_CH_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL3_CH_2 bitfields
 */

/* --- Register HW_IPU_DC_RL3_CH_2, field COD_NEW_ADDR_PRIORITY_CHAN_2 (RW)
 *
 * This field defines the priority of the end of line event (associated with channel #2) The
 * priority between the events should be set to a unique value. i.e. two events must not have the
 * same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL3_CH_2_COD_NEW_ADDR_PRIORITY_CHAN_2      0
#define BM_IPU_DC_RL3_CH_2_COD_NEW_ADDR_PRIORITY_CHAN_2      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_2_COD_NEW_ADDR_PRIORITY_CHAN_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL3_CH_2_COD_NEW_ADDR_PRIORITY_CHAN_2)
#else
#define BF_IPU_DC_RL3_CH_2_COD_NEW_ADDR_PRIORITY_CHAN_2(v)   (((v) << 0) & BM_IPU_DC_RL3_CH_2_COD_NEW_ADDR_PRIORITY_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_PRIORITY_CHAN_2 field to a new value.
#define BW_IPU_DC_RL3_CH_2_COD_NEW_ADDR_PRIORITY_CHAN_2(v)   BF_CS1(IPU_DC_RL3_CH_2, COD_NEW_ADDR_PRIORITY_CHAN_2, v)
#endif


/* --- Register HW_IPU_DC_RL3_CH_2, field COD_NEW_ADDR_START_CHAN_2 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides (associated with channel #2)
 */

#define BP_IPU_DC_RL3_CH_2_COD_NEW_ADDR_START_CHAN_2      8
#define BM_IPU_DC_RL3_CH_2_COD_NEW_ADDR_START_CHAN_2      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_2_COD_NEW_ADDR_START_CHAN_2(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL3_CH_2_COD_NEW_ADDR_START_CHAN_2)
#else
#define BF_IPU_DC_RL3_CH_2_COD_NEW_ADDR_START_CHAN_2(v)   (((v) << 8) & BM_IPU_DC_RL3_CH_2_COD_NEW_ADDR_START_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_2 field to a new value.
#define BW_IPU_DC_RL3_CH_2_COD_NEW_ADDR_START_CHAN_2(v)   BF_CS1(IPU_DC_RL3_CH_2, COD_NEW_ADDR_START_CHAN_2, v)
#endif

/* --- Register HW_IPU_DC_RL3_CH_2, field COD_NEW_CHAN_PRIORITY_CHAN_2 (RW)
 *
 * This field defines the priority of the end of line event (associated with channel #2) The
 * priority between the events should be set to a unique value. i.e. two events must not have the
 * same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL3_CH_2_COD_NEW_CHAN_PRIORITY_CHAN_2      16
#define BM_IPU_DC_RL3_CH_2_COD_NEW_CHAN_PRIORITY_CHAN_2      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_2_COD_NEW_CHAN_PRIORITY_CHAN_2(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL3_CH_2_COD_NEW_CHAN_PRIORITY_CHAN_2)
#else
#define BF_IPU_DC_RL3_CH_2_COD_NEW_CHAN_PRIORITY_CHAN_2(v)   (((v) << 16) & BM_IPU_DC_RL3_CH_2_COD_NEW_CHAN_PRIORITY_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_PRIORITY_CHAN_2 field to a new value.
#define BW_IPU_DC_RL3_CH_2_COD_NEW_CHAN_PRIORITY_CHAN_2(v)   BF_CS1(IPU_DC_RL3_CH_2, COD_NEW_CHAN_PRIORITY_CHAN_2, v)
#endif


/* --- Register HW_IPU_DC_RL3_CH_2, field COD_NEW_CHAN_START_CHAN_2 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides (associated with channel #2)
 */

#define BP_IPU_DC_RL3_CH_2_COD_NEW_CHAN_START_CHAN_2      24
#define BM_IPU_DC_RL3_CH_2_COD_NEW_CHAN_START_CHAN_2      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_2_COD_NEW_CHAN_START_CHAN_2(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL3_CH_2_COD_NEW_CHAN_START_CHAN_2)
#else
#define BF_IPU_DC_RL3_CH_2_COD_NEW_CHAN_START_CHAN_2(v)   (((v) << 24) & BM_IPU_DC_RL3_CH_2_COD_NEW_CHAN_START_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_2 field to a new value.
#define BW_IPU_DC_RL3_CH_2_COD_NEW_CHAN_START_CHAN_2(v)   BF_CS1(IPU_DC_RL3_CH_2, COD_NEW_CHAN_START_CHAN_2, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL4_CH_2 - DC Routine Link Register 4 Channel 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_DATA_PRIORITY_CHAN_2 : 4; //!< This field defines the priority of the end of line event (associated with channel #2) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_2 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #2)
        unsigned RESERVED1 : 16; //!< Reserved.
    } B;
} hw_ipu_dc_rl4_ch_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL4_CH_2 register
 */
#define HW_IPU_DC_RL4_CH_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x58050)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL4_CH_2(x)           (*(volatile hw_ipu_dc_rl4_ch_2_t *) HW_IPU_DC_RL4_CH_2_ADDR(x))
#define HW_IPU_DC_RL4_CH_2_RD(x)        (HW_IPU_DC_RL4_CH_2(x).U)
#define HW_IPU_DC_RL4_CH_2_WR(x, v)     (HW_IPU_DC_RL4_CH_2(x).U = (v))
#define HW_IPU_DC_RL4_CH_2_SET(x, v)    (HW_IPU_DC_RL4_CH_2_WR(x, HW_IPU_DC_RL4_CH_2_RD(x) |  (v)))
#define HW_IPU_DC_RL4_CH_2_CLR(x, v)    (HW_IPU_DC_RL4_CH_2_WR(x, HW_IPU_DC_RL4_CH_2_RD(x) & ~(v)))
#define HW_IPU_DC_RL4_CH_2_TOG(x, v)    (HW_IPU_DC_RL4_CH_2_WR(x, HW_IPU_DC_RL4_CH_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL4_CH_2 bitfields
 */

/* --- Register HW_IPU_DC_RL4_CH_2, field COD_NEW_DATA_PRIORITY_CHAN_2 (RW)
 *
 * This field defines the priority of the end of line event (associated with channel #2) The
 * priority between the events should be set to a unique value. i.e. two events must not have the
 * same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL4_CH_2_COD_NEW_DATA_PRIORITY_CHAN_2      0
#define BM_IPU_DC_RL4_CH_2_COD_NEW_DATA_PRIORITY_CHAN_2      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_2_COD_NEW_DATA_PRIORITY_CHAN_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL4_CH_2_COD_NEW_DATA_PRIORITY_CHAN_2)
#else
#define BF_IPU_DC_RL4_CH_2_COD_NEW_DATA_PRIORITY_CHAN_2(v)   (((v) << 0) & BM_IPU_DC_RL4_CH_2_COD_NEW_DATA_PRIORITY_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_PRIORITY_CHAN_2 field to a new value.
#define BW_IPU_DC_RL4_CH_2_COD_NEW_DATA_PRIORITY_CHAN_2(v)   BF_CS1(IPU_DC_RL4_CH_2, COD_NEW_DATA_PRIORITY_CHAN_2, v)
#endif


/* --- Register HW_IPU_DC_RL4_CH_2, field COD_NEW_DATA_START_CHAN_2 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides (associated with channel #2)
 */

#define BP_IPU_DC_RL4_CH_2_COD_NEW_DATA_START_CHAN_2      8
#define BM_IPU_DC_RL4_CH_2_COD_NEW_DATA_START_CHAN_2      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_2_COD_NEW_DATA_START_CHAN_2(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL4_CH_2_COD_NEW_DATA_START_CHAN_2)
#else
#define BF_IPU_DC_RL4_CH_2_COD_NEW_DATA_START_CHAN_2(v)   (((v) << 8) & BM_IPU_DC_RL4_CH_2_COD_NEW_DATA_START_CHAN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_2 field to a new value.
#define BW_IPU_DC_RL4_CH_2_COD_NEW_DATA_START_CHAN_2(v)   BF_CS1(IPU_DC_RL4_CH_2, COD_NEW_DATA_START_CHAN_2, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_CMD_CH_CONF_3 - DC Command Channel 3 Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned W_SIZE_3 : 2; //!< Word Size associated with channel #3 The data coming from the IDMAC is 32bit wide. This field defines the size of the word used by the DC
        unsigned RESERVED0 : 6; //!< Reserved.
        unsigned COD_CMND_START_CHAN_RS0_3 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the command start event resides (associated with channel #3); This field is relevant when RS is equal to 0
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_CMND_START_CHAN_RS1_3 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the command start event resides (associated with channel #3); This field is relevant when RS is equal to 1
    } B;
} hw_ipu_dc_cmd_ch_conf_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_CMD_CH_CONF_3 register
 */
#define HW_IPU_DC_CMD_CH_CONF_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x58054)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_CMD_CH_CONF_3(x)           (*(volatile hw_ipu_dc_cmd_ch_conf_3_t *) HW_IPU_DC_CMD_CH_CONF_3_ADDR(x))
#define HW_IPU_DC_CMD_CH_CONF_3_RD(x)        (HW_IPU_DC_CMD_CH_CONF_3(x).U)
#define HW_IPU_DC_CMD_CH_CONF_3_WR(x, v)     (HW_IPU_DC_CMD_CH_CONF_3(x).U = (v))
#define HW_IPU_DC_CMD_CH_CONF_3_SET(x, v)    (HW_IPU_DC_CMD_CH_CONF_3_WR(x, HW_IPU_DC_CMD_CH_CONF_3_RD(x) |  (v)))
#define HW_IPU_DC_CMD_CH_CONF_3_CLR(x, v)    (HW_IPU_DC_CMD_CH_CONF_3_WR(x, HW_IPU_DC_CMD_CH_CONF_3_RD(x) & ~(v)))
#define HW_IPU_DC_CMD_CH_CONF_3_TOG(x, v)    (HW_IPU_DC_CMD_CH_CONF_3_WR(x, HW_IPU_DC_CMD_CH_CONF_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_CMD_CH_CONF_3 bitfields
 */

/* --- Register HW_IPU_DC_CMD_CH_CONF_3, field W_SIZE_3 (RW)
 *
 * Word Size associated with channel #3 The data coming from the IDMAC is 32bit wide. This field
 * defines the size of the word used by the DC
 *
 * Values:
 * 00 - 8 bits are used - a 32 bit words includes 4X8bit valid words.
 * 01 - 16 LSB bits - a 32 bit words includes 2 X16bit valid words.
 * 10 - 24 MSB bits are used (RGB) - 8 LSB bits are ignored by the DC
 * 11 - 32 bits are used
 */

#define BP_IPU_DC_CMD_CH_CONF_3_W_SIZE_3      0
#define BM_IPU_DC_CMD_CH_CONF_3_W_SIZE_3      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_CMD_CH_CONF_3_W_SIZE_3(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_CMD_CH_CONF_3_W_SIZE_3)
#else
#define BF_IPU_DC_CMD_CH_CONF_3_W_SIZE_3(v)   (((v) << 0) & BM_IPU_DC_CMD_CH_CONF_3_W_SIZE_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the W_SIZE_3 field to a new value.
#define BW_IPU_DC_CMD_CH_CONF_3_W_SIZE_3(v)   BF_CS1(IPU_DC_CMD_CH_CONF_3, W_SIZE_3, v)
#endif


/* --- Register HW_IPU_DC_CMD_CH_CONF_3, field COD_CMND_START_CHAN_RS0_3 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the command start event resides (associated with channel #3); This field is relevant when RS is
 * equal to 0
 */

#define BP_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS0_3      8
#define BM_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS0_3      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS0_3(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS0_3)
#else
#define BF_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS0_3(v)   (((v) << 8) & BM_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS0_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_CMND_START_CHAN_RS0_3 field to a new value.
#define BW_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS0_3(v)   BF_CS1(IPU_DC_CMD_CH_CONF_3, COD_CMND_START_CHAN_RS0_3, v)
#endif

/* --- Register HW_IPU_DC_CMD_CH_CONF_3, field COD_CMND_START_CHAN_RS1_3 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the command start event resides (associated with channel #3); This field is relevant when RS is
 * equal to 1
 */

#define BP_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS1_3      24
#define BM_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS1_3      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS1_3(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS1_3)
#else
#define BF_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS1_3(v)   (((v) << 24) & BM_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS1_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_CMND_START_CHAN_RS1_3 field to a new value.
#define BW_IPU_DC_CMD_CH_CONF_3_COD_CMND_START_CHAN_RS1_3(v)   BF_CS1(IPU_DC_CMD_CH_CONF_3, COD_CMND_START_CHAN_RS1_3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_CMD_CH_CONF_4 - DC Command Channel 4 Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned W_SIZE_4 : 2; //!< Word Size associated with channel #4 The data coming from the IDMAC is 32bit wide. This field defines the size of the word used by the DC
        unsigned RESERVED0 : 6; //!< Reserved.
        unsigned COD_CMND_START_CHAN_RS0_4 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the command start event resides (associated with channel #4); This field is relevant when RS is equal to 0
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_CMND_START_CHAN_RS1_4 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the command start event resides (associated with channel #4); This field is relevant when RS is equal to 1
    } B;
} hw_ipu_dc_cmd_ch_conf_4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_CMD_CH_CONF_4 register
 */
#define HW_IPU_DC_CMD_CH_CONF_4_ADDR(x)      (REGS_IPU_BASE(x) + 0x58058)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_CMD_CH_CONF_4(x)           (*(volatile hw_ipu_dc_cmd_ch_conf_4_t *) HW_IPU_DC_CMD_CH_CONF_4_ADDR(x))
#define HW_IPU_DC_CMD_CH_CONF_4_RD(x)        (HW_IPU_DC_CMD_CH_CONF_4(x).U)
#define HW_IPU_DC_CMD_CH_CONF_4_WR(x, v)     (HW_IPU_DC_CMD_CH_CONF_4(x).U = (v))
#define HW_IPU_DC_CMD_CH_CONF_4_SET(x, v)    (HW_IPU_DC_CMD_CH_CONF_4_WR(x, HW_IPU_DC_CMD_CH_CONF_4_RD(x) |  (v)))
#define HW_IPU_DC_CMD_CH_CONF_4_CLR(x, v)    (HW_IPU_DC_CMD_CH_CONF_4_WR(x, HW_IPU_DC_CMD_CH_CONF_4_RD(x) & ~(v)))
#define HW_IPU_DC_CMD_CH_CONF_4_TOG(x, v)    (HW_IPU_DC_CMD_CH_CONF_4_WR(x, HW_IPU_DC_CMD_CH_CONF_4_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_CMD_CH_CONF_4 bitfields
 */

/* --- Register HW_IPU_DC_CMD_CH_CONF_4, field W_SIZE_4 (RW)
 *
 * Word Size associated with channel #4 The data coming from the IDMAC is 32bit wide. This field
 * defines the size of the word used by the DC
 *
 * Values:
 * 00 - 8 bits are used - a 32 bit words includes 4X8bit valid words.
 * 01 - 16 LSB bits - a 32 bit words includes 2 X16bit valid words.
 * 10 - 24 MSB bits are used (RGB) - 8 LSB bits are ignored by the DC
 * 11 - 32 bits are used
 */

#define BP_IPU_DC_CMD_CH_CONF_4_W_SIZE_4      0
#define BM_IPU_DC_CMD_CH_CONF_4_W_SIZE_4      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_CMD_CH_CONF_4_W_SIZE_4(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_CMD_CH_CONF_4_W_SIZE_4)
#else
#define BF_IPU_DC_CMD_CH_CONF_4_W_SIZE_4(v)   (((v) << 0) & BM_IPU_DC_CMD_CH_CONF_4_W_SIZE_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the W_SIZE_4 field to a new value.
#define BW_IPU_DC_CMD_CH_CONF_4_W_SIZE_4(v)   BF_CS1(IPU_DC_CMD_CH_CONF_4, W_SIZE_4, v)
#endif


/* --- Register HW_IPU_DC_CMD_CH_CONF_4, field COD_CMND_START_CHAN_RS0_4 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the command start event resides (associated with channel #4); This field is relevant when RS is
 * equal to 0
 */

#define BP_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS0_4      8
#define BM_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS0_4      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS0_4(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS0_4)
#else
#define BF_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS0_4(v)   (((v) << 8) & BM_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS0_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_CMND_START_CHAN_RS0_4 field to a new value.
#define BW_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS0_4(v)   BF_CS1(IPU_DC_CMD_CH_CONF_4, COD_CMND_START_CHAN_RS0_4, v)
#endif

/* --- Register HW_IPU_DC_CMD_CH_CONF_4, field COD_CMND_START_CHAN_RS1_4 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the command start event resides (associated with channel #4); This field is relevant when RS is
 * equal to 1
 */

#define BP_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS1_4      24
#define BM_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS1_4      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS1_4(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS1_4)
#else
#define BF_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS1_4(v)   (((v) << 24) & BM_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS1_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_CMND_START_CHAN_RS1_4 field to a new value.
#define BW_IPU_DC_CMD_CH_CONF_4_COD_CMND_START_CHAN_RS1_4(v)   BF_CS1(IPU_DC_CMD_CH_CONF_4, COD_CMND_START_CHAN_RS1_4, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_WR_CH_CONF_5 - DC Write Channel 5Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned W_SIZE_5 : 2; //!< Word Size associated with channel #5 The data coming from the IDMAC is 32bit wide. This field defines the size of the word used by the DC
        unsigned PROG_DI_ID_5 : 1; //!< This bit select the DI which a transaction associated with channel #5 can be performed to. When channel 28 is connected to DI0, channel 23 must be connected to DI1 even if ch23 is not used. This is done by writing 1 to this bit.
        unsigned PROG_DISP_ID_5 : 2; //!< The field defines which one of the 4 displays is associated with channel #5.
        unsigned PROG_CHAN_TYP_5 : 3; //!< This field define the mode of operation of channel #5
        unsigned CHAN_MASK_DEFAULT_5 : 1; //!< Event mask bit for channel #5 When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event
        unsigned FIELD_MODE_5 : 1; //!< Field mode bit for channel #5 This bit defines if the channel works in field mode or frame mode; This bit is relevant if the flow is sync flow
        unsigned RESERVED0 : 6; //!< Reserved.
        unsigned PROG_START_TIME_5 : 11; //!< This field defines the delay between display 's vertical synchronization pulse and the start time point of DC's channel 5 window. The delay is defined in pairs of rows. It is used for tearing elimination
        unsigned RESERVED1 : 5; //!< Reserved.
    } B;
} hw_ipu_dc_wr_ch_conf_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_WR_CH_CONF_5 register
 */
#define HW_IPU_DC_WR_CH_CONF_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x5805c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_WR_CH_CONF_5(x)           (*(volatile hw_ipu_dc_wr_ch_conf_5_t *) HW_IPU_DC_WR_CH_CONF_5_ADDR(x))
#define HW_IPU_DC_WR_CH_CONF_5_RD(x)        (HW_IPU_DC_WR_CH_CONF_5(x).U)
#define HW_IPU_DC_WR_CH_CONF_5_WR(x, v)     (HW_IPU_DC_WR_CH_CONF_5(x).U = (v))
#define HW_IPU_DC_WR_CH_CONF_5_SET(x, v)    (HW_IPU_DC_WR_CH_CONF_5_WR(x, HW_IPU_DC_WR_CH_CONF_5_RD(x) |  (v)))
#define HW_IPU_DC_WR_CH_CONF_5_CLR(x, v)    (HW_IPU_DC_WR_CH_CONF_5_WR(x, HW_IPU_DC_WR_CH_CONF_5_RD(x) & ~(v)))
#define HW_IPU_DC_WR_CH_CONF_5_TOG(x, v)    (HW_IPU_DC_WR_CH_CONF_5_WR(x, HW_IPU_DC_WR_CH_CONF_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_WR_CH_CONF_5 bitfields
 */

/* --- Register HW_IPU_DC_WR_CH_CONF_5, field W_SIZE_5 (RW)
 *
 * Word Size associated with channel #5 The data coming from the IDMAC is 32bit wide. This field
 * defines the size of the word used by the DC
 *
 * Values:
 * 00 - 8 bits are used - a 32 bit words includes 4X8bit valid words.
 * 01 - 16 LSB bits - a 32 bit words includes 2 X16bit valid words.
 * 10 - 24 MSB bits are used (RGB) - 8 LSB bits are ignored by the DC
 * 11 - 32 bits are used
 */

#define BP_IPU_DC_WR_CH_CONF_5_W_SIZE_5      0
#define BM_IPU_DC_WR_CH_CONF_5_W_SIZE_5      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_5_W_SIZE_5(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_WR_CH_CONF_5_W_SIZE_5)
#else
#define BF_IPU_DC_WR_CH_CONF_5_W_SIZE_5(v)   (((v) << 0) & BM_IPU_DC_WR_CH_CONF_5_W_SIZE_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the W_SIZE_5 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_5_W_SIZE_5(v)   BF_CS1(IPU_DC_WR_CH_CONF_5, W_SIZE_5, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_5, field PROG_DI_ID_5 (RW)
 *
 * This bit select the DI which a transaction associated with channel #5 can be performed to. When
 * channel 28 is connected to DI0, channel 23 must be connected to DI1 even if ch23 is not used.
 * This is done by writing 1 to this bit.
 *
 * Values:
 * 1 - DI #1
 * 0 - DI #0
 */

#define BP_IPU_DC_WR_CH_CONF_5_PROG_DI_ID_5      2
#define BM_IPU_DC_WR_CH_CONF_5_PROG_DI_ID_5      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_5_PROG_DI_ID_5(v)   ((((reg32_t) v) << 2) & BM_IPU_DC_WR_CH_CONF_5_PROG_DI_ID_5)
#else
#define BF_IPU_DC_WR_CH_CONF_5_PROG_DI_ID_5(v)   (((v) << 2) & BM_IPU_DC_WR_CH_CONF_5_PROG_DI_ID_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_DI_ID_5 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_5_PROG_DI_ID_5(v)   BF_CS1(IPU_DC_WR_CH_CONF_5, PROG_DI_ID_5, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_5, field PROG_DISP_ID_5 (RW)
 *
 * The field defines which one of the 4 displays is associated with channel #5.
 *
 * Values:
 * 00 - display #0
 * 01 - display #1
 * 10 - display #2
 * 11 - display #3
 */

#define BP_IPU_DC_WR_CH_CONF_5_PROG_DISP_ID_5      3
#define BM_IPU_DC_WR_CH_CONF_5_PROG_DISP_ID_5      0x00000018

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_5_PROG_DISP_ID_5(v)   ((((reg32_t) v) << 3) & BM_IPU_DC_WR_CH_CONF_5_PROG_DISP_ID_5)
#else
#define BF_IPU_DC_WR_CH_CONF_5_PROG_DISP_ID_5(v)   (((v) << 3) & BM_IPU_DC_WR_CH_CONF_5_PROG_DISP_ID_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_DISP_ID_5 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_5_PROG_DISP_ID_5(v)   BF_CS1(IPU_DC_WR_CH_CONF_5, PROG_DISP_ID_5, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_5, field PROG_CHAN_TYP_5 (RW)
 *
 * This field define the mode of operation of channel #5
 *
 * Values:
 * 000 - Disable
 * 001 - Reserved
 * 010 - Reserved
 * 100 - Normal mode without anti-tearing. For sync display this is the only mode allowed
 * 101 - Normal mode with anti-tearing
 * 110 - Reserved
 * 111 - Additional command channel is added to the flow handled by DC channel #5
 */

#define BP_IPU_DC_WR_CH_CONF_5_PROG_CHAN_TYP_5      5
#define BM_IPU_DC_WR_CH_CONF_5_PROG_CHAN_TYP_5      0x000000e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_5_PROG_CHAN_TYP_5(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_WR_CH_CONF_5_PROG_CHAN_TYP_5)
#else
#define BF_IPU_DC_WR_CH_CONF_5_PROG_CHAN_TYP_5(v)   (((v) << 5) & BM_IPU_DC_WR_CH_CONF_5_PROG_CHAN_TYP_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_CHAN_TYP_5 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_5_PROG_CHAN_TYP_5(v)   BF_CS1(IPU_DC_WR_CH_CONF_5, PROG_CHAN_TYP_5, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_5, field CHAN_MASK_DEFAULT_5 (RW)
 *
 * Event mask bit for channel #5 When more then one event is used during a flow (EOF, EOL, NL, NF,
 * EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority
 * event
 *
 * Values:
 * 1 - All the events are used - no mask
 * 0 - Only the highest priority event is used, the rest are masked
 */

#define BP_IPU_DC_WR_CH_CONF_5_CHAN_MASK_DEFAULT_5      8
#define BM_IPU_DC_WR_CH_CONF_5_CHAN_MASK_DEFAULT_5      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_5_CHAN_MASK_DEFAULT_5(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_WR_CH_CONF_5_CHAN_MASK_DEFAULT_5)
#else
#define BF_IPU_DC_WR_CH_CONF_5_CHAN_MASK_DEFAULT_5(v)   (((v) << 8) & BM_IPU_DC_WR_CH_CONF_5_CHAN_MASK_DEFAULT_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CHAN_MASK_DEFAULT_5 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_5_CHAN_MASK_DEFAULT_5(v)   BF_CS1(IPU_DC_WR_CH_CONF_5, CHAN_MASK_DEFAULT_5, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_5, field FIELD_MODE_5 (RW)
 *
 * Field mode bit for channel #5 This bit defines if the channel works in field mode or frame mode;
 * This bit is relevant if the flow is sync flow
 *
 * Values:
 * 1 - Field mode
 * 0 - Frame mode
 */

#define BP_IPU_DC_WR_CH_CONF_5_FIELD_MODE_5      9
#define BM_IPU_DC_WR_CH_CONF_5_FIELD_MODE_5      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_5_FIELD_MODE_5(v)   ((((reg32_t) v) << 9) & BM_IPU_DC_WR_CH_CONF_5_FIELD_MODE_5)
#else
#define BF_IPU_DC_WR_CH_CONF_5_FIELD_MODE_5(v)   (((v) << 9) & BM_IPU_DC_WR_CH_CONF_5_FIELD_MODE_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the FIELD_MODE_5 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_5_FIELD_MODE_5(v)   BF_CS1(IPU_DC_WR_CH_CONF_5, FIELD_MODE_5, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_5, field PROG_START_TIME_5 (RW)
 *
 * This field defines the delay between display 's vertical synchronization pulse and the start time
 * point of DC's channel 5 window. The delay is defined in pairs of rows. It is used for tearing
 * elimination
 */

#define BP_IPU_DC_WR_CH_CONF_5_PROG_START_TIME_5      16
#define BM_IPU_DC_WR_CH_CONF_5_PROG_START_TIME_5      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_5_PROG_START_TIME_5(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_WR_CH_CONF_5_PROG_START_TIME_5)
#else
#define BF_IPU_DC_WR_CH_CONF_5_PROG_START_TIME_5(v)   (((v) << 16) & BM_IPU_DC_WR_CH_CONF_5_PROG_START_TIME_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_START_TIME_5 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_5_PROG_START_TIME_5(v)   BF_CS1(IPU_DC_WR_CH_CONF_5, PROG_START_TIME_5, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_WR_CH_ADDR_5 - DC Write Channel 5Address Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned ST_ADDR_5 : 29; //!< This field defines the start address within the display's memory space where the write transactions will be done to for channel #5.
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_wr_ch_addr_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_WR_CH_ADDR_5 register
 */
#define HW_IPU_DC_WR_CH_ADDR_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x58060)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_WR_CH_ADDR_5(x)           (*(volatile hw_ipu_dc_wr_ch_addr_5_t *) HW_IPU_DC_WR_CH_ADDR_5_ADDR(x))
#define HW_IPU_DC_WR_CH_ADDR_5_RD(x)        (HW_IPU_DC_WR_CH_ADDR_5(x).U)
#define HW_IPU_DC_WR_CH_ADDR_5_WR(x, v)     (HW_IPU_DC_WR_CH_ADDR_5(x).U = (v))
#define HW_IPU_DC_WR_CH_ADDR_5_SET(x, v)    (HW_IPU_DC_WR_CH_ADDR_5_WR(x, HW_IPU_DC_WR_CH_ADDR_5_RD(x) |  (v)))
#define HW_IPU_DC_WR_CH_ADDR_5_CLR(x, v)    (HW_IPU_DC_WR_CH_ADDR_5_WR(x, HW_IPU_DC_WR_CH_ADDR_5_RD(x) & ~(v)))
#define HW_IPU_DC_WR_CH_ADDR_5_TOG(x, v)    (HW_IPU_DC_WR_CH_ADDR_5_WR(x, HW_IPU_DC_WR_CH_ADDR_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_WR_CH_ADDR_5 bitfields
 */

/* --- Register HW_IPU_DC_WR_CH_ADDR_5, field ST_ADDR_5 (RW)
 *
 * This field defines the start address within the display's memory space where the write
 * transactions will be done to for channel #5.
 */

#define BP_IPU_DC_WR_CH_ADDR_5_ST_ADDR_5      0
#define BM_IPU_DC_WR_CH_ADDR_5_ST_ADDR_5      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_ADDR_5_ST_ADDR_5(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_WR_CH_ADDR_5_ST_ADDR_5)
#else
#define BF_IPU_DC_WR_CH_ADDR_5_ST_ADDR_5(v)   (((v) << 0) & BM_IPU_DC_WR_CH_ADDR_5_ST_ADDR_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ST_ADDR_5 field to a new value.
#define BW_IPU_DC_WR_CH_ADDR_5_ST_ADDR_5(v)   BF_CS1(IPU_DC_WR_CH_ADDR_5, ST_ADDR_5, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL0_CH_5 - DC Routine Link Register 0 Channel 5 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NF_PRIORITY_CHAN_5 : 4; //!< This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NF_START_CHAN_5 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new frame event resides (associated with channel #5)
        unsigned COD_NL_PRIORITY_CHAN_5 : 4; //!< This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NL_START_CHAN_5 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new line event resides (associated with channel #5)
    } B;
} hw_ipu_dc_rl0_ch_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL0_CH_5 register
 */
#define HW_IPU_DC_RL0_CH_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x58064)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL0_CH_5(x)           (*(volatile hw_ipu_dc_rl0_ch_5_t *) HW_IPU_DC_RL0_CH_5_ADDR(x))
#define HW_IPU_DC_RL0_CH_5_RD(x)        (HW_IPU_DC_RL0_CH_5(x).U)
#define HW_IPU_DC_RL0_CH_5_WR(x, v)     (HW_IPU_DC_RL0_CH_5(x).U = (v))
#define HW_IPU_DC_RL0_CH_5_SET(x, v)    (HW_IPU_DC_RL0_CH_5_WR(x, HW_IPU_DC_RL0_CH_5_RD(x) |  (v)))
#define HW_IPU_DC_RL0_CH_5_CLR(x, v)    (HW_IPU_DC_RL0_CH_5_WR(x, HW_IPU_DC_RL0_CH_5_RD(x) & ~(v)))
#define HW_IPU_DC_RL0_CH_5_TOG(x, v)    (HW_IPU_DC_RL0_CH_5_WR(x, HW_IPU_DC_RL0_CH_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL0_CH_5 bitfields
 */

/* --- Register HW_IPU_DC_RL0_CH_5, field COD_NF_PRIORITY_CHAN_5 (RW)
 *
 * This field defines the priority of the new line event (associated with channel #5) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL0_CH_5_COD_NF_PRIORITY_CHAN_5      0
#define BM_IPU_DC_RL0_CH_5_COD_NF_PRIORITY_CHAN_5      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_5_COD_NF_PRIORITY_CHAN_5(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL0_CH_5_COD_NF_PRIORITY_CHAN_5)
#else
#define BF_IPU_DC_RL0_CH_5_COD_NF_PRIORITY_CHAN_5(v)   (((v) << 0) & BM_IPU_DC_RL0_CH_5_COD_NF_PRIORITY_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NF_PRIORITY_CHAN_5 field to a new value.
#define BW_IPU_DC_RL0_CH_5_COD_NF_PRIORITY_CHAN_5(v)   BF_CS1(IPU_DC_RL0_CH_5, COD_NF_PRIORITY_CHAN_5, v)
#endif


/* --- Register HW_IPU_DC_RL0_CH_5, field COD_NF_START_CHAN_5 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new frame event resides (associated with channel #5)
 */

#define BP_IPU_DC_RL0_CH_5_COD_NF_START_CHAN_5      8
#define BM_IPU_DC_RL0_CH_5_COD_NF_START_CHAN_5      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_5_COD_NF_START_CHAN_5(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL0_CH_5_COD_NF_START_CHAN_5)
#else
#define BF_IPU_DC_RL0_CH_5_COD_NF_START_CHAN_5(v)   (((v) << 8) & BM_IPU_DC_RL0_CH_5_COD_NF_START_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NF_START_CHAN_5 field to a new value.
#define BW_IPU_DC_RL0_CH_5_COD_NF_START_CHAN_5(v)   BF_CS1(IPU_DC_RL0_CH_5, COD_NF_START_CHAN_5, v)
#endif

/* --- Register HW_IPU_DC_RL0_CH_5, field COD_NL_PRIORITY_CHAN_5 (RW)
 *
 * This field defines the priority of the new line event (associated with channel #5) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL0_CH_5_COD_NL_PRIORITY_CHAN_5      16
#define BM_IPU_DC_RL0_CH_5_COD_NL_PRIORITY_CHAN_5      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_5_COD_NL_PRIORITY_CHAN_5(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL0_CH_5_COD_NL_PRIORITY_CHAN_5)
#else
#define BF_IPU_DC_RL0_CH_5_COD_NL_PRIORITY_CHAN_5(v)   (((v) << 16) & BM_IPU_DC_RL0_CH_5_COD_NL_PRIORITY_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NL_PRIORITY_CHAN_5 field to a new value.
#define BW_IPU_DC_RL0_CH_5_COD_NL_PRIORITY_CHAN_5(v)   BF_CS1(IPU_DC_RL0_CH_5, COD_NL_PRIORITY_CHAN_5, v)
#endif


/* --- Register HW_IPU_DC_RL0_CH_5, field COD_NL_START_CHAN_5 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new line event resides (associated with channel #5)
 */

#define BP_IPU_DC_RL0_CH_5_COD_NL_START_CHAN_5      24
#define BM_IPU_DC_RL0_CH_5_COD_NL_START_CHAN_5      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_5_COD_NL_START_CHAN_5(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL0_CH_5_COD_NL_START_CHAN_5)
#else
#define BF_IPU_DC_RL0_CH_5_COD_NL_START_CHAN_5(v)   (((v) << 24) & BM_IPU_DC_RL0_CH_5_COD_NL_START_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NL_START_CHAN_5 field to a new value.
#define BW_IPU_DC_RL0_CH_5_COD_NL_START_CHAN_5(v)   BF_CS1(IPU_DC_RL0_CH_5, COD_NL_START_CHAN_5, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL1_CH_5 - DC Routine Link Register 1 Channel 5 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_EOF_PRIORITY_CHAN_5 : 4; //!< This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_EOF_START_CHAN_5 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end of frame event resides (associated with channel #5)
        unsigned COD_NFIELD_PRIORITY_CHAN_5 : 4; //!< This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NFIELD_START_CHAN_5 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new field event resides (associated with channel #5)
    } B;
} hw_ipu_dc_rl1_ch_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL1_CH_5 register
 */
#define HW_IPU_DC_RL1_CH_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x58068)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL1_CH_5(x)           (*(volatile hw_ipu_dc_rl1_ch_5_t *) HW_IPU_DC_RL1_CH_5_ADDR(x))
#define HW_IPU_DC_RL1_CH_5_RD(x)        (HW_IPU_DC_RL1_CH_5(x).U)
#define HW_IPU_DC_RL1_CH_5_WR(x, v)     (HW_IPU_DC_RL1_CH_5(x).U = (v))
#define HW_IPU_DC_RL1_CH_5_SET(x, v)    (HW_IPU_DC_RL1_CH_5_WR(x, HW_IPU_DC_RL1_CH_5_RD(x) |  (v)))
#define HW_IPU_DC_RL1_CH_5_CLR(x, v)    (HW_IPU_DC_RL1_CH_5_WR(x, HW_IPU_DC_RL1_CH_5_RD(x) & ~(v)))
#define HW_IPU_DC_RL1_CH_5_TOG(x, v)    (HW_IPU_DC_RL1_CH_5_WR(x, HW_IPU_DC_RL1_CH_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL1_CH_5 bitfields
 */

/* --- Register HW_IPU_DC_RL1_CH_5, field COD_EOF_PRIORITY_CHAN_5 (RW)
 *
 * This field defines the priority of the new line event (associated with channel #5) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL1_CH_5_COD_EOF_PRIORITY_CHAN_5      0
#define BM_IPU_DC_RL1_CH_5_COD_EOF_PRIORITY_CHAN_5      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_5_COD_EOF_PRIORITY_CHAN_5(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL1_CH_5_COD_EOF_PRIORITY_CHAN_5)
#else
#define BF_IPU_DC_RL1_CH_5_COD_EOF_PRIORITY_CHAN_5(v)   (((v) << 0) & BM_IPU_DC_RL1_CH_5_COD_EOF_PRIORITY_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOF_PRIORITY_CHAN_5 field to a new value.
#define BW_IPU_DC_RL1_CH_5_COD_EOF_PRIORITY_CHAN_5(v)   BF_CS1(IPU_DC_RL1_CH_5, COD_EOF_PRIORITY_CHAN_5, v)
#endif


/* --- Register HW_IPU_DC_RL1_CH_5, field COD_EOF_START_CHAN_5 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end of frame event resides (associated with channel #5)
 */

#define BP_IPU_DC_RL1_CH_5_COD_EOF_START_CHAN_5      8
#define BM_IPU_DC_RL1_CH_5_COD_EOF_START_CHAN_5      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_5_COD_EOF_START_CHAN_5(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL1_CH_5_COD_EOF_START_CHAN_5)
#else
#define BF_IPU_DC_RL1_CH_5_COD_EOF_START_CHAN_5(v)   (((v) << 8) & BM_IPU_DC_RL1_CH_5_COD_EOF_START_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOF_START_CHAN_5 field to a new value.
#define BW_IPU_DC_RL1_CH_5_COD_EOF_START_CHAN_5(v)   BF_CS1(IPU_DC_RL1_CH_5, COD_EOF_START_CHAN_5, v)
#endif

/* --- Register HW_IPU_DC_RL1_CH_5, field COD_NFIELD_PRIORITY_CHAN_5 (RW)
 *
 * This field defines the priority of the new line event (associated with channel #5) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL1_CH_5_COD_NFIELD_PRIORITY_CHAN_5      16
#define BM_IPU_DC_RL1_CH_5_COD_NFIELD_PRIORITY_CHAN_5      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_5_COD_NFIELD_PRIORITY_CHAN_5(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL1_CH_5_COD_NFIELD_PRIORITY_CHAN_5)
#else
#define BF_IPU_DC_RL1_CH_5_COD_NFIELD_PRIORITY_CHAN_5(v)   (((v) << 16) & BM_IPU_DC_RL1_CH_5_COD_NFIELD_PRIORITY_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NFIELD_PRIORITY_CHAN_5 field to a new value.
#define BW_IPU_DC_RL1_CH_5_COD_NFIELD_PRIORITY_CHAN_5(v)   BF_CS1(IPU_DC_RL1_CH_5, COD_NFIELD_PRIORITY_CHAN_5, v)
#endif


/* --- Register HW_IPU_DC_RL1_CH_5, field COD_NFIELD_START_CHAN_5 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new field event resides (associated with channel #5)
 */

#define BP_IPU_DC_RL1_CH_5_COD_NFIELD_START_CHAN_5      24
#define BM_IPU_DC_RL1_CH_5_COD_NFIELD_START_CHAN_5      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_5_COD_NFIELD_START_CHAN_5(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL1_CH_5_COD_NFIELD_START_CHAN_5)
#else
#define BF_IPU_DC_RL1_CH_5_COD_NFIELD_START_CHAN_5(v)   (((v) << 24) & BM_IPU_DC_RL1_CH_5_COD_NFIELD_START_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NFIELD_START_CHAN_5 field to a new value.
#define BW_IPU_DC_RL1_CH_5_COD_NFIELD_START_CHAN_5(v)   BF_CS1(IPU_DC_RL1_CH_5, COD_NFIELD_START_CHAN_5, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL2_CH_5 - DC Routine Link Register 2 Channel 5 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_EOL_PRIORITY_CHAN_5 : 4; //!< This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_EOL_START_CHAN_5 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end of line event resides (associated with channel #5)
        unsigned COD_EOFIELD_PRIORITY_CHAN_5 : 4; //!< This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_EOFIELD_START_CHAN_5 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end of field event resides (associated with channel #5)
    } B;
} hw_ipu_dc_rl2_ch_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL2_CH_5 register
 */
#define HW_IPU_DC_RL2_CH_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x5806c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL2_CH_5(x)           (*(volatile hw_ipu_dc_rl2_ch_5_t *) HW_IPU_DC_RL2_CH_5_ADDR(x))
#define HW_IPU_DC_RL2_CH_5_RD(x)        (HW_IPU_DC_RL2_CH_5(x).U)
#define HW_IPU_DC_RL2_CH_5_WR(x, v)     (HW_IPU_DC_RL2_CH_5(x).U = (v))
#define HW_IPU_DC_RL2_CH_5_SET(x, v)    (HW_IPU_DC_RL2_CH_5_WR(x, HW_IPU_DC_RL2_CH_5_RD(x) |  (v)))
#define HW_IPU_DC_RL2_CH_5_CLR(x, v)    (HW_IPU_DC_RL2_CH_5_WR(x, HW_IPU_DC_RL2_CH_5_RD(x) & ~(v)))
#define HW_IPU_DC_RL2_CH_5_TOG(x, v)    (HW_IPU_DC_RL2_CH_5_WR(x, HW_IPU_DC_RL2_CH_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL2_CH_5 bitfields
 */

/* --- Register HW_IPU_DC_RL2_CH_5, field COD_EOL_PRIORITY_CHAN_5 (RW)
 *
 * This field defines the priority of the new line event (associated with channel #5) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL2_CH_5_COD_EOL_PRIORITY_CHAN_5      0
#define BM_IPU_DC_RL2_CH_5_COD_EOL_PRIORITY_CHAN_5      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_5_COD_EOL_PRIORITY_CHAN_5(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL2_CH_5_COD_EOL_PRIORITY_CHAN_5)
#else
#define BF_IPU_DC_RL2_CH_5_COD_EOL_PRIORITY_CHAN_5(v)   (((v) << 0) & BM_IPU_DC_RL2_CH_5_COD_EOL_PRIORITY_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOL_PRIORITY_CHAN_5 field to a new value.
#define BW_IPU_DC_RL2_CH_5_COD_EOL_PRIORITY_CHAN_5(v)   BF_CS1(IPU_DC_RL2_CH_5, COD_EOL_PRIORITY_CHAN_5, v)
#endif


/* --- Register HW_IPU_DC_RL2_CH_5, field COD_EOL_START_CHAN_5 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end of line event resides (associated with channel #5)
 */

#define BP_IPU_DC_RL2_CH_5_COD_EOL_START_CHAN_5      8
#define BM_IPU_DC_RL2_CH_5_COD_EOL_START_CHAN_5      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_5_COD_EOL_START_CHAN_5(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL2_CH_5_COD_EOL_START_CHAN_5)
#else
#define BF_IPU_DC_RL2_CH_5_COD_EOL_START_CHAN_5(v)   (((v) << 8) & BM_IPU_DC_RL2_CH_5_COD_EOL_START_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOL_START_CHAN_5 field to a new value.
#define BW_IPU_DC_RL2_CH_5_COD_EOL_START_CHAN_5(v)   BF_CS1(IPU_DC_RL2_CH_5, COD_EOL_START_CHAN_5, v)
#endif

/* --- Register HW_IPU_DC_RL2_CH_5, field COD_EOFIELD_PRIORITY_CHAN_5 (RW)
 *
 * This field defines the priority of the new line event (associated with channel #5) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL2_CH_5_COD_EOFIELD_PRIORITY_CHAN_5      16
#define BM_IPU_DC_RL2_CH_5_COD_EOFIELD_PRIORITY_CHAN_5      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_5_COD_EOFIELD_PRIORITY_CHAN_5(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL2_CH_5_COD_EOFIELD_PRIORITY_CHAN_5)
#else
#define BF_IPU_DC_RL2_CH_5_COD_EOFIELD_PRIORITY_CHAN_5(v)   (((v) << 16) & BM_IPU_DC_RL2_CH_5_COD_EOFIELD_PRIORITY_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOFIELD_PRIORITY_CHAN_5 field to a new value.
#define BW_IPU_DC_RL2_CH_5_COD_EOFIELD_PRIORITY_CHAN_5(v)   BF_CS1(IPU_DC_RL2_CH_5, COD_EOFIELD_PRIORITY_CHAN_5, v)
#endif


/* --- Register HW_IPU_DC_RL2_CH_5, field COD_EOFIELD_START_CHAN_5 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end of field event resides (associated with channel #5)
 */

#define BP_IPU_DC_RL2_CH_5_COD_EOFIELD_START_CHAN_5      24
#define BM_IPU_DC_RL2_CH_5_COD_EOFIELD_START_CHAN_5      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_5_COD_EOFIELD_START_CHAN_5(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL2_CH_5_COD_EOFIELD_START_CHAN_5)
#else
#define BF_IPU_DC_RL2_CH_5_COD_EOFIELD_START_CHAN_5(v)   (((v) << 24) & BM_IPU_DC_RL2_CH_5_COD_EOFIELD_START_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOFIELD_START_CHAN_5 field to a new value.
#define BW_IPU_DC_RL2_CH_5_COD_EOFIELD_START_CHAN_5(v)   BF_CS1(IPU_DC_RL2_CH_5, COD_EOFIELD_START_CHAN_5, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL3_CH_5 - DC Routine Link Register3 Channel 5 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_ADDR_PRIORITY_CHAN_5 : 4; //!< This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_5 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #5)
        unsigned COD_NEW_CHAN_PRIORITY_CHAN_5 : 4; //!< This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_5 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #5)
    } B;
} hw_ipu_dc_rl3_ch_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL3_CH_5 register
 */
#define HW_IPU_DC_RL3_CH_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x58070)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL3_CH_5(x)           (*(volatile hw_ipu_dc_rl3_ch_5_t *) HW_IPU_DC_RL3_CH_5_ADDR(x))
#define HW_IPU_DC_RL3_CH_5_RD(x)        (HW_IPU_DC_RL3_CH_5(x).U)
#define HW_IPU_DC_RL3_CH_5_WR(x, v)     (HW_IPU_DC_RL3_CH_5(x).U = (v))
#define HW_IPU_DC_RL3_CH_5_SET(x, v)    (HW_IPU_DC_RL3_CH_5_WR(x, HW_IPU_DC_RL3_CH_5_RD(x) |  (v)))
#define HW_IPU_DC_RL3_CH_5_CLR(x, v)    (HW_IPU_DC_RL3_CH_5_WR(x, HW_IPU_DC_RL3_CH_5_RD(x) & ~(v)))
#define HW_IPU_DC_RL3_CH_5_TOG(x, v)    (HW_IPU_DC_RL3_CH_5_WR(x, HW_IPU_DC_RL3_CH_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL3_CH_5 bitfields
 */

/* --- Register HW_IPU_DC_RL3_CH_5, field COD_NEW_ADDR_PRIORITY_CHAN_5 (RW)
 *
 * This field defines the priority of the new line event (associated with channel #5) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL3_CH_5_COD_NEW_ADDR_PRIORITY_CHAN_5      0
#define BM_IPU_DC_RL3_CH_5_COD_NEW_ADDR_PRIORITY_CHAN_5      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_5_COD_NEW_ADDR_PRIORITY_CHAN_5(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL3_CH_5_COD_NEW_ADDR_PRIORITY_CHAN_5)
#else
#define BF_IPU_DC_RL3_CH_5_COD_NEW_ADDR_PRIORITY_CHAN_5(v)   (((v) << 0) & BM_IPU_DC_RL3_CH_5_COD_NEW_ADDR_PRIORITY_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_PRIORITY_CHAN_5 field to a new value.
#define BW_IPU_DC_RL3_CH_5_COD_NEW_ADDR_PRIORITY_CHAN_5(v)   BF_CS1(IPU_DC_RL3_CH_5, COD_NEW_ADDR_PRIORITY_CHAN_5, v)
#endif


/* --- Register HW_IPU_DC_RL3_CH_5, field COD_NEW_ADDR_START_CHAN_5 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides (associated with channel #5)
 */

#define BP_IPU_DC_RL3_CH_5_COD_NEW_ADDR_START_CHAN_5      8
#define BM_IPU_DC_RL3_CH_5_COD_NEW_ADDR_START_CHAN_5      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_5_COD_NEW_ADDR_START_CHAN_5(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL3_CH_5_COD_NEW_ADDR_START_CHAN_5)
#else
#define BF_IPU_DC_RL3_CH_5_COD_NEW_ADDR_START_CHAN_5(v)   (((v) << 8) & BM_IPU_DC_RL3_CH_5_COD_NEW_ADDR_START_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_5 field to a new value.
#define BW_IPU_DC_RL3_CH_5_COD_NEW_ADDR_START_CHAN_5(v)   BF_CS1(IPU_DC_RL3_CH_5, COD_NEW_ADDR_START_CHAN_5, v)
#endif

/* --- Register HW_IPU_DC_RL3_CH_5, field COD_NEW_CHAN_PRIORITY_CHAN_5 (RW)
 *
 * This field defines the priority of the new line event (associated with channel #5) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL3_CH_5_COD_NEW_CHAN_PRIORITY_CHAN_5      16
#define BM_IPU_DC_RL3_CH_5_COD_NEW_CHAN_PRIORITY_CHAN_5      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_5_COD_NEW_CHAN_PRIORITY_CHAN_5(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL3_CH_5_COD_NEW_CHAN_PRIORITY_CHAN_5)
#else
#define BF_IPU_DC_RL3_CH_5_COD_NEW_CHAN_PRIORITY_CHAN_5(v)   (((v) << 16) & BM_IPU_DC_RL3_CH_5_COD_NEW_CHAN_PRIORITY_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_PRIORITY_CHAN_5 field to a new value.
#define BW_IPU_DC_RL3_CH_5_COD_NEW_CHAN_PRIORITY_CHAN_5(v)   BF_CS1(IPU_DC_RL3_CH_5, COD_NEW_CHAN_PRIORITY_CHAN_5, v)
#endif


/* --- Register HW_IPU_DC_RL3_CH_5, field COD_NEW_CHAN_START_CHAN_5 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides (associated with channel #5)
 */

#define BP_IPU_DC_RL3_CH_5_COD_NEW_CHAN_START_CHAN_5      24
#define BM_IPU_DC_RL3_CH_5_COD_NEW_CHAN_START_CHAN_5      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_5_COD_NEW_CHAN_START_CHAN_5(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL3_CH_5_COD_NEW_CHAN_START_CHAN_5)
#else
#define BF_IPU_DC_RL3_CH_5_COD_NEW_CHAN_START_CHAN_5(v)   (((v) << 24) & BM_IPU_DC_RL3_CH_5_COD_NEW_CHAN_START_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_5 field to a new value.
#define BW_IPU_DC_RL3_CH_5_COD_NEW_CHAN_START_CHAN_5(v)   BF_CS1(IPU_DC_RL3_CH_5, COD_NEW_CHAN_START_CHAN_5, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL4_CH_5 - DC Routine Link Register 4 Channel 5 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_DATA_PRIORITY_CHAN_5 : 4; //!< This field defines the priority of the new line event (associated with channel #5) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_5 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #5)
        unsigned RESERVED1 : 16; //!< Reserved.
    } B;
} hw_ipu_dc_rl4_ch_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL4_CH_5 register
 */
#define HW_IPU_DC_RL4_CH_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x58074)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL4_CH_5(x)           (*(volatile hw_ipu_dc_rl4_ch_5_t *) HW_IPU_DC_RL4_CH_5_ADDR(x))
#define HW_IPU_DC_RL4_CH_5_RD(x)        (HW_IPU_DC_RL4_CH_5(x).U)
#define HW_IPU_DC_RL4_CH_5_WR(x, v)     (HW_IPU_DC_RL4_CH_5(x).U = (v))
#define HW_IPU_DC_RL4_CH_5_SET(x, v)    (HW_IPU_DC_RL4_CH_5_WR(x, HW_IPU_DC_RL4_CH_5_RD(x) |  (v)))
#define HW_IPU_DC_RL4_CH_5_CLR(x, v)    (HW_IPU_DC_RL4_CH_5_WR(x, HW_IPU_DC_RL4_CH_5_RD(x) & ~(v)))
#define HW_IPU_DC_RL4_CH_5_TOG(x, v)    (HW_IPU_DC_RL4_CH_5_WR(x, HW_IPU_DC_RL4_CH_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL4_CH_5 bitfields
 */

/* --- Register HW_IPU_DC_RL4_CH_5, field COD_NEW_DATA_PRIORITY_CHAN_5 (RW)
 *
 * This field defines the priority of the new line event (associated with channel #5) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL4_CH_5_COD_NEW_DATA_PRIORITY_CHAN_5      0
#define BM_IPU_DC_RL4_CH_5_COD_NEW_DATA_PRIORITY_CHAN_5      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_5_COD_NEW_DATA_PRIORITY_CHAN_5(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL4_CH_5_COD_NEW_DATA_PRIORITY_CHAN_5)
#else
#define BF_IPU_DC_RL4_CH_5_COD_NEW_DATA_PRIORITY_CHAN_5(v)   (((v) << 0) & BM_IPU_DC_RL4_CH_5_COD_NEW_DATA_PRIORITY_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_PRIORITY_CHAN_5 field to a new value.
#define BW_IPU_DC_RL4_CH_5_COD_NEW_DATA_PRIORITY_CHAN_5(v)   BF_CS1(IPU_DC_RL4_CH_5, COD_NEW_DATA_PRIORITY_CHAN_5, v)
#endif


/* --- Register HW_IPU_DC_RL4_CH_5, field COD_NEW_DATA_START_CHAN_5 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides (associated with channel #5)
 */

#define BP_IPU_DC_RL4_CH_5_COD_NEW_DATA_START_CHAN_5      8
#define BM_IPU_DC_RL4_CH_5_COD_NEW_DATA_START_CHAN_5      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_5_COD_NEW_DATA_START_CHAN_5(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL4_CH_5_COD_NEW_DATA_START_CHAN_5)
#else
#define BF_IPU_DC_RL4_CH_5_COD_NEW_DATA_START_CHAN_5(v)   (((v) << 8) & BM_IPU_DC_RL4_CH_5_COD_NEW_DATA_START_CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_5 field to a new value.
#define BW_IPU_DC_RL4_CH_5_COD_NEW_DATA_START_CHAN_5(v)   BF_CS1(IPU_DC_RL4_CH_5, COD_NEW_DATA_START_CHAN_5, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_WR_CH_CONF_6 - DC Write Channel 6 Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned W_SIZE_6 : 2; //!< Word Size associated with channel #6 The data coming from the IDMAC is 32bit wide. This field defines the size of the word used by the DC
        unsigned PROG_DI_ID_6 : 1; //!< This bit select the DI which a transaction associated with channel #6 can be performed to
        unsigned PROG_DISP_ID_6 : 2; //!< The field defines which one of the 4 displays is associated with channel #6.
        unsigned PROG_CHAN_TYP_6 : 3; //!< This field define the mode of operation of channel #6
        unsigned CHAN_MASK_DEFAULT_6 : 1; //!< Event mask bit for channel #6 When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned PROG_START_TIME_6 : 11; //!< This field defines the delay between display 's vertical synchronization pulse and the start time point of DC's channel 6 window. The delay is defined in pairs of rows. It is used for tearing elimination
        unsigned RESERVED1 : 5; //!< Reserved.
    } B;
} hw_ipu_dc_wr_ch_conf_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_WR_CH_CONF_6 register
 */
#define HW_IPU_DC_WR_CH_CONF_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x58078)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_WR_CH_CONF_6(x)           (*(volatile hw_ipu_dc_wr_ch_conf_6_t *) HW_IPU_DC_WR_CH_CONF_6_ADDR(x))
#define HW_IPU_DC_WR_CH_CONF_6_RD(x)        (HW_IPU_DC_WR_CH_CONF_6(x).U)
#define HW_IPU_DC_WR_CH_CONF_6_WR(x, v)     (HW_IPU_DC_WR_CH_CONF_6(x).U = (v))
#define HW_IPU_DC_WR_CH_CONF_6_SET(x, v)    (HW_IPU_DC_WR_CH_CONF_6_WR(x, HW_IPU_DC_WR_CH_CONF_6_RD(x) |  (v)))
#define HW_IPU_DC_WR_CH_CONF_6_CLR(x, v)    (HW_IPU_DC_WR_CH_CONF_6_WR(x, HW_IPU_DC_WR_CH_CONF_6_RD(x) & ~(v)))
#define HW_IPU_DC_WR_CH_CONF_6_TOG(x, v)    (HW_IPU_DC_WR_CH_CONF_6_WR(x, HW_IPU_DC_WR_CH_CONF_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_WR_CH_CONF_6 bitfields
 */

/* --- Register HW_IPU_DC_WR_CH_CONF_6, field W_SIZE_6 (RW)
 *
 * Word Size associated with channel #6 The data coming from the IDMAC is 32bit wide. This field
 * defines the size of the word used by the DC
 *
 * Values:
 * 00 - 8 bits are used - a 32 bit words includes 4X8bit valid words.
 * 01 - 16 LSB bits - a 32 bit words includes 2 X16bit valid words.
 * 10 - 24 MSB bits are used (RGB) - 8 LSB bits are ignored by the DC
 * 11 - 32 bits are used
 */

#define BP_IPU_DC_WR_CH_CONF_6_W_SIZE_6      0
#define BM_IPU_DC_WR_CH_CONF_6_W_SIZE_6      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_6_W_SIZE_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_WR_CH_CONF_6_W_SIZE_6)
#else
#define BF_IPU_DC_WR_CH_CONF_6_W_SIZE_6(v)   (((v) << 0) & BM_IPU_DC_WR_CH_CONF_6_W_SIZE_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the W_SIZE_6 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_6_W_SIZE_6(v)   BF_CS1(IPU_DC_WR_CH_CONF_6, W_SIZE_6, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_6, field PROG_DI_ID_6 (RW)
 *
 * This bit select the DI which a transaction associated with channel #6 can be performed to
 *
 * Values:
 * 1 - DI #1
 * 0 - DI #0
 */

#define BP_IPU_DC_WR_CH_CONF_6_PROG_DI_ID_6      2
#define BM_IPU_DC_WR_CH_CONF_6_PROG_DI_ID_6      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_6_PROG_DI_ID_6(v)   ((((reg32_t) v) << 2) & BM_IPU_DC_WR_CH_CONF_6_PROG_DI_ID_6)
#else
#define BF_IPU_DC_WR_CH_CONF_6_PROG_DI_ID_6(v)   (((v) << 2) & BM_IPU_DC_WR_CH_CONF_6_PROG_DI_ID_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_DI_ID_6 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_6_PROG_DI_ID_6(v)   BF_CS1(IPU_DC_WR_CH_CONF_6, PROG_DI_ID_6, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_6, field PROG_DISP_ID_6 (RW)
 *
 * The field defines which one of the 4 displays is associated with channel #6.
 *
 * Values:
 * 00 - display #0
 * 01 - display #1
 * 10 - display #2
 * 11 - display #3
 */

#define BP_IPU_DC_WR_CH_CONF_6_PROG_DISP_ID_6      3
#define BM_IPU_DC_WR_CH_CONF_6_PROG_DISP_ID_6      0x00000018

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_6_PROG_DISP_ID_6(v)   ((((reg32_t) v) << 3) & BM_IPU_DC_WR_CH_CONF_6_PROG_DISP_ID_6)
#else
#define BF_IPU_DC_WR_CH_CONF_6_PROG_DISP_ID_6(v)   (((v) << 3) & BM_IPU_DC_WR_CH_CONF_6_PROG_DISP_ID_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_DISP_ID_6 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_6_PROG_DISP_ID_6(v)   BF_CS1(IPU_DC_WR_CH_CONF_6, PROG_DISP_ID_6, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_6, field PROG_CHAN_TYP_6 (RW)
 *
 * This field define the mode of operation of channel #6
 *
 * Values:
 * 000 - Disable
 * 001 - Reserved
 * 010 - Reserved
 * 100 - Normal mode without anti-tearing. For sync display this is the only mode allowed
 * 101 - Normal mode with anti-tearing
 * 110 - Reserved
 * 111 - Additional command channel is added to the flow handled by DC channel #6
 */

#define BP_IPU_DC_WR_CH_CONF_6_PROG_CHAN_TYP_6      5
#define BM_IPU_DC_WR_CH_CONF_6_PROG_CHAN_TYP_6      0x000000e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_6_PROG_CHAN_TYP_6(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_WR_CH_CONF_6_PROG_CHAN_TYP_6)
#else
#define BF_IPU_DC_WR_CH_CONF_6_PROG_CHAN_TYP_6(v)   (((v) << 5) & BM_IPU_DC_WR_CH_CONF_6_PROG_CHAN_TYP_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_CHAN_TYP_6 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_6_PROG_CHAN_TYP_6(v)   BF_CS1(IPU_DC_WR_CH_CONF_6, PROG_CHAN_TYP_6, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_6, field CHAN_MASK_DEFAULT_6 (RW)
 *
 * Event mask bit for channel #6 When more then one event is used during a flow (EOF, EOL, NL, NF,
 * EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority
 * event
 *
 * Values:
 * 1 - All the events are used - no mask
 * 0 - Only the highest priority event is used, the rest are masked
 */

#define BP_IPU_DC_WR_CH_CONF_6_CHAN_MASK_DEFAULT_6      8
#define BM_IPU_DC_WR_CH_CONF_6_CHAN_MASK_DEFAULT_6      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_6_CHAN_MASK_DEFAULT_6(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_WR_CH_CONF_6_CHAN_MASK_DEFAULT_6)
#else
#define BF_IPU_DC_WR_CH_CONF_6_CHAN_MASK_DEFAULT_6(v)   (((v) << 8) & BM_IPU_DC_WR_CH_CONF_6_CHAN_MASK_DEFAULT_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CHAN_MASK_DEFAULT_6 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_6_CHAN_MASK_DEFAULT_6(v)   BF_CS1(IPU_DC_WR_CH_CONF_6, CHAN_MASK_DEFAULT_6, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF_6, field PROG_START_TIME_6 (RW)
 *
 * This field defines the delay between display 's vertical synchronization pulse and the start time
 * point of DC's channel 6 window. The delay is defined in pairs of rows. It is used for tearing
 * elimination
 */

#define BP_IPU_DC_WR_CH_CONF_6_PROG_START_TIME_6      16
#define BM_IPU_DC_WR_CH_CONF_6_PROG_START_TIME_6      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF_6_PROG_START_TIME_6(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_WR_CH_CONF_6_PROG_START_TIME_6)
#else
#define BF_IPU_DC_WR_CH_CONF_6_PROG_START_TIME_6(v)   (((v) << 16) & BM_IPU_DC_WR_CH_CONF_6_PROG_START_TIME_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the PROG_START_TIME_6 field to a new value.
#define BW_IPU_DC_WR_CH_CONF_6_PROG_START_TIME_6(v)   BF_CS1(IPU_DC_WR_CH_CONF_6, PROG_START_TIME_6, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_WR_CH_ADDR_6 - DC Write Channel 6 Address Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned ST_ADDR_6 : 29; //!< This field defines the start address within the display's memory space where the write transactions will be done to for channel #6.
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_wr_ch_addr_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_WR_CH_ADDR_6 register
 */
#define HW_IPU_DC_WR_CH_ADDR_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x5807c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_WR_CH_ADDR_6(x)           (*(volatile hw_ipu_dc_wr_ch_addr_6_t *) HW_IPU_DC_WR_CH_ADDR_6_ADDR(x))
#define HW_IPU_DC_WR_CH_ADDR_6_RD(x)        (HW_IPU_DC_WR_CH_ADDR_6(x).U)
#define HW_IPU_DC_WR_CH_ADDR_6_WR(x, v)     (HW_IPU_DC_WR_CH_ADDR_6(x).U = (v))
#define HW_IPU_DC_WR_CH_ADDR_6_SET(x, v)    (HW_IPU_DC_WR_CH_ADDR_6_WR(x, HW_IPU_DC_WR_CH_ADDR_6_RD(x) |  (v)))
#define HW_IPU_DC_WR_CH_ADDR_6_CLR(x, v)    (HW_IPU_DC_WR_CH_ADDR_6_WR(x, HW_IPU_DC_WR_CH_ADDR_6_RD(x) & ~(v)))
#define HW_IPU_DC_WR_CH_ADDR_6_TOG(x, v)    (HW_IPU_DC_WR_CH_ADDR_6_WR(x, HW_IPU_DC_WR_CH_ADDR_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_WR_CH_ADDR_6 bitfields
 */

/* --- Register HW_IPU_DC_WR_CH_ADDR_6, field ST_ADDR_6 (RW)
 *
 * This field defines the start address within the display's memory space where the write
 * transactions will be done to for channel #6.
 */

#define BP_IPU_DC_WR_CH_ADDR_6_ST_ADDR_6      0
#define BM_IPU_DC_WR_CH_ADDR_6_ST_ADDR_6      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_ADDR_6_ST_ADDR_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_WR_CH_ADDR_6_ST_ADDR_6)
#else
#define BF_IPU_DC_WR_CH_ADDR_6_ST_ADDR_6(v)   (((v) << 0) & BM_IPU_DC_WR_CH_ADDR_6_ST_ADDR_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ST_ADDR_6 field to a new value.
#define BW_IPU_DC_WR_CH_ADDR_6_ST_ADDR_6(v)   BF_CS1(IPU_DC_WR_CH_ADDR_6, ST_ADDR_6, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL0_CH_6 - DC Routine Link Register 0Channel 6 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NF_PRIORITY_CHAN_6 : 4; //!< This field defines the priority of the new frame event (associated with channel #6) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NF_START_CHAN_6 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new frame event resides (associated with channel #6)
        unsigned COD_NL_PRIORITY_CHAN_6 : 4; //!< This field defines the priority of the new line event (associated with channel #6) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NL_START_CHAN_6 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new line event resides (associated with channel #6)
    } B;
} hw_ipu_dc_rl0_ch_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL0_CH_6 register
 */
#define HW_IPU_DC_RL0_CH_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x58080)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL0_CH_6(x)           (*(volatile hw_ipu_dc_rl0_ch_6_t *) HW_IPU_DC_RL0_CH_6_ADDR(x))
#define HW_IPU_DC_RL0_CH_6_RD(x)        (HW_IPU_DC_RL0_CH_6(x).U)
#define HW_IPU_DC_RL0_CH_6_WR(x, v)     (HW_IPU_DC_RL0_CH_6(x).U = (v))
#define HW_IPU_DC_RL0_CH_6_SET(x, v)    (HW_IPU_DC_RL0_CH_6_WR(x, HW_IPU_DC_RL0_CH_6_RD(x) |  (v)))
#define HW_IPU_DC_RL0_CH_6_CLR(x, v)    (HW_IPU_DC_RL0_CH_6_WR(x, HW_IPU_DC_RL0_CH_6_RD(x) & ~(v)))
#define HW_IPU_DC_RL0_CH_6_TOG(x, v)    (HW_IPU_DC_RL0_CH_6_WR(x, HW_IPU_DC_RL0_CH_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL0_CH_6 bitfields
 */

/* --- Register HW_IPU_DC_RL0_CH_6, field COD_NF_PRIORITY_CHAN_6 (RW)
 *
 * This field defines the priority of the new frame event (associated with channel #6) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL0_CH_6_COD_NF_PRIORITY_CHAN_6      0
#define BM_IPU_DC_RL0_CH_6_COD_NF_PRIORITY_CHAN_6      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_6_COD_NF_PRIORITY_CHAN_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL0_CH_6_COD_NF_PRIORITY_CHAN_6)
#else
#define BF_IPU_DC_RL0_CH_6_COD_NF_PRIORITY_CHAN_6(v)   (((v) << 0) & BM_IPU_DC_RL0_CH_6_COD_NF_PRIORITY_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NF_PRIORITY_CHAN_6 field to a new value.
#define BW_IPU_DC_RL0_CH_6_COD_NF_PRIORITY_CHAN_6(v)   BF_CS1(IPU_DC_RL0_CH_6, COD_NF_PRIORITY_CHAN_6, v)
#endif


/* --- Register HW_IPU_DC_RL0_CH_6, field COD_NF_START_CHAN_6 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new frame event resides (associated with channel #6)
 */

#define BP_IPU_DC_RL0_CH_6_COD_NF_START_CHAN_6      8
#define BM_IPU_DC_RL0_CH_6_COD_NF_START_CHAN_6      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_6_COD_NF_START_CHAN_6(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL0_CH_6_COD_NF_START_CHAN_6)
#else
#define BF_IPU_DC_RL0_CH_6_COD_NF_START_CHAN_6(v)   (((v) << 8) & BM_IPU_DC_RL0_CH_6_COD_NF_START_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NF_START_CHAN_6 field to a new value.
#define BW_IPU_DC_RL0_CH_6_COD_NF_START_CHAN_6(v)   BF_CS1(IPU_DC_RL0_CH_6, COD_NF_START_CHAN_6, v)
#endif

/* --- Register HW_IPU_DC_RL0_CH_6, field COD_NL_PRIORITY_CHAN_6 (RW)
 *
 * This field defines the priority of the new line event (associated with channel #6) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL0_CH_6_COD_NL_PRIORITY_CHAN_6      16
#define BM_IPU_DC_RL0_CH_6_COD_NL_PRIORITY_CHAN_6      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_6_COD_NL_PRIORITY_CHAN_6(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL0_CH_6_COD_NL_PRIORITY_CHAN_6)
#else
#define BF_IPU_DC_RL0_CH_6_COD_NL_PRIORITY_CHAN_6(v)   (((v) << 16) & BM_IPU_DC_RL0_CH_6_COD_NL_PRIORITY_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NL_PRIORITY_CHAN_6 field to a new value.
#define BW_IPU_DC_RL0_CH_6_COD_NL_PRIORITY_CHAN_6(v)   BF_CS1(IPU_DC_RL0_CH_6, COD_NL_PRIORITY_CHAN_6, v)
#endif


/* --- Register HW_IPU_DC_RL0_CH_6, field COD_NL_START_CHAN_6 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new line event resides (associated with channel #6)
 */

#define BP_IPU_DC_RL0_CH_6_COD_NL_START_CHAN_6      24
#define BM_IPU_DC_RL0_CH_6_COD_NL_START_CHAN_6      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL0_CH_6_COD_NL_START_CHAN_6(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL0_CH_6_COD_NL_START_CHAN_6)
#else
#define BF_IPU_DC_RL0_CH_6_COD_NL_START_CHAN_6(v)   (((v) << 24) & BM_IPU_DC_RL0_CH_6_COD_NL_START_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NL_START_CHAN_6 field to a new value.
#define BW_IPU_DC_RL0_CH_6_COD_NL_START_CHAN_6(v)   BF_CS1(IPU_DC_RL0_CH_6, COD_NL_START_CHAN_6, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL1_CH_6 - DC Routine Link Register 1 Channel 6 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_EOF_PRIORITY_CHAN_6 : 4; //!< This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_EOF_START_CHAN_6 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end of frame event resides (associated with channel #6)
        unsigned COD_NFIELD_PRIORITY_CHAN_6 : 4; //!< This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NFIELD_START_CHAN_6 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new field event resides (associated with channel #6)
    } B;
} hw_ipu_dc_rl1_ch_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL1_CH_6 register
 */
#define HW_IPU_DC_RL1_CH_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x58084)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL1_CH_6(x)           (*(volatile hw_ipu_dc_rl1_ch_6_t *) HW_IPU_DC_RL1_CH_6_ADDR(x))
#define HW_IPU_DC_RL1_CH_6_RD(x)        (HW_IPU_DC_RL1_CH_6(x).U)
#define HW_IPU_DC_RL1_CH_6_WR(x, v)     (HW_IPU_DC_RL1_CH_6(x).U = (v))
#define HW_IPU_DC_RL1_CH_6_SET(x, v)    (HW_IPU_DC_RL1_CH_6_WR(x, HW_IPU_DC_RL1_CH_6_RD(x) |  (v)))
#define HW_IPU_DC_RL1_CH_6_CLR(x, v)    (HW_IPU_DC_RL1_CH_6_WR(x, HW_IPU_DC_RL1_CH_6_RD(x) & ~(v)))
#define HW_IPU_DC_RL1_CH_6_TOG(x, v)    (HW_IPU_DC_RL1_CH_6_WR(x, HW_IPU_DC_RL1_CH_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL1_CH_6 bitfields
 */

/* --- Register HW_IPU_DC_RL1_CH_6, field COD_EOF_PRIORITY_CHAN_6 (RW)
 *
 * This field defines the priority of the new field event (associated with channel #6) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL1_CH_6_COD_EOF_PRIORITY_CHAN_6      0
#define BM_IPU_DC_RL1_CH_6_COD_EOF_PRIORITY_CHAN_6      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_6_COD_EOF_PRIORITY_CHAN_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL1_CH_6_COD_EOF_PRIORITY_CHAN_6)
#else
#define BF_IPU_DC_RL1_CH_6_COD_EOF_PRIORITY_CHAN_6(v)   (((v) << 0) & BM_IPU_DC_RL1_CH_6_COD_EOF_PRIORITY_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOF_PRIORITY_CHAN_6 field to a new value.
#define BW_IPU_DC_RL1_CH_6_COD_EOF_PRIORITY_CHAN_6(v)   BF_CS1(IPU_DC_RL1_CH_6, COD_EOF_PRIORITY_CHAN_6, v)
#endif


/* --- Register HW_IPU_DC_RL1_CH_6, field COD_EOF_START_CHAN_6 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end of frame event resides (associated with channel #6)
 */

#define BP_IPU_DC_RL1_CH_6_COD_EOF_START_CHAN_6      8
#define BM_IPU_DC_RL1_CH_6_COD_EOF_START_CHAN_6      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_6_COD_EOF_START_CHAN_6(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL1_CH_6_COD_EOF_START_CHAN_6)
#else
#define BF_IPU_DC_RL1_CH_6_COD_EOF_START_CHAN_6(v)   (((v) << 8) & BM_IPU_DC_RL1_CH_6_COD_EOF_START_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOF_START_CHAN_6 field to a new value.
#define BW_IPU_DC_RL1_CH_6_COD_EOF_START_CHAN_6(v)   BF_CS1(IPU_DC_RL1_CH_6, COD_EOF_START_CHAN_6, v)
#endif

/* --- Register HW_IPU_DC_RL1_CH_6, field COD_NFIELD_PRIORITY_CHAN_6 (RW)
 *
 * This field defines the priority of the new field event (associated with channel #6) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL1_CH_6_COD_NFIELD_PRIORITY_CHAN_6      16
#define BM_IPU_DC_RL1_CH_6_COD_NFIELD_PRIORITY_CHAN_6      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_6_COD_NFIELD_PRIORITY_CHAN_6(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL1_CH_6_COD_NFIELD_PRIORITY_CHAN_6)
#else
#define BF_IPU_DC_RL1_CH_6_COD_NFIELD_PRIORITY_CHAN_6(v)   (((v) << 16) & BM_IPU_DC_RL1_CH_6_COD_NFIELD_PRIORITY_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NFIELD_PRIORITY_CHAN_6 field to a new value.
#define BW_IPU_DC_RL1_CH_6_COD_NFIELD_PRIORITY_CHAN_6(v)   BF_CS1(IPU_DC_RL1_CH_6, COD_NFIELD_PRIORITY_CHAN_6, v)
#endif


/* --- Register HW_IPU_DC_RL1_CH_6, field COD_NFIELD_START_CHAN_6 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new field event resides (associated with channel #6)
 */

#define BP_IPU_DC_RL1_CH_6_COD_NFIELD_START_CHAN_6      24
#define BM_IPU_DC_RL1_CH_6_COD_NFIELD_START_CHAN_6      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_6_COD_NFIELD_START_CHAN_6(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL1_CH_6_COD_NFIELD_START_CHAN_6)
#else
#define BF_IPU_DC_RL1_CH_6_COD_NFIELD_START_CHAN_6(v)   (((v) << 24) & BM_IPU_DC_RL1_CH_6_COD_NFIELD_START_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NFIELD_START_CHAN_6 field to a new value.
#define BW_IPU_DC_RL1_CH_6_COD_NFIELD_START_CHAN_6(v)   BF_CS1(IPU_DC_RL1_CH_6, COD_NFIELD_START_CHAN_6, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL2_CH_6 - DC Routine Link Register 2 Channel 6 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_EOL_PRIORITY_CHAN_6 : 4; //!< This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_EOL_START_CHAN_6 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end of line event resides (associated with channel #6)
        unsigned COD_EOFIELD_PRIORITY_CHAN_6 : 4; //!< This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_EOFIELD_START_CHAN_6 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the end of field event resides (associated with channel #6)
    } B;
} hw_ipu_dc_rl2_ch_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL2_CH_6 register
 */
#define HW_IPU_DC_RL2_CH_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x58088)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL2_CH_6(x)           (*(volatile hw_ipu_dc_rl2_ch_6_t *) HW_IPU_DC_RL2_CH_6_ADDR(x))
#define HW_IPU_DC_RL2_CH_6_RD(x)        (HW_IPU_DC_RL2_CH_6(x).U)
#define HW_IPU_DC_RL2_CH_6_WR(x, v)     (HW_IPU_DC_RL2_CH_6(x).U = (v))
#define HW_IPU_DC_RL2_CH_6_SET(x, v)    (HW_IPU_DC_RL2_CH_6_WR(x, HW_IPU_DC_RL2_CH_6_RD(x) |  (v)))
#define HW_IPU_DC_RL2_CH_6_CLR(x, v)    (HW_IPU_DC_RL2_CH_6_WR(x, HW_IPU_DC_RL2_CH_6_RD(x) & ~(v)))
#define HW_IPU_DC_RL2_CH_6_TOG(x, v)    (HW_IPU_DC_RL2_CH_6_WR(x, HW_IPU_DC_RL2_CH_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL2_CH_6 bitfields
 */

/* --- Register HW_IPU_DC_RL2_CH_6, field COD_EOL_PRIORITY_CHAN_6 (RW)
 *
 * This field defines the priority of the new field event (associated with channel #6) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL2_CH_6_COD_EOL_PRIORITY_CHAN_6      0
#define BM_IPU_DC_RL2_CH_6_COD_EOL_PRIORITY_CHAN_6      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_6_COD_EOL_PRIORITY_CHAN_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL2_CH_6_COD_EOL_PRIORITY_CHAN_6)
#else
#define BF_IPU_DC_RL2_CH_6_COD_EOL_PRIORITY_CHAN_6(v)   (((v) << 0) & BM_IPU_DC_RL2_CH_6_COD_EOL_PRIORITY_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOL_PRIORITY_CHAN_6 field to a new value.
#define BW_IPU_DC_RL2_CH_6_COD_EOL_PRIORITY_CHAN_6(v)   BF_CS1(IPU_DC_RL2_CH_6, COD_EOL_PRIORITY_CHAN_6, v)
#endif


/* --- Register HW_IPU_DC_RL2_CH_6, field COD_EOL_START_CHAN_6 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end of line event resides (associated with channel #6)
 */

#define BP_IPU_DC_RL2_CH_6_COD_EOL_START_CHAN_6      8
#define BM_IPU_DC_RL2_CH_6_COD_EOL_START_CHAN_6      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_6_COD_EOL_START_CHAN_6(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL2_CH_6_COD_EOL_START_CHAN_6)
#else
#define BF_IPU_DC_RL2_CH_6_COD_EOL_START_CHAN_6(v)   (((v) << 8) & BM_IPU_DC_RL2_CH_6_COD_EOL_START_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOL_START_CHAN_6 field to a new value.
#define BW_IPU_DC_RL2_CH_6_COD_EOL_START_CHAN_6(v)   BF_CS1(IPU_DC_RL2_CH_6, COD_EOL_START_CHAN_6, v)
#endif

/* --- Register HW_IPU_DC_RL2_CH_6, field COD_EOFIELD_PRIORITY_CHAN_6 (RW)
 *
 * This field defines the priority of the new field event (associated with channel #6) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL2_CH_6_COD_EOFIELD_PRIORITY_CHAN_6      16
#define BM_IPU_DC_RL2_CH_6_COD_EOFIELD_PRIORITY_CHAN_6      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_6_COD_EOFIELD_PRIORITY_CHAN_6(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL2_CH_6_COD_EOFIELD_PRIORITY_CHAN_6)
#else
#define BF_IPU_DC_RL2_CH_6_COD_EOFIELD_PRIORITY_CHAN_6(v)   (((v) << 16) & BM_IPU_DC_RL2_CH_6_COD_EOFIELD_PRIORITY_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOFIELD_PRIORITY_CHAN_6 field to a new value.
#define BW_IPU_DC_RL2_CH_6_COD_EOFIELD_PRIORITY_CHAN_6(v)   BF_CS1(IPU_DC_RL2_CH_6, COD_EOFIELD_PRIORITY_CHAN_6, v)
#endif


/* --- Register HW_IPU_DC_RL2_CH_6, field COD_EOFIELD_START_CHAN_6 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the end of field event resides (associated with channel #6)
 */

#define BP_IPU_DC_RL2_CH_6_COD_EOFIELD_START_CHAN_6      24
#define BM_IPU_DC_RL2_CH_6_COD_EOFIELD_START_CHAN_6      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_6_COD_EOFIELD_START_CHAN_6(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL2_CH_6_COD_EOFIELD_START_CHAN_6)
#else
#define BF_IPU_DC_RL2_CH_6_COD_EOFIELD_START_CHAN_6(v)   (((v) << 24) & BM_IPU_DC_RL2_CH_6_COD_EOFIELD_START_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EOFIELD_START_CHAN_6 field to a new value.
#define BW_IPU_DC_RL2_CH_6_COD_EOFIELD_START_CHAN_6(v)   BF_CS1(IPU_DC_RL2_CH_6, COD_EOFIELD_START_CHAN_6, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL3_CH_6 - DC Routine Link Register 3 Channel 6 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_ADDR_PRIORITY_CHAN_6 : 4; //!< This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_6 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #6)
        unsigned COD_NEW_CHAN_PRIORITY_CHAN_6 : 4; //!< This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED1 : 4; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_6 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #6)
    } B;
} hw_ipu_dc_rl3_ch_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL3_CH_6 register
 */
#define HW_IPU_DC_RL3_CH_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x5808c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL3_CH_6(x)           (*(volatile hw_ipu_dc_rl3_ch_6_t *) HW_IPU_DC_RL3_CH_6_ADDR(x))
#define HW_IPU_DC_RL3_CH_6_RD(x)        (HW_IPU_DC_RL3_CH_6(x).U)
#define HW_IPU_DC_RL3_CH_6_WR(x, v)     (HW_IPU_DC_RL3_CH_6(x).U = (v))
#define HW_IPU_DC_RL3_CH_6_SET(x, v)    (HW_IPU_DC_RL3_CH_6_WR(x, HW_IPU_DC_RL3_CH_6_RD(x) |  (v)))
#define HW_IPU_DC_RL3_CH_6_CLR(x, v)    (HW_IPU_DC_RL3_CH_6_WR(x, HW_IPU_DC_RL3_CH_6_RD(x) & ~(v)))
#define HW_IPU_DC_RL3_CH_6_TOG(x, v)    (HW_IPU_DC_RL3_CH_6_WR(x, HW_IPU_DC_RL3_CH_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL3_CH_6 bitfields
 */

/* --- Register HW_IPU_DC_RL3_CH_6, field COD_NEW_ADDR_PRIORITY_CHAN_6 (RW)
 *
 * This field defines the priority of the new field event (associated with channel #6) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL3_CH_6_COD_NEW_ADDR_PRIORITY_CHAN_6      0
#define BM_IPU_DC_RL3_CH_6_COD_NEW_ADDR_PRIORITY_CHAN_6      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_6_COD_NEW_ADDR_PRIORITY_CHAN_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL3_CH_6_COD_NEW_ADDR_PRIORITY_CHAN_6)
#else
#define BF_IPU_DC_RL3_CH_6_COD_NEW_ADDR_PRIORITY_CHAN_6(v)   (((v) << 0) & BM_IPU_DC_RL3_CH_6_COD_NEW_ADDR_PRIORITY_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_PRIORITY_CHAN_6 field to a new value.
#define BW_IPU_DC_RL3_CH_6_COD_NEW_ADDR_PRIORITY_CHAN_6(v)   BF_CS1(IPU_DC_RL3_CH_6, COD_NEW_ADDR_PRIORITY_CHAN_6, v)
#endif


/* --- Register HW_IPU_DC_RL3_CH_6, field COD_NEW_ADDR_START_CHAN_6 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides (associated with channel #6)
 */

#define BP_IPU_DC_RL3_CH_6_COD_NEW_ADDR_START_CHAN_6      8
#define BM_IPU_DC_RL3_CH_6_COD_NEW_ADDR_START_CHAN_6      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_6_COD_NEW_ADDR_START_CHAN_6(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL3_CH_6_COD_NEW_ADDR_START_CHAN_6)
#else
#define BF_IPU_DC_RL3_CH_6_COD_NEW_ADDR_START_CHAN_6(v)   (((v) << 8) & BM_IPU_DC_RL3_CH_6_COD_NEW_ADDR_START_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_6 field to a new value.
#define BW_IPU_DC_RL3_CH_6_COD_NEW_ADDR_START_CHAN_6(v)   BF_CS1(IPU_DC_RL3_CH_6, COD_NEW_ADDR_START_CHAN_6, v)
#endif

/* --- Register HW_IPU_DC_RL3_CH_6, field COD_NEW_CHAN_PRIORITY_CHAN_6 (RW)
 *
 * This field defines the priority of the new field event (associated with channel #6) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL3_CH_6_COD_NEW_CHAN_PRIORITY_CHAN_6      16
#define BM_IPU_DC_RL3_CH_6_COD_NEW_CHAN_PRIORITY_CHAN_6      0x000f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_6_COD_NEW_CHAN_PRIORITY_CHAN_6(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_RL3_CH_6_COD_NEW_CHAN_PRIORITY_CHAN_6)
#else
#define BF_IPU_DC_RL3_CH_6_COD_NEW_CHAN_PRIORITY_CHAN_6(v)   (((v) << 16) & BM_IPU_DC_RL3_CH_6_COD_NEW_CHAN_PRIORITY_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_PRIORITY_CHAN_6 field to a new value.
#define BW_IPU_DC_RL3_CH_6_COD_NEW_CHAN_PRIORITY_CHAN_6(v)   BF_CS1(IPU_DC_RL3_CH_6, COD_NEW_CHAN_PRIORITY_CHAN_6, v)
#endif


/* --- Register HW_IPU_DC_RL3_CH_6, field COD_NEW_CHAN_START_CHAN_6 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides (associated with channel #6)
 */

#define BP_IPU_DC_RL3_CH_6_COD_NEW_CHAN_START_CHAN_6      24
#define BM_IPU_DC_RL3_CH_6_COD_NEW_CHAN_START_CHAN_6      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_6_COD_NEW_CHAN_START_CHAN_6(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL3_CH_6_COD_NEW_CHAN_START_CHAN_6)
#else
#define BF_IPU_DC_RL3_CH_6_COD_NEW_CHAN_START_CHAN_6(v)   (((v) << 24) & BM_IPU_DC_RL3_CH_6_COD_NEW_CHAN_START_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_6 field to a new value.
#define BW_IPU_DC_RL3_CH_6_COD_NEW_CHAN_START_CHAN_6(v)   BF_CS1(IPU_DC_RL3_CH_6, COD_NEW_CHAN_START_CHAN_6, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL4_CH_6 - DC Routine Link Register 4 Channel 6 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_DATA_PRIORITY_CHAN_6 : 4; //!< This field defines the priority of the new field event (associated with channel #6) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_6 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #6)
        unsigned RESERVED1 : 16; //!< Reserved.
    } B;
} hw_ipu_dc_rl4_ch_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL4_CH_6 register
 */
#define HW_IPU_DC_RL4_CH_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x58090)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL4_CH_6(x)           (*(volatile hw_ipu_dc_rl4_ch_6_t *) HW_IPU_DC_RL4_CH_6_ADDR(x))
#define HW_IPU_DC_RL4_CH_6_RD(x)        (HW_IPU_DC_RL4_CH_6(x).U)
#define HW_IPU_DC_RL4_CH_6_WR(x, v)     (HW_IPU_DC_RL4_CH_6(x).U = (v))
#define HW_IPU_DC_RL4_CH_6_SET(x, v)    (HW_IPU_DC_RL4_CH_6_WR(x, HW_IPU_DC_RL4_CH_6_RD(x) |  (v)))
#define HW_IPU_DC_RL4_CH_6_CLR(x, v)    (HW_IPU_DC_RL4_CH_6_WR(x, HW_IPU_DC_RL4_CH_6_RD(x) & ~(v)))
#define HW_IPU_DC_RL4_CH_6_TOG(x, v)    (HW_IPU_DC_RL4_CH_6_WR(x, HW_IPU_DC_RL4_CH_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL4_CH_6 bitfields
 */

/* --- Register HW_IPU_DC_RL4_CH_6, field COD_NEW_DATA_PRIORITY_CHAN_6 (RW)
 *
 * This field defines the priority of the new field event (associated with channel #6) The priority
 * between the events should be set to a unique value. i.e. two events must not have the same
 * priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL4_CH_6_COD_NEW_DATA_PRIORITY_CHAN_6      0
#define BM_IPU_DC_RL4_CH_6_COD_NEW_DATA_PRIORITY_CHAN_6      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_6_COD_NEW_DATA_PRIORITY_CHAN_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL4_CH_6_COD_NEW_DATA_PRIORITY_CHAN_6)
#else
#define BF_IPU_DC_RL4_CH_6_COD_NEW_DATA_PRIORITY_CHAN_6(v)   (((v) << 0) & BM_IPU_DC_RL4_CH_6_COD_NEW_DATA_PRIORITY_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_PRIORITY_CHAN_6 field to a new value.
#define BW_IPU_DC_RL4_CH_6_COD_NEW_DATA_PRIORITY_CHAN_6(v)   BF_CS1(IPU_DC_RL4_CH_6, COD_NEW_DATA_PRIORITY_CHAN_6, v)
#endif


/* --- Register HW_IPU_DC_RL4_CH_6, field COD_NEW_DATA_START_CHAN_6 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides (associated with channel #6)
 */

#define BP_IPU_DC_RL4_CH_6_COD_NEW_DATA_START_CHAN_6      8
#define BM_IPU_DC_RL4_CH_6_COD_NEW_DATA_START_CHAN_6      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_6_COD_NEW_DATA_START_CHAN_6(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL4_CH_6_COD_NEW_DATA_START_CHAN_6)
#else
#define BF_IPU_DC_RL4_CH_6_COD_NEW_DATA_START_CHAN_6(v)   (((v) << 8) & BM_IPU_DC_RL4_CH_6_COD_NEW_DATA_START_CHAN_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_6 field to a new value.
#define BW_IPU_DC_RL4_CH_6_COD_NEW_DATA_START_CHAN_6(v)   BF_CS1(IPU_DC_RL4_CH_6, COD_NEW_DATA_START_CHAN_6, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_WR_CH_CONF1_8 - DC Write Channel 8 Configuration 1Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned W_SIZE_8 : 2; //!< Word Size associated with channel #8 The data coming from the IDMAC is 32bit wide. This field defines the size of the word used by the DC
        unsigned CHAN_MASK_DEFAULT_8 : 1; //!< Event mask bit for channel #8 When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event
        unsigned MCU_DISP_ID_8 : 2; //!< The field defines which one of the 4 displays is associated with channel #8.
        unsigned RESERVED0 : 27; //!< Reserved.
    } B;
} hw_ipu_dc_wr_ch_conf1_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_WR_CH_CONF1_8 register
 */
#define HW_IPU_DC_WR_CH_CONF1_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x58094)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_WR_CH_CONF1_8(x)           (*(volatile hw_ipu_dc_wr_ch_conf1_8_t *) HW_IPU_DC_WR_CH_CONF1_8_ADDR(x))
#define HW_IPU_DC_WR_CH_CONF1_8_RD(x)        (HW_IPU_DC_WR_CH_CONF1_8(x).U)
#define HW_IPU_DC_WR_CH_CONF1_8_WR(x, v)     (HW_IPU_DC_WR_CH_CONF1_8(x).U = (v))
#define HW_IPU_DC_WR_CH_CONF1_8_SET(x, v)    (HW_IPU_DC_WR_CH_CONF1_8_WR(x, HW_IPU_DC_WR_CH_CONF1_8_RD(x) |  (v)))
#define HW_IPU_DC_WR_CH_CONF1_8_CLR(x, v)    (HW_IPU_DC_WR_CH_CONF1_8_WR(x, HW_IPU_DC_WR_CH_CONF1_8_RD(x) & ~(v)))
#define HW_IPU_DC_WR_CH_CONF1_8_TOG(x, v)    (HW_IPU_DC_WR_CH_CONF1_8_WR(x, HW_IPU_DC_WR_CH_CONF1_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_WR_CH_CONF1_8 bitfields
 */

/* --- Register HW_IPU_DC_WR_CH_CONF1_8, field W_SIZE_8 (RW)
 *
 * Word Size associated with channel #8 The data coming from the IDMAC is 32bit wide. This field
 * defines the size of the word used by the DC
 *
 * Values:
 * 00 - 8 bits are used - a 32 bit words includes 4X8bit valid words.
 * 01 - 16 LSB bits - a 32 bit words includes 2 X16bit valid words.
 * 10 - 24 MSB bits are used (RGB) - 8 LSB bits are ignored by the DC
 * 11 - 32 bits are used
 */

#define BP_IPU_DC_WR_CH_CONF1_8_W_SIZE_8      0
#define BM_IPU_DC_WR_CH_CONF1_8_W_SIZE_8      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF1_8_W_SIZE_8(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_WR_CH_CONF1_8_W_SIZE_8)
#else
#define BF_IPU_DC_WR_CH_CONF1_8_W_SIZE_8(v)   (((v) << 0) & BM_IPU_DC_WR_CH_CONF1_8_W_SIZE_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the W_SIZE_8 field to a new value.
#define BW_IPU_DC_WR_CH_CONF1_8_W_SIZE_8(v)   BF_CS1(IPU_DC_WR_CH_CONF1_8, W_SIZE_8, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF1_8, field CHAN_MASK_DEFAULT_8 (RW)
 *
 * Event mask bit for channel #8 When more then one event is used during a flow (EOF, EOL, NL, NF,
 * EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority
 * event
 *
 * Values:
 * 1 - All the events are used - no mask
 * 0 - Only the highest priority event is used, the rest are masked
 */

#define BP_IPU_DC_WR_CH_CONF1_8_CHAN_MASK_DEFAULT_8      2
#define BM_IPU_DC_WR_CH_CONF1_8_CHAN_MASK_DEFAULT_8      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF1_8_CHAN_MASK_DEFAULT_8(v)   ((((reg32_t) v) << 2) & BM_IPU_DC_WR_CH_CONF1_8_CHAN_MASK_DEFAULT_8)
#else
#define BF_IPU_DC_WR_CH_CONF1_8_CHAN_MASK_DEFAULT_8(v)   (((v) << 2) & BM_IPU_DC_WR_CH_CONF1_8_CHAN_MASK_DEFAULT_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CHAN_MASK_DEFAULT_8 field to a new value.
#define BW_IPU_DC_WR_CH_CONF1_8_CHAN_MASK_DEFAULT_8(v)   BF_CS1(IPU_DC_WR_CH_CONF1_8, CHAN_MASK_DEFAULT_8, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF1_8, field MCU_DISP_ID_8 (RW)
 *
 * The field defines which one of the 4 displays is associated with channel #8.
 *
 * Values:
 * 00 - display #0
 * 01 - display #1
 * 10 - display #2
 * 11 - display #3
 */

#define BP_IPU_DC_WR_CH_CONF1_8_MCU_DISP_ID_8      3
#define BM_IPU_DC_WR_CH_CONF1_8_MCU_DISP_ID_8      0x00000018

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF1_8_MCU_DISP_ID_8(v)   ((((reg32_t) v) << 3) & BM_IPU_DC_WR_CH_CONF1_8_MCU_DISP_ID_8)
#else
#define BF_IPU_DC_WR_CH_CONF1_8_MCU_DISP_ID_8(v)   (((v) << 3) & BM_IPU_DC_WR_CH_CONF1_8_MCU_DISP_ID_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_DISP_ID_8 field to a new value.
#define BW_IPU_DC_WR_CH_CONF1_8_MCU_DISP_ID_8(v)   BF_CS1(IPU_DC_WR_CH_CONF1_8, MCU_DISP_ID_8, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_WR_CH_CONF2_8 - DC Write Channel 8 Configuration 2 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned NEW_ADDR_SPACE_SA_8 : 29; //!< Channel #8 is used for ARM platform direct access to the display. This field defines the base address of the second region accessible on the display
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_wr_ch_conf2_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_WR_CH_CONF2_8 register
 */
#define HW_IPU_DC_WR_CH_CONF2_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x58098)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_WR_CH_CONF2_8(x)           (*(volatile hw_ipu_dc_wr_ch_conf2_8_t *) HW_IPU_DC_WR_CH_CONF2_8_ADDR(x))
#define HW_IPU_DC_WR_CH_CONF2_8_RD(x)        (HW_IPU_DC_WR_CH_CONF2_8(x).U)
#define HW_IPU_DC_WR_CH_CONF2_8_WR(x, v)     (HW_IPU_DC_WR_CH_CONF2_8(x).U = (v))
#define HW_IPU_DC_WR_CH_CONF2_8_SET(x, v)    (HW_IPU_DC_WR_CH_CONF2_8_WR(x, HW_IPU_DC_WR_CH_CONF2_8_RD(x) |  (v)))
#define HW_IPU_DC_WR_CH_CONF2_8_CLR(x, v)    (HW_IPU_DC_WR_CH_CONF2_8_WR(x, HW_IPU_DC_WR_CH_CONF2_8_RD(x) & ~(v)))
#define HW_IPU_DC_WR_CH_CONF2_8_TOG(x, v)    (HW_IPU_DC_WR_CH_CONF2_8_WR(x, HW_IPU_DC_WR_CH_CONF2_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_WR_CH_CONF2_8 bitfields
 */

/* --- Register HW_IPU_DC_WR_CH_CONF2_8, field NEW_ADDR_SPACE_SA_8 (RW)
 *
 * Channel #8 is used for ARM platform direct access to the display. This field defines the base
 * address of the second region accessible on the display
 */

#define BP_IPU_DC_WR_CH_CONF2_8_NEW_ADDR_SPACE_SA_8      0
#define BM_IPU_DC_WR_CH_CONF2_8_NEW_ADDR_SPACE_SA_8      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF2_8_NEW_ADDR_SPACE_SA_8(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_WR_CH_CONF2_8_NEW_ADDR_SPACE_SA_8)
#else
#define BF_IPU_DC_WR_CH_CONF2_8_NEW_ADDR_SPACE_SA_8(v)   (((v) << 0) & BM_IPU_DC_WR_CH_CONF2_8_NEW_ADDR_SPACE_SA_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the NEW_ADDR_SPACE_SA_8 field to a new value.
#define BW_IPU_DC_WR_CH_CONF2_8_NEW_ADDR_SPACE_SA_8(v)   BF_CS1(IPU_DC_WR_CH_CONF2_8, NEW_ADDR_SPACE_SA_8, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL1_CH_8 - DC Routine Link Register 1 Channel 8 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_ADDR_PRIORITY_CHAN_8 : 4; //!< This field defines the priority of the new address event (associated with channel #8, both regions) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_W_8_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #8, first region)
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_W_8_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #8, second region)
    } B;
} hw_ipu_dc_rl1_ch_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL1_CH_8 register
 */
#define HW_IPU_DC_RL1_CH_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x5809c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL1_CH_8(x)           (*(volatile hw_ipu_dc_rl1_ch_8_t *) HW_IPU_DC_RL1_CH_8_ADDR(x))
#define HW_IPU_DC_RL1_CH_8_RD(x)        (HW_IPU_DC_RL1_CH_8(x).U)
#define HW_IPU_DC_RL1_CH_8_WR(x, v)     (HW_IPU_DC_RL1_CH_8(x).U = (v))
#define HW_IPU_DC_RL1_CH_8_SET(x, v)    (HW_IPU_DC_RL1_CH_8_WR(x, HW_IPU_DC_RL1_CH_8_RD(x) |  (v)))
#define HW_IPU_DC_RL1_CH_8_CLR(x, v)    (HW_IPU_DC_RL1_CH_8_WR(x, HW_IPU_DC_RL1_CH_8_RD(x) & ~(v)))
#define HW_IPU_DC_RL1_CH_8_TOG(x, v)    (HW_IPU_DC_RL1_CH_8_WR(x, HW_IPU_DC_RL1_CH_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL1_CH_8 bitfields
 */

/* --- Register HW_IPU_DC_RL1_CH_8, field COD_NEW_ADDR_PRIORITY_CHAN_8 (RW)
 *
 * This field defines the priority of the new address event (associated with channel #8, both
 * regions) The priority between the events should be set to a unique value. i.e. two events must
 * not have the same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL1_CH_8_COD_NEW_ADDR_PRIORITY_CHAN_8      0
#define BM_IPU_DC_RL1_CH_8_COD_NEW_ADDR_PRIORITY_CHAN_8      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_8_COD_NEW_ADDR_PRIORITY_CHAN_8(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL1_CH_8_COD_NEW_ADDR_PRIORITY_CHAN_8)
#else
#define BF_IPU_DC_RL1_CH_8_COD_NEW_ADDR_PRIORITY_CHAN_8(v)   (((v) << 0) & BM_IPU_DC_RL1_CH_8_COD_NEW_ADDR_PRIORITY_CHAN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_PRIORITY_CHAN_8 field to a new value.
#define BW_IPU_DC_RL1_CH_8_COD_NEW_ADDR_PRIORITY_CHAN_8(v)   BF_CS1(IPU_DC_RL1_CH_8, COD_NEW_ADDR_PRIORITY_CHAN_8, v)
#endif


/* --- Register HW_IPU_DC_RL1_CH_8, field COD_NEW_ADDR_START_CHAN_W_8_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides (associated with channel #8, first region)
 */

#define BP_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_0      8
#define BM_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_0)
#else
#define BF_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_0(v)   (((v) << 8) & BM_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_W_8_0 field to a new value.
#define BW_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_0(v)   BF_CS1(IPU_DC_RL1_CH_8, COD_NEW_ADDR_START_CHAN_W_8_0, v)
#endif

/* --- Register HW_IPU_DC_RL1_CH_8, field COD_NEW_ADDR_START_CHAN_W_8_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides (associated with channel #8, second region)
 */

#define BP_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_1      24
#define BM_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_1)
#else
#define BF_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_1(v)   (((v) << 24) & BM_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_W_8_1 field to a new value.
#define BW_IPU_DC_RL1_CH_8_COD_NEW_ADDR_START_CHAN_W_8_1(v)   BF_CS1(IPU_DC_RL1_CH_8, COD_NEW_ADDR_START_CHAN_W_8_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL2_CH_8 - DC Routine Link Register 2 Channel 8 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_CHAN_PRIORITY_CHAN_8 : 4; //!< This field defines the priority of the new address event (associated with channel #8, both regions) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_W_8_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #8, first region)
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_W_8_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #8, second region)
    } B;
} hw_ipu_dc_rl2_ch_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL2_CH_8 register
 */
#define HW_IPU_DC_RL2_CH_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x580a0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL2_CH_8(x)           (*(volatile hw_ipu_dc_rl2_ch_8_t *) HW_IPU_DC_RL2_CH_8_ADDR(x))
#define HW_IPU_DC_RL2_CH_8_RD(x)        (HW_IPU_DC_RL2_CH_8(x).U)
#define HW_IPU_DC_RL2_CH_8_WR(x, v)     (HW_IPU_DC_RL2_CH_8(x).U = (v))
#define HW_IPU_DC_RL2_CH_8_SET(x, v)    (HW_IPU_DC_RL2_CH_8_WR(x, HW_IPU_DC_RL2_CH_8_RD(x) |  (v)))
#define HW_IPU_DC_RL2_CH_8_CLR(x, v)    (HW_IPU_DC_RL2_CH_8_WR(x, HW_IPU_DC_RL2_CH_8_RD(x) & ~(v)))
#define HW_IPU_DC_RL2_CH_8_TOG(x, v)    (HW_IPU_DC_RL2_CH_8_WR(x, HW_IPU_DC_RL2_CH_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL2_CH_8 bitfields
 */

/* --- Register HW_IPU_DC_RL2_CH_8, field COD_NEW_CHAN_PRIORITY_CHAN_8 (RW)
 *
 * This field defines the priority of the new address event (associated with channel #8, both
 * regions) The priority between the events should be set to a unique value. i.e. two events must
 * not have the same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL2_CH_8_COD_NEW_CHAN_PRIORITY_CHAN_8      0
#define BM_IPU_DC_RL2_CH_8_COD_NEW_CHAN_PRIORITY_CHAN_8      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_8_COD_NEW_CHAN_PRIORITY_CHAN_8(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL2_CH_8_COD_NEW_CHAN_PRIORITY_CHAN_8)
#else
#define BF_IPU_DC_RL2_CH_8_COD_NEW_CHAN_PRIORITY_CHAN_8(v)   (((v) << 0) & BM_IPU_DC_RL2_CH_8_COD_NEW_CHAN_PRIORITY_CHAN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_PRIORITY_CHAN_8 field to a new value.
#define BW_IPU_DC_RL2_CH_8_COD_NEW_CHAN_PRIORITY_CHAN_8(v)   BF_CS1(IPU_DC_RL2_CH_8, COD_NEW_CHAN_PRIORITY_CHAN_8, v)
#endif


/* --- Register HW_IPU_DC_RL2_CH_8, field COD_NEW_CHAN_START_CHAN_W_8_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides (associated with channel #8, first region)
 */

#define BP_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_0      8
#define BM_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_0)
#else
#define BF_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_0(v)   (((v) << 8) & BM_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_W_8_0 field to a new value.
#define BW_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_0(v)   BF_CS1(IPU_DC_RL2_CH_8, COD_NEW_CHAN_START_CHAN_W_8_0, v)
#endif

/* --- Register HW_IPU_DC_RL2_CH_8, field COD_NEW_CHAN_START_CHAN_W_8_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides (associated with channel #8, second region)
 */

#define BP_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_1      24
#define BM_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_1)
#else
#define BF_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_1(v)   (((v) << 24) & BM_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_W_8_1 field to a new value.
#define BW_IPU_DC_RL2_CH_8_COD_NEW_CHAN_START_CHAN_W_8_1(v)   BF_CS1(IPU_DC_RL2_CH_8, COD_NEW_CHAN_START_CHAN_W_8_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL3_CH_8 - DC Routine Link Register 3 Channel 8 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_DATA_PRIORITY_CHAN_8 : 4; //!< This field defines the priority of the new address event (associated with channel #8, both regions) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_W_8_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #8, first region)
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_W_8_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #8,second region)
    } B;
} hw_ipu_dc_rl3_ch_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL3_CH_8 register
 */
#define HW_IPU_DC_RL3_CH_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x580a4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL3_CH_8(x)           (*(volatile hw_ipu_dc_rl3_ch_8_t *) HW_IPU_DC_RL3_CH_8_ADDR(x))
#define HW_IPU_DC_RL3_CH_8_RD(x)        (HW_IPU_DC_RL3_CH_8(x).U)
#define HW_IPU_DC_RL3_CH_8_WR(x, v)     (HW_IPU_DC_RL3_CH_8(x).U = (v))
#define HW_IPU_DC_RL3_CH_8_SET(x, v)    (HW_IPU_DC_RL3_CH_8_WR(x, HW_IPU_DC_RL3_CH_8_RD(x) |  (v)))
#define HW_IPU_DC_RL3_CH_8_CLR(x, v)    (HW_IPU_DC_RL3_CH_8_WR(x, HW_IPU_DC_RL3_CH_8_RD(x) & ~(v)))
#define HW_IPU_DC_RL3_CH_8_TOG(x, v)    (HW_IPU_DC_RL3_CH_8_WR(x, HW_IPU_DC_RL3_CH_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL3_CH_8 bitfields
 */

/* --- Register HW_IPU_DC_RL3_CH_8, field COD_NEW_DATA_PRIORITY_CHAN_8 (RW)
 *
 * This field defines the priority of the new address event (associated with channel #8, both
 * regions) The priority between the events should be set to a unique value. i.e. two events must
 * not have the same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL3_CH_8_COD_NEW_DATA_PRIORITY_CHAN_8      0
#define BM_IPU_DC_RL3_CH_8_COD_NEW_DATA_PRIORITY_CHAN_8      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_8_COD_NEW_DATA_PRIORITY_CHAN_8(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL3_CH_8_COD_NEW_DATA_PRIORITY_CHAN_8)
#else
#define BF_IPU_DC_RL3_CH_8_COD_NEW_DATA_PRIORITY_CHAN_8(v)   (((v) << 0) & BM_IPU_DC_RL3_CH_8_COD_NEW_DATA_PRIORITY_CHAN_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_PRIORITY_CHAN_8 field to a new value.
#define BW_IPU_DC_RL3_CH_8_COD_NEW_DATA_PRIORITY_CHAN_8(v)   BF_CS1(IPU_DC_RL3_CH_8, COD_NEW_DATA_PRIORITY_CHAN_8, v)
#endif


/* --- Register HW_IPU_DC_RL3_CH_8, field COD_NEW_DATA_START_CHAN_W_8_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides (associated with channel #8, first region)
 */

#define BP_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_0      8
#define BM_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_0)
#else
#define BF_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_0(v)   (((v) << 8) & BM_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_W_8_0 field to a new value.
#define BW_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_0(v)   BF_CS1(IPU_DC_RL3_CH_8, COD_NEW_DATA_START_CHAN_W_8_0, v)
#endif

/* --- Register HW_IPU_DC_RL3_CH_8, field COD_NEW_DATA_START_CHAN_W_8_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides (associated with channel #8,second region)
 */

#define BP_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_1      24
#define BM_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_1)
#else
#define BF_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_1(v)   (((v) << 24) & BM_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_W_8_1 field to a new value.
#define BW_IPU_DC_RL3_CH_8_COD_NEW_DATA_START_CHAN_W_8_1(v)   BF_CS1(IPU_DC_RL3_CH_8, COD_NEW_DATA_START_CHAN_W_8_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL4_CH_8 - DC Routine Link Register 4 Channel 8 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 8; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_R_8_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #8, first region)
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_R_8_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #8, second region)
    } B;
} hw_ipu_dc_rl4_ch_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL4_CH_8 register
 */
#define HW_IPU_DC_RL4_CH_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x580a8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL4_CH_8(x)           (*(volatile hw_ipu_dc_rl4_ch_8_t *) HW_IPU_DC_RL4_CH_8_ADDR(x))
#define HW_IPU_DC_RL4_CH_8_RD(x)        (HW_IPU_DC_RL4_CH_8(x).U)
#define HW_IPU_DC_RL4_CH_8_WR(x, v)     (HW_IPU_DC_RL4_CH_8(x).U = (v))
#define HW_IPU_DC_RL4_CH_8_SET(x, v)    (HW_IPU_DC_RL4_CH_8_WR(x, HW_IPU_DC_RL4_CH_8_RD(x) |  (v)))
#define HW_IPU_DC_RL4_CH_8_CLR(x, v)    (HW_IPU_DC_RL4_CH_8_WR(x, HW_IPU_DC_RL4_CH_8_RD(x) & ~(v)))
#define HW_IPU_DC_RL4_CH_8_TOG(x, v)    (HW_IPU_DC_RL4_CH_8_WR(x, HW_IPU_DC_RL4_CH_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL4_CH_8 bitfields
 */

/* --- Register HW_IPU_DC_RL4_CH_8, field COD_NEW_ADDR_START_CHAN_R_8_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides (associated with channel #8, first region)
 */

#define BP_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_0      8
#define BM_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_0)
#else
#define BF_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_0(v)   (((v) << 8) & BM_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_R_8_0 field to a new value.
#define BW_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_0(v)   BF_CS1(IPU_DC_RL4_CH_8, COD_NEW_ADDR_START_CHAN_R_8_0, v)
#endif

/* --- Register HW_IPU_DC_RL4_CH_8, field COD_NEW_ADDR_START_CHAN_R_8_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides (associated with channel #8, second region)
 */

#define BP_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_1      24
#define BM_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_1)
#else
#define BF_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_1(v)   (((v) << 24) & BM_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_R_8_1 field to a new value.
#define BW_IPU_DC_RL4_CH_8_COD_NEW_ADDR_START_CHAN_R_8_1(v)   BF_CS1(IPU_DC_RL4_CH_8, COD_NEW_ADDR_START_CHAN_R_8_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL5_CH_8 - DC Routine Link Register 5 Channel 8 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 8; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_R_8_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #8, first region)
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_R_8_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #8, second region)
    } B;
} hw_ipu_dc_rl5_ch_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL5_CH_8 register
 */
#define HW_IPU_DC_RL5_CH_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x580ac)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL5_CH_8(x)           (*(volatile hw_ipu_dc_rl5_ch_8_t *) HW_IPU_DC_RL5_CH_8_ADDR(x))
#define HW_IPU_DC_RL5_CH_8_RD(x)        (HW_IPU_DC_RL5_CH_8(x).U)
#define HW_IPU_DC_RL5_CH_8_WR(x, v)     (HW_IPU_DC_RL5_CH_8(x).U = (v))
#define HW_IPU_DC_RL5_CH_8_SET(x, v)    (HW_IPU_DC_RL5_CH_8_WR(x, HW_IPU_DC_RL5_CH_8_RD(x) |  (v)))
#define HW_IPU_DC_RL5_CH_8_CLR(x, v)    (HW_IPU_DC_RL5_CH_8_WR(x, HW_IPU_DC_RL5_CH_8_RD(x) & ~(v)))
#define HW_IPU_DC_RL5_CH_8_TOG(x, v)    (HW_IPU_DC_RL5_CH_8_WR(x, HW_IPU_DC_RL5_CH_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL5_CH_8 bitfields
 */

/* --- Register HW_IPU_DC_RL5_CH_8, field COD_NEW_CHAN_START_CHAN_R_8_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides (associated with channel #8, first region)
 */

#define BP_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_0      8
#define BM_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_0)
#else
#define BF_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_0(v)   (((v) << 8) & BM_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_R_8_0 field to a new value.
#define BW_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_0(v)   BF_CS1(IPU_DC_RL5_CH_8, COD_NEW_CHAN_START_CHAN_R_8_0, v)
#endif

/* --- Register HW_IPU_DC_RL5_CH_8, field COD_NEW_CHAN_START_CHAN_R_8_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides (associated with channel #8, second region)
 */

#define BP_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_1      24
#define BM_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_1)
#else
#define BF_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_1(v)   (((v) << 24) & BM_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_R_8_1 field to a new value.
#define BW_IPU_DC_RL5_CH_8_COD_NEW_CHAN_START_CHAN_R_8_1(v)   BF_CS1(IPU_DC_RL5_CH_8, COD_NEW_CHAN_START_CHAN_R_8_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL6_CH_8 - DC Routine Link Register 6 Channel 8 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 8; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_R_8_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #8, first region)
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_R_8_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #8, second region)
    } B;
} hw_ipu_dc_rl6_ch_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL6_CH_8 register
 */
#define HW_IPU_DC_RL6_CH_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x580b0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL6_CH_8(x)           (*(volatile hw_ipu_dc_rl6_ch_8_t *) HW_IPU_DC_RL6_CH_8_ADDR(x))
#define HW_IPU_DC_RL6_CH_8_RD(x)        (HW_IPU_DC_RL6_CH_8(x).U)
#define HW_IPU_DC_RL6_CH_8_WR(x, v)     (HW_IPU_DC_RL6_CH_8(x).U = (v))
#define HW_IPU_DC_RL6_CH_8_SET(x, v)    (HW_IPU_DC_RL6_CH_8_WR(x, HW_IPU_DC_RL6_CH_8_RD(x) |  (v)))
#define HW_IPU_DC_RL6_CH_8_CLR(x, v)    (HW_IPU_DC_RL6_CH_8_WR(x, HW_IPU_DC_RL6_CH_8_RD(x) & ~(v)))
#define HW_IPU_DC_RL6_CH_8_TOG(x, v)    (HW_IPU_DC_RL6_CH_8_WR(x, HW_IPU_DC_RL6_CH_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL6_CH_8 bitfields
 */

/* --- Register HW_IPU_DC_RL6_CH_8, field COD_NEW_DATA_START_CHAN_R_8_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides (associated with channel #8, first region)
 */

#define BP_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_0      8
#define BM_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_0)
#else
#define BF_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_0(v)   (((v) << 8) & BM_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_R_8_0 field to a new value.
#define BW_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_0(v)   BF_CS1(IPU_DC_RL6_CH_8, COD_NEW_DATA_START_CHAN_R_8_0, v)
#endif

/* --- Register HW_IPU_DC_RL6_CH_8, field COD_NEW_DATA_START_CHAN_R_8_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides (associated with channel #8, second region)
 */

#define BP_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_1      24
#define BM_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_1)
#else
#define BF_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_1(v)   (((v) << 24) & BM_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_R_8_1 field to a new value.
#define BW_IPU_DC_RL6_CH_8_COD_NEW_DATA_START_CHAN_R_8_1(v)   BF_CS1(IPU_DC_RL6_CH_8, COD_NEW_DATA_START_CHAN_R_8_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_WR_CH_CONF1_9 - DC Write Channel 9 Configuration 1Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned W_SIZE_9 : 2; //!< Word Size associated with channel #9 The data coming from the IDMAC is 32bit wide. This field defines the size of the word used by the DC
        unsigned CHAN_MASK_DEFAULT_9 : 1; //!< Event mask bit for channel #9 When more then one event is used during a flow (EOF, EOL, NL, NF, EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority event
        unsigned MCU_DISP_ID_9 : 2; //!< The field defines which one of the 4 displays is associated with channel #9.
        unsigned RESERVED0 : 27; //!< Reserved.
    } B;
} hw_ipu_dc_wr_ch_conf1_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_WR_CH_CONF1_9 register
 */
#define HW_IPU_DC_WR_CH_CONF1_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x580b4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_WR_CH_CONF1_9(x)           (*(volatile hw_ipu_dc_wr_ch_conf1_9_t *) HW_IPU_DC_WR_CH_CONF1_9_ADDR(x))
#define HW_IPU_DC_WR_CH_CONF1_9_RD(x)        (HW_IPU_DC_WR_CH_CONF1_9(x).U)
#define HW_IPU_DC_WR_CH_CONF1_9_WR(x, v)     (HW_IPU_DC_WR_CH_CONF1_9(x).U = (v))
#define HW_IPU_DC_WR_CH_CONF1_9_SET(x, v)    (HW_IPU_DC_WR_CH_CONF1_9_WR(x, HW_IPU_DC_WR_CH_CONF1_9_RD(x) |  (v)))
#define HW_IPU_DC_WR_CH_CONF1_9_CLR(x, v)    (HW_IPU_DC_WR_CH_CONF1_9_WR(x, HW_IPU_DC_WR_CH_CONF1_9_RD(x) & ~(v)))
#define HW_IPU_DC_WR_CH_CONF1_9_TOG(x, v)    (HW_IPU_DC_WR_CH_CONF1_9_WR(x, HW_IPU_DC_WR_CH_CONF1_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_WR_CH_CONF1_9 bitfields
 */

/* --- Register HW_IPU_DC_WR_CH_CONF1_9, field W_SIZE_9 (RW)
 *
 * Word Size associated with channel #9 The data coming from the IDMAC is 32bit wide. This field
 * defines the size of the word used by the DC
 *
 * Values:
 * 00 - 8 bits are used - a 32 bit words includes 4X8bit valid words.
 * 01 - 16 LSB bits - a 32 bit words includes 2 X16bit valid words.
 * 10 - 24 MSB bits are used (RGB) - 8 LSB bits are ignored by the DC
 * 11 - 32 bits are used
 */

#define BP_IPU_DC_WR_CH_CONF1_9_W_SIZE_9      0
#define BM_IPU_DC_WR_CH_CONF1_9_W_SIZE_9      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF1_9_W_SIZE_9(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_WR_CH_CONF1_9_W_SIZE_9)
#else
#define BF_IPU_DC_WR_CH_CONF1_9_W_SIZE_9(v)   (((v) << 0) & BM_IPU_DC_WR_CH_CONF1_9_W_SIZE_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the W_SIZE_9 field to a new value.
#define BW_IPU_DC_WR_CH_CONF1_9_W_SIZE_9(v)   BF_CS1(IPU_DC_WR_CH_CONF1_9, W_SIZE_9, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF1_9, field CHAN_MASK_DEFAULT_9 (RW)
 *
 * Event mask bit for channel #9 When more then one event is used during a flow (EOF, EOL, NL, NF,
 * EOFIELD, etc.) masks all the event besides the event that is defined as the highest priority
 * event
 *
 * Values:
 * 1 - All the events are used - no mask
 * 0 - Only the highest priority event is used, the rest are masked
 */

#define BP_IPU_DC_WR_CH_CONF1_9_CHAN_MASK_DEFAULT_9      2
#define BM_IPU_DC_WR_CH_CONF1_9_CHAN_MASK_DEFAULT_9      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF1_9_CHAN_MASK_DEFAULT_9(v)   ((((reg32_t) v) << 2) & BM_IPU_DC_WR_CH_CONF1_9_CHAN_MASK_DEFAULT_9)
#else
#define BF_IPU_DC_WR_CH_CONF1_9_CHAN_MASK_DEFAULT_9(v)   (((v) << 2) & BM_IPU_DC_WR_CH_CONF1_9_CHAN_MASK_DEFAULT_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the CHAN_MASK_DEFAULT_9 field to a new value.
#define BW_IPU_DC_WR_CH_CONF1_9_CHAN_MASK_DEFAULT_9(v)   BF_CS1(IPU_DC_WR_CH_CONF1_9, CHAN_MASK_DEFAULT_9, v)
#endif


/* --- Register HW_IPU_DC_WR_CH_CONF1_9, field MCU_DISP_ID_9 (RW)
 *
 * The field defines which one of the 4 displays is associated with channel #9.
 *
 * Values:
 * 00 - display #0
 * 01 - display #1
 * 10 - display #2
 * 11 - display #3
 */

#define BP_IPU_DC_WR_CH_CONF1_9_MCU_DISP_ID_9      3
#define BM_IPU_DC_WR_CH_CONF1_9_MCU_DISP_ID_9      0x00000018

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF1_9_MCU_DISP_ID_9(v)   ((((reg32_t) v) << 3) & BM_IPU_DC_WR_CH_CONF1_9_MCU_DISP_ID_9)
#else
#define BF_IPU_DC_WR_CH_CONF1_9_MCU_DISP_ID_9(v)   (((v) << 3) & BM_IPU_DC_WR_CH_CONF1_9_MCU_DISP_ID_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_DISP_ID_9 field to a new value.
#define BW_IPU_DC_WR_CH_CONF1_9_MCU_DISP_ID_9(v)   BF_CS1(IPU_DC_WR_CH_CONF1_9, MCU_DISP_ID_9, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_WR_CH_CONF2_9 - DC Write Channel 9Configuration 2Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned NEW_ADDR_SPACE_SA_9 : 29; //!< Channel #8 is used for ARM platform direct access to the display. This field defines the base address of the second region accessible on the display
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_wr_ch_conf2_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_WR_CH_CONF2_9 register
 */
#define HW_IPU_DC_WR_CH_CONF2_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x580b8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_WR_CH_CONF2_9(x)           (*(volatile hw_ipu_dc_wr_ch_conf2_9_t *) HW_IPU_DC_WR_CH_CONF2_9_ADDR(x))
#define HW_IPU_DC_WR_CH_CONF2_9_RD(x)        (HW_IPU_DC_WR_CH_CONF2_9(x).U)
#define HW_IPU_DC_WR_CH_CONF2_9_WR(x, v)     (HW_IPU_DC_WR_CH_CONF2_9(x).U = (v))
#define HW_IPU_DC_WR_CH_CONF2_9_SET(x, v)    (HW_IPU_DC_WR_CH_CONF2_9_WR(x, HW_IPU_DC_WR_CH_CONF2_9_RD(x) |  (v)))
#define HW_IPU_DC_WR_CH_CONF2_9_CLR(x, v)    (HW_IPU_DC_WR_CH_CONF2_9_WR(x, HW_IPU_DC_WR_CH_CONF2_9_RD(x) & ~(v)))
#define HW_IPU_DC_WR_CH_CONF2_9_TOG(x, v)    (HW_IPU_DC_WR_CH_CONF2_9_WR(x, HW_IPU_DC_WR_CH_CONF2_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_WR_CH_CONF2_9 bitfields
 */

/* --- Register HW_IPU_DC_WR_CH_CONF2_9, field NEW_ADDR_SPACE_SA_9 (RW)
 *
 * Channel #8 is used for ARM platform direct access to the display. This field defines the base
 * address of the second region accessible on the display
 */

#define BP_IPU_DC_WR_CH_CONF2_9_NEW_ADDR_SPACE_SA_9      0
#define BM_IPU_DC_WR_CH_CONF2_9_NEW_ADDR_SPACE_SA_9      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_CONF2_9_NEW_ADDR_SPACE_SA_9(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_WR_CH_CONF2_9_NEW_ADDR_SPACE_SA_9)
#else
#define BF_IPU_DC_WR_CH_CONF2_9_NEW_ADDR_SPACE_SA_9(v)   (((v) << 0) & BM_IPU_DC_WR_CH_CONF2_9_NEW_ADDR_SPACE_SA_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the NEW_ADDR_SPACE_SA_9 field to a new value.
#define BW_IPU_DC_WR_CH_CONF2_9_NEW_ADDR_SPACE_SA_9(v)   BF_CS1(IPU_DC_WR_CH_CONF2_9, NEW_ADDR_SPACE_SA_9, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL1_CH_9 - DC Routine Link Register 1 Channel 9 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_ADDR_PRIORITY_CHAN_9 : 4; //!< This field defines the priority of the new address event (associated with channel #9, both regions) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_W_9_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #9, first region)
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_W_9_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #9, second region)
    } B;
} hw_ipu_dc_rl1_ch_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL1_CH_9 register
 */
#define HW_IPU_DC_RL1_CH_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x580bc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL1_CH_9(x)           (*(volatile hw_ipu_dc_rl1_ch_9_t *) HW_IPU_DC_RL1_CH_9_ADDR(x))
#define HW_IPU_DC_RL1_CH_9_RD(x)        (HW_IPU_DC_RL1_CH_9(x).U)
#define HW_IPU_DC_RL1_CH_9_WR(x, v)     (HW_IPU_DC_RL1_CH_9(x).U = (v))
#define HW_IPU_DC_RL1_CH_9_SET(x, v)    (HW_IPU_DC_RL1_CH_9_WR(x, HW_IPU_DC_RL1_CH_9_RD(x) |  (v)))
#define HW_IPU_DC_RL1_CH_9_CLR(x, v)    (HW_IPU_DC_RL1_CH_9_WR(x, HW_IPU_DC_RL1_CH_9_RD(x) & ~(v)))
#define HW_IPU_DC_RL1_CH_9_TOG(x, v)    (HW_IPU_DC_RL1_CH_9_WR(x, HW_IPU_DC_RL1_CH_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL1_CH_9 bitfields
 */

/* --- Register HW_IPU_DC_RL1_CH_9, field COD_NEW_ADDR_PRIORITY_CHAN_9 (RW)
 *
 * This field defines the priority of the new address event (associated with channel #9, both
 * regions) The priority between the events should be set to a unique value. i.e. two events must
 * not have the same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL1_CH_9_COD_NEW_ADDR_PRIORITY_CHAN_9      0
#define BM_IPU_DC_RL1_CH_9_COD_NEW_ADDR_PRIORITY_CHAN_9      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_9_COD_NEW_ADDR_PRIORITY_CHAN_9(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL1_CH_9_COD_NEW_ADDR_PRIORITY_CHAN_9)
#else
#define BF_IPU_DC_RL1_CH_9_COD_NEW_ADDR_PRIORITY_CHAN_9(v)   (((v) << 0) & BM_IPU_DC_RL1_CH_9_COD_NEW_ADDR_PRIORITY_CHAN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_PRIORITY_CHAN_9 field to a new value.
#define BW_IPU_DC_RL1_CH_9_COD_NEW_ADDR_PRIORITY_CHAN_9(v)   BF_CS1(IPU_DC_RL1_CH_9, COD_NEW_ADDR_PRIORITY_CHAN_9, v)
#endif


/* --- Register HW_IPU_DC_RL1_CH_9, field COD_NEW_ADDR_START_CHAN_W_9_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides (associated with channel #9, first region)
 */

#define BP_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_0      8
#define BM_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_0)
#else
#define BF_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_0(v)   (((v) << 8) & BM_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_W_9_0 field to a new value.
#define BW_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_0(v)   BF_CS1(IPU_DC_RL1_CH_9, COD_NEW_ADDR_START_CHAN_W_9_0, v)
#endif

/* --- Register HW_IPU_DC_RL1_CH_9, field COD_NEW_ADDR_START_CHAN_W_9_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides (associated with channel #9, second region)
 */

#define BP_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_1      24
#define BM_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_1)
#else
#define BF_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_1(v)   (((v) << 24) & BM_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_W_9_1 field to a new value.
#define BW_IPU_DC_RL1_CH_9_COD_NEW_ADDR_START_CHAN_W_9_1(v)   BF_CS1(IPU_DC_RL1_CH_9, COD_NEW_ADDR_START_CHAN_W_9_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL2_CH_9 - DC Routine Link Register 2 Channel 9 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_CHAN_PRIORITY_CHAN_9 : 4; //!< This field defines the priority of the new address event (associated with channel #9, both regions) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_W_9_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #9, first region)
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_W_9_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #9, second region)
    } B;
} hw_ipu_dc_rl2_ch_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL2_CH_9 register
 */
#define HW_IPU_DC_RL2_CH_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x580c0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL2_CH_9(x)           (*(volatile hw_ipu_dc_rl2_ch_9_t *) HW_IPU_DC_RL2_CH_9_ADDR(x))
#define HW_IPU_DC_RL2_CH_9_RD(x)        (HW_IPU_DC_RL2_CH_9(x).U)
#define HW_IPU_DC_RL2_CH_9_WR(x, v)     (HW_IPU_DC_RL2_CH_9(x).U = (v))
#define HW_IPU_DC_RL2_CH_9_SET(x, v)    (HW_IPU_DC_RL2_CH_9_WR(x, HW_IPU_DC_RL2_CH_9_RD(x) |  (v)))
#define HW_IPU_DC_RL2_CH_9_CLR(x, v)    (HW_IPU_DC_RL2_CH_9_WR(x, HW_IPU_DC_RL2_CH_9_RD(x) & ~(v)))
#define HW_IPU_DC_RL2_CH_9_TOG(x, v)    (HW_IPU_DC_RL2_CH_9_WR(x, HW_IPU_DC_RL2_CH_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL2_CH_9 bitfields
 */

/* --- Register HW_IPU_DC_RL2_CH_9, field COD_NEW_CHAN_PRIORITY_CHAN_9 (RW)
 *
 * This field defines the priority of the new address event (associated with channel #9, both
 * regions) The priority between the events should be set to a unique value. i.e. two events must
 * not have the same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL2_CH_9_COD_NEW_CHAN_PRIORITY_CHAN_9      0
#define BM_IPU_DC_RL2_CH_9_COD_NEW_CHAN_PRIORITY_CHAN_9      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_9_COD_NEW_CHAN_PRIORITY_CHAN_9(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL2_CH_9_COD_NEW_CHAN_PRIORITY_CHAN_9)
#else
#define BF_IPU_DC_RL2_CH_9_COD_NEW_CHAN_PRIORITY_CHAN_9(v)   (((v) << 0) & BM_IPU_DC_RL2_CH_9_COD_NEW_CHAN_PRIORITY_CHAN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_PRIORITY_CHAN_9 field to a new value.
#define BW_IPU_DC_RL2_CH_9_COD_NEW_CHAN_PRIORITY_CHAN_9(v)   BF_CS1(IPU_DC_RL2_CH_9, COD_NEW_CHAN_PRIORITY_CHAN_9, v)
#endif


/* --- Register HW_IPU_DC_RL2_CH_9, field COD_NEW_CHAN_START_CHAN_W_9_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides (associated with channel #9, first region)
 */

#define BP_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_0      8
#define BM_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_0)
#else
#define BF_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_0(v)   (((v) << 8) & BM_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_W_9_0 field to a new value.
#define BW_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_0(v)   BF_CS1(IPU_DC_RL2_CH_9, COD_NEW_CHAN_START_CHAN_W_9_0, v)
#endif

/* --- Register HW_IPU_DC_RL2_CH_9, field COD_NEW_CHAN_START_CHAN_W_9_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides (associated with channel #9, second region)
 */

#define BP_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_1      24
#define BM_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_1)
#else
#define BF_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_1(v)   (((v) << 24) & BM_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_W_9_1 field to a new value.
#define BW_IPU_DC_RL2_CH_9_COD_NEW_CHAN_START_CHAN_W_9_1(v)   BF_CS1(IPU_DC_RL2_CH_9, COD_NEW_CHAN_START_CHAN_W_9_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL3_CH_9 - DC Routine Link Register 3Channel 9 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned COD_NEW_DATA_PRIORITY_CHAN_9 : 4; //!< This field defines the priority of the new address event (associated with channel #9, both regions) The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 4; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_W_9_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #9, first region)
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_W_9_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #9, second region)
    } B;
} hw_ipu_dc_rl3_ch_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL3_CH_9 register
 */
#define HW_IPU_DC_RL3_CH_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x580c4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL3_CH_9(x)           (*(volatile hw_ipu_dc_rl3_ch_9_t *) HW_IPU_DC_RL3_CH_9_ADDR(x))
#define HW_IPU_DC_RL3_CH_9_RD(x)        (HW_IPU_DC_RL3_CH_9(x).U)
#define HW_IPU_DC_RL3_CH_9_WR(x, v)     (HW_IPU_DC_RL3_CH_9(x).U = (v))
#define HW_IPU_DC_RL3_CH_9_SET(x, v)    (HW_IPU_DC_RL3_CH_9_WR(x, HW_IPU_DC_RL3_CH_9_RD(x) |  (v)))
#define HW_IPU_DC_RL3_CH_9_CLR(x, v)    (HW_IPU_DC_RL3_CH_9_WR(x, HW_IPU_DC_RL3_CH_9_RD(x) & ~(v)))
#define HW_IPU_DC_RL3_CH_9_TOG(x, v)    (HW_IPU_DC_RL3_CH_9_WR(x, HW_IPU_DC_RL3_CH_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL3_CH_9 bitfields
 */

/* --- Register HW_IPU_DC_RL3_CH_9, field COD_NEW_DATA_PRIORITY_CHAN_9 (RW)
 *
 * This field defines the priority of the new address event (associated with channel #9, both
 * regions) The priority between the events should be set to a unique value. i.e. two events must
 * not have the same priority (except 0000 - disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_RL3_CH_9_COD_NEW_DATA_PRIORITY_CHAN_9      0
#define BM_IPU_DC_RL3_CH_9_COD_NEW_DATA_PRIORITY_CHAN_9      0x0000000f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_9_COD_NEW_DATA_PRIORITY_CHAN_9(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_RL3_CH_9_COD_NEW_DATA_PRIORITY_CHAN_9)
#else
#define BF_IPU_DC_RL3_CH_9_COD_NEW_DATA_PRIORITY_CHAN_9(v)   (((v) << 0) & BM_IPU_DC_RL3_CH_9_COD_NEW_DATA_PRIORITY_CHAN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_PRIORITY_CHAN_9 field to a new value.
#define BW_IPU_DC_RL3_CH_9_COD_NEW_DATA_PRIORITY_CHAN_9(v)   BF_CS1(IPU_DC_RL3_CH_9, COD_NEW_DATA_PRIORITY_CHAN_9, v)
#endif


/* --- Register HW_IPU_DC_RL3_CH_9, field COD_NEW_DATA_START_CHAN_W_9_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides (associated with channel #9, first region)
 */

#define BP_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_0      8
#define BM_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_0)
#else
#define BF_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_0(v)   (((v) << 8) & BM_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_W_9_0 field to a new value.
#define BW_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_0(v)   BF_CS1(IPU_DC_RL3_CH_9, COD_NEW_DATA_START_CHAN_W_9_0, v)
#endif

/* --- Register HW_IPU_DC_RL3_CH_9, field COD_NEW_DATA_START_CHAN_W_9_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides (associated with channel #9, second region)
 */

#define BP_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_1      24
#define BM_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_1)
#else
#define BF_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_1(v)   (((v) << 24) & BM_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_W_9_1 field to a new value.
#define BW_IPU_DC_RL3_CH_9_COD_NEW_DATA_START_CHAN_W_9_1(v)   BF_CS1(IPU_DC_RL3_CH_9, COD_NEW_DATA_START_CHAN_W_9_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL4_CH_9 - DC Routine Link Register 4 Channel 9 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 8; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_R_9_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #9, first region)
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_NEW_ADDR_START_CHAN_R_9_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new address event resides (associated with channel #9, second region)
    } B;
} hw_ipu_dc_rl4_ch_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL4_CH_9 register
 */
#define HW_IPU_DC_RL4_CH_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x580c8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL4_CH_9(x)           (*(volatile hw_ipu_dc_rl4_ch_9_t *) HW_IPU_DC_RL4_CH_9_ADDR(x))
#define HW_IPU_DC_RL4_CH_9_RD(x)        (HW_IPU_DC_RL4_CH_9(x).U)
#define HW_IPU_DC_RL4_CH_9_WR(x, v)     (HW_IPU_DC_RL4_CH_9(x).U = (v))
#define HW_IPU_DC_RL4_CH_9_SET(x, v)    (HW_IPU_DC_RL4_CH_9_WR(x, HW_IPU_DC_RL4_CH_9_RD(x) |  (v)))
#define HW_IPU_DC_RL4_CH_9_CLR(x, v)    (HW_IPU_DC_RL4_CH_9_WR(x, HW_IPU_DC_RL4_CH_9_RD(x) & ~(v)))
#define HW_IPU_DC_RL4_CH_9_TOG(x, v)    (HW_IPU_DC_RL4_CH_9_WR(x, HW_IPU_DC_RL4_CH_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL4_CH_9 bitfields
 */

/* --- Register HW_IPU_DC_RL4_CH_9, field COD_NEW_ADDR_START_CHAN_R_9_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides (associated with channel #9, first region)
 */

#define BP_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_0      8
#define BM_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_0)
#else
#define BF_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_0(v)   (((v) << 8) & BM_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_R_9_0 field to a new value.
#define BW_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_0(v)   BF_CS1(IPU_DC_RL4_CH_9, COD_NEW_ADDR_START_CHAN_R_9_0, v)
#endif

/* --- Register HW_IPU_DC_RL4_CH_9, field COD_NEW_ADDR_START_CHAN_R_9_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new address event resides (associated with channel #9, second region)
 */

#define BP_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_1      24
#define BM_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_1)
#else
#define BF_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_1(v)   (((v) << 24) & BM_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_ADDR_START_CHAN_R_9_1 field to a new value.
#define BW_IPU_DC_RL4_CH_9_COD_NEW_ADDR_START_CHAN_R_9_1(v)   BF_CS1(IPU_DC_RL4_CH_9, COD_NEW_ADDR_START_CHAN_R_9_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL5_CH_9 - DC Routine Link Register 5 Channel 9 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 8; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_R_9_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #9, first region)
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_NEW_CHAN_START_CHAN_R_9_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new channel event resides (associated with channel #9, second region)
    } B;
} hw_ipu_dc_rl5_ch_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL5_CH_9 register
 */
#define HW_IPU_DC_RL5_CH_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x580cc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL5_CH_9(x)           (*(volatile hw_ipu_dc_rl5_ch_9_t *) HW_IPU_DC_RL5_CH_9_ADDR(x))
#define HW_IPU_DC_RL5_CH_9_RD(x)        (HW_IPU_DC_RL5_CH_9(x).U)
#define HW_IPU_DC_RL5_CH_9_WR(x, v)     (HW_IPU_DC_RL5_CH_9(x).U = (v))
#define HW_IPU_DC_RL5_CH_9_SET(x, v)    (HW_IPU_DC_RL5_CH_9_WR(x, HW_IPU_DC_RL5_CH_9_RD(x) |  (v)))
#define HW_IPU_DC_RL5_CH_9_CLR(x, v)    (HW_IPU_DC_RL5_CH_9_WR(x, HW_IPU_DC_RL5_CH_9_RD(x) & ~(v)))
#define HW_IPU_DC_RL5_CH_9_TOG(x, v)    (HW_IPU_DC_RL5_CH_9_WR(x, HW_IPU_DC_RL5_CH_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL5_CH_9 bitfields
 */

/* --- Register HW_IPU_DC_RL5_CH_9, field COD_NEW_CHAN_START_CHAN_R_9_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides (associated with channel #9, first region)
 */

#define BP_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_0      8
#define BM_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_0)
#else
#define BF_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_0(v)   (((v) << 8) & BM_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_R_9_0 field to a new value.
#define BW_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_0(v)   BF_CS1(IPU_DC_RL5_CH_9, COD_NEW_CHAN_START_CHAN_R_9_0, v)
#endif

/* --- Register HW_IPU_DC_RL5_CH_9, field COD_NEW_CHAN_START_CHAN_R_9_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new channel event resides (associated with channel #9, second region)
 */

#define BP_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_1      24
#define BM_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_1)
#else
#define BF_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_1(v)   (((v) << 24) & BM_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_CHAN_START_CHAN_R_9_1 field to a new value.
#define BW_IPU_DC_RL5_CH_9_COD_NEW_CHAN_START_CHAN_R_9_1(v)   BF_CS1(IPU_DC_RL5_CH_9, COD_NEW_CHAN_START_CHAN_R_9_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_RL6_CH_9 - DC Routine Link Register 6 Channel 9 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 8; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_R_9_0 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #9, first region)
        unsigned RESERVED1 : 8; //!< Reserved.
        unsigned COD_NEW_DATA_START_CHAN_R_9_1 : 8; //!< This field is a pointer to the address within the microcode memory where the routine that handles the new data event resides (associated with channel #9, second region)
    } B;
} hw_ipu_dc_rl6_ch_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_RL6_CH_9 register
 */
#define HW_IPU_DC_RL6_CH_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x580d0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_RL6_CH_9(x)           (*(volatile hw_ipu_dc_rl6_ch_9_t *) HW_IPU_DC_RL6_CH_9_ADDR(x))
#define HW_IPU_DC_RL6_CH_9_RD(x)        (HW_IPU_DC_RL6_CH_9(x).U)
#define HW_IPU_DC_RL6_CH_9_WR(x, v)     (HW_IPU_DC_RL6_CH_9(x).U = (v))
#define HW_IPU_DC_RL6_CH_9_SET(x, v)    (HW_IPU_DC_RL6_CH_9_WR(x, HW_IPU_DC_RL6_CH_9_RD(x) |  (v)))
#define HW_IPU_DC_RL6_CH_9_CLR(x, v)    (HW_IPU_DC_RL6_CH_9_WR(x, HW_IPU_DC_RL6_CH_9_RD(x) & ~(v)))
#define HW_IPU_DC_RL6_CH_9_TOG(x, v)    (HW_IPU_DC_RL6_CH_9_WR(x, HW_IPU_DC_RL6_CH_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_RL6_CH_9 bitfields
 */

/* --- Register HW_IPU_DC_RL6_CH_9, field COD_NEW_DATA_START_CHAN_R_9_0 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides (associated with channel #9, first region)
 */

#define BP_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_0      8
#define BM_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_0)
#else
#define BF_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_0(v)   (((v) << 8) & BM_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_R_9_0 field to a new value.
#define BW_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_0(v)   BF_CS1(IPU_DC_RL6_CH_9, COD_NEW_DATA_START_CHAN_R_9_0, v)
#endif

/* --- Register HW_IPU_DC_RL6_CH_9, field COD_NEW_DATA_START_CHAN_R_9_1 (RW)
 *
 * This field is a pointer to the address within the microcode memory where the routine that handles
 * the new data event resides (associated with channel #9, second region)
 */

#define BP_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_1      24
#define BM_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_1)
#else
#define BF_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_1(v)   (((v) << 24) & BM_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_NEW_DATA_START_CHAN_R_9_1 field to a new value.
#define BW_IPU_DC_RL6_CH_9_COD_NEW_DATA_START_CHAN_R_9_1(v)   BF_CS1(IPU_DC_RL6_CH_9, COD_NEW_DATA_START_CHAN_R_9_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_GEN - DC General Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned SYNC_1_6 : 2; //!< This field
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned MASK_EN : 1; //!< Enable of the mask channel
        unsigned MASK4CHAN_5 : 1; //!< Sync flow can be associated with a mask channel. Only one sync flow can have a mask. This bit is ignored if MASK_EN is clear
        unsigned SYNC_PRIORITY_5 : 1; //!< When 2 sync flows are running, this bit sets the priority of channel #5. both SYNC_PRIORITY_5 and SYNC_PRIORITY_1 should not have the value of 0 This bit should be
        unsigned SYNC_PRIORITY_1 : 1; //!< When 2 sync flows are running, this bit sets the priority of channel #1. both SYNC_PRIORITY_5 and SYNC_PRIORITY_1 should not have the value of 0 This bit should be
        unsigned DC_CH5_TYPE : 1; //!< Channel 5 is used for synchronous flow. When this channel is used for accessing asynchronous display that is activated in a synchronous way
        unsigned RESERVED2 : 7; //!< Reserved.
        unsigned DC_BKDIV : 8; //!< Blinking Rate This field defines the blinking rate. The blinking occurs every N-th frame While N is defined by DC_BKDIV
        unsigned DC_BK_EN : 1; //!< Cursor blinking enable
        unsigned RESERVED3 : 7; //!< Reserved.
    } B;
} hw_ipu_dc_gen_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_GEN register
 */
#define HW_IPU_DC_GEN_ADDR(x)      (REGS_IPU_BASE(x) + 0x580d4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_GEN(x)           (*(volatile hw_ipu_dc_gen_t *) HW_IPU_DC_GEN_ADDR(x))
#define HW_IPU_DC_GEN_RD(x)        (HW_IPU_DC_GEN(x).U)
#define HW_IPU_DC_GEN_WR(x, v)     (HW_IPU_DC_GEN(x).U = (v))
#define HW_IPU_DC_GEN_SET(x, v)    (HW_IPU_DC_GEN_WR(x, HW_IPU_DC_GEN_RD(x) |  (v)))
#define HW_IPU_DC_GEN_CLR(x, v)    (HW_IPU_DC_GEN_WR(x, HW_IPU_DC_GEN_RD(x) & ~(v)))
#define HW_IPU_DC_GEN_TOG(x, v)    (HW_IPU_DC_GEN_WR(x, HW_IPU_DC_GEN_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_GEN bitfields
 */

/* --- Register HW_IPU_DC_GEN, field SYNC_1_6 (RW)
 *
 * This field
 *
 * Values:
 * 00 - Channel 1 of the DC handles async flow
 * 01 - Illegal
 * 10 - Channel 1 of the DC handles sync flow
 * 11 - illegal
 */

#define BP_IPU_DC_GEN_SYNC_1_6      1
#define BM_IPU_DC_GEN_SYNC_1_6      0x00000006

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_GEN_SYNC_1_6(v)   ((((reg32_t) v) << 1) & BM_IPU_DC_GEN_SYNC_1_6)
#else
#define BF_IPU_DC_GEN_SYNC_1_6(v)   (((v) << 1) & BM_IPU_DC_GEN_SYNC_1_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SYNC_1_6 field to a new value.
#define BW_IPU_DC_GEN_SYNC_1_6(v)   BF_CS1(IPU_DC_GEN, SYNC_1_6, v)
#endif


/* --- Register HW_IPU_DC_GEN, field MASK_EN (RW)
 *
 * Enable of the mask channel
 *
 * Values:
 * 1 - mask channel is enabled
 * 0 - mask channel is disabled
 */

#define BP_IPU_DC_GEN_MASK_EN      4
#define BM_IPU_DC_GEN_MASK_EN      0x00000010

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_GEN_MASK_EN(v)   ((((reg32_t) v) << 4) & BM_IPU_DC_GEN_MASK_EN)
#else
#define BF_IPU_DC_GEN_MASK_EN(v)   (((v) << 4) & BM_IPU_DC_GEN_MASK_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MASK_EN field to a new value.
#define BW_IPU_DC_GEN_MASK_EN(v)   BF_CS1(IPU_DC_GEN, MASK_EN, v)
#endif


/* --- Register HW_IPU_DC_GEN, field MASK4CHAN_5 (RW)
 *
 * Sync flow can be associated with a mask channel. Only one sync flow can have a mask. This bit is
 * ignored if MASK_EN is clear
 *
 * Values:
 * 1 - mask channel is associated to the sync flow via DP
 * 0 - mask channel is associated to the sync flow via DC (without DP)
 */

#define BP_IPU_DC_GEN_MASK4CHAN_5      5
#define BM_IPU_DC_GEN_MASK4CHAN_5      0x00000020

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_GEN_MASK4CHAN_5(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_GEN_MASK4CHAN_5)
#else
#define BF_IPU_DC_GEN_MASK4CHAN_5(v)   (((v) << 5) & BM_IPU_DC_GEN_MASK4CHAN_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MASK4CHAN_5 field to a new value.
#define BW_IPU_DC_GEN_MASK4CHAN_5(v)   BF_CS1(IPU_DC_GEN, MASK4CHAN_5, v)
#endif


/* --- Register HW_IPU_DC_GEN, field SYNC_PRIORITY_5 (RW)
 *
 * When 2 sync flows are running, this bit sets the priority of channel #5. both SYNC_PRIORITY_5 and
 * SYNC_PRIORITY_1 should not have the value of 0 This bit should be
 *
 * Values:
 * 1 - high priority
 * 0 - low Priority
 */

#define BP_IPU_DC_GEN_SYNC_PRIORITY_5      6
#define BM_IPU_DC_GEN_SYNC_PRIORITY_5      0x00000040

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_GEN_SYNC_PRIORITY_5(v)   ((((reg32_t) v) << 6) & BM_IPU_DC_GEN_SYNC_PRIORITY_5)
#else
#define BF_IPU_DC_GEN_SYNC_PRIORITY_5(v)   (((v) << 6) & BM_IPU_DC_GEN_SYNC_PRIORITY_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SYNC_PRIORITY_5 field to a new value.
#define BW_IPU_DC_GEN_SYNC_PRIORITY_5(v)   BF_CS1(IPU_DC_GEN, SYNC_PRIORITY_5, v)
#endif


/* --- Register HW_IPU_DC_GEN, field SYNC_PRIORITY_1 (RW)
 *
 * When 2 sync flows are running, this bit sets the priority of channel #1. both SYNC_PRIORITY_5 and
 * SYNC_PRIORITY_1 should not have the value of 0 This bit should be
 *
 * Values:
 * 1 - high Priority
 * 0 - low Priority
 */

#define BP_IPU_DC_GEN_SYNC_PRIORITY_1      7
#define BM_IPU_DC_GEN_SYNC_PRIORITY_1      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_GEN_SYNC_PRIORITY_1(v)   ((((reg32_t) v) << 7) & BM_IPU_DC_GEN_SYNC_PRIORITY_1)
#else
#define BF_IPU_DC_GEN_SYNC_PRIORITY_1(v)   (((v) << 7) & BM_IPU_DC_GEN_SYNC_PRIORITY_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SYNC_PRIORITY_1 field to a new value.
#define BW_IPU_DC_GEN_SYNC_PRIORITY_1(v)   BF_CS1(IPU_DC_GEN, SYNC_PRIORITY_1, v)
#endif


/* --- Register HW_IPU_DC_GEN, field DC_CH5_TYPE (RW)
 *
 * Channel 5 is used for synchronous flow. When this channel is used for accessing asynchronous
 * display that is activated in a synchronous way
 *
 * Values:
 * 1 - Enable the asynchronous interface via channel 5
 * 0 - normal mode, synchronous flow via channel 5
 */

#define BP_IPU_DC_GEN_DC_CH5_TYPE      8
#define BM_IPU_DC_GEN_DC_CH5_TYPE      0x00000100

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_GEN_DC_CH5_TYPE(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_GEN_DC_CH5_TYPE)
#else
#define BF_IPU_DC_GEN_DC_CH5_TYPE(v)   (((v) << 8) & BM_IPU_DC_GEN_DC_CH5_TYPE)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_CH5_TYPE field to a new value.
#define BW_IPU_DC_GEN_DC_CH5_TYPE(v)   BF_CS1(IPU_DC_GEN, DC_CH5_TYPE, v)
#endif


/* --- Register HW_IPU_DC_GEN, field DC_BKDIV (RW)
 *
 * Blinking Rate This field defines the blinking rate. The blinking occurs every N-th frame While N
 * is defined by DC_BKDIV
 */

#define BP_IPU_DC_GEN_DC_BKDIV      16
#define BM_IPU_DC_GEN_DC_BKDIV      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_GEN_DC_BKDIV(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_GEN_DC_BKDIV)
#else
#define BF_IPU_DC_GEN_DC_BKDIV(v)   (((v) << 16) & BM_IPU_DC_GEN_DC_BKDIV)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_BKDIV field to a new value.
#define BW_IPU_DC_GEN_DC_BKDIV(v)   BF_CS1(IPU_DC_GEN, DC_BKDIV, v)
#endif

/* --- Register HW_IPU_DC_GEN, field DC_BK_EN (RW)
 *
 * Cursor blinking enable
 *
 * Values:
 * 1 - blinking is enabled
 * 0 - blinking is disabled
 */

#define BP_IPU_DC_GEN_DC_BK_EN      24
#define BM_IPU_DC_GEN_DC_BK_EN      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_GEN_DC_BK_EN(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_GEN_DC_BK_EN)
#else
#define BF_IPU_DC_GEN_DC_BK_EN(v)   (((v) << 24) & BM_IPU_DC_GEN_DC_BK_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DC_BK_EN field to a new value.
#define BW_IPU_DC_GEN_DC_BK_EN(v)   BF_CS1(IPU_DC_GEN, DC_BK_EN, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_DISP_CONF1_0 - DC Display Configuration 1 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DISP_TYP_0 : 2; //!< This field defines the type of the display
        unsigned ADDR_INCREMENT_0 : 2; //!< This field is the increment step for auto increment mode
        unsigned ADDR_BE_L_INC_0 : 2; //!< This bits define the increment mode when the latest access was done with some of the byte enable signals are low, in that case different increment should be done instead of the normal auto increment of the address IF MCU_ACC_LB_MASK_0 is 0 then only 00 and 10 values are allowed.
        unsigned MCU_ACC_LB_MASK_0 : 1; //!< The DC compares between the current access to the a calculated address. The calculated address is the next consecutive address following the last address. This bit defines the comparing mode
        unsigned DISP_RD_VALUE_PTR_0 : 1; //!< When the display works in wait for status mode. The IPU polls the display and compare the value to the value stored on the status DI_READ_DATA_ACK_VALUE and mask it with DI_READ_DATA_MASK. The DC holds 2 sets of mask and value. This field holds a pointer to the corresponding set of mask and value.
        unsigned RESERVED0 : 24; //!< Reserved.
    } B;
} hw_ipu_dc_disp_conf1_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_DISP_CONF1_0 register
 */
#define HW_IPU_DC_DISP_CONF1_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x580d8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_DISP_CONF1_0(x)           (*(volatile hw_ipu_dc_disp_conf1_0_t *) HW_IPU_DC_DISP_CONF1_0_ADDR(x))
#define HW_IPU_DC_DISP_CONF1_0_RD(x)        (HW_IPU_DC_DISP_CONF1_0(x).U)
#define HW_IPU_DC_DISP_CONF1_0_WR(x, v)     (HW_IPU_DC_DISP_CONF1_0(x).U = (v))
#define HW_IPU_DC_DISP_CONF1_0_SET(x, v)    (HW_IPU_DC_DISP_CONF1_0_WR(x, HW_IPU_DC_DISP_CONF1_0_RD(x) |  (v)))
#define HW_IPU_DC_DISP_CONF1_0_CLR(x, v)    (HW_IPU_DC_DISP_CONF1_0_WR(x, HW_IPU_DC_DISP_CONF1_0_RD(x) & ~(v)))
#define HW_IPU_DC_DISP_CONF1_0_TOG(x, v)    (HW_IPU_DC_DISP_CONF1_0_WR(x, HW_IPU_DC_DISP_CONF1_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_DISP_CONF1_0 bitfields
 */

/* --- Register HW_IPU_DC_DISP_CONF1_0, field DISP_TYP_0 (RW)
 *
 * This field defines the type of the display
 *
 * Values:
 * 00 - Serial accesses display
 * 01 - Reserved
 * 10 - parallel display, without byte_enable support
 * 11 - parallel display, with byte_enable support
 */

#define BP_IPU_DC_DISP_CONF1_0_DISP_TYP_0      0
#define BM_IPU_DC_DISP_CONF1_0_DISP_TYP_0      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_0_DISP_TYP_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_DISP_CONF1_0_DISP_TYP_0)
#else
#define BF_IPU_DC_DISP_CONF1_0_DISP_TYP_0(v)   (((v) << 0) & BM_IPU_DC_DISP_CONF1_0_DISP_TYP_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DISP_TYP_0 field to a new value.
#define BW_IPU_DC_DISP_CONF1_0_DISP_TYP_0(v)   BF_CS1(IPU_DC_DISP_CONF1_0, DISP_TYP_0, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_0, field ADDR_INCREMENT_0 (RW)
 *
 * This field is the increment step for auto increment mode
 *
 * Values:
 * 00 - Increment the address by 1
 * 01 - Increment the address by 2
 * 10 - Increment the address by 3
 * 11 - Increment the address by 4
 */

#define BP_IPU_DC_DISP_CONF1_0_ADDR_INCREMENT_0      2
#define BM_IPU_DC_DISP_CONF1_0_ADDR_INCREMENT_0      0x0000000c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_0_ADDR_INCREMENT_0(v)   ((((reg32_t) v) << 2) & BM_IPU_DC_DISP_CONF1_0_ADDR_INCREMENT_0)
#else
#define BF_IPU_DC_DISP_CONF1_0_ADDR_INCREMENT_0(v)   (((v) << 2) & BM_IPU_DC_DISP_CONF1_0_ADDR_INCREMENT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ADDR_INCREMENT_0 field to a new value.
#define BW_IPU_DC_DISP_CONF1_0_ADDR_INCREMENT_0(v)   BF_CS1(IPU_DC_DISP_CONF1_0, ADDR_INCREMENT_0, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_0, field ADDR_BE_L_INC_0 (RW)
 *
 * This bits define the increment mode when the latest access was done with some of the byte enable
 * signals are low, in that case different increment should be done instead of the normal auto
 * increment of the address IF MCU_ACC_LB_MASK_0 is 0 then only 00 and 10 values are allowed.
 *
 * Values:
 * 00 - No increment
 * 01 - Increment by 1
 * 10 - Increment by 2
 * 11 - Increment by 3
 */

#define BP_IPU_DC_DISP_CONF1_0_ADDR_BE_L_INC_0      4
#define BM_IPU_DC_DISP_CONF1_0_ADDR_BE_L_INC_0      0x00000030

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_0_ADDR_BE_L_INC_0(v)   ((((reg32_t) v) << 4) & BM_IPU_DC_DISP_CONF1_0_ADDR_BE_L_INC_0)
#else
#define BF_IPU_DC_DISP_CONF1_0_ADDR_BE_L_INC_0(v)   (((v) << 4) & BM_IPU_DC_DISP_CONF1_0_ADDR_BE_L_INC_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ADDR_BE_L_INC_0 field to a new value.
#define BW_IPU_DC_DISP_CONF1_0_ADDR_BE_L_INC_0(v)   BF_CS1(IPU_DC_DISP_CONF1_0, ADDR_BE_L_INC_0, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_0, field MCU_ACC_LB_MASK_0 (RW)
 *
 * The DC compares between the current access to the a calculated address. The calculated address is
 * the next consecutive address following the last address. This bit defines the comparing mode
 *
 * Values:
 * 1 - The 2 addresses are fully compared
 * 0 - The 2 addresses are compared, but the ADDR[0] bit of the new address is ignored
 */

#define BP_IPU_DC_DISP_CONF1_0_MCU_ACC_LB_MASK_0      6
#define BM_IPU_DC_DISP_CONF1_0_MCU_ACC_LB_MASK_0      0x00000040

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_0_MCU_ACC_LB_MASK_0(v)   ((((reg32_t) v) << 6) & BM_IPU_DC_DISP_CONF1_0_MCU_ACC_LB_MASK_0)
#else
#define BF_IPU_DC_DISP_CONF1_0_MCU_ACC_LB_MASK_0(v)   (((v) << 6) & BM_IPU_DC_DISP_CONF1_0_MCU_ACC_LB_MASK_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_ACC_LB_MASK_0 field to a new value.
#define BW_IPU_DC_DISP_CONF1_0_MCU_ACC_LB_MASK_0(v)   BF_CS1(IPU_DC_DISP_CONF1_0, MCU_ACC_LB_MASK_0, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_0, field DISP_RD_VALUE_PTR_0 (RW)
 *
 * When the display works in wait for status mode. The IPU polls the display and compare the value
 * to the value stored on the status DI_READ_DATA_ACK_VALUE and mask it with DI_READ_DATA_MASK. The
 * DC holds 2 sets of mask and value. This field holds a pointer to the corresponding set of mask
 * and value.
 *
 * Values:
 * 1 - DI_READ_DATA_ACK_VALUE_1 & DI_READ_DATA_MASK_1 are used for display 0
 * 0 - DI_READ_DATA_ACK_VALUE_0 & DI_READ_DATA_MASK_0 are used for display 0
 */

#define BP_IPU_DC_DISP_CONF1_0_DISP_RD_VALUE_PTR_0      7
#define BM_IPU_DC_DISP_CONF1_0_DISP_RD_VALUE_PTR_0      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_0_DISP_RD_VALUE_PTR_0(v)   ((((reg32_t) v) << 7) & BM_IPU_DC_DISP_CONF1_0_DISP_RD_VALUE_PTR_0)
#else
#define BF_IPU_DC_DISP_CONF1_0_DISP_RD_VALUE_PTR_0(v)   (((v) << 7) & BM_IPU_DC_DISP_CONF1_0_DISP_RD_VALUE_PTR_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DISP_RD_VALUE_PTR_0 field to a new value.
#define BW_IPU_DC_DISP_CONF1_0_DISP_RD_VALUE_PTR_0(v)   BF_CS1(IPU_DC_DISP_CONF1_0, DISP_RD_VALUE_PTR_0, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_DISP_CONF1_1 - DC Display Configuration 1 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DISP_TYP_1 : 2; //!< This field defines the type of the display
        unsigned ADDR_INCREMENT_1 : 2; //!< This field is the increment step for auto increment mode
        unsigned ADDR_BE_L_INC_1 : 2; //!< This bits define the increment mode when the latest access was done with some of the byte enable signals are low, in that case different increment should be done instead of the normal auto increment of the address IF MCU_ACC_LB_MASK_1 is 0 then only 00 and 10 values are allowed.
        unsigned MCU_ACC_LB_MASK_1 : 1; //!< The DC compares between the current access to the a calculated address. The calculated address is the next consecutive address following the last address. This bit defines the comparing mode
        unsigned DISP_RD_VALUE_PTR_1 : 1; //!< When the display works in wait for status mode. The IPU polls the display and compare the value to the value stored on the status DI_READ_DATA_ACK_VALUE and mask it with DI_READ_DATA_MASK. The DC holds 2 sets of mask and value. This field holds a pointer to the corresponding set of mask and value.
        unsigned RESERVED0 : 24; //!< Reserved.
    } B;
} hw_ipu_dc_disp_conf1_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_DISP_CONF1_1 register
 */
#define HW_IPU_DC_DISP_CONF1_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x580dc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_DISP_CONF1_1(x)           (*(volatile hw_ipu_dc_disp_conf1_1_t *) HW_IPU_DC_DISP_CONF1_1_ADDR(x))
#define HW_IPU_DC_DISP_CONF1_1_RD(x)        (HW_IPU_DC_DISP_CONF1_1(x).U)
#define HW_IPU_DC_DISP_CONF1_1_WR(x, v)     (HW_IPU_DC_DISP_CONF1_1(x).U = (v))
#define HW_IPU_DC_DISP_CONF1_1_SET(x, v)    (HW_IPU_DC_DISP_CONF1_1_WR(x, HW_IPU_DC_DISP_CONF1_1_RD(x) |  (v)))
#define HW_IPU_DC_DISP_CONF1_1_CLR(x, v)    (HW_IPU_DC_DISP_CONF1_1_WR(x, HW_IPU_DC_DISP_CONF1_1_RD(x) & ~(v)))
#define HW_IPU_DC_DISP_CONF1_1_TOG(x, v)    (HW_IPU_DC_DISP_CONF1_1_WR(x, HW_IPU_DC_DISP_CONF1_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_DISP_CONF1_1 bitfields
 */

/* --- Register HW_IPU_DC_DISP_CONF1_1, field DISP_TYP_1 (RW)
 *
 * This field defines the type of the display
 *
 * Values:
 * 00 - Serial accesses display
 * 01 - Reserved
 * 10 - parallel display, without byte_enable support
 * 11 - parallel display, with byte_enable support
 */

#define BP_IPU_DC_DISP_CONF1_1_DISP_TYP_1      0
#define BM_IPU_DC_DISP_CONF1_1_DISP_TYP_1      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_1_DISP_TYP_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_DISP_CONF1_1_DISP_TYP_1)
#else
#define BF_IPU_DC_DISP_CONF1_1_DISP_TYP_1(v)   (((v) << 0) & BM_IPU_DC_DISP_CONF1_1_DISP_TYP_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DISP_TYP_1 field to a new value.
#define BW_IPU_DC_DISP_CONF1_1_DISP_TYP_1(v)   BF_CS1(IPU_DC_DISP_CONF1_1, DISP_TYP_1, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_1, field ADDR_INCREMENT_1 (RW)
 *
 * This field is the increment step for auto increment mode
 *
 * Values:
 * 00 - Increment the address by 1
 * 01 - Increment the address by 2
 * 10 - Increment the address by 3
 * 11 - Increment the address by 4
 */

#define BP_IPU_DC_DISP_CONF1_1_ADDR_INCREMENT_1      2
#define BM_IPU_DC_DISP_CONF1_1_ADDR_INCREMENT_1      0x0000000c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_1_ADDR_INCREMENT_1(v)   ((((reg32_t) v) << 2) & BM_IPU_DC_DISP_CONF1_1_ADDR_INCREMENT_1)
#else
#define BF_IPU_DC_DISP_CONF1_1_ADDR_INCREMENT_1(v)   (((v) << 2) & BM_IPU_DC_DISP_CONF1_1_ADDR_INCREMENT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ADDR_INCREMENT_1 field to a new value.
#define BW_IPU_DC_DISP_CONF1_1_ADDR_INCREMENT_1(v)   BF_CS1(IPU_DC_DISP_CONF1_1, ADDR_INCREMENT_1, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_1, field ADDR_BE_L_INC_1 (RW)
 *
 * This bits define the increment mode when the latest access was done with some of the byte enable
 * signals are low, in that case different increment should be done instead of the normal auto
 * increment of the address IF MCU_ACC_LB_MASK_1 is 0 then only 00 and 10 values are allowed.
 *
 * Values:
 * 00 - No increment
 * 01 - Increment by 1
 * 10 - Increment by 2
 * 11 - Increment by 3
 */

#define BP_IPU_DC_DISP_CONF1_1_ADDR_BE_L_INC_1      4
#define BM_IPU_DC_DISP_CONF1_1_ADDR_BE_L_INC_1      0x00000030

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_1_ADDR_BE_L_INC_1(v)   ((((reg32_t) v) << 4) & BM_IPU_DC_DISP_CONF1_1_ADDR_BE_L_INC_1)
#else
#define BF_IPU_DC_DISP_CONF1_1_ADDR_BE_L_INC_1(v)   (((v) << 4) & BM_IPU_DC_DISP_CONF1_1_ADDR_BE_L_INC_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ADDR_BE_L_INC_1 field to a new value.
#define BW_IPU_DC_DISP_CONF1_1_ADDR_BE_L_INC_1(v)   BF_CS1(IPU_DC_DISP_CONF1_1, ADDR_BE_L_INC_1, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_1, field MCU_ACC_LB_MASK_1 (RW)
 *
 * The DC compares between the current access to the a calculated address. The calculated address is
 * the next consecutive address following the last address. This bit defines the comparing mode
 *
 * Values:
 * 1 - The 2 addresses are fully compared
 * 0 - The 2 addresses are compared, but the ADDR[0] bit of the new address is ignored
 */

#define BP_IPU_DC_DISP_CONF1_1_MCU_ACC_LB_MASK_1      6
#define BM_IPU_DC_DISP_CONF1_1_MCU_ACC_LB_MASK_1      0x00000040

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_1_MCU_ACC_LB_MASK_1(v)   ((((reg32_t) v) << 6) & BM_IPU_DC_DISP_CONF1_1_MCU_ACC_LB_MASK_1)
#else
#define BF_IPU_DC_DISP_CONF1_1_MCU_ACC_LB_MASK_1(v)   (((v) << 6) & BM_IPU_DC_DISP_CONF1_1_MCU_ACC_LB_MASK_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_ACC_LB_MASK_1 field to a new value.
#define BW_IPU_DC_DISP_CONF1_1_MCU_ACC_LB_MASK_1(v)   BF_CS1(IPU_DC_DISP_CONF1_1, MCU_ACC_LB_MASK_1, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_1, field DISP_RD_VALUE_PTR_1 (RW)
 *
 * When the display works in wait for status mode. The IPU polls the display and compare the value
 * to the value stored on the status DI_READ_DATA_ACK_VALUE and mask it with DI_READ_DATA_MASK. The
 * DC holds 2 sets of mask and value. This field holds a pointer to the corresponding set of mask
 * and value.
 *
 * Values:
 * 1 - DI_READ_DATA_ACK_VALUE_1 & DI_READ_DATA_MASK_1 are used for display 1
 * 0 - DI_READ_DATA_ACK_VALUE_0 & DI_READ_DATA_MASK_0 are used for display 1
 */

#define BP_IPU_DC_DISP_CONF1_1_DISP_RD_VALUE_PTR_1      7
#define BM_IPU_DC_DISP_CONF1_1_DISP_RD_VALUE_PTR_1      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_1_DISP_RD_VALUE_PTR_1(v)   ((((reg32_t) v) << 7) & BM_IPU_DC_DISP_CONF1_1_DISP_RD_VALUE_PTR_1)
#else
#define BF_IPU_DC_DISP_CONF1_1_DISP_RD_VALUE_PTR_1(v)   (((v) << 7) & BM_IPU_DC_DISP_CONF1_1_DISP_RD_VALUE_PTR_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DISP_RD_VALUE_PTR_1 field to a new value.
#define BW_IPU_DC_DISP_CONF1_1_DISP_RD_VALUE_PTR_1(v)   BF_CS1(IPU_DC_DISP_CONF1_1, DISP_RD_VALUE_PTR_1, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_DISP_CONF1_2 - DC Display Configuration 1 Register 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DISP_TYP_2 : 2; //!< This field defines the type of the display
        unsigned ADDR_INCREMENT_2 : 2; //!< This field is the increment step for auto increment mode
        unsigned ADDR_BE_L_INC_2 : 2; //!< This bits define the increment mode when the latest access was done with some of the byte enable signals are low, in that case different increment should be done instead of the normal auto increment of the address IF MCU_ACC_LB_MASK_2 is 0 then only 00 and 10 values are allowed.
        unsigned MCU_ACC_LB_MASK_2 : 1; //!< The DC compares between the current access to the a calculated address. The calculated address is the next consecutive address following the last address. This bit defines the comparing mode
        unsigned DISP_RD_VALUE_PTR_2 : 1; //!< When the display works in wait for status mode. The IPU polls the display and compare the value to the value stored on the status DI_READ_DATA_ACK_VALUE and mask it with DI_READ_DATA_MASK. The DC holds 2 sets of mask and value. This field holds a pointer to the corresponding set of mask and value.
        unsigned RESERVED0 : 24; //!< Reserved.
    } B;
} hw_ipu_dc_disp_conf1_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_DISP_CONF1_2 register
 */
#define HW_IPU_DC_DISP_CONF1_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x580e0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_DISP_CONF1_2(x)           (*(volatile hw_ipu_dc_disp_conf1_2_t *) HW_IPU_DC_DISP_CONF1_2_ADDR(x))
#define HW_IPU_DC_DISP_CONF1_2_RD(x)        (HW_IPU_DC_DISP_CONF1_2(x).U)
#define HW_IPU_DC_DISP_CONF1_2_WR(x, v)     (HW_IPU_DC_DISP_CONF1_2(x).U = (v))
#define HW_IPU_DC_DISP_CONF1_2_SET(x, v)    (HW_IPU_DC_DISP_CONF1_2_WR(x, HW_IPU_DC_DISP_CONF1_2_RD(x) |  (v)))
#define HW_IPU_DC_DISP_CONF1_2_CLR(x, v)    (HW_IPU_DC_DISP_CONF1_2_WR(x, HW_IPU_DC_DISP_CONF1_2_RD(x) & ~(v)))
#define HW_IPU_DC_DISP_CONF1_2_TOG(x, v)    (HW_IPU_DC_DISP_CONF1_2_WR(x, HW_IPU_DC_DISP_CONF1_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_DISP_CONF1_2 bitfields
 */

/* --- Register HW_IPU_DC_DISP_CONF1_2, field DISP_TYP_2 (RW)
 *
 * This field defines the type of the display
 *
 * Values:
 * 00 - Serial accesses display
 * 01 - Reserved
 * 10 - parallel display, without byte_enable support
 * 11 - parallel display, with byte_enable support
 */

#define BP_IPU_DC_DISP_CONF1_2_DISP_TYP_2      0
#define BM_IPU_DC_DISP_CONF1_2_DISP_TYP_2      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_2_DISP_TYP_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_DISP_CONF1_2_DISP_TYP_2)
#else
#define BF_IPU_DC_DISP_CONF1_2_DISP_TYP_2(v)   (((v) << 0) & BM_IPU_DC_DISP_CONF1_2_DISP_TYP_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DISP_TYP_2 field to a new value.
#define BW_IPU_DC_DISP_CONF1_2_DISP_TYP_2(v)   BF_CS1(IPU_DC_DISP_CONF1_2, DISP_TYP_2, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_2, field ADDR_INCREMENT_2 (RW)
 *
 * This field is the increment step for auto increment mode
 *
 * Values:
 * 00 - Increment the address by 1
 * 01 - Increment the address by 2
 * 10 - Increment the address by 3
 * 11 - Increment the address by 4
 */

#define BP_IPU_DC_DISP_CONF1_2_ADDR_INCREMENT_2      2
#define BM_IPU_DC_DISP_CONF1_2_ADDR_INCREMENT_2      0x0000000c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_2_ADDR_INCREMENT_2(v)   ((((reg32_t) v) << 2) & BM_IPU_DC_DISP_CONF1_2_ADDR_INCREMENT_2)
#else
#define BF_IPU_DC_DISP_CONF1_2_ADDR_INCREMENT_2(v)   (((v) << 2) & BM_IPU_DC_DISP_CONF1_2_ADDR_INCREMENT_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ADDR_INCREMENT_2 field to a new value.
#define BW_IPU_DC_DISP_CONF1_2_ADDR_INCREMENT_2(v)   BF_CS1(IPU_DC_DISP_CONF1_2, ADDR_INCREMENT_2, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_2, field ADDR_BE_L_INC_2 (RW)
 *
 * This bits define the increment mode when the latest access was done with some of the byte enable
 * signals are low, in that case different increment should be done instead of the normal auto
 * increment of the address IF MCU_ACC_LB_MASK_2 is 0 then only 00 and 10 values are allowed.
 *
 * Values:
 * 00 - No increment
 * 01 - Increment by 1
 * 10 - Increment by 2
 * 11 - Increment by 3
 */

#define BP_IPU_DC_DISP_CONF1_2_ADDR_BE_L_INC_2      4
#define BM_IPU_DC_DISP_CONF1_2_ADDR_BE_L_INC_2      0x00000030

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_2_ADDR_BE_L_INC_2(v)   ((((reg32_t) v) << 4) & BM_IPU_DC_DISP_CONF1_2_ADDR_BE_L_INC_2)
#else
#define BF_IPU_DC_DISP_CONF1_2_ADDR_BE_L_INC_2(v)   (((v) << 4) & BM_IPU_DC_DISP_CONF1_2_ADDR_BE_L_INC_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ADDR_BE_L_INC_2 field to a new value.
#define BW_IPU_DC_DISP_CONF1_2_ADDR_BE_L_INC_2(v)   BF_CS1(IPU_DC_DISP_CONF1_2, ADDR_BE_L_INC_2, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_2, field MCU_ACC_LB_MASK_2 (RW)
 *
 * The DC compares between the current access to the a calculated address. The calculated address is
 * the next consecutive address following the last address. This bit defines the comparing mode
 *
 * Values:
 * 1 - The 2 addresses are fully compared
 * 0 - The 2 addresses are compared, but the ADDR[0] bit of the new address is ignored
 */

#define BP_IPU_DC_DISP_CONF1_2_MCU_ACC_LB_MASK_2      6
#define BM_IPU_DC_DISP_CONF1_2_MCU_ACC_LB_MASK_2      0x00000040

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_2_MCU_ACC_LB_MASK_2(v)   ((((reg32_t) v) << 6) & BM_IPU_DC_DISP_CONF1_2_MCU_ACC_LB_MASK_2)
#else
#define BF_IPU_DC_DISP_CONF1_2_MCU_ACC_LB_MASK_2(v)   (((v) << 6) & BM_IPU_DC_DISP_CONF1_2_MCU_ACC_LB_MASK_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_ACC_LB_MASK_2 field to a new value.
#define BW_IPU_DC_DISP_CONF1_2_MCU_ACC_LB_MASK_2(v)   BF_CS1(IPU_DC_DISP_CONF1_2, MCU_ACC_LB_MASK_2, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_2, field DISP_RD_VALUE_PTR_2 (RW)
 *
 * When the display works in wait for status mode. The IPU polls the display and compare the value
 * to the value stored on the status DI_READ_DATA_ACK_VALUE and mask it with DI_READ_DATA_MASK. The
 * DC holds 2 sets of mask and value. This field holds a pointer to the corresponding set of mask
 * and value.
 *
 * Values:
 * 1 - DI_READ_DATA_ACK_VALUE_1 & DI_READ_DATA_MASK_1 are used for display 2
 * 0 - DI_READ_DATA_ACK_VALUE_0 & DI_READ_DATA_MASK_0 are used for display 2
 */

#define BP_IPU_DC_DISP_CONF1_2_DISP_RD_VALUE_PTR_2      7
#define BM_IPU_DC_DISP_CONF1_2_DISP_RD_VALUE_PTR_2      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_2_DISP_RD_VALUE_PTR_2(v)   ((((reg32_t) v) << 7) & BM_IPU_DC_DISP_CONF1_2_DISP_RD_VALUE_PTR_2)
#else
#define BF_IPU_DC_DISP_CONF1_2_DISP_RD_VALUE_PTR_2(v)   (((v) << 7) & BM_IPU_DC_DISP_CONF1_2_DISP_RD_VALUE_PTR_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DISP_RD_VALUE_PTR_2 field to a new value.
#define BW_IPU_DC_DISP_CONF1_2_DISP_RD_VALUE_PTR_2(v)   BF_CS1(IPU_DC_DISP_CONF1_2, DISP_RD_VALUE_PTR_2, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_DISP_CONF1_3 - DC Display Configuration 1 Register 3 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DISP_TYP_3 : 2; //!< This field defines the type of the display
        unsigned ADDR_INCREMENT_3 : 2; //!< This field is the increment step for auto increment mode
        unsigned ADDR_BE_L_INC_3 : 2; //!< This bits define the increment mode when the latest access was done with some of the byte enable signals are low, in that case different increment should be done instead of the normal auto increment of the address IF MCU_ACC_LB_MASK_3 is 0 then only 00 and 10 values are allowed.
        unsigned MCU_ACC_LB_MASK_3 : 1; //!< The DC compares between the current access to the a calculated address. The calculated address is the next consecutive address following the last address. This bit defines the comparing mode
        unsigned DISP_RD_VALUE_PTR_3 : 1; //!< When the display works in wait for status mode. The IPU polls the display and compare the value to the value stored on the status DI_READ_DATA_ACK_VALUE and mask it with DI_READ_DATA_MASK. The DC holds 2 sets of mask and value. This field holds a pointer to the corresponding set of mask and value.
        unsigned RESERVED0 : 24; //!< Reserved.
    } B;
} hw_ipu_dc_disp_conf1_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_DISP_CONF1_3 register
 */
#define HW_IPU_DC_DISP_CONF1_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x580e4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_DISP_CONF1_3(x)           (*(volatile hw_ipu_dc_disp_conf1_3_t *) HW_IPU_DC_DISP_CONF1_3_ADDR(x))
#define HW_IPU_DC_DISP_CONF1_3_RD(x)        (HW_IPU_DC_DISP_CONF1_3(x).U)
#define HW_IPU_DC_DISP_CONF1_3_WR(x, v)     (HW_IPU_DC_DISP_CONF1_3(x).U = (v))
#define HW_IPU_DC_DISP_CONF1_3_SET(x, v)    (HW_IPU_DC_DISP_CONF1_3_WR(x, HW_IPU_DC_DISP_CONF1_3_RD(x) |  (v)))
#define HW_IPU_DC_DISP_CONF1_3_CLR(x, v)    (HW_IPU_DC_DISP_CONF1_3_WR(x, HW_IPU_DC_DISP_CONF1_3_RD(x) & ~(v)))
#define HW_IPU_DC_DISP_CONF1_3_TOG(x, v)    (HW_IPU_DC_DISP_CONF1_3_WR(x, HW_IPU_DC_DISP_CONF1_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_DISP_CONF1_3 bitfields
 */

/* --- Register HW_IPU_DC_DISP_CONF1_3, field DISP_TYP_3 (RW)
 *
 * This field defines the type of the display
 *
 * Values:
 * 00 - Serial accesses display
 * 01 - Reserved
 * 10 - parallel display, without byte_enable support
 * 11 - parallel display, with byte_enable support
 */

#define BP_IPU_DC_DISP_CONF1_3_DISP_TYP_3      0
#define BM_IPU_DC_DISP_CONF1_3_DISP_TYP_3      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_3_DISP_TYP_3(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_DISP_CONF1_3_DISP_TYP_3)
#else
#define BF_IPU_DC_DISP_CONF1_3_DISP_TYP_3(v)   (((v) << 0) & BM_IPU_DC_DISP_CONF1_3_DISP_TYP_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DISP_TYP_3 field to a new value.
#define BW_IPU_DC_DISP_CONF1_3_DISP_TYP_3(v)   BF_CS1(IPU_DC_DISP_CONF1_3, DISP_TYP_3, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_3, field ADDR_INCREMENT_3 (RW)
 *
 * This field is the increment step for auto increment mode
 *
 * Values:
 * 00 - Increment the address by 1
 * 01 - Increment the address by 2
 * 10 - Increment the address by 3
 * 11 - Increment the address by 4
 */

#define BP_IPU_DC_DISP_CONF1_3_ADDR_INCREMENT_3      2
#define BM_IPU_DC_DISP_CONF1_3_ADDR_INCREMENT_3      0x0000000c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_3_ADDR_INCREMENT_3(v)   ((((reg32_t) v) << 2) & BM_IPU_DC_DISP_CONF1_3_ADDR_INCREMENT_3)
#else
#define BF_IPU_DC_DISP_CONF1_3_ADDR_INCREMENT_3(v)   (((v) << 2) & BM_IPU_DC_DISP_CONF1_3_ADDR_INCREMENT_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ADDR_INCREMENT_3 field to a new value.
#define BW_IPU_DC_DISP_CONF1_3_ADDR_INCREMENT_3(v)   BF_CS1(IPU_DC_DISP_CONF1_3, ADDR_INCREMENT_3, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_3, field ADDR_BE_L_INC_3 (RW)
 *
 * This bits define the increment mode when the latest access was done with some of the byte enable
 * signals are low, in that case different increment should be done instead of the normal auto
 * increment of the address IF MCU_ACC_LB_MASK_3 is 0 then only 00 and 10 values are allowed.
 *
 * Values:
 * 00 - No increment
 * 01 - Increment by 1
 * 10 - Increment by 2
 * 11 - Increment by 3
 */

#define BP_IPU_DC_DISP_CONF1_3_ADDR_BE_L_INC_3      4
#define BM_IPU_DC_DISP_CONF1_3_ADDR_BE_L_INC_3      0x00000030

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_3_ADDR_BE_L_INC_3(v)   ((((reg32_t) v) << 4) & BM_IPU_DC_DISP_CONF1_3_ADDR_BE_L_INC_3)
#else
#define BF_IPU_DC_DISP_CONF1_3_ADDR_BE_L_INC_3(v)   (((v) << 4) & BM_IPU_DC_DISP_CONF1_3_ADDR_BE_L_INC_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ADDR_BE_L_INC_3 field to a new value.
#define BW_IPU_DC_DISP_CONF1_3_ADDR_BE_L_INC_3(v)   BF_CS1(IPU_DC_DISP_CONF1_3, ADDR_BE_L_INC_3, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_3, field MCU_ACC_LB_MASK_3 (RW)
 *
 * The DC compares between the current access to the a calculated address. The calculated address is
 * the next consecutive address following the last address. This bit defines the comparing mode
 *
 * Values:
 * 1 - The 2 addresses are fully compared
 * 0 - The 2 addresses are compared, but the ADDR[0] bit of the new address is ignored
 */

#define BP_IPU_DC_DISP_CONF1_3_MCU_ACC_LB_MASK_3      6
#define BM_IPU_DC_DISP_CONF1_3_MCU_ACC_LB_MASK_3      0x00000040

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_3_MCU_ACC_LB_MASK_3(v)   ((((reg32_t) v) << 6) & BM_IPU_DC_DISP_CONF1_3_MCU_ACC_LB_MASK_3)
#else
#define BF_IPU_DC_DISP_CONF1_3_MCU_ACC_LB_MASK_3(v)   (((v) << 6) & BM_IPU_DC_DISP_CONF1_3_MCU_ACC_LB_MASK_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_ACC_LB_MASK_3 field to a new value.
#define BW_IPU_DC_DISP_CONF1_3_MCU_ACC_LB_MASK_3(v)   BF_CS1(IPU_DC_DISP_CONF1_3, MCU_ACC_LB_MASK_3, v)
#endif


/* --- Register HW_IPU_DC_DISP_CONF1_3, field DISP_RD_VALUE_PTR_3 (RW)
 *
 * When the display works in wait for status mode. The IPU polls the display and compare the value
 * to the value stored on the status DI_READ_DATA_ACK_VALUE and mask it with DI_READ_DATA_MASK. The
 * DC holds 2 sets of mask and value. This field holds a pointer to the corresponding set of mask
 * and value.
 *
 * Values:
 * 1 - DI_READ_DATA_ACK_VALUE_1 & DI_READ_DATA_MASK_1 are used for display 3
 * 0 - DI_READ_DATA_ACK_VALUE_0 & DI_READ_DATA_MASK_0 are used for display 3
 */

#define BP_IPU_DC_DISP_CONF1_3_DISP_RD_VALUE_PTR_3      7
#define BM_IPU_DC_DISP_CONF1_3_DISP_RD_VALUE_PTR_3      0x00000080

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF1_3_DISP_RD_VALUE_PTR_3(v)   ((((reg32_t) v) << 7) & BM_IPU_DC_DISP_CONF1_3_DISP_RD_VALUE_PTR_3)
#else
#define BF_IPU_DC_DISP_CONF1_3_DISP_RD_VALUE_PTR_3(v)   (((v) << 7) & BM_IPU_DC_DISP_CONF1_3_DISP_RD_VALUE_PTR_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DISP_RD_VALUE_PTR_3 field to a new value.
#define BW_IPU_DC_DISP_CONF1_3_DISP_RD_VALUE_PTR_3(v)   BF_CS1(IPU_DC_DISP_CONF1_3, DISP_RD_VALUE_PTR_3, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_DISP_CONF2_0 - DC Display Configuration 2 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SL_0 : 29; //!< Stride line of display 0
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_disp_conf2_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_DISP_CONF2_0 register
 */
#define HW_IPU_DC_DISP_CONF2_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x580e8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_DISP_CONF2_0(x)           (*(volatile hw_ipu_dc_disp_conf2_0_t *) HW_IPU_DC_DISP_CONF2_0_ADDR(x))
#define HW_IPU_DC_DISP_CONF2_0_RD(x)        (HW_IPU_DC_DISP_CONF2_0(x).U)
#define HW_IPU_DC_DISP_CONF2_0_WR(x, v)     (HW_IPU_DC_DISP_CONF2_0(x).U = (v))
#define HW_IPU_DC_DISP_CONF2_0_SET(x, v)    (HW_IPU_DC_DISP_CONF2_0_WR(x, HW_IPU_DC_DISP_CONF2_0_RD(x) |  (v)))
#define HW_IPU_DC_DISP_CONF2_0_CLR(x, v)    (HW_IPU_DC_DISP_CONF2_0_WR(x, HW_IPU_DC_DISP_CONF2_0_RD(x) & ~(v)))
#define HW_IPU_DC_DISP_CONF2_0_TOG(x, v)    (HW_IPU_DC_DISP_CONF2_0_WR(x, HW_IPU_DC_DISP_CONF2_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_DISP_CONF2_0 bitfields
 */

/* --- Register HW_IPU_DC_DISP_CONF2_0, field SL_0 (RW)
 *
 * Stride line of display 0
 */

#define BP_IPU_DC_DISP_CONF2_0_SL_0      0
#define BM_IPU_DC_DISP_CONF2_0_SL_0      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF2_0_SL_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_DISP_CONF2_0_SL_0)
#else
#define BF_IPU_DC_DISP_CONF2_0_SL_0(v)   (((v) << 0) & BM_IPU_DC_DISP_CONF2_0_SL_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SL_0 field to a new value.
#define BW_IPU_DC_DISP_CONF2_0_SL_0(v)   BF_CS1(IPU_DC_DISP_CONF2_0, SL_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_DISP_CONF2_2 - DC Display Configuration 2 Register 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SL_2 : 29; //!< Stride line of display 2
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_disp_conf2_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_DISP_CONF2_2 register
 */
#define HW_IPU_DC_DISP_CONF2_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x580f0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_DISP_CONF2_2(x)           (*(volatile hw_ipu_dc_disp_conf2_2_t *) HW_IPU_DC_DISP_CONF2_2_ADDR(x))
#define HW_IPU_DC_DISP_CONF2_2_RD(x)        (HW_IPU_DC_DISP_CONF2_2(x).U)
#define HW_IPU_DC_DISP_CONF2_2_WR(x, v)     (HW_IPU_DC_DISP_CONF2_2(x).U = (v))
#define HW_IPU_DC_DISP_CONF2_2_SET(x, v)    (HW_IPU_DC_DISP_CONF2_2_WR(x, HW_IPU_DC_DISP_CONF2_2_RD(x) |  (v)))
#define HW_IPU_DC_DISP_CONF2_2_CLR(x, v)    (HW_IPU_DC_DISP_CONF2_2_WR(x, HW_IPU_DC_DISP_CONF2_2_RD(x) & ~(v)))
#define HW_IPU_DC_DISP_CONF2_2_TOG(x, v)    (HW_IPU_DC_DISP_CONF2_2_WR(x, HW_IPU_DC_DISP_CONF2_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_DISP_CONF2_2 bitfields
 */

/* --- Register HW_IPU_DC_DISP_CONF2_2, field SL_2 (RW)
 *
 * Stride line of display 2
 */

#define BP_IPU_DC_DISP_CONF2_2_SL_2      0
#define BM_IPU_DC_DISP_CONF2_2_SL_2      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF2_2_SL_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_DISP_CONF2_2_SL_2)
#else
#define BF_IPU_DC_DISP_CONF2_2_SL_2(v)   (((v) << 0) & BM_IPU_DC_DISP_CONF2_2_SL_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SL_2 field to a new value.
#define BW_IPU_DC_DISP_CONF2_2_SL_2(v)   BF_CS1(IPU_DC_DISP_CONF2_2, SL_2, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_DISP_CONF2_3 - DC Display Configuration 2 Register 3 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SL_3 : 29; //!< Stride line of display 3
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_disp_conf2_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_DISP_CONF2_3 register
 */
#define HW_IPU_DC_DISP_CONF2_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x580f4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_DISP_CONF2_3(x)           (*(volatile hw_ipu_dc_disp_conf2_3_t *) HW_IPU_DC_DISP_CONF2_3_ADDR(x))
#define HW_IPU_DC_DISP_CONF2_3_RD(x)        (HW_IPU_DC_DISP_CONF2_3(x).U)
#define HW_IPU_DC_DISP_CONF2_3_WR(x, v)     (HW_IPU_DC_DISP_CONF2_3(x).U = (v))
#define HW_IPU_DC_DISP_CONF2_3_SET(x, v)    (HW_IPU_DC_DISP_CONF2_3_WR(x, HW_IPU_DC_DISP_CONF2_3_RD(x) |  (v)))
#define HW_IPU_DC_DISP_CONF2_3_CLR(x, v)    (HW_IPU_DC_DISP_CONF2_3_WR(x, HW_IPU_DC_DISP_CONF2_3_RD(x) & ~(v)))
#define HW_IPU_DC_DISP_CONF2_3_TOG(x, v)    (HW_IPU_DC_DISP_CONF2_3_WR(x, HW_IPU_DC_DISP_CONF2_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_DISP_CONF2_3 bitfields
 */

/* --- Register HW_IPU_DC_DISP_CONF2_3, field SL_3 (RW)
 *
 * Stride line of display 3
 */

#define BP_IPU_DC_DISP_CONF2_3_SL_3      0
#define BM_IPU_DC_DISP_CONF2_3_SL_3      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF2_3_SL_3(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_DISP_CONF2_3_SL_3)
#else
#define BF_IPU_DC_DISP_CONF2_3_SL_3(v)   (((v) << 0) & BM_IPU_DC_DISP_CONF2_3_SL_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SL_3 field to a new value.
#define BW_IPU_DC_DISP_CONF2_3_SL_3(v)   BF_CS1(IPU_DC_DISP_CONF2_3, SL_3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_DI0_CONF_1 - DC DI0Configuration Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI_READ_DATA_MASK_0 : 32; //!< This field defines the mask value of the data read from the display.
    } B;
} hw_ipu_dc_di0_conf_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_DI0_CONF_1 register
 */
#define HW_IPU_DC_DI0_CONF_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x580f8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_DI0_CONF_1(x)           (*(volatile hw_ipu_dc_di0_conf_1_t *) HW_IPU_DC_DI0_CONF_1_ADDR(x))
#define HW_IPU_DC_DI0_CONF_1_RD(x)        (HW_IPU_DC_DI0_CONF_1(x).U)
#define HW_IPU_DC_DI0_CONF_1_WR(x, v)     (HW_IPU_DC_DI0_CONF_1(x).U = (v))
#define HW_IPU_DC_DI0_CONF_1_SET(x, v)    (HW_IPU_DC_DI0_CONF_1_WR(x, HW_IPU_DC_DI0_CONF_1_RD(x) |  (v)))
#define HW_IPU_DC_DI0_CONF_1_CLR(x, v)    (HW_IPU_DC_DI0_CONF_1_WR(x, HW_IPU_DC_DI0_CONF_1_RD(x) & ~(v)))
#define HW_IPU_DC_DI0_CONF_1_TOG(x, v)    (HW_IPU_DC_DI0_CONF_1_WR(x, HW_IPU_DC_DI0_CONF_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_DI0_CONF_1 bitfields
 */

/* --- Register HW_IPU_DC_DI0_CONF_1, field DI_READ_DATA_MASK_0 (RW)
 *
 * This field defines the mask value of the data read from the display.
 */

#define BP_IPU_DC_DI0_CONF_1_DI_READ_DATA_MASK_0      0
#define BM_IPU_DC_DI0_CONF_1_DI_READ_DATA_MASK_0      0xffffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DI0_CONF_1_DI_READ_DATA_MASK_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_DI0_CONF_1_DI_READ_DATA_MASK_0)
#else
#define BF_IPU_DC_DI0_CONF_1_DI_READ_DATA_MASK_0(v)   (((v) << 0) & BM_IPU_DC_DI0_CONF_1_DI_READ_DATA_MASK_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI_READ_DATA_MASK_0 field to a new value.
#define BW_IPU_DC_DI0_CONF_1_DI_READ_DATA_MASK_0(v)   BF_CS1(IPU_DC_DI0_CONF_1, DI_READ_DATA_MASK_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_DI0_CONF_2 - DC DI0Configuration Register 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI_READ_DATA_ACK_VALUE_0 : 32; //!< This is the expected data to be read from the display. The value reads from the display is anded with the DI_READ_DATA_MASK_0 and compared with the DI_READ_DATA_ACK_VALUE_0. This field is used for the READ_STATUS task of the DC
    } B;
} hw_ipu_dc_di0_conf_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_DI0_CONF_2 register
 */
#define HW_IPU_DC_DI0_CONF_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x580fc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_DI0_CONF_2(x)           (*(volatile hw_ipu_dc_di0_conf_2_t *) HW_IPU_DC_DI0_CONF_2_ADDR(x))
#define HW_IPU_DC_DI0_CONF_2_RD(x)        (HW_IPU_DC_DI0_CONF_2(x).U)
#define HW_IPU_DC_DI0_CONF_2_WR(x, v)     (HW_IPU_DC_DI0_CONF_2(x).U = (v))
#define HW_IPU_DC_DI0_CONF_2_SET(x, v)    (HW_IPU_DC_DI0_CONF_2_WR(x, HW_IPU_DC_DI0_CONF_2_RD(x) |  (v)))
#define HW_IPU_DC_DI0_CONF_2_CLR(x, v)    (HW_IPU_DC_DI0_CONF_2_WR(x, HW_IPU_DC_DI0_CONF_2_RD(x) & ~(v)))
#define HW_IPU_DC_DI0_CONF_2_TOG(x, v)    (HW_IPU_DC_DI0_CONF_2_WR(x, HW_IPU_DC_DI0_CONF_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_DI0_CONF_2 bitfields
 */

/* --- Register HW_IPU_DC_DI0_CONF_2, field DI_READ_DATA_ACK_VALUE_0 (RW)
 *
 * This is the expected data to be read from the display. The value reads from the display is anded
 * with the DI_READ_DATA_MASK_0 and compared with the DI_READ_DATA_ACK_VALUE_0. This field is used
 * for the READ_STATUS task of the DC
 */

#define BP_IPU_DC_DI0_CONF_2_DI_READ_DATA_ACK_VALUE_0      0
#define BM_IPU_DC_DI0_CONF_2_DI_READ_DATA_ACK_VALUE_0      0xffffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DI0_CONF_2_DI_READ_DATA_ACK_VALUE_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_DI0_CONF_2_DI_READ_DATA_ACK_VALUE_0)
#else
#define BF_IPU_DC_DI0_CONF_2_DI_READ_DATA_ACK_VALUE_0(v)   (((v) << 0) & BM_IPU_DC_DI0_CONF_2_DI_READ_DATA_ACK_VALUE_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI_READ_DATA_ACK_VALUE_0 field to a new value.
#define BW_IPU_DC_DI0_CONF_2_DI_READ_DATA_ACK_VALUE_0(v)   BF_CS1(IPU_DC_DI0_CONF_2, DI_READ_DATA_ACK_VALUE_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_DI1_CONF_1 - DC DI1Configuration Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI_READ_DATA_MASK_1 : 32; //!< This field defines the mask value of the data read from the display.
    } B;
} hw_ipu_dc_di1_conf_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_DI1_CONF_1 register
 */
#define HW_IPU_DC_DI1_CONF_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x58100)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_DI1_CONF_1(x)           (*(volatile hw_ipu_dc_di1_conf_1_t *) HW_IPU_DC_DI1_CONF_1_ADDR(x))
#define HW_IPU_DC_DI1_CONF_1_RD(x)        (HW_IPU_DC_DI1_CONF_1(x).U)
#define HW_IPU_DC_DI1_CONF_1_WR(x, v)     (HW_IPU_DC_DI1_CONF_1(x).U = (v))
#define HW_IPU_DC_DI1_CONF_1_SET(x, v)    (HW_IPU_DC_DI1_CONF_1_WR(x, HW_IPU_DC_DI1_CONF_1_RD(x) |  (v)))
#define HW_IPU_DC_DI1_CONF_1_CLR(x, v)    (HW_IPU_DC_DI1_CONF_1_WR(x, HW_IPU_DC_DI1_CONF_1_RD(x) & ~(v)))
#define HW_IPU_DC_DI1_CONF_1_TOG(x, v)    (HW_IPU_DC_DI1_CONF_1_WR(x, HW_IPU_DC_DI1_CONF_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_DI1_CONF_1 bitfields
 */

/* --- Register HW_IPU_DC_DI1_CONF_1, field DI_READ_DATA_MASK_1 (RW)
 *
 * This field defines the mask value of the data read from the display.
 */

#define BP_IPU_DC_DI1_CONF_1_DI_READ_DATA_MASK_1      0
#define BM_IPU_DC_DI1_CONF_1_DI_READ_DATA_MASK_1      0xffffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DI1_CONF_1_DI_READ_DATA_MASK_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_DI1_CONF_1_DI_READ_DATA_MASK_1)
#else
#define BF_IPU_DC_DI1_CONF_1_DI_READ_DATA_MASK_1(v)   (((v) << 0) & BM_IPU_DC_DI1_CONF_1_DI_READ_DATA_MASK_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI_READ_DATA_MASK_1 field to a new value.
#define BW_IPU_DC_DI1_CONF_1_DI_READ_DATA_MASK_1(v)   BF_CS1(IPU_DC_DI1_CONF_1, DI_READ_DATA_MASK_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_DI1_CONF_2 - DC DI1Configuration Register 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DI_READ_DATA_ACK_VALUE_1 : 32; //!< This is the expected data to be read from the display. The value reads from the display is anded with the DI_READ_DATA_MASK_1 and compared with the DI_READ_DATA_ACK_VALUE_1 This field is used for the READ_STATUS task of the DC
    } B;
} hw_ipu_dc_di1_conf_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_DI1_CONF_2 register
 */
#define HW_IPU_DC_DI1_CONF_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x58104)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_DI1_CONF_2(x)           (*(volatile hw_ipu_dc_di1_conf_2_t *) HW_IPU_DC_DI1_CONF_2_ADDR(x))
#define HW_IPU_DC_DI1_CONF_2_RD(x)        (HW_IPU_DC_DI1_CONF_2(x).U)
#define HW_IPU_DC_DI1_CONF_2_WR(x, v)     (HW_IPU_DC_DI1_CONF_2(x).U = (v))
#define HW_IPU_DC_DI1_CONF_2_SET(x, v)    (HW_IPU_DC_DI1_CONF_2_WR(x, HW_IPU_DC_DI1_CONF_2_RD(x) |  (v)))
#define HW_IPU_DC_DI1_CONF_2_CLR(x, v)    (HW_IPU_DC_DI1_CONF_2_WR(x, HW_IPU_DC_DI1_CONF_2_RD(x) & ~(v)))
#define HW_IPU_DC_DI1_CONF_2_TOG(x, v)    (HW_IPU_DC_DI1_CONF_2_WR(x, HW_IPU_DC_DI1_CONF_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_DI1_CONF_2 bitfields
 */

/* --- Register HW_IPU_DC_DI1_CONF_2, field DI_READ_DATA_ACK_VALUE_1 (RW)
 *
 * This is the expected data to be read from the display. The value reads from the display is anded
 * with the DI_READ_DATA_MASK_1 and compared with the DI_READ_DATA_ACK_VALUE_1 This field is used
 * for the READ_STATUS task of the DC
 */

#define BP_IPU_DC_DI1_CONF_2_DI_READ_DATA_ACK_VALUE_1      0
#define BM_IPU_DC_DI1_CONF_2_DI_READ_DATA_ACK_VALUE_1      0xffffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DI1_CONF_2_DI_READ_DATA_ACK_VALUE_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_DI1_CONF_2_DI_READ_DATA_ACK_VALUE_1)
#else
#define BF_IPU_DC_DI1_CONF_2_DI_READ_DATA_ACK_VALUE_1(v)   (((v) << 0) & BM_IPU_DC_DI1_CONF_2_DI_READ_DATA_ACK_VALUE_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DI_READ_DATA_ACK_VALUE_1 field to a new value.
#define BW_IPU_DC_DI1_CONF_2_DI_READ_DATA_ACK_VALUE_1(v)   BF_CS1(IPU_DC_DI1_CONF_2, DI_READ_DATA_ACK_VALUE_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_0 - DC Mapping Configuration Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_0 : 5; //!< Mapping pointer #0 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_0 : 5; //!< Mapping pointer #0 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_0 : 5; //!< Mapping pointer #0 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_1 : 5; //!< Mapping pointer #1 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_1 : 5; //!< Mapping pointer #1 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_1 : 5; //!< Mapping pointer #1 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_0 register
 */
#define HW_IPU_DC_MAP_CONF_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x58108)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_0(x)           (*(volatile hw_ipu_dc_map_conf_0_t *) HW_IPU_DC_MAP_CONF_0_ADDR(x))
#define HW_IPU_DC_MAP_CONF_0_RD(x)        (HW_IPU_DC_MAP_CONF_0(x).U)
#define HW_IPU_DC_MAP_CONF_0_WR(x, v)     (HW_IPU_DC_MAP_CONF_0(x).U = (v))
#define HW_IPU_DC_MAP_CONF_0_SET(x, v)    (HW_IPU_DC_MAP_CONF_0_WR(x, HW_IPU_DC_MAP_CONF_0_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_0_CLR(x, v)    (HW_IPU_DC_MAP_CONF_0_WR(x, HW_IPU_DC_MAP_CONF_0_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_0_TOG(x, v)    (HW_IPU_DC_MAP_CONF_0_WR(x, HW_IPU_DC_MAP_CONF_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_0 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_0, field MAPPING_PNTR_BYTE0_0 (RW)
 *
 * Mapping pointer #0 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_0      0
#define BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_0      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_0)
#else
#define BF_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_0(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_0 field to a new value.
#define BW_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_0(v)   BF_CS1(IPU_DC_MAP_CONF_0, MAPPING_PNTR_BYTE0_0, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_0, field MAPPING_PNTR_BYTE1_0 (RW)
 *
 * Mapping pointer #0 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_0      5
#define BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_0      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_0(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_0)
#else
#define BF_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_0(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_0 field to a new value.
#define BW_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_0(v)   BF_CS1(IPU_DC_MAP_CONF_0, MAPPING_PNTR_BYTE1_0, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_0, field MAPPING_PNTR_BYTE2_0 (RW)
 *
 * Mapping pointer #0 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_0      10
#define BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_0      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_0(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_0)
#else
#define BF_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_0(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_0 field to a new value.
#define BW_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_0(v)   BF_CS1(IPU_DC_MAP_CONF_0, MAPPING_PNTR_BYTE2_0, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_0, field MAPPING_PNTR_BYTE0_1 (RW)
 *
 * Mapping pointer #1 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_1      16
#define BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_1      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_1)
#else
#define BF_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_1(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_1 field to a new value.
#define BW_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE0_1(v)   BF_CS1(IPU_DC_MAP_CONF_0, MAPPING_PNTR_BYTE0_1, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_0, field MAPPING_PNTR_BYTE1_1 (RW)
 *
 * Mapping pointer #1 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_1      21
#define BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_1      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_1(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_1)
#else
#define BF_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_1(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_1 field to a new value.
#define BW_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE1_1(v)   BF_CS1(IPU_DC_MAP_CONF_0, MAPPING_PNTR_BYTE1_1, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_0, field MAPPING_PNTR_BYTE2_1 (RW)
 *
 * Mapping pointer #1 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_1      26
#define BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_1      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_1(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_1)
#else
#define BF_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_1(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_1 field to a new value.
#define BW_IPU_DC_MAP_CONF_0_MAPPING_PNTR_BYTE2_1(v)   BF_CS1(IPU_DC_MAP_CONF_0, MAPPING_PNTR_BYTE2_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_1 - DC Mapping Configuration Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_2 : 5; //!< Mapping pointer #1 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_2 : 5; //!< Mapping pointer #1 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_2 : 5; //!< Mapping pointer #1 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_3 : 5; //!< Mapping pointer #3 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_3 : 5; //!< Mapping pointer #3 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_3 : 5; //!< Mapping pointer #3 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_1 register
 */
#define HW_IPU_DC_MAP_CONF_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x5810c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_1(x)           (*(volatile hw_ipu_dc_map_conf_1_t *) HW_IPU_DC_MAP_CONF_1_ADDR(x))
#define HW_IPU_DC_MAP_CONF_1_RD(x)        (HW_IPU_DC_MAP_CONF_1(x).U)
#define HW_IPU_DC_MAP_CONF_1_WR(x, v)     (HW_IPU_DC_MAP_CONF_1(x).U = (v))
#define HW_IPU_DC_MAP_CONF_1_SET(x, v)    (HW_IPU_DC_MAP_CONF_1_WR(x, HW_IPU_DC_MAP_CONF_1_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_1_CLR(x, v)    (HW_IPU_DC_MAP_CONF_1_WR(x, HW_IPU_DC_MAP_CONF_1_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_1_TOG(x, v)    (HW_IPU_DC_MAP_CONF_1_WR(x, HW_IPU_DC_MAP_CONF_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_1 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_1, field MAPPING_PNTR_BYTE0_2 (RW)
 *
 * Mapping pointer #1 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_2      0
#define BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_2      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_2)
#else
#define BF_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_2(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_2 field to a new value.
#define BW_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_2(v)   BF_CS1(IPU_DC_MAP_CONF_1, MAPPING_PNTR_BYTE0_2, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_1, field MAPPING_PNTR_BYTE1_2 (RW)
 *
 * Mapping pointer #1 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_2      5
#define BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_2      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_2(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_2)
#else
#define BF_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_2(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_2 field to a new value.
#define BW_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_2(v)   BF_CS1(IPU_DC_MAP_CONF_1, MAPPING_PNTR_BYTE1_2, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_1, field MAPPING_PNTR_BYTE2_2 (RW)
 *
 * Mapping pointer #1 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_2      10
#define BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_2      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_2(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_2)
#else
#define BF_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_2(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_2 field to a new value.
#define BW_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_2(v)   BF_CS1(IPU_DC_MAP_CONF_1, MAPPING_PNTR_BYTE2_2, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_1, field MAPPING_PNTR_BYTE0_3 (RW)
 *
 * Mapping pointer #3 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_3      16
#define BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_3      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_3(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_3)
#else
#define BF_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_3(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_3 field to a new value.
#define BW_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE0_3(v)   BF_CS1(IPU_DC_MAP_CONF_1, MAPPING_PNTR_BYTE0_3, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_1, field MAPPING_PNTR_BYTE1_3 (RW)
 *
 * Mapping pointer #3 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_3      21
#define BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_3      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_3(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_3)
#else
#define BF_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_3(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_3 field to a new value.
#define BW_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE1_3(v)   BF_CS1(IPU_DC_MAP_CONF_1, MAPPING_PNTR_BYTE1_3, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_1, field MAPPING_PNTR_BYTE2_3 (RW)
 *
 * Mapping pointer #3 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_3      26
#define BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_3      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_3(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_3)
#else
#define BF_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_3(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_3 field to a new value.
#define BW_IPU_DC_MAP_CONF_1_MAPPING_PNTR_BYTE2_3(v)   BF_CS1(IPU_DC_MAP_CONF_1, MAPPING_PNTR_BYTE2_3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_2 - DC Mapping Configuration Register 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_4 : 5; //!< Mapping pointer #4 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_4 : 5; //!< Mapping pointer #4 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_4 : 5; //!< Mapping pointer #4 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_5 : 5; //!< Mapping pointer #5 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_5 : 5; //!< Mapping pointer #5 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_5 : 5; //!< Mapping pointer #5 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_2 register
 */
#define HW_IPU_DC_MAP_CONF_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x58110)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_2(x)           (*(volatile hw_ipu_dc_map_conf_2_t *) HW_IPU_DC_MAP_CONF_2_ADDR(x))
#define HW_IPU_DC_MAP_CONF_2_RD(x)        (HW_IPU_DC_MAP_CONF_2(x).U)
#define HW_IPU_DC_MAP_CONF_2_WR(x, v)     (HW_IPU_DC_MAP_CONF_2(x).U = (v))
#define HW_IPU_DC_MAP_CONF_2_SET(x, v)    (HW_IPU_DC_MAP_CONF_2_WR(x, HW_IPU_DC_MAP_CONF_2_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_2_CLR(x, v)    (HW_IPU_DC_MAP_CONF_2_WR(x, HW_IPU_DC_MAP_CONF_2_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_2_TOG(x, v)    (HW_IPU_DC_MAP_CONF_2_WR(x, HW_IPU_DC_MAP_CONF_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_2 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_2, field MAPPING_PNTR_BYTE0_4 (RW)
 *
 * Mapping pointer #4 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_4      0
#define BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_4      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_4(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_4)
#else
#define BF_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_4(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_4 field to a new value.
#define BW_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_4(v)   BF_CS1(IPU_DC_MAP_CONF_2, MAPPING_PNTR_BYTE0_4, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_2, field MAPPING_PNTR_BYTE1_4 (RW)
 *
 * Mapping pointer #4 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_4      5
#define BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_4      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_4(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_4)
#else
#define BF_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_4(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_4 field to a new value.
#define BW_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_4(v)   BF_CS1(IPU_DC_MAP_CONF_2, MAPPING_PNTR_BYTE1_4, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_2, field MAPPING_PNTR_BYTE2_4 (RW)
 *
 * Mapping pointer #4 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_4      10
#define BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_4      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_4(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_4)
#else
#define BF_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_4(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_4 field to a new value.
#define BW_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_4(v)   BF_CS1(IPU_DC_MAP_CONF_2, MAPPING_PNTR_BYTE2_4, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_2, field MAPPING_PNTR_BYTE0_5 (RW)
 *
 * Mapping pointer #5 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_5      16
#define BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_5      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_5(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_5)
#else
#define BF_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_5(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_5 field to a new value.
#define BW_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE0_5(v)   BF_CS1(IPU_DC_MAP_CONF_2, MAPPING_PNTR_BYTE0_5, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_2, field MAPPING_PNTR_BYTE1_5 (RW)
 *
 * Mapping pointer #5 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_5      21
#define BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_5      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_5(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_5)
#else
#define BF_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_5(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_5 field to a new value.
#define BW_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE1_5(v)   BF_CS1(IPU_DC_MAP_CONF_2, MAPPING_PNTR_BYTE1_5, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_2, field MAPPING_PNTR_BYTE2_5 (RW)
 *
 * Mapping pointer #5 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_5      26
#define BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_5      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_5(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_5)
#else
#define BF_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_5(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_5 field to a new value.
#define BW_IPU_DC_MAP_CONF_2_MAPPING_PNTR_BYTE2_5(v)   BF_CS1(IPU_DC_MAP_CONF_2, MAPPING_PNTR_BYTE2_5, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_3 - DC Mapping Configuration Register 3 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_6 : 5; //!< Mapping pointer #6 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_6 : 5; //!< Mapping pointer #6 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_6 : 5; //!< Mapping pointer #6 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_7 : 5; //!< Mapping pointer #7 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_7 : 5; //!< Mapping pointer #7 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_7 : 5; //!< Mapping pointer #7 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_3 register
 */
#define HW_IPU_DC_MAP_CONF_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x58114)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_3(x)           (*(volatile hw_ipu_dc_map_conf_3_t *) HW_IPU_DC_MAP_CONF_3_ADDR(x))
#define HW_IPU_DC_MAP_CONF_3_RD(x)        (HW_IPU_DC_MAP_CONF_3(x).U)
#define HW_IPU_DC_MAP_CONF_3_WR(x, v)     (HW_IPU_DC_MAP_CONF_3(x).U = (v))
#define HW_IPU_DC_MAP_CONF_3_SET(x, v)    (HW_IPU_DC_MAP_CONF_3_WR(x, HW_IPU_DC_MAP_CONF_3_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_3_CLR(x, v)    (HW_IPU_DC_MAP_CONF_3_WR(x, HW_IPU_DC_MAP_CONF_3_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_3_TOG(x, v)    (HW_IPU_DC_MAP_CONF_3_WR(x, HW_IPU_DC_MAP_CONF_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_3 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_3, field MAPPING_PNTR_BYTE0_6 (RW)
 *
 * Mapping pointer #6 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_6      0
#define BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_6      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_6)
#else
#define BF_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_6(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_6 field to a new value.
#define BW_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_6(v)   BF_CS1(IPU_DC_MAP_CONF_3, MAPPING_PNTR_BYTE0_6, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_3, field MAPPING_PNTR_BYTE1_6 (RW)
 *
 * Mapping pointer #6 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_6      5
#define BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_6      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_6(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_6)
#else
#define BF_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_6(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_6 field to a new value.
#define BW_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_6(v)   BF_CS1(IPU_DC_MAP_CONF_3, MAPPING_PNTR_BYTE1_6, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_3, field MAPPING_PNTR_BYTE2_6 (RW)
 *
 * Mapping pointer #6 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_6      10
#define BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_6      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_6(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_6)
#else
#define BF_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_6(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_6 field to a new value.
#define BW_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_6(v)   BF_CS1(IPU_DC_MAP_CONF_3, MAPPING_PNTR_BYTE2_6, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_3, field MAPPING_PNTR_BYTE0_7 (RW)
 *
 * Mapping pointer #7 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_7      16
#define BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_7      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_7(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_7)
#else
#define BF_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_7(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_7 field to a new value.
#define BW_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE0_7(v)   BF_CS1(IPU_DC_MAP_CONF_3, MAPPING_PNTR_BYTE0_7, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_3, field MAPPING_PNTR_BYTE1_7 (RW)
 *
 * Mapping pointer #7 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_7      21
#define BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_7      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_7(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_7)
#else
#define BF_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_7(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_7 field to a new value.
#define BW_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE1_7(v)   BF_CS1(IPU_DC_MAP_CONF_3, MAPPING_PNTR_BYTE1_7, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_3, field MAPPING_PNTR_BYTE2_7 (RW)
 *
 * Mapping pointer #7 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_7      26
#define BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_7      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_7(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_7)
#else
#define BF_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_7(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_7 field to a new value.
#define BW_IPU_DC_MAP_CONF_3_MAPPING_PNTR_BYTE2_7(v)   BF_CS1(IPU_DC_MAP_CONF_3, MAPPING_PNTR_BYTE2_7, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_4 - DC Mapping Configuration Register 4 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_8 : 5; //!< Mapping pointer #8 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_8 : 5; //!< Mapping pointer #8 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_8 : 5; //!< Mapping pointer #8 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_9 : 5; //!< Mapping pointer #9 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_1 : 5; //!< Mapping pointer #9 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_9 : 5; //!< Mapping pointer #9 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_4 register
 */
#define HW_IPU_DC_MAP_CONF_4_ADDR(x)      (REGS_IPU_BASE(x) + 0x58118)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_4(x)           (*(volatile hw_ipu_dc_map_conf_4_t *) HW_IPU_DC_MAP_CONF_4_ADDR(x))
#define HW_IPU_DC_MAP_CONF_4_RD(x)        (HW_IPU_DC_MAP_CONF_4(x).U)
#define HW_IPU_DC_MAP_CONF_4_WR(x, v)     (HW_IPU_DC_MAP_CONF_4(x).U = (v))
#define HW_IPU_DC_MAP_CONF_4_SET(x, v)    (HW_IPU_DC_MAP_CONF_4_WR(x, HW_IPU_DC_MAP_CONF_4_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_4_CLR(x, v)    (HW_IPU_DC_MAP_CONF_4_WR(x, HW_IPU_DC_MAP_CONF_4_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_4_TOG(x, v)    (HW_IPU_DC_MAP_CONF_4_WR(x, HW_IPU_DC_MAP_CONF_4_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_4 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_4, field MAPPING_PNTR_BYTE0_8 (RW)
 *
 * Mapping pointer #8 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_8      0
#define BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_8      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_8(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_8)
#else
#define BF_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_8(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_8 field to a new value.
#define BW_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_8(v)   BF_CS1(IPU_DC_MAP_CONF_4, MAPPING_PNTR_BYTE0_8, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_4, field MAPPING_PNTR_BYTE1_8 (RW)
 *
 * Mapping pointer #8 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_8      5
#define BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_8      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_8(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_8)
#else
#define BF_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_8(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_8 field to a new value.
#define BW_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_8(v)   BF_CS1(IPU_DC_MAP_CONF_4, MAPPING_PNTR_BYTE1_8, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_4, field MAPPING_PNTR_BYTE2_8 (RW)
 *
 * Mapping pointer #8 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_8      10
#define BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_8      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_8(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_8)
#else
#define BF_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_8(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_8 field to a new value.
#define BW_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_8(v)   BF_CS1(IPU_DC_MAP_CONF_4, MAPPING_PNTR_BYTE2_8, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_4, field MAPPING_PNTR_BYTE0_9 (RW)
 *
 * Mapping pointer #9 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_9      16
#define BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_9      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_9(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_9)
#else
#define BF_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_9(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_9 field to a new value.
#define BW_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE0_9(v)   BF_CS1(IPU_DC_MAP_CONF_4, MAPPING_PNTR_BYTE0_9, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_4, field MAPPING_PNTR_BYTE1_1 (RW)
 *
 * Mapping pointer #9 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_1      21
#define BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_1      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_1(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_1)
#else
#define BF_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_1(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_1 field to a new value.
#define BW_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE1_1(v)   BF_CS1(IPU_DC_MAP_CONF_4, MAPPING_PNTR_BYTE1_1, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_4, field MAPPING_PNTR_BYTE2_9 (RW)
 *
 * Mapping pointer #9 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i>
 * used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_9      26
#define BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_9      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_9(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_9)
#else
#define BF_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_9(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_9 field to a new value.
#define BW_IPU_DC_MAP_CONF_4_MAPPING_PNTR_BYTE2_9(v)   BF_CS1(IPU_DC_MAP_CONF_4, MAPPING_PNTR_BYTE2_9, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_5 - DC Mapping Configuration Register 5 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_10 : 5; //!< Mapping pointer #10 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_10 : 5; //!< Mapping pointer #10 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_10 : 5; //!< Mapping pointer #10 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_11 : 5; //!< Mapping pointer #11 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_11 : 5; //!< Mapping pointer #11 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_11 : 5; //!< Mapping pointer #11 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_5_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_5 register
 */
#define HW_IPU_DC_MAP_CONF_5_ADDR(x)      (REGS_IPU_BASE(x) + 0x5811c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_5(x)           (*(volatile hw_ipu_dc_map_conf_5_t *) HW_IPU_DC_MAP_CONF_5_ADDR(x))
#define HW_IPU_DC_MAP_CONF_5_RD(x)        (HW_IPU_DC_MAP_CONF_5(x).U)
#define HW_IPU_DC_MAP_CONF_5_WR(x, v)     (HW_IPU_DC_MAP_CONF_5(x).U = (v))
#define HW_IPU_DC_MAP_CONF_5_SET(x, v)    (HW_IPU_DC_MAP_CONF_5_WR(x, HW_IPU_DC_MAP_CONF_5_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_5_CLR(x, v)    (HW_IPU_DC_MAP_CONF_5_WR(x, HW_IPU_DC_MAP_CONF_5_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_5_TOG(x, v)    (HW_IPU_DC_MAP_CONF_5_WR(x, HW_IPU_DC_MAP_CONF_5_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_5 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_5, field MAPPING_PNTR_BYTE0_10 (RW)
 *
 * Mapping pointer #10 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_10      0
#define BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_10      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_10(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_10)
#else
#define BF_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_10(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_10 field to a new value.
#define BW_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_10(v)   BF_CS1(IPU_DC_MAP_CONF_5, MAPPING_PNTR_BYTE0_10, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_5, field MAPPING_PNTR_BYTE1_10 (RW)
 *
 * Mapping pointer #10 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_10      5
#define BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_10      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_10(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_10)
#else
#define BF_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_10(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_10 field to a new value.
#define BW_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_10(v)   BF_CS1(IPU_DC_MAP_CONF_5, MAPPING_PNTR_BYTE1_10, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_5, field MAPPING_PNTR_BYTE2_10 (RW)
 *
 * Mapping pointer #10 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_10      10
#define BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_10      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_10(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_10)
#else
#define BF_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_10(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_10 field to a new value.
#define BW_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_10(v)   BF_CS1(IPU_DC_MAP_CONF_5, MAPPING_PNTR_BYTE2_10, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_5, field MAPPING_PNTR_BYTE0_11 (RW)
 *
 * Mapping pointer #11 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_11      16
#define BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_11      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_11(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_11)
#else
#define BF_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_11(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_11 field to a new value.
#define BW_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE0_11(v)   BF_CS1(IPU_DC_MAP_CONF_5, MAPPING_PNTR_BYTE0_11, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_5, field MAPPING_PNTR_BYTE1_11 (RW)
 *
 * Mapping pointer #11 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_11      21
#define BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_11      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_11(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_11)
#else
#define BF_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_11(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_11 field to a new value.
#define BW_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE1_11(v)   BF_CS1(IPU_DC_MAP_CONF_5, MAPPING_PNTR_BYTE1_11, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_5, field MAPPING_PNTR_BYTE2_11 (RW)
 *
 * Mapping pointer #11 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_11      26
#define BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_11      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_11(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_11)
#else
#define BF_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_11(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_11 field to a new value.
#define BW_IPU_DC_MAP_CONF_5_MAPPING_PNTR_BYTE2_11(v)   BF_CS1(IPU_DC_MAP_CONF_5, MAPPING_PNTR_BYTE2_11, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_6 - DC Mapping Configuration Register 6 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_12 : 5; //!< Mapping pointer #12 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_12 : 5; //!< Mapping pointer #12 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_12 : 5; //!< Mapping pointer #12 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_13 : 5; //!< Mapping pointer #13 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_13 : 5; //!< Mapping pointer #13 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_13 : 5; //!< Mapping pointer #13 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_6_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_6 register
 */
#define HW_IPU_DC_MAP_CONF_6_ADDR(x)      (REGS_IPU_BASE(x) + 0x58120)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_6(x)           (*(volatile hw_ipu_dc_map_conf_6_t *) HW_IPU_DC_MAP_CONF_6_ADDR(x))
#define HW_IPU_DC_MAP_CONF_6_RD(x)        (HW_IPU_DC_MAP_CONF_6(x).U)
#define HW_IPU_DC_MAP_CONF_6_WR(x, v)     (HW_IPU_DC_MAP_CONF_6(x).U = (v))
#define HW_IPU_DC_MAP_CONF_6_SET(x, v)    (HW_IPU_DC_MAP_CONF_6_WR(x, HW_IPU_DC_MAP_CONF_6_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_6_CLR(x, v)    (HW_IPU_DC_MAP_CONF_6_WR(x, HW_IPU_DC_MAP_CONF_6_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_6_TOG(x, v)    (HW_IPU_DC_MAP_CONF_6_WR(x, HW_IPU_DC_MAP_CONF_6_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_6 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_6, field MAPPING_PNTR_BYTE0_12 (RW)
 *
 * Mapping pointer #12 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_12      0
#define BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_12      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_12(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_12)
#else
#define BF_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_12(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_12 field to a new value.
#define BW_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_12(v)   BF_CS1(IPU_DC_MAP_CONF_6, MAPPING_PNTR_BYTE0_12, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_6, field MAPPING_PNTR_BYTE1_12 (RW)
 *
 * Mapping pointer #12 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_12      5
#define BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_12      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_12(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_12)
#else
#define BF_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_12(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_12 field to a new value.
#define BW_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_12(v)   BF_CS1(IPU_DC_MAP_CONF_6, MAPPING_PNTR_BYTE1_12, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_6, field MAPPING_PNTR_BYTE2_12 (RW)
 *
 * Mapping pointer #12 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_12      10
#define BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_12      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_12(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_12)
#else
#define BF_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_12(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_12 field to a new value.
#define BW_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_12(v)   BF_CS1(IPU_DC_MAP_CONF_6, MAPPING_PNTR_BYTE2_12, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_6, field MAPPING_PNTR_BYTE0_13 (RW)
 *
 * Mapping pointer #13 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_13      16
#define BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_13      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_13(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_13)
#else
#define BF_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_13(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_13 field to a new value.
#define BW_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE0_13(v)   BF_CS1(IPU_DC_MAP_CONF_6, MAPPING_PNTR_BYTE0_13, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_6, field MAPPING_PNTR_BYTE1_13 (RW)
 *
 * Mapping pointer #13 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_13      21
#define BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_13      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_13(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_13)
#else
#define BF_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_13(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_13 field to a new value.
#define BW_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE1_13(v)   BF_CS1(IPU_DC_MAP_CONF_6, MAPPING_PNTR_BYTE1_13, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_6, field MAPPING_PNTR_BYTE2_13 (RW)
 *
 * Mapping pointer #13 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_13      26
#define BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_13      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_13(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_13)
#else
#define BF_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_13(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_13 field to a new value.
#define BW_IPU_DC_MAP_CONF_6_MAPPING_PNTR_BYTE2_13(v)   BF_CS1(IPU_DC_MAP_CONF_6, MAPPING_PNTR_BYTE2_13, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_7 - DC Mapping Configuration Register 7 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_14 : 5; //!< Mapping pointer #14 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_14 : 5; //!< Mapping pointer #14 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_14 : 5; //!< Mapping pointer #14 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_15 : 5; //!< Mapping pointer #15 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_15 : 5; //!< Mapping pointer #15 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_15 : 5; //!< Mapping pointer #15 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_7_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_7 register
 */
#define HW_IPU_DC_MAP_CONF_7_ADDR(x)      (REGS_IPU_BASE(x) + 0x58124)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_7(x)           (*(volatile hw_ipu_dc_map_conf_7_t *) HW_IPU_DC_MAP_CONF_7_ADDR(x))
#define HW_IPU_DC_MAP_CONF_7_RD(x)        (HW_IPU_DC_MAP_CONF_7(x).U)
#define HW_IPU_DC_MAP_CONF_7_WR(x, v)     (HW_IPU_DC_MAP_CONF_7(x).U = (v))
#define HW_IPU_DC_MAP_CONF_7_SET(x, v)    (HW_IPU_DC_MAP_CONF_7_WR(x, HW_IPU_DC_MAP_CONF_7_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_7_CLR(x, v)    (HW_IPU_DC_MAP_CONF_7_WR(x, HW_IPU_DC_MAP_CONF_7_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_7_TOG(x, v)    (HW_IPU_DC_MAP_CONF_7_WR(x, HW_IPU_DC_MAP_CONF_7_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_7 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_7, field MAPPING_PNTR_BYTE0_14 (RW)
 *
 * Mapping pointer #14 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_14      0
#define BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_14      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_14(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_14)
#else
#define BF_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_14(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_14 field to a new value.
#define BW_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_14(v)   BF_CS1(IPU_DC_MAP_CONF_7, MAPPING_PNTR_BYTE0_14, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_7, field MAPPING_PNTR_BYTE1_14 (RW)
 *
 * Mapping pointer #14 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_14      5
#define BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_14      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_14(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_14)
#else
#define BF_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_14(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_14 field to a new value.
#define BW_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_14(v)   BF_CS1(IPU_DC_MAP_CONF_7, MAPPING_PNTR_BYTE1_14, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_7, field MAPPING_PNTR_BYTE2_14 (RW)
 *
 * Mapping pointer #14 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_14      10
#define BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_14      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_14(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_14)
#else
#define BF_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_14(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_14 field to a new value.
#define BW_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_14(v)   BF_CS1(IPU_DC_MAP_CONF_7, MAPPING_PNTR_BYTE2_14, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_7, field MAPPING_PNTR_BYTE0_15 (RW)
 *
 * Mapping pointer #15 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_15      16
#define BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_15      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_15(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_15)
#else
#define BF_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_15(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_15 field to a new value.
#define BW_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE0_15(v)   BF_CS1(IPU_DC_MAP_CONF_7, MAPPING_PNTR_BYTE0_15, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_7, field MAPPING_PNTR_BYTE1_15 (RW)
 *
 * Mapping pointer #15 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_15      21
#define BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_15      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_15(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_15)
#else
#define BF_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_15(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_15 field to a new value.
#define BW_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE1_15(v)   BF_CS1(IPU_DC_MAP_CONF_7, MAPPING_PNTR_BYTE1_15, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_7, field MAPPING_PNTR_BYTE2_15 (RW)
 *
 * Mapping pointer #15 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_15      26
#define BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_15      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_15(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_15)
#else
#define BF_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_15(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_15 field to a new value.
#define BW_IPU_DC_MAP_CONF_7_MAPPING_PNTR_BYTE2_15(v)   BF_CS1(IPU_DC_MAP_CONF_7, MAPPING_PNTR_BYTE2_15, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_8 - DC Mapping Configuration Register 8 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_16 : 5; //!< Mapping pointer #16 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_16 : 5; //!< Mapping pointer #16 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_16 : 5; //!< Mapping pointer #16 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_17 : 5; //!< Mapping pointer #17 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_17 : 5; //!< Mapping pointer #17 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_17 : 5; //!< Mapping pointer #17 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_8_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_8 register
 */
#define HW_IPU_DC_MAP_CONF_8_ADDR(x)      (REGS_IPU_BASE(x) + 0x58128)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_8(x)           (*(volatile hw_ipu_dc_map_conf_8_t *) HW_IPU_DC_MAP_CONF_8_ADDR(x))
#define HW_IPU_DC_MAP_CONF_8_RD(x)        (HW_IPU_DC_MAP_CONF_8(x).U)
#define HW_IPU_DC_MAP_CONF_8_WR(x, v)     (HW_IPU_DC_MAP_CONF_8(x).U = (v))
#define HW_IPU_DC_MAP_CONF_8_SET(x, v)    (HW_IPU_DC_MAP_CONF_8_WR(x, HW_IPU_DC_MAP_CONF_8_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_8_CLR(x, v)    (HW_IPU_DC_MAP_CONF_8_WR(x, HW_IPU_DC_MAP_CONF_8_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_8_TOG(x, v)    (HW_IPU_DC_MAP_CONF_8_WR(x, HW_IPU_DC_MAP_CONF_8_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_8 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_8, field MAPPING_PNTR_BYTE0_16 (RW)
 *
 * Mapping pointer #16 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_16      0
#define BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_16      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_16(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_16)
#else
#define BF_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_16(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_16 field to a new value.
#define BW_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_16(v)   BF_CS1(IPU_DC_MAP_CONF_8, MAPPING_PNTR_BYTE0_16, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_8, field MAPPING_PNTR_BYTE1_16 (RW)
 *
 * Mapping pointer #16 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_16      5
#define BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_16      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_16(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_16)
#else
#define BF_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_16(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_16 field to a new value.
#define BW_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_16(v)   BF_CS1(IPU_DC_MAP_CONF_8, MAPPING_PNTR_BYTE1_16, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_8, field MAPPING_PNTR_BYTE2_16 (RW)
 *
 * Mapping pointer #16 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_16      10
#define BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_16      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_16(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_16)
#else
#define BF_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_16(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_16 field to a new value.
#define BW_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_16(v)   BF_CS1(IPU_DC_MAP_CONF_8, MAPPING_PNTR_BYTE2_16, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_8, field MAPPING_PNTR_BYTE0_17 (RW)
 *
 * Mapping pointer #17 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_17      16
#define BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_17      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_17(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_17)
#else
#define BF_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_17(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_17 field to a new value.
#define BW_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE0_17(v)   BF_CS1(IPU_DC_MAP_CONF_8, MAPPING_PNTR_BYTE0_17, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_8, field MAPPING_PNTR_BYTE1_17 (RW)
 *
 * Mapping pointer #17 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_17      21
#define BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_17      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_17(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_17)
#else
#define BF_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_17(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_17 field to a new value.
#define BW_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE1_17(v)   BF_CS1(IPU_DC_MAP_CONF_8, MAPPING_PNTR_BYTE1_17, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_8, field MAPPING_PNTR_BYTE2_17 (RW)
 *
 * Mapping pointer #17 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_17      26
#define BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_17      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_17(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_17)
#else
#define BF_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_17(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_17 field to a new value.
#define BW_IPU_DC_MAP_CONF_8_MAPPING_PNTR_BYTE2_17(v)   BF_CS1(IPU_DC_MAP_CONF_8, MAPPING_PNTR_BYTE2_17, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_9 - DC Mapping Configuration Register 9 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_18 : 5; //!< Mapping pointer #18 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_18 : 5; //!< Mapping pointer #18 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_18 : 5; //!< Mapping pointer #18 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_19 : 5; //!< Mapping pointer #19 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_19 : 5; //!< Mapping pointer #19 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_19 : 5; //!< Mapping pointer #19 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_9_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_9 register
 */
#define HW_IPU_DC_MAP_CONF_9_ADDR(x)      (REGS_IPU_BASE(x) + 0x5812c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_9(x)           (*(volatile hw_ipu_dc_map_conf_9_t *) HW_IPU_DC_MAP_CONF_9_ADDR(x))
#define HW_IPU_DC_MAP_CONF_9_RD(x)        (HW_IPU_DC_MAP_CONF_9(x).U)
#define HW_IPU_DC_MAP_CONF_9_WR(x, v)     (HW_IPU_DC_MAP_CONF_9(x).U = (v))
#define HW_IPU_DC_MAP_CONF_9_SET(x, v)    (HW_IPU_DC_MAP_CONF_9_WR(x, HW_IPU_DC_MAP_CONF_9_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_9_CLR(x, v)    (HW_IPU_DC_MAP_CONF_9_WR(x, HW_IPU_DC_MAP_CONF_9_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_9_TOG(x, v)    (HW_IPU_DC_MAP_CONF_9_WR(x, HW_IPU_DC_MAP_CONF_9_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_9 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_9, field MAPPING_PNTR_BYTE0_18 (RW)
 *
 * Mapping pointer #18 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_18      0
#define BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_18      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_18(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_18)
#else
#define BF_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_18(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_18 field to a new value.
#define BW_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_18(v)   BF_CS1(IPU_DC_MAP_CONF_9, MAPPING_PNTR_BYTE0_18, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_9, field MAPPING_PNTR_BYTE1_18 (RW)
 *
 * Mapping pointer #18 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_18      5
#define BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_18      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_18(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_18)
#else
#define BF_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_18(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_18 field to a new value.
#define BW_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_18(v)   BF_CS1(IPU_DC_MAP_CONF_9, MAPPING_PNTR_BYTE1_18, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_9, field MAPPING_PNTR_BYTE2_18 (RW)
 *
 * Mapping pointer #18 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_18      10
#define BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_18      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_18(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_18)
#else
#define BF_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_18(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_18 field to a new value.
#define BW_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_18(v)   BF_CS1(IPU_DC_MAP_CONF_9, MAPPING_PNTR_BYTE2_18, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_9, field MAPPING_PNTR_BYTE0_19 (RW)
 *
 * Mapping pointer #19 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_19      16
#define BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_19      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_19(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_19)
#else
#define BF_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_19(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_19 field to a new value.
#define BW_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE0_19(v)   BF_CS1(IPU_DC_MAP_CONF_9, MAPPING_PNTR_BYTE0_19, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_9, field MAPPING_PNTR_BYTE1_19 (RW)
 *
 * Mapping pointer #19 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_19      21
#define BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_19      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_19(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_19)
#else
#define BF_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_19(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_19 field to a new value.
#define BW_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE1_19(v)   BF_CS1(IPU_DC_MAP_CONF_9, MAPPING_PNTR_BYTE1_19, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_9, field MAPPING_PNTR_BYTE2_19 (RW)
 *
 * Mapping pointer #19 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_19      26
#define BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_19      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_19(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_19)
#else
#define BF_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_19(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_19 field to a new value.
#define BW_IPU_DC_MAP_CONF_9_MAPPING_PNTR_BYTE2_19(v)   BF_CS1(IPU_DC_MAP_CONF_9, MAPPING_PNTR_BYTE2_19, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_10 - DC Mapping Configuration Register 10 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_20 : 5; //!< Mapping pointer #20 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_20 : 5; //!< Mapping pointer #20 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_20 : 5; //!< Mapping pointer #20 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_21 : 5; //!< Mapping pointer #21 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_21 : 5; //!< Mapping pointer #21 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_21 : 5; //!< Mapping pointer #21 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_10_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_10 register
 */
#define HW_IPU_DC_MAP_CONF_10_ADDR(x)      (REGS_IPU_BASE(x) + 0x58130)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_10(x)           (*(volatile hw_ipu_dc_map_conf_10_t *) HW_IPU_DC_MAP_CONF_10_ADDR(x))
#define HW_IPU_DC_MAP_CONF_10_RD(x)        (HW_IPU_DC_MAP_CONF_10(x).U)
#define HW_IPU_DC_MAP_CONF_10_WR(x, v)     (HW_IPU_DC_MAP_CONF_10(x).U = (v))
#define HW_IPU_DC_MAP_CONF_10_SET(x, v)    (HW_IPU_DC_MAP_CONF_10_WR(x, HW_IPU_DC_MAP_CONF_10_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_10_CLR(x, v)    (HW_IPU_DC_MAP_CONF_10_WR(x, HW_IPU_DC_MAP_CONF_10_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_10_TOG(x, v)    (HW_IPU_DC_MAP_CONF_10_WR(x, HW_IPU_DC_MAP_CONF_10_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_10 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_10, field MAPPING_PNTR_BYTE0_20 (RW)
 *
 * Mapping pointer #20 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_20      0
#define BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_20      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_20(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_20)
#else
#define BF_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_20(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_20 field to a new value.
#define BW_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_20(v)   BF_CS1(IPU_DC_MAP_CONF_10, MAPPING_PNTR_BYTE0_20, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_10, field MAPPING_PNTR_BYTE1_20 (RW)
 *
 * Mapping pointer #20 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_20      5
#define BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_20      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_20(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_20)
#else
#define BF_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_20(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_20 field to a new value.
#define BW_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_20(v)   BF_CS1(IPU_DC_MAP_CONF_10, MAPPING_PNTR_BYTE1_20, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_10, field MAPPING_PNTR_BYTE2_20 (RW)
 *
 * Mapping pointer #20 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_20      10
#define BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_20      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_20(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_20)
#else
#define BF_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_20(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_20 field to a new value.
#define BW_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_20(v)   BF_CS1(IPU_DC_MAP_CONF_10, MAPPING_PNTR_BYTE2_20, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_10, field MAPPING_PNTR_BYTE0_21 (RW)
 *
 * Mapping pointer #21 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_21      16
#define BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_21      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_21(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_21)
#else
#define BF_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_21(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_21 field to a new value.
#define BW_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE0_21(v)   BF_CS1(IPU_DC_MAP_CONF_10, MAPPING_PNTR_BYTE0_21, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_10, field MAPPING_PNTR_BYTE1_21 (RW)
 *
 * Mapping pointer #21 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_21      21
#define BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_21      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_21(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_21)
#else
#define BF_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_21(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_21 field to a new value.
#define BW_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE1_21(v)   BF_CS1(IPU_DC_MAP_CONF_10, MAPPING_PNTR_BYTE1_21, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_10, field MAPPING_PNTR_BYTE2_21 (RW)
 *
 * Mapping pointer #21 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_21      26
#define BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_21      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_21(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_21)
#else
#define BF_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_21(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_21 field to a new value.
#define BW_IPU_DC_MAP_CONF_10_MAPPING_PNTR_BYTE2_21(v)   BF_CS1(IPU_DC_MAP_CONF_10, MAPPING_PNTR_BYTE2_21, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_11 - DC Mapping Configuration Register 11 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_22 : 5; //!< Mapping pointer #22 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_22 : 5; //!< Mapping pointer #22 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_22 : 5; //!< Mapping pointer #22 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_23 : 5; //!< Mapping pointer #23 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_23 : 5; //!< Mapping pointer #23 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_23 : 5; //!< Mapping pointer #23 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_11_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_11 register
 */
#define HW_IPU_DC_MAP_CONF_11_ADDR(x)      (REGS_IPU_BASE(x) + 0x58134)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_11(x)           (*(volatile hw_ipu_dc_map_conf_11_t *) HW_IPU_DC_MAP_CONF_11_ADDR(x))
#define HW_IPU_DC_MAP_CONF_11_RD(x)        (HW_IPU_DC_MAP_CONF_11(x).U)
#define HW_IPU_DC_MAP_CONF_11_WR(x, v)     (HW_IPU_DC_MAP_CONF_11(x).U = (v))
#define HW_IPU_DC_MAP_CONF_11_SET(x, v)    (HW_IPU_DC_MAP_CONF_11_WR(x, HW_IPU_DC_MAP_CONF_11_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_11_CLR(x, v)    (HW_IPU_DC_MAP_CONF_11_WR(x, HW_IPU_DC_MAP_CONF_11_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_11_TOG(x, v)    (HW_IPU_DC_MAP_CONF_11_WR(x, HW_IPU_DC_MAP_CONF_11_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_11 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_11, field MAPPING_PNTR_BYTE0_22 (RW)
 *
 * Mapping pointer #22 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_22      0
#define BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_22      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_22(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_22)
#else
#define BF_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_22(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_22 field to a new value.
#define BW_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_22(v)   BF_CS1(IPU_DC_MAP_CONF_11, MAPPING_PNTR_BYTE0_22, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_11, field MAPPING_PNTR_BYTE1_22 (RW)
 *
 * Mapping pointer #22 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_22      5
#define BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_22      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_22(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_22)
#else
#define BF_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_22(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_22 field to a new value.
#define BW_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_22(v)   BF_CS1(IPU_DC_MAP_CONF_11, MAPPING_PNTR_BYTE1_22, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_11, field MAPPING_PNTR_BYTE2_22 (RW)
 *
 * Mapping pointer #22 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_22      10
#define BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_22      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_22(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_22)
#else
#define BF_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_22(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_22 field to a new value.
#define BW_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_22(v)   BF_CS1(IPU_DC_MAP_CONF_11, MAPPING_PNTR_BYTE2_22, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_11, field MAPPING_PNTR_BYTE0_23 (RW)
 *
 * Mapping pointer #23 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_23      16
#define BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_23      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_23(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_23)
#else
#define BF_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_23(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_23 field to a new value.
#define BW_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE0_23(v)   BF_CS1(IPU_DC_MAP_CONF_11, MAPPING_PNTR_BYTE0_23, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_11, field MAPPING_PNTR_BYTE1_23 (RW)
 *
 * Mapping pointer #23 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_23      21
#define BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_23      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_23(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_23)
#else
#define BF_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_23(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_23 field to a new value.
#define BW_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE1_23(v)   BF_CS1(IPU_DC_MAP_CONF_11, MAPPING_PNTR_BYTE1_23, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_11, field MAPPING_PNTR_BYTE2_23 (RW)
 *
 * Mapping pointer #23 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_23      26
#define BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_23      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_23(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_23)
#else
#define BF_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_23(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_23 field to a new value.
#define BW_IPU_DC_MAP_CONF_11_MAPPING_PNTR_BYTE2_23(v)   BF_CS1(IPU_DC_MAP_CONF_11, MAPPING_PNTR_BYTE2_23, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_12 - DC Mapping Configuration Register 12 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_24 : 5; //!< Mapping pointer #24 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_24 : 5; //!< Mapping pointer #24 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_24 : 5; //!< Mapping pointer #24 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_25 : 5; //!< Mapping pointer #25 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_25 : 5; //!< Mapping pointer #25 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_25 : 5; //!< Mapping pointer #25 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_12_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_12 register
 */
#define HW_IPU_DC_MAP_CONF_12_ADDR(x)      (REGS_IPU_BASE(x) + 0x58138)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_12(x)           (*(volatile hw_ipu_dc_map_conf_12_t *) HW_IPU_DC_MAP_CONF_12_ADDR(x))
#define HW_IPU_DC_MAP_CONF_12_RD(x)        (HW_IPU_DC_MAP_CONF_12(x).U)
#define HW_IPU_DC_MAP_CONF_12_WR(x, v)     (HW_IPU_DC_MAP_CONF_12(x).U = (v))
#define HW_IPU_DC_MAP_CONF_12_SET(x, v)    (HW_IPU_DC_MAP_CONF_12_WR(x, HW_IPU_DC_MAP_CONF_12_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_12_CLR(x, v)    (HW_IPU_DC_MAP_CONF_12_WR(x, HW_IPU_DC_MAP_CONF_12_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_12_TOG(x, v)    (HW_IPU_DC_MAP_CONF_12_WR(x, HW_IPU_DC_MAP_CONF_12_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_12 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_12, field MAPPING_PNTR_BYTE0_24 (RW)
 *
 * Mapping pointer #24 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_24      0
#define BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_24      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_24(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_24)
#else
#define BF_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_24(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_24 field to a new value.
#define BW_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_24(v)   BF_CS1(IPU_DC_MAP_CONF_12, MAPPING_PNTR_BYTE0_24, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_12, field MAPPING_PNTR_BYTE1_24 (RW)
 *
 * Mapping pointer #24 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_24      5
#define BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_24      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_24(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_24)
#else
#define BF_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_24(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_24 field to a new value.
#define BW_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_24(v)   BF_CS1(IPU_DC_MAP_CONF_12, MAPPING_PNTR_BYTE1_24, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_12, field MAPPING_PNTR_BYTE2_24 (RW)
 *
 * Mapping pointer #24 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_24      10
#define BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_24      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_24(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_24)
#else
#define BF_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_24(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_24)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_24 field to a new value.
#define BW_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_24(v)   BF_CS1(IPU_DC_MAP_CONF_12, MAPPING_PNTR_BYTE2_24, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_12, field MAPPING_PNTR_BYTE0_25 (RW)
 *
 * Mapping pointer #25 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_25      16
#define BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_25      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_25(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_25)
#else
#define BF_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_25(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_25 field to a new value.
#define BW_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE0_25(v)   BF_CS1(IPU_DC_MAP_CONF_12, MAPPING_PNTR_BYTE0_25, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_12, field MAPPING_PNTR_BYTE1_25 (RW)
 *
 * Mapping pointer #25 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_25      21
#define BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_25      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_25(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_25)
#else
#define BF_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_25(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_25 field to a new value.
#define BW_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE1_25(v)   BF_CS1(IPU_DC_MAP_CONF_12, MAPPING_PNTR_BYTE1_25, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_12, field MAPPING_PNTR_BYTE2_25 (RW)
 *
 * Mapping pointer #25 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_25      26
#define BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_25      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_25(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_25)
#else
#define BF_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_25(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_25)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_25 field to a new value.
#define BW_IPU_DC_MAP_CONF_12_MAPPING_PNTR_BYTE2_25(v)   BF_CS1(IPU_DC_MAP_CONF_12, MAPPING_PNTR_BYTE2_25, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_13 - DC Mapping Configuration Register 13 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE0_26 : 5; //!< Mapping pointer #26 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_26 : 5; //!< Mapping pointer #26 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_26 : 5; //!< Mapping pointer #26 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_27 : 5; //!< Mapping pointer #27 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_27 : 5; //!< Mapping pointer #27 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_27 : 5; //!< Mapping pointer #27 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_13_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_13 register
 */
#define HW_IPU_DC_MAP_CONF_13_ADDR(x)      (REGS_IPU_BASE(x) + 0x5813c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_13(x)           (*(volatile hw_ipu_dc_map_conf_13_t *) HW_IPU_DC_MAP_CONF_13_ADDR(x))
#define HW_IPU_DC_MAP_CONF_13_RD(x)        (HW_IPU_DC_MAP_CONF_13(x).U)
#define HW_IPU_DC_MAP_CONF_13_WR(x, v)     (HW_IPU_DC_MAP_CONF_13(x).U = (v))
#define HW_IPU_DC_MAP_CONF_13_SET(x, v)    (HW_IPU_DC_MAP_CONF_13_WR(x, HW_IPU_DC_MAP_CONF_13_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_13_CLR(x, v)    (HW_IPU_DC_MAP_CONF_13_WR(x, HW_IPU_DC_MAP_CONF_13_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_13_TOG(x, v)    (HW_IPU_DC_MAP_CONF_13_WR(x, HW_IPU_DC_MAP_CONF_13_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_13 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_13, field MAPPING_PNTR_BYTE0_26 (RW)
 *
 * Mapping pointer #26 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_26      0
#define BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_26      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_26(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_26)
#else
#define BF_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_26(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_26 field to a new value.
#define BW_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_26(v)   BF_CS1(IPU_DC_MAP_CONF_13, MAPPING_PNTR_BYTE0_26, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_13, field MAPPING_PNTR_BYTE1_26 (RW)
 *
 * Mapping pointer #26 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_26      5
#define BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_26      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_26(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_26)
#else
#define BF_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_26(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_26 field to a new value.
#define BW_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_26(v)   BF_CS1(IPU_DC_MAP_CONF_13, MAPPING_PNTR_BYTE1_26, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_13, field MAPPING_PNTR_BYTE2_26 (RW)
 *
 * Mapping pointer #26 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_26      10
#define BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_26      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_26(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_26)
#else
#define BF_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_26(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_26)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_26 field to a new value.
#define BW_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_26(v)   BF_CS1(IPU_DC_MAP_CONF_13, MAPPING_PNTR_BYTE2_26, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_13, field MAPPING_PNTR_BYTE0_27 (RW)
 *
 * Mapping pointer #27 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_27      16
#define BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_27      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_27(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_27)
#else
#define BF_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_27(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_27 field to a new value.
#define BW_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE0_27(v)   BF_CS1(IPU_DC_MAP_CONF_13, MAPPING_PNTR_BYTE0_27, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_13, field MAPPING_PNTR_BYTE1_27 (RW)
 *
 * Mapping pointer #27 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_27      21
#define BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_27      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_27(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_27)
#else
#define BF_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_27(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_27 field to a new value.
#define BW_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE1_27(v)   BF_CS1(IPU_DC_MAP_CONF_13, MAPPING_PNTR_BYTE1_27, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_13, field MAPPING_PNTR_BYTE2_27 (RW)
 *
 * Mapping pointer #27 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_27      26
#define BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_27      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_27(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_27)
#else
#define BF_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_27(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_27)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_27 field to a new value.
#define BW_IPU_DC_MAP_CONF_13_MAPPING_PNTR_BYTE2_27(v)   BF_CS1(IPU_DC_MAP_CONF_13, MAPPING_PNTR_BYTE2_27, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_14 - DC Mapping Configuration Register 14 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MAPPING_PNTR_BYTE2_28 : 5; //!< Mapping pointer #28 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_28 : 5; //!< Mapping pointer #28 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_28F : 5; //!< Mapping pointer #28 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned MAPPING_PNTR_BYTE0_29 : 5; //!< Mapping pointer #29 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #0
        unsigned MAPPING_PNTR_BYTE1_29 : 5; //!< Mapping pointer #29 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #1
        unsigned MAPPING_PNTR_BYTE2_29 : 5; //!< Mapping pointer #29 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and MD_MASK_<i> used for mapping byte #2
        unsigned RESERVED1 : 1; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_14_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_14 register
 */
#define HW_IPU_DC_MAP_CONF_14_ADDR(x)      (REGS_IPU_BASE(x) + 0x58140)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_14(x)           (*(volatile hw_ipu_dc_map_conf_14_t *) HW_IPU_DC_MAP_CONF_14_ADDR(x))
#define HW_IPU_DC_MAP_CONF_14_RD(x)        (HW_IPU_DC_MAP_CONF_14(x).U)
#define HW_IPU_DC_MAP_CONF_14_WR(x, v)     (HW_IPU_DC_MAP_CONF_14(x).U = (v))
#define HW_IPU_DC_MAP_CONF_14_SET(x, v)    (HW_IPU_DC_MAP_CONF_14_WR(x, HW_IPU_DC_MAP_CONF_14_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_14_CLR(x, v)    (HW_IPU_DC_MAP_CONF_14_WR(x, HW_IPU_DC_MAP_CONF_14_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_14_TOG(x, v)    (HW_IPU_DC_MAP_CONF_14_WR(x, HW_IPU_DC_MAP_CONF_14_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_14 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_14, field MAPPING_PNTR_BYTE2_28 (RW)
 *
 * Mapping pointer #28 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28      0
#define BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28      0x0000001f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28)
#else
#define BF_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_28 field to a new value.
#define BW_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28(v)   BF_CS1(IPU_DC_MAP_CONF_14, MAPPING_PNTR_BYTE2_28, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_14, field MAPPING_PNTR_BYTE1_28 (RW)
 *
 * Mapping pointer #28 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_28      5
#define BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_28      0x000003e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_28(v)   ((((reg32_t) v) << 5) & BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_28)
#else
#define BF_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_28(v)   (((v) << 5) & BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_28 field to a new value.
#define BW_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_28(v)   BF_CS1(IPU_DC_MAP_CONF_14, MAPPING_PNTR_BYTE1_28, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_14, field MAPPING_PNTR_BYTE2_28F (RW)
 *
 * Mapping pointer #28 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28F      10
#define BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28F      0x00007c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28F(v)   ((((reg32_t) v) << 10) & BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28F)
#else
#define BF_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28F(v)   (((v) << 10) & BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_28F field to a new value.
#define BW_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_28F(v)   BF_CS1(IPU_DC_MAP_CONF_14, MAPPING_PNTR_BYTE2_28F, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_14, field MAPPING_PNTR_BYTE0_29 (RW)
 *
 * Mapping pointer #29 for Byte 0 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #0
 */

#define BP_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE0_29      16
#define BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE0_29      0x001f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE0_29(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE0_29)
#else
#define BF_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE0_29(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE0_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE0_29 field to a new value.
#define BW_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE0_29(v)   BF_CS1(IPU_DC_MAP_CONF_14, MAPPING_PNTR_BYTE0_29, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_14, field MAPPING_PNTR_BYTE1_29 (RW)
 *
 * Mapping pointer #29 for Byte 1 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #1
 */

#define BP_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_29      21
#define BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_29      0x03e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_29(v)   ((((reg32_t) v) << 21) & BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_29)
#else
#define BF_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_29(v)   (((v) << 21) & BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE1_29 field to a new value.
#define BW_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE1_29(v)   BF_CS1(IPU_DC_MAP_CONF_14, MAPPING_PNTR_BYTE1_29, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_14, field MAPPING_PNTR_BYTE2_29 (RW)
 *
 * Mapping pointer #29 for Byte 2 This field is a pointer to the set of MD_OFFSET_<i> and
 * MD_MASK_<i> used for mapping byte #2
 */

#define BP_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_29      26
#define BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_29      0x7c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_29(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_29)
#else
#define BF_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_29(v)   (((v) << 26) & BM_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_29)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MAPPING_PNTR_BYTE2_29 field to a new value.
#define BW_IPU_DC_MAP_CONF_14_MAPPING_PNTR_BYTE2_29(v)   BF_CS1(IPU_DC_MAP_CONF_14, MAPPING_PNTR_BYTE2_29, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_15 - DC Mapping Configuration Register 15 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MD_MASK_0 : 8; //!< Mapping unit's mask value #0 This field defines the mask value #0 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_0 : 5; //!< Mapping unit's offset parameter #0 This field defines the offset parameter #0 within the 24bit word coming from the DC.
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned MD_MASK_1 : 8; //!< Mapping unit's mask value #1 This field defines the mask value #1 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_1 : 5; //!< Mapping unit's offset parameter #1 This field defines the offset parameter #1 within the 24bit word coming from the DC.
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_15_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_15 register
 */
#define HW_IPU_DC_MAP_CONF_15_ADDR(x)      (REGS_IPU_BASE(x) + 0x58144)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_15(x)           (*(volatile hw_ipu_dc_map_conf_15_t *) HW_IPU_DC_MAP_CONF_15_ADDR(x))
#define HW_IPU_DC_MAP_CONF_15_RD(x)        (HW_IPU_DC_MAP_CONF_15(x).U)
#define HW_IPU_DC_MAP_CONF_15_WR(x, v)     (HW_IPU_DC_MAP_CONF_15(x).U = (v))
#define HW_IPU_DC_MAP_CONF_15_SET(x, v)    (HW_IPU_DC_MAP_CONF_15_WR(x, HW_IPU_DC_MAP_CONF_15_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_15_CLR(x, v)    (HW_IPU_DC_MAP_CONF_15_WR(x, HW_IPU_DC_MAP_CONF_15_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_15_TOG(x, v)    (HW_IPU_DC_MAP_CONF_15_WR(x, HW_IPU_DC_MAP_CONF_15_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_15 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_15, field MD_MASK_0 (RW)
 *
 * Mapping unit's mask value #0 This field defines the mask value #0 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_15_MD_MASK_0      0
#define BM_IPU_DC_MAP_CONF_15_MD_MASK_0      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_15_MD_MASK_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_15_MD_MASK_0)
#else
#define BF_IPU_DC_MAP_CONF_15_MD_MASK_0(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_15_MD_MASK_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_0 field to a new value.
#define BW_IPU_DC_MAP_CONF_15_MD_MASK_0(v)   BF_CS1(IPU_DC_MAP_CONF_15, MD_MASK_0, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_15, field MD_OFFSET_0 (RW)
 *
 * Mapping unit's offset parameter #0 This field defines the offset parameter #0 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_15_MD_OFFSET_0      8
#define BM_IPU_DC_MAP_CONF_15_MD_OFFSET_0      0x00001f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_15_MD_OFFSET_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_MAP_CONF_15_MD_OFFSET_0)
#else
#define BF_IPU_DC_MAP_CONF_15_MD_OFFSET_0(v)   (((v) << 8) & BM_IPU_DC_MAP_CONF_15_MD_OFFSET_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_0 field to a new value.
#define BW_IPU_DC_MAP_CONF_15_MD_OFFSET_0(v)   BF_CS1(IPU_DC_MAP_CONF_15, MD_OFFSET_0, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_15, field MD_MASK_1 (RW)
 *
 * Mapping unit's mask value #1 This field defines the mask value #1 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_15_MD_MASK_1      16
#define BM_IPU_DC_MAP_CONF_15_MD_MASK_1      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_15_MD_MASK_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_15_MD_MASK_1)
#else
#define BF_IPU_DC_MAP_CONF_15_MD_MASK_1(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_15_MD_MASK_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_1 field to a new value.
#define BW_IPU_DC_MAP_CONF_15_MD_MASK_1(v)   BF_CS1(IPU_DC_MAP_CONF_15, MD_MASK_1, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_15, field MD_OFFSET_1 (RW)
 *
 * Mapping unit's offset parameter #1 This field defines the offset parameter #1 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_15_MD_OFFSET_1      24
#define BM_IPU_DC_MAP_CONF_15_MD_OFFSET_1      0x1f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_15_MD_OFFSET_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_MAP_CONF_15_MD_OFFSET_1)
#else
#define BF_IPU_DC_MAP_CONF_15_MD_OFFSET_1(v)   (((v) << 24) & BM_IPU_DC_MAP_CONF_15_MD_OFFSET_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_1 field to a new value.
#define BW_IPU_DC_MAP_CONF_15_MD_OFFSET_1(v)   BF_CS1(IPU_DC_MAP_CONF_15, MD_OFFSET_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_16 - DC Mapping Configuration Register 16 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MD_MASK_0 : 8; //!< Mapping unit's mask value #2 This field defines the mask value #2 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_2 : 5; //!< Mapping unit's offset parameter #2 This field defines the offset parameter #2 within the 24bit word coming from the DC.
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned MD_MASK_3 : 8; //!< Mapping unit's mask value #3 This field defines the mask value #3 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_3 : 5; //!< Mapping unit's offset parameter #3 This field defines the offset parameter #3 within the 24bit word coming from the DC.
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_16_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_16 register
 */
#define HW_IPU_DC_MAP_CONF_16_ADDR(x)      (REGS_IPU_BASE(x) + 0x58148)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_16(x)           (*(volatile hw_ipu_dc_map_conf_16_t *) HW_IPU_DC_MAP_CONF_16_ADDR(x))
#define HW_IPU_DC_MAP_CONF_16_RD(x)        (HW_IPU_DC_MAP_CONF_16(x).U)
#define HW_IPU_DC_MAP_CONF_16_WR(x, v)     (HW_IPU_DC_MAP_CONF_16(x).U = (v))
#define HW_IPU_DC_MAP_CONF_16_SET(x, v)    (HW_IPU_DC_MAP_CONF_16_WR(x, HW_IPU_DC_MAP_CONF_16_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_16_CLR(x, v)    (HW_IPU_DC_MAP_CONF_16_WR(x, HW_IPU_DC_MAP_CONF_16_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_16_TOG(x, v)    (HW_IPU_DC_MAP_CONF_16_WR(x, HW_IPU_DC_MAP_CONF_16_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_16 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_16, field MD_MASK_0 (RW)
 *
 * Mapping unit's mask value #2 This field defines the mask value #2 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_16_MD_MASK_0      0
#define BM_IPU_DC_MAP_CONF_16_MD_MASK_0      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_16_MD_MASK_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_16_MD_MASK_0)
#else
#define BF_IPU_DC_MAP_CONF_16_MD_MASK_0(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_16_MD_MASK_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_0 field to a new value.
#define BW_IPU_DC_MAP_CONF_16_MD_MASK_0(v)   BF_CS1(IPU_DC_MAP_CONF_16, MD_MASK_0, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_16, field MD_OFFSET_2 (RW)
 *
 * Mapping unit's offset parameter #2 This field defines the offset parameter #2 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_16_MD_OFFSET_2      8
#define BM_IPU_DC_MAP_CONF_16_MD_OFFSET_2      0x00001f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_16_MD_OFFSET_2(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_MAP_CONF_16_MD_OFFSET_2)
#else
#define BF_IPU_DC_MAP_CONF_16_MD_OFFSET_2(v)   (((v) << 8) & BM_IPU_DC_MAP_CONF_16_MD_OFFSET_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_2 field to a new value.
#define BW_IPU_DC_MAP_CONF_16_MD_OFFSET_2(v)   BF_CS1(IPU_DC_MAP_CONF_16, MD_OFFSET_2, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_16, field MD_MASK_3 (RW)
 *
 * Mapping unit's mask value #3 This field defines the mask value #3 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_16_MD_MASK_3      16
#define BM_IPU_DC_MAP_CONF_16_MD_MASK_3      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_16_MD_MASK_3(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_16_MD_MASK_3)
#else
#define BF_IPU_DC_MAP_CONF_16_MD_MASK_3(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_16_MD_MASK_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_3 field to a new value.
#define BW_IPU_DC_MAP_CONF_16_MD_MASK_3(v)   BF_CS1(IPU_DC_MAP_CONF_16, MD_MASK_3, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_16, field MD_OFFSET_3 (RW)
 *
 * Mapping unit's offset parameter #3 This field defines the offset parameter #3 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_16_MD_OFFSET_3      24
#define BM_IPU_DC_MAP_CONF_16_MD_OFFSET_3      0x1f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_16_MD_OFFSET_3(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_MAP_CONF_16_MD_OFFSET_3)
#else
#define BF_IPU_DC_MAP_CONF_16_MD_OFFSET_3(v)   (((v) << 24) & BM_IPU_DC_MAP_CONF_16_MD_OFFSET_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_3 field to a new value.
#define BW_IPU_DC_MAP_CONF_16_MD_OFFSET_3(v)   BF_CS1(IPU_DC_MAP_CONF_16, MD_OFFSET_3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_17 - DC Mapping Configuration Register 17 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MD_MASK_4 : 8; //!< Mapping unit's mask value #4 This field defines the mask value #4 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_4 : 5; //!< Mapping unit's offset parameter #4 This field defines the offset parameter #4 within the 24bit word coming from the DC.
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned MD_MASK_5 : 8; //!< Mapping unit's mask value #5 This field defines the mask value #5 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_5 : 5; //!< Mapping unit's offset parameter #5 This field defines the offset parameter #5 within the 24bit word coming from the DC.
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_17_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_17 register
 */
#define HW_IPU_DC_MAP_CONF_17_ADDR(x)      (REGS_IPU_BASE(x) + 0x5814c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_17(x)           (*(volatile hw_ipu_dc_map_conf_17_t *) HW_IPU_DC_MAP_CONF_17_ADDR(x))
#define HW_IPU_DC_MAP_CONF_17_RD(x)        (HW_IPU_DC_MAP_CONF_17(x).U)
#define HW_IPU_DC_MAP_CONF_17_WR(x, v)     (HW_IPU_DC_MAP_CONF_17(x).U = (v))
#define HW_IPU_DC_MAP_CONF_17_SET(x, v)    (HW_IPU_DC_MAP_CONF_17_WR(x, HW_IPU_DC_MAP_CONF_17_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_17_CLR(x, v)    (HW_IPU_DC_MAP_CONF_17_WR(x, HW_IPU_DC_MAP_CONF_17_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_17_TOG(x, v)    (HW_IPU_DC_MAP_CONF_17_WR(x, HW_IPU_DC_MAP_CONF_17_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_17 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_17, field MD_MASK_4 (RW)
 *
 * Mapping unit's mask value #4 This field defines the mask value #4 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_17_MD_MASK_4      0
#define BM_IPU_DC_MAP_CONF_17_MD_MASK_4      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_17_MD_MASK_4(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_17_MD_MASK_4)
#else
#define BF_IPU_DC_MAP_CONF_17_MD_MASK_4(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_17_MD_MASK_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_4 field to a new value.
#define BW_IPU_DC_MAP_CONF_17_MD_MASK_4(v)   BF_CS1(IPU_DC_MAP_CONF_17, MD_MASK_4, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_17, field MD_OFFSET_4 (RW)
 *
 * Mapping unit's offset parameter #4 This field defines the offset parameter #4 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_17_MD_OFFSET_4      8
#define BM_IPU_DC_MAP_CONF_17_MD_OFFSET_4      0x00001f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_17_MD_OFFSET_4(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_MAP_CONF_17_MD_OFFSET_4)
#else
#define BF_IPU_DC_MAP_CONF_17_MD_OFFSET_4(v)   (((v) << 8) & BM_IPU_DC_MAP_CONF_17_MD_OFFSET_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_4 field to a new value.
#define BW_IPU_DC_MAP_CONF_17_MD_OFFSET_4(v)   BF_CS1(IPU_DC_MAP_CONF_17, MD_OFFSET_4, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_17, field MD_MASK_5 (RW)
 *
 * Mapping unit's mask value #5 This field defines the mask value #5 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_17_MD_MASK_5      16
#define BM_IPU_DC_MAP_CONF_17_MD_MASK_5      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_17_MD_MASK_5(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_17_MD_MASK_5)
#else
#define BF_IPU_DC_MAP_CONF_17_MD_MASK_5(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_17_MD_MASK_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_5 field to a new value.
#define BW_IPU_DC_MAP_CONF_17_MD_MASK_5(v)   BF_CS1(IPU_DC_MAP_CONF_17, MD_MASK_5, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_17, field MD_OFFSET_5 (RW)
 *
 * Mapping unit's offset parameter #5 This field defines the offset parameter #5 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_17_MD_OFFSET_5      24
#define BM_IPU_DC_MAP_CONF_17_MD_OFFSET_5      0x1f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_17_MD_OFFSET_5(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_MAP_CONF_17_MD_OFFSET_5)
#else
#define BF_IPU_DC_MAP_CONF_17_MD_OFFSET_5(v)   (((v) << 24) & BM_IPU_DC_MAP_CONF_17_MD_OFFSET_5)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_5 field to a new value.
#define BW_IPU_DC_MAP_CONF_17_MD_OFFSET_5(v)   BF_CS1(IPU_DC_MAP_CONF_17, MD_OFFSET_5, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_18 - DC Mapping Configuration Register 18 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MD_MASK_6 : 8; //!< Mapping unit's mask value #6 This field defines the mask value #6 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_6 : 5; //!< Mapping unit's offset parameter #6 This field defines the offset parameter #6 within the 24bit word coming from the DC.
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned MD_MASK_7 : 8; //!< Mapping unit's mask value #7 This field defines the mask value #7 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_7 : 5; //!< Mapping unit's offset parameter #7 This field defines the offset parameter #7 within the 24bit word coming from the DC.
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_18_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_18 register
 */
#define HW_IPU_DC_MAP_CONF_18_ADDR(x)      (REGS_IPU_BASE(x) + 0x58150)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_18(x)           (*(volatile hw_ipu_dc_map_conf_18_t *) HW_IPU_DC_MAP_CONF_18_ADDR(x))
#define HW_IPU_DC_MAP_CONF_18_RD(x)        (HW_IPU_DC_MAP_CONF_18(x).U)
#define HW_IPU_DC_MAP_CONF_18_WR(x, v)     (HW_IPU_DC_MAP_CONF_18(x).U = (v))
#define HW_IPU_DC_MAP_CONF_18_SET(x, v)    (HW_IPU_DC_MAP_CONF_18_WR(x, HW_IPU_DC_MAP_CONF_18_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_18_CLR(x, v)    (HW_IPU_DC_MAP_CONF_18_WR(x, HW_IPU_DC_MAP_CONF_18_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_18_TOG(x, v)    (HW_IPU_DC_MAP_CONF_18_WR(x, HW_IPU_DC_MAP_CONF_18_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_18 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_18, field MD_MASK_6 (RW)
 *
 * Mapping unit's mask value #6 This field defines the mask value #6 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_18_MD_MASK_6      0
#define BM_IPU_DC_MAP_CONF_18_MD_MASK_6      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_18_MD_MASK_6(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_18_MD_MASK_6)
#else
#define BF_IPU_DC_MAP_CONF_18_MD_MASK_6(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_18_MD_MASK_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_6 field to a new value.
#define BW_IPU_DC_MAP_CONF_18_MD_MASK_6(v)   BF_CS1(IPU_DC_MAP_CONF_18, MD_MASK_6, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_18, field MD_OFFSET_6 (RW)
 *
 * Mapping unit's offset parameter #6 This field defines the offset parameter #6 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_18_MD_OFFSET_6      8
#define BM_IPU_DC_MAP_CONF_18_MD_OFFSET_6      0x00001f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_18_MD_OFFSET_6(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_MAP_CONF_18_MD_OFFSET_6)
#else
#define BF_IPU_DC_MAP_CONF_18_MD_OFFSET_6(v)   (((v) << 8) & BM_IPU_DC_MAP_CONF_18_MD_OFFSET_6)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_6 field to a new value.
#define BW_IPU_DC_MAP_CONF_18_MD_OFFSET_6(v)   BF_CS1(IPU_DC_MAP_CONF_18, MD_OFFSET_6, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_18, field MD_MASK_7 (RW)
 *
 * Mapping unit's mask value #7 This field defines the mask value #7 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_18_MD_MASK_7      16
#define BM_IPU_DC_MAP_CONF_18_MD_MASK_7      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_18_MD_MASK_7(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_18_MD_MASK_7)
#else
#define BF_IPU_DC_MAP_CONF_18_MD_MASK_7(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_18_MD_MASK_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_7 field to a new value.
#define BW_IPU_DC_MAP_CONF_18_MD_MASK_7(v)   BF_CS1(IPU_DC_MAP_CONF_18, MD_MASK_7, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_18, field MD_OFFSET_7 (RW)
 *
 * Mapping unit's offset parameter #7 This field defines the offset parameter #7 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_18_MD_OFFSET_7      24
#define BM_IPU_DC_MAP_CONF_18_MD_OFFSET_7      0x1f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_18_MD_OFFSET_7(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_MAP_CONF_18_MD_OFFSET_7)
#else
#define BF_IPU_DC_MAP_CONF_18_MD_OFFSET_7(v)   (((v) << 24) & BM_IPU_DC_MAP_CONF_18_MD_OFFSET_7)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_7 field to a new value.
#define BW_IPU_DC_MAP_CONF_18_MD_OFFSET_7(v)   BF_CS1(IPU_DC_MAP_CONF_18, MD_OFFSET_7, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_19 - DC Mapping Configuration Register 19 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MD_MASK_8 : 8; //!< Mapping unit's mask value #8 This field defines the mask value #8 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_8 : 5; //!< Mapping unit's offset parameter #8 This field defines the offset parameter #8 within the 24bit word coming from the DC.
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned MD_MASK_9 : 8; //!< Mapping unit's mask value #9 This field defines the mask value #9 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_9 : 5; //!< Mapping unit's offset parameter #9 This field defines the offset parameter #9 within the 24bit word coming from the DC.
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_19_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_19 register
 */
#define HW_IPU_DC_MAP_CONF_19_ADDR(x)      (REGS_IPU_BASE(x) + 0x58154)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_19(x)           (*(volatile hw_ipu_dc_map_conf_19_t *) HW_IPU_DC_MAP_CONF_19_ADDR(x))
#define HW_IPU_DC_MAP_CONF_19_RD(x)        (HW_IPU_DC_MAP_CONF_19(x).U)
#define HW_IPU_DC_MAP_CONF_19_WR(x, v)     (HW_IPU_DC_MAP_CONF_19(x).U = (v))
#define HW_IPU_DC_MAP_CONF_19_SET(x, v)    (HW_IPU_DC_MAP_CONF_19_WR(x, HW_IPU_DC_MAP_CONF_19_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_19_CLR(x, v)    (HW_IPU_DC_MAP_CONF_19_WR(x, HW_IPU_DC_MAP_CONF_19_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_19_TOG(x, v)    (HW_IPU_DC_MAP_CONF_19_WR(x, HW_IPU_DC_MAP_CONF_19_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_19 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_19, field MD_MASK_8 (RW)
 *
 * Mapping unit's mask value #8 This field defines the mask value #8 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_19_MD_MASK_8      0
#define BM_IPU_DC_MAP_CONF_19_MD_MASK_8      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_19_MD_MASK_8(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_19_MD_MASK_8)
#else
#define BF_IPU_DC_MAP_CONF_19_MD_MASK_8(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_19_MD_MASK_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_8 field to a new value.
#define BW_IPU_DC_MAP_CONF_19_MD_MASK_8(v)   BF_CS1(IPU_DC_MAP_CONF_19, MD_MASK_8, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_19, field MD_OFFSET_8 (RW)
 *
 * Mapping unit's offset parameter #8 This field defines the offset parameter #8 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_19_MD_OFFSET_8      8
#define BM_IPU_DC_MAP_CONF_19_MD_OFFSET_8      0x00001f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_19_MD_OFFSET_8(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_MAP_CONF_19_MD_OFFSET_8)
#else
#define BF_IPU_DC_MAP_CONF_19_MD_OFFSET_8(v)   (((v) << 8) & BM_IPU_DC_MAP_CONF_19_MD_OFFSET_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_8 field to a new value.
#define BW_IPU_DC_MAP_CONF_19_MD_OFFSET_8(v)   BF_CS1(IPU_DC_MAP_CONF_19, MD_OFFSET_8, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_19, field MD_MASK_9 (RW)
 *
 * Mapping unit's mask value #9 This field defines the mask value #9 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_19_MD_MASK_9      16
#define BM_IPU_DC_MAP_CONF_19_MD_MASK_9      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_19_MD_MASK_9(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_19_MD_MASK_9)
#else
#define BF_IPU_DC_MAP_CONF_19_MD_MASK_9(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_19_MD_MASK_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_9 field to a new value.
#define BW_IPU_DC_MAP_CONF_19_MD_MASK_9(v)   BF_CS1(IPU_DC_MAP_CONF_19, MD_MASK_9, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_19, field MD_OFFSET_9 (RW)
 *
 * Mapping unit's offset parameter #9 This field defines the offset parameter #9 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_19_MD_OFFSET_9      24
#define BM_IPU_DC_MAP_CONF_19_MD_OFFSET_9      0x1f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_19_MD_OFFSET_9(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_MAP_CONF_19_MD_OFFSET_9)
#else
#define BF_IPU_DC_MAP_CONF_19_MD_OFFSET_9(v)   (((v) << 24) & BM_IPU_DC_MAP_CONF_19_MD_OFFSET_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_9 field to a new value.
#define BW_IPU_DC_MAP_CONF_19_MD_OFFSET_9(v)   BF_CS1(IPU_DC_MAP_CONF_19, MD_OFFSET_9, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_20 - DC Mapping Configuration Register 20 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MD_MASK_10 : 8; //!< Mapping unit's mask value #10 This field defines the mask value #10 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_10 : 5; //!< Mapping unit's offset parameter #10 This field defines the offset parameter #10 within the 24bit word coming from the DC.
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned MD_MASK_11 : 8; //!< Mapping unit's mask value #11 This field defines the mask value #11 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_11 : 5; //!< Mapping unit's offset parameter #11 This field defines the offset parameter #11 within the 24bit word coming from the DC.
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_20_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_20 register
 */
#define HW_IPU_DC_MAP_CONF_20_ADDR(x)      (REGS_IPU_BASE(x) + 0x58158)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_20(x)           (*(volatile hw_ipu_dc_map_conf_20_t *) HW_IPU_DC_MAP_CONF_20_ADDR(x))
#define HW_IPU_DC_MAP_CONF_20_RD(x)        (HW_IPU_DC_MAP_CONF_20(x).U)
#define HW_IPU_DC_MAP_CONF_20_WR(x, v)     (HW_IPU_DC_MAP_CONF_20(x).U = (v))
#define HW_IPU_DC_MAP_CONF_20_SET(x, v)    (HW_IPU_DC_MAP_CONF_20_WR(x, HW_IPU_DC_MAP_CONF_20_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_20_CLR(x, v)    (HW_IPU_DC_MAP_CONF_20_WR(x, HW_IPU_DC_MAP_CONF_20_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_20_TOG(x, v)    (HW_IPU_DC_MAP_CONF_20_WR(x, HW_IPU_DC_MAP_CONF_20_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_20 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_20, field MD_MASK_10 (RW)
 *
 * Mapping unit's mask value #10 This field defines the mask value #10 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_20_MD_MASK_10      0
#define BM_IPU_DC_MAP_CONF_20_MD_MASK_10      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_20_MD_MASK_10(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_20_MD_MASK_10)
#else
#define BF_IPU_DC_MAP_CONF_20_MD_MASK_10(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_20_MD_MASK_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_10 field to a new value.
#define BW_IPU_DC_MAP_CONF_20_MD_MASK_10(v)   BF_CS1(IPU_DC_MAP_CONF_20, MD_MASK_10, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_20, field MD_OFFSET_10 (RW)
 *
 * Mapping unit's offset parameter #10 This field defines the offset parameter #10 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_20_MD_OFFSET_10      8
#define BM_IPU_DC_MAP_CONF_20_MD_OFFSET_10      0x00001f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_20_MD_OFFSET_10(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_MAP_CONF_20_MD_OFFSET_10)
#else
#define BF_IPU_DC_MAP_CONF_20_MD_OFFSET_10(v)   (((v) << 8) & BM_IPU_DC_MAP_CONF_20_MD_OFFSET_10)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_10 field to a new value.
#define BW_IPU_DC_MAP_CONF_20_MD_OFFSET_10(v)   BF_CS1(IPU_DC_MAP_CONF_20, MD_OFFSET_10, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_20, field MD_MASK_11 (RW)
 *
 * Mapping unit's mask value #11 This field defines the mask value #11 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_20_MD_MASK_11      16
#define BM_IPU_DC_MAP_CONF_20_MD_MASK_11      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_20_MD_MASK_11(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_20_MD_MASK_11)
#else
#define BF_IPU_DC_MAP_CONF_20_MD_MASK_11(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_20_MD_MASK_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_11 field to a new value.
#define BW_IPU_DC_MAP_CONF_20_MD_MASK_11(v)   BF_CS1(IPU_DC_MAP_CONF_20, MD_MASK_11, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_20, field MD_OFFSET_11 (RW)
 *
 * Mapping unit's offset parameter #11 This field defines the offset parameter #11 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_20_MD_OFFSET_11      24
#define BM_IPU_DC_MAP_CONF_20_MD_OFFSET_11      0x1f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_20_MD_OFFSET_11(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_MAP_CONF_20_MD_OFFSET_11)
#else
#define BF_IPU_DC_MAP_CONF_20_MD_OFFSET_11(v)   (((v) << 24) & BM_IPU_DC_MAP_CONF_20_MD_OFFSET_11)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_11 field to a new value.
#define BW_IPU_DC_MAP_CONF_20_MD_OFFSET_11(v)   BF_CS1(IPU_DC_MAP_CONF_20, MD_OFFSET_11, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_21 - DC Mapping Configuration Register 21 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MD_MASK_12 : 8; //!< Mapping unit's mask value #12 This field defines the mask value #12 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_12 : 5; //!< Mapping unit's offset parameter #12 This field defines the offset parameter #12 within the 24bit word coming from the DC.
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned MD_MASK_13 : 8; //!< Mapping unit's mask value #13 This field defines the mask value #13 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_13 : 5; //!< Mapping unit's offset parameter #13 This field defines the offset parameter #13 within the 24bit word coming from the DC.
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_21_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_21 register
 */
#define HW_IPU_DC_MAP_CONF_21_ADDR(x)      (REGS_IPU_BASE(x) + 0x5815c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_21(x)           (*(volatile hw_ipu_dc_map_conf_21_t *) HW_IPU_DC_MAP_CONF_21_ADDR(x))
#define HW_IPU_DC_MAP_CONF_21_RD(x)        (HW_IPU_DC_MAP_CONF_21(x).U)
#define HW_IPU_DC_MAP_CONF_21_WR(x, v)     (HW_IPU_DC_MAP_CONF_21(x).U = (v))
#define HW_IPU_DC_MAP_CONF_21_SET(x, v)    (HW_IPU_DC_MAP_CONF_21_WR(x, HW_IPU_DC_MAP_CONF_21_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_21_CLR(x, v)    (HW_IPU_DC_MAP_CONF_21_WR(x, HW_IPU_DC_MAP_CONF_21_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_21_TOG(x, v)    (HW_IPU_DC_MAP_CONF_21_WR(x, HW_IPU_DC_MAP_CONF_21_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_21 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_21, field MD_MASK_12 (RW)
 *
 * Mapping unit's mask value #12 This field defines the mask value #12 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_21_MD_MASK_12      0
#define BM_IPU_DC_MAP_CONF_21_MD_MASK_12      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_21_MD_MASK_12(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_21_MD_MASK_12)
#else
#define BF_IPU_DC_MAP_CONF_21_MD_MASK_12(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_21_MD_MASK_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_12 field to a new value.
#define BW_IPU_DC_MAP_CONF_21_MD_MASK_12(v)   BF_CS1(IPU_DC_MAP_CONF_21, MD_MASK_12, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_21, field MD_OFFSET_12 (RW)
 *
 * Mapping unit's offset parameter #12 This field defines the offset parameter #12 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_21_MD_OFFSET_12      8
#define BM_IPU_DC_MAP_CONF_21_MD_OFFSET_12      0x00001f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_21_MD_OFFSET_12(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_MAP_CONF_21_MD_OFFSET_12)
#else
#define BF_IPU_DC_MAP_CONF_21_MD_OFFSET_12(v)   (((v) << 8) & BM_IPU_DC_MAP_CONF_21_MD_OFFSET_12)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_12 field to a new value.
#define BW_IPU_DC_MAP_CONF_21_MD_OFFSET_12(v)   BF_CS1(IPU_DC_MAP_CONF_21, MD_OFFSET_12, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_21, field MD_MASK_13 (RW)
 *
 * Mapping unit's mask value #13 This field defines the mask value #13 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_21_MD_MASK_13      16
#define BM_IPU_DC_MAP_CONF_21_MD_MASK_13      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_21_MD_MASK_13(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_21_MD_MASK_13)
#else
#define BF_IPU_DC_MAP_CONF_21_MD_MASK_13(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_21_MD_MASK_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_13 field to a new value.
#define BW_IPU_DC_MAP_CONF_21_MD_MASK_13(v)   BF_CS1(IPU_DC_MAP_CONF_21, MD_MASK_13, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_21, field MD_OFFSET_13 (RW)
 *
 * Mapping unit's offset parameter #13 This field defines the offset parameter #13 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_21_MD_OFFSET_13      24
#define BM_IPU_DC_MAP_CONF_21_MD_OFFSET_13      0x1f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_21_MD_OFFSET_13(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_MAP_CONF_21_MD_OFFSET_13)
#else
#define BF_IPU_DC_MAP_CONF_21_MD_OFFSET_13(v)   (((v) << 24) & BM_IPU_DC_MAP_CONF_21_MD_OFFSET_13)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_13 field to a new value.
#define BW_IPU_DC_MAP_CONF_21_MD_OFFSET_13(v)   BF_CS1(IPU_DC_MAP_CONF_21, MD_OFFSET_13, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_22 - DC Mapping Configuration Register 22 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MD_MASK_14 : 8; //!< Mapping unit's mask value #14 This field defines the mask value #14 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_14 : 5; //!< Mapping unit's offset parameter #14 This field defines the offset parameter #14 within the 24bit word coming from the DC.
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned MD_MASK_15 : 8; //!< Mapping unit's mask value #15 This field defines the mask value #15 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_15 : 5; //!< Mapping unit's offset parameter #15 This field defines the offset parameter #15 within the 24bit word coming from the DC.
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_22_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_22 register
 */
#define HW_IPU_DC_MAP_CONF_22_ADDR(x)      (REGS_IPU_BASE(x) + 0x58160)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_22(x)           (*(volatile hw_ipu_dc_map_conf_22_t *) HW_IPU_DC_MAP_CONF_22_ADDR(x))
#define HW_IPU_DC_MAP_CONF_22_RD(x)        (HW_IPU_DC_MAP_CONF_22(x).U)
#define HW_IPU_DC_MAP_CONF_22_WR(x, v)     (HW_IPU_DC_MAP_CONF_22(x).U = (v))
#define HW_IPU_DC_MAP_CONF_22_SET(x, v)    (HW_IPU_DC_MAP_CONF_22_WR(x, HW_IPU_DC_MAP_CONF_22_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_22_CLR(x, v)    (HW_IPU_DC_MAP_CONF_22_WR(x, HW_IPU_DC_MAP_CONF_22_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_22_TOG(x, v)    (HW_IPU_DC_MAP_CONF_22_WR(x, HW_IPU_DC_MAP_CONF_22_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_22 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_22, field MD_MASK_14 (RW)
 *
 * Mapping unit's mask value #14 This field defines the mask value #14 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_22_MD_MASK_14      0
#define BM_IPU_DC_MAP_CONF_22_MD_MASK_14      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_22_MD_MASK_14(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_22_MD_MASK_14)
#else
#define BF_IPU_DC_MAP_CONF_22_MD_MASK_14(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_22_MD_MASK_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_14 field to a new value.
#define BW_IPU_DC_MAP_CONF_22_MD_MASK_14(v)   BF_CS1(IPU_DC_MAP_CONF_22, MD_MASK_14, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_22, field MD_OFFSET_14 (RW)
 *
 * Mapping unit's offset parameter #14 This field defines the offset parameter #14 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_22_MD_OFFSET_14      8
#define BM_IPU_DC_MAP_CONF_22_MD_OFFSET_14      0x00001f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_22_MD_OFFSET_14(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_MAP_CONF_22_MD_OFFSET_14)
#else
#define BF_IPU_DC_MAP_CONF_22_MD_OFFSET_14(v)   (((v) << 8) & BM_IPU_DC_MAP_CONF_22_MD_OFFSET_14)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_14 field to a new value.
#define BW_IPU_DC_MAP_CONF_22_MD_OFFSET_14(v)   BF_CS1(IPU_DC_MAP_CONF_22, MD_OFFSET_14, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_22, field MD_MASK_15 (RW)
 *
 * Mapping unit's mask value #15 This field defines the mask value #15 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_22_MD_MASK_15      16
#define BM_IPU_DC_MAP_CONF_22_MD_MASK_15      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_22_MD_MASK_15(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_22_MD_MASK_15)
#else
#define BF_IPU_DC_MAP_CONF_22_MD_MASK_15(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_22_MD_MASK_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_15 field to a new value.
#define BW_IPU_DC_MAP_CONF_22_MD_MASK_15(v)   BF_CS1(IPU_DC_MAP_CONF_22, MD_MASK_15, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_22, field MD_OFFSET_15 (RW)
 *
 * Mapping unit's offset parameter #15 This field defines the offset parameter #15 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_22_MD_OFFSET_15      24
#define BM_IPU_DC_MAP_CONF_22_MD_OFFSET_15      0x1f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_22_MD_OFFSET_15(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_MAP_CONF_22_MD_OFFSET_15)
#else
#define BF_IPU_DC_MAP_CONF_22_MD_OFFSET_15(v)   (((v) << 24) & BM_IPU_DC_MAP_CONF_22_MD_OFFSET_15)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_15 field to a new value.
#define BW_IPU_DC_MAP_CONF_22_MD_OFFSET_15(v)   BF_CS1(IPU_DC_MAP_CONF_22, MD_OFFSET_15, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_23 - DC Mapping Configuration Register 23 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MD_MASK_16 : 8; //!< Mapping unit's mask value #16 This field defines the mask value #16 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_16 : 5; //!< Mapping unit's offset parameter #16 This field defines the offset parameter #16 within the 24bit word coming from the DC.
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned MD_MASK_17 : 8; //!< Mapping unit's mask value #17 This field defines the mask value #17 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_17 : 5; //!< Mapping unit's offset parameter #17 This field defines the offset parameter #17 within the 24bit word coming from the DC.
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_23_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_23 register
 */
#define HW_IPU_DC_MAP_CONF_23_ADDR(x)      (REGS_IPU_BASE(x) + 0x58164)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_23(x)           (*(volatile hw_ipu_dc_map_conf_23_t *) HW_IPU_DC_MAP_CONF_23_ADDR(x))
#define HW_IPU_DC_MAP_CONF_23_RD(x)        (HW_IPU_DC_MAP_CONF_23(x).U)
#define HW_IPU_DC_MAP_CONF_23_WR(x, v)     (HW_IPU_DC_MAP_CONF_23(x).U = (v))
#define HW_IPU_DC_MAP_CONF_23_SET(x, v)    (HW_IPU_DC_MAP_CONF_23_WR(x, HW_IPU_DC_MAP_CONF_23_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_23_CLR(x, v)    (HW_IPU_DC_MAP_CONF_23_WR(x, HW_IPU_DC_MAP_CONF_23_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_23_TOG(x, v)    (HW_IPU_DC_MAP_CONF_23_WR(x, HW_IPU_DC_MAP_CONF_23_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_23 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_23, field MD_MASK_16 (RW)
 *
 * Mapping unit's mask value #16 This field defines the mask value #16 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_23_MD_MASK_16      0
#define BM_IPU_DC_MAP_CONF_23_MD_MASK_16      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_23_MD_MASK_16(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_23_MD_MASK_16)
#else
#define BF_IPU_DC_MAP_CONF_23_MD_MASK_16(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_23_MD_MASK_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_16 field to a new value.
#define BW_IPU_DC_MAP_CONF_23_MD_MASK_16(v)   BF_CS1(IPU_DC_MAP_CONF_23, MD_MASK_16, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_23, field MD_OFFSET_16 (RW)
 *
 * Mapping unit's offset parameter #16 This field defines the offset parameter #16 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_23_MD_OFFSET_16      8
#define BM_IPU_DC_MAP_CONF_23_MD_OFFSET_16      0x00001f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_23_MD_OFFSET_16(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_MAP_CONF_23_MD_OFFSET_16)
#else
#define BF_IPU_DC_MAP_CONF_23_MD_OFFSET_16(v)   (((v) << 8) & BM_IPU_DC_MAP_CONF_23_MD_OFFSET_16)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_16 field to a new value.
#define BW_IPU_DC_MAP_CONF_23_MD_OFFSET_16(v)   BF_CS1(IPU_DC_MAP_CONF_23, MD_OFFSET_16, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_23, field MD_MASK_17 (RW)
 *
 * Mapping unit's mask value #17 This field defines the mask value #17 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_23_MD_MASK_17      16
#define BM_IPU_DC_MAP_CONF_23_MD_MASK_17      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_23_MD_MASK_17(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_23_MD_MASK_17)
#else
#define BF_IPU_DC_MAP_CONF_23_MD_MASK_17(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_23_MD_MASK_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_17 field to a new value.
#define BW_IPU_DC_MAP_CONF_23_MD_MASK_17(v)   BF_CS1(IPU_DC_MAP_CONF_23, MD_MASK_17, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_23, field MD_OFFSET_17 (RW)
 *
 * Mapping unit's offset parameter #17 This field defines the offset parameter #17 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_23_MD_OFFSET_17      24
#define BM_IPU_DC_MAP_CONF_23_MD_OFFSET_17      0x1f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_23_MD_OFFSET_17(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_MAP_CONF_23_MD_OFFSET_17)
#else
#define BF_IPU_DC_MAP_CONF_23_MD_OFFSET_17(v)   (((v) << 24) & BM_IPU_DC_MAP_CONF_23_MD_OFFSET_17)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_17 field to a new value.
#define BW_IPU_DC_MAP_CONF_23_MD_OFFSET_17(v)   BF_CS1(IPU_DC_MAP_CONF_23, MD_OFFSET_17, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_24 - DC Mapping Configuration Register 24 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MD_MASK_18 : 8; //!< Mapping unit's mask value #18 This field defines the mask value #18 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_18 : 5; //!< Mapping unit's offset parameter #18 This field defines the offset parameter #18 within the 24bit word coming from the DC.
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned MD_MASK_19 : 8; //!< Mapping unit's mask value #19 This field defines the mask value #19 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_19 : 5; //!< Mapping unit's offset parameter #19 This field defines the offset parameter #19 within the 24bit word coming from the DC.
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_24_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_24 register
 */
#define HW_IPU_DC_MAP_CONF_24_ADDR(x)      (REGS_IPU_BASE(x) + 0x58168)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_24(x)           (*(volatile hw_ipu_dc_map_conf_24_t *) HW_IPU_DC_MAP_CONF_24_ADDR(x))
#define HW_IPU_DC_MAP_CONF_24_RD(x)        (HW_IPU_DC_MAP_CONF_24(x).U)
#define HW_IPU_DC_MAP_CONF_24_WR(x, v)     (HW_IPU_DC_MAP_CONF_24(x).U = (v))
#define HW_IPU_DC_MAP_CONF_24_SET(x, v)    (HW_IPU_DC_MAP_CONF_24_WR(x, HW_IPU_DC_MAP_CONF_24_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_24_CLR(x, v)    (HW_IPU_DC_MAP_CONF_24_WR(x, HW_IPU_DC_MAP_CONF_24_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_24_TOG(x, v)    (HW_IPU_DC_MAP_CONF_24_WR(x, HW_IPU_DC_MAP_CONF_24_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_24 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_24, field MD_MASK_18 (RW)
 *
 * Mapping unit's mask value #18 This field defines the mask value #18 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_24_MD_MASK_18      0
#define BM_IPU_DC_MAP_CONF_24_MD_MASK_18      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_24_MD_MASK_18(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_24_MD_MASK_18)
#else
#define BF_IPU_DC_MAP_CONF_24_MD_MASK_18(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_24_MD_MASK_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_18 field to a new value.
#define BW_IPU_DC_MAP_CONF_24_MD_MASK_18(v)   BF_CS1(IPU_DC_MAP_CONF_24, MD_MASK_18, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_24, field MD_OFFSET_18 (RW)
 *
 * Mapping unit's offset parameter #18 This field defines the offset parameter #18 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_24_MD_OFFSET_18      8
#define BM_IPU_DC_MAP_CONF_24_MD_OFFSET_18      0x00001f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_24_MD_OFFSET_18(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_MAP_CONF_24_MD_OFFSET_18)
#else
#define BF_IPU_DC_MAP_CONF_24_MD_OFFSET_18(v)   (((v) << 8) & BM_IPU_DC_MAP_CONF_24_MD_OFFSET_18)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_18 field to a new value.
#define BW_IPU_DC_MAP_CONF_24_MD_OFFSET_18(v)   BF_CS1(IPU_DC_MAP_CONF_24, MD_OFFSET_18, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_24, field MD_MASK_19 (RW)
 *
 * Mapping unit's mask value #19 This field defines the mask value #19 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_24_MD_MASK_19      16
#define BM_IPU_DC_MAP_CONF_24_MD_MASK_19      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_24_MD_MASK_19(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_24_MD_MASK_19)
#else
#define BF_IPU_DC_MAP_CONF_24_MD_MASK_19(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_24_MD_MASK_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_19 field to a new value.
#define BW_IPU_DC_MAP_CONF_24_MD_MASK_19(v)   BF_CS1(IPU_DC_MAP_CONF_24, MD_MASK_19, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_24, field MD_OFFSET_19 (RW)
 *
 * Mapping unit's offset parameter #19 This field defines the offset parameter #19 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_24_MD_OFFSET_19      24
#define BM_IPU_DC_MAP_CONF_24_MD_OFFSET_19      0x1f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_24_MD_OFFSET_19(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_MAP_CONF_24_MD_OFFSET_19)
#else
#define BF_IPU_DC_MAP_CONF_24_MD_OFFSET_19(v)   (((v) << 24) & BM_IPU_DC_MAP_CONF_24_MD_OFFSET_19)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_19 field to a new value.
#define BW_IPU_DC_MAP_CONF_24_MD_OFFSET_19(v)   BF_CS1(IPU_DC_MAP_CONF_24, MD_OFFSET_19, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_25 - DC Mapping Configuration Register 25 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MD_MASK_20 : 8; //!< Mapping unit's mask value #20 This field defines the mask value #20 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_20 : 5; //!< Mapping unit's offset parameter #20 This field defines the offset parameter #20 within the 24bit word coming from the DC.
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned MD_MASK_21 : 8; //!< Mapping unit's mask value #21 This field defines the mask value #21 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_21 : 5; //!< Mapping unit's offset parameter #21 This field defines the offset parameter #21 within the 24bit word coming from the DC.
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_25_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_25 register
 */
#define HW_IPU_DC_MAP_CONF_25_ADDR(x)      (REGS_IPU_BASE(x) + 0x5816c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_25(x)           (*(volatile hw_ipu_dc_map_conf_25_t *) HW_IPU_DC_MAP_CONF_25_ADDR(x))
#define HW_IPU_DC_MAP_CONF_25_RD(x)        (HW_IPU_DC_MAP_CONF_25(x).U)
#define HW_IPU_DC_MAP_CONF_25_WR(x, v)     (HW_IPU_DC_MAP_CONF_25(x).U = (v))
#define HW_IPU_DC_MAP_CONF_25_SET(x, v)    (HW_IPU_DC_MAP_CONF_25_WR(x, HW_IPU_DC_MAP_CONF_25_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_25_CLR(x, v)    (HW_IPU_DC_MAP_CONF_25_WR(x, HW_IPU_DC_MAP_CONF_25_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_25_TOG(x, v)    (HW_IPU_DC_MAP_CONF_25_WR(x, HW_IPU_DC_MAP_CONF_25_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_25 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_25, field MD_MASK_20 (RW)
 *
 * Mapping unit's mask value #20 This field defines the mask value #20 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_25_MD_MASK_20      0
#define BM_IPU_DC_MAP_CONF_25_MD_MASK_20      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_25_MD_MASK_20(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_25_MD_MASK_20)
#else
#define BF_IPU_DC_MAP_CONF_25_MD_MASK_20(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_25_MD_MASK_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_20 field to a new value.
#define BW_IPU_DC_MAP_CONF_25_MD_MASK_20(v)   BF_CS1(IPU_DC_MAP_CONF_25, MD_MASK_20, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_25, field MD_OFFSET_20 (RW)
 *
 * Mapping unit's offset parameter #20 This field defines the offset parameter #20 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_25_MD_OFFSET_20      8
#define BM_IPU_DC_MAP_CONF_25_MD_OFFSET_20      0x00001f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_25_MD_OFFSET_20(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_MAP_CONF_25_MD_OFFSET_20)
#else
#define BF_IPU_DC_MAP_CONF_25_MD_OFFSET_20(v)   (((v) << 8) & BM_IPU_DC_MAP_CONF_25_MD_OFFSET_20)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_20 field to a new value.
#define BW_IPU_DC_MAP_CONF_25_MD_OFFSET_20(v)   BF_CS1(IPU_DC_MAP_CONF_25, MD_OFFSET_20, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_25, field MD_MASK_21 (RW)
 *
 * Mapping unit's mask value #21 This field defines the mask value #21 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_25_MD_MASK_21      16
#define BM_IPU_DC_MAP_CONF_25_MD_MASK_21      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_25_MD_MASK_21(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_25_MD_MASK_21)
#else
#define BF_IPU_DC_MAP_CONF_25_MD_MASK_21(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_25_MD_MASK_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_21 field to a new value.
#define BW_IPU_DC_MAP_CONF_25_MD_MASK_21(v)   BF_CS1(IPU_DC_MAP_CONF_25, MD_MASK_21, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_25, field MD_OFFSET_21 (RW)
 *
 * Mapping unit's offset parameter #21 This field defines the offset parameter #21 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_25_MD_OFFSET_21      24
#define BM_IPU_DC_MAP_CONF_25_MD_OFFSET_21      0x1f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_25_MD_OFFSET_21(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_MAP_CONF_25_MD_OFFSET_21)
#else
#define BF_IPU_DC_MAP_CONF_25_MD_OFFSET_21(v)   (((v) << 24) & BM_IPU_DC_MAP_CONF_25_MD_OFFSET_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_21 field to a new value.
#define BW_IPU_DC_MAP_CONF_25_MD_OFFSET_21(v)   BF_CS1(IPU_DC_MAP_CONF_25, MD_OFFSET_21, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_MAP_CONF_26 - DC Mapping Configuration Register 26 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MD_MASK_22 : 8; //!< Mapping unit's mask value #22 This field defines the mask value #22 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_22 : 5; //!< Mapping unit's offset parameter #22 This field defines the offset parameter #22 within the 24bit word coming from the DC.
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned MD_MASK_23 : 8; //!< Mapping unit's mask value #23 This field defines the mask value #23 within the 8bit word coming from the DC.
        unsigned MD_OFFSET_23 : 5; //!< Mapping unit's offset parameter #23 This field defines the offset parameter #23 within the 24bit word coming from the DC.
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_map_conf_26_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_MAP_CONF_26 register
 */
#define HW_IPU_DC_MAP_CONF_26_ADDR(x)      (REGS_IPU_BASE(x) + 0x58170)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_MAP_CONF_26(x)           (*(volatile hw_ipu_dc_map_conf_26_t *) HW_IPU_DC_MAP_CONF_26_ADDR(x))
#define HW_IPU_DC_MAP_CONF_26_RD(x)        (HW_IPU_DC_MAP_CONF_26(x).U)
#define HW_IPU_DC_MAP_CONF_26_WR(x, v)     (HW_IPU_DC_MAP_CONF_26(x).U = (v))
#define HW_IPU_DC_MAP_CONF_26_SET(x, v)    (HW_IPU_DC_MAP_CONF_26_WR(x, HW_IPU_DC_MAP_CONF_26_RD(x) |  (v)))
#define HW_IPU_DC_MAP_CONF_26_CLR(x, v)    (HW_IPU_DC_MAP_CONF_26_WR(x, HW_IPU_DC_MAP_CONF_26_RD(x) & ~(v)))
#define HW_IPU_DC_MAP_CONF_26_TOG(x, v)    (HW_IPU_DC_MAP_CONF_26_WR(x, HW_IPU_DC_MAP_CONF_26_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_MAP_CONF_26 bitfields
 */

/* --- Register HW_IPU_DC_MAP_CONF_26, field MD_MASK_22 (RW)
 *
 * Mapping unit's mask value #22 This field defines the mask value #22 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_26_MD_MASK_22      0
#define BM_IPU_DC_MAP_CONF_26_MD_MASK_22      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_26_MD_MASK_22(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_MAP_CONF_26_MD_MASK_22)
#else
#define BF_IPU_DC_MAP_CONF_26_MD_MASK_22(v)   (((v) << 0) & BM_IPU_DC_MAP_CONF_26_MD_MASK_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_22 field to a new value.
#define BW_IPU_DC_MAP_CONF_26_MD_MASK_22(v)   BF_CS1(IPU_DC_MAP_CONF_26, MD_MASK_22, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_26, field MD_OFFSET_22 (RW)
 *
 * Mapping unit's offset parameter #22 This field defines the offset parameter #22 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_26_MD_OFFSET_22      8
#define BM_IPU_DC_MAP_CONF_26_MD_OFFSET_22      0x00001f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_26_MD_OFFSET_22(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_MAP_CONF_26_MD_OFFSET_22)
#else
#define BF_IPU_DC_MAP_CONF_26_MD_OFFSET_22(v)   (((v) << 8) & BM_IPU_DC_MAP_CONF_26_MD_OFFSET_22)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_22 field to a new value.
#define BW_IPU_DC_MAP_CONF_26_MD_OFFSET_22(v)   BF_CS1(IPU_DC_MAP_CONF_26, MD_OFFSET_22, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_26, field MD_MASK_23 (RW)
 *
 * Mapping unit's mask value #23 This field defines the mask value #23 within the 8bit word coming
 * from the DC.
 */

#define BP_IPU_DC_MAP_CONF_26_MD_MASK_23      16
#define BM_IPU_DC_MAP_CONF_26_MD_MASK_23      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_26_MD_MASK_23(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_MAP_CONF_26_MD_MASK_23)
#else
#define BF_IPU_DC_MAP_CONF_26_MD_MASK_23(v)   (((v) << 16) & BM_IPU_DC_MAP_CONF_26_MD_MASK_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_MASK_23 field to a new value.
#define BW_IPU_DC_MAP_CONF_26_MD_MASK_23(v)   BF_CS1(IPU_DC_MAP_CONF_26, MD_MASK_23, v)
#endif

/* --- Register HW_IPU_DC_MAP_CONF_26, field MD_OFFSET_23 (RW)
 *
 * Mapping unit's offset parameter #23 This field defines the offset parameter #23 within the 24bit
 * word coming from the DC.
 */

#define BP_IPU_DC_MAP_CONF_26_MD_OFFSET_23      24
#define BM_IPU_DC_MAP_CONF_26_MD_OFFSET_23      0x1f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_MAP_CONF_26_MD_OFFSET_23(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_MAP_CONF_26_MD_OFFSET_23)
#else
#define BF_IPU_DC_MAP_CONF_26_MD_OFFSET_23(v)   (((v) << 24) & BM_IPU_DC_MAP_CONF_26_MD_OFFSET_23)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MD_OFFSET_23 field to a new value.
#define BW_IPU_DC_MAP_CONF_26_MD_OFFSET_23(v)   BF_CS1(IPU_DC_MAP_CONF_26, MD_OFFSET_23, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE0_0 - DC User General Data Event 0 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned ID_CODED_0 : 3; //!< This field defines the number of DC channel number that user's general event #0 will be associated to.
        unsigned COD_EV_PRIORITY_0 : 4; //!< This field defines the priority of the user general event #0 The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned COD_EV_START_0 : 8; //!< This field holds a pointer in the microcode holding the routine to be performed following the user general event #0. When ODD_MODE is enabled, only the even events will use this pointer When ODD_MODE is disabled, all the events will use this pointer
        unsigned COD_ODD_START_0 : 8; //!< This field holds a pointer in the microcode holding the routine to be performed following the user general event #0. When ODD_MODE is enabled, only the odd events will use this pointer When ODD_MODE is disabled this field is ignored
        unsigned RESERVED1 : 1; //!< Reserved.
        unsigned ODD_EN_0 : 1; //!< The user's general event #0 may be split into 2 internal signals. One one mode all the events are sent on one signal, on the second mode odd events are sent over one signal while even events are sent over the other signal (ODD_MODE)
        unsigned AUTORESTART_0 : 1; //!< User's general event #0 auto restart mode
        unsigned NF_NL_0 : 2; //!< the user may attach his general event #0 to New-line New-Frame and New-field events. One of these event triggers the user's general event #0's counter. The actual internal trigger is the pixel following the occurrence of the selected event.
        unsigned RESERVED2 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde0_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE0_0 register
 */
#define HW_IPU_DC_UGDE0_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x58174)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE0_0(x)           (*(volatile hw_ipu_dc_ugde0_0_t *) HW_IPU_DC_UGDE0_0_ADDR(x))
#define HW_IPU_DC_UGDE0_0_RD(x)        (HW_IPU_DC_UGDE0_0(x).U)
#define HW_IPU_DC_UGDE0_0_WR(x, v)     (HW_IPU_DC_UGDE0_0(x).U = (v))
#define HW_IPU_DC_UGDE0_0_SET(x, v)    (HW_IPU_DC_UGDE0_0_WR(x, HW_IPU_DC_UGDE0_0_RD(x) |  (v)))
#define HW_IPU_DC_UGDE0_0_CLR(x, v)    (HW_IPU_DC_UGDE0_0_WR(x, HW_IPU_DC_UGDE0_0_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE0_0_TOG(x, v)    (HW_IPU_DC_UGDE0_0_WR(x, HW_IPU_DC_UGDE0_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE0_0 bitfields
 */

/* --- Register HW_IPU_DC_UGDE0_0, field ID_CODED_0 (RW)
 *
 * This field defines the number of DC channel number that user's general event #0 will be
 * associated to.
 *
 * Values:
 * 000 - DC channel_0
 * 001 - DC channel_1
 * 010 - DC channel_2
 * 011 - DC channel_5 (DP_SYNC)
 * 100 - DC channel_6 (DP ASYNC)
 * 101 - Reserved
 * 110 - Reserved.
 * 111 - Reserved.
 */

#define BP_IPU_DC_UGDE0_0_ID_CODED_0      0
#define BM_IPU_DC_UGDE0_0_ID_CODED_0      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE0_0_ID_CODED_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE0_0_ID_CODED_0)
#else
#define BF_IPU_DC_UGDE0_0_ID_CODED_0(v)   (((v) << 0) & BM_IPU_DC_UGDE0_0_ID_CODED_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ID_CODED_0 field to a new value.
#define BW_IPU_DC_UGDE0_0_ID_CODED_0(v)   BF_CS1(IPU_DC_UGDE0_0, ID_CODED_0, v)
#endif


/* --- Register HW_IPU_DC_UGDE0_0, field COD_EV_PRIORITY_0 (RW)
 *
 * This field defines the priority of the user general event #0 The priority between the events
 * should be set to a unique value. i.e. two events must not have the same priority (except 0000 -
 * disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_UGDE0_0_COD_EV_PRIORITY_0      3
#define BM_IPU_DC_UGDE0_0_COD_EV_PRIORITY_0      0x00000078

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE0_0_COD_EV_PRIORITY_0(v)   ((((reg32_t) v) << 3) & BM_IPU_DC_UGDE0_0_COD_EV_PRIORITY_0)
#else
#define BF_IPU_DC_UGDE0_0_COD_EV_PRIORITY_0(v)   (((v) << 3) & BM_IPU_DC_UGDE0_0_COD_EV_PRIORITY_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EV_PRIORITY_0 field to a new value.
#define BW_IPU_DC_UGDE0_0_COD_EV_PRIORITY_0(v)   BF_CS1(IPU_DC_UGDE0_0, COD_EV_PRIORITY_0, v)
#endif


/* --- Register HW_IPU_DC_UGDE0_0, field COD_EV_START_0 (RW)
 *
 * This field holds a pointer in the microcode holding the routine to be performed following the
 * user general event #0. When ODD_MODE is enabled, only the even events will use this pointer When
 * ODD_MODE is disabled, all the events will use this pointer
 */

#define BP_IPU_DC_UGDE0_0_COD_EV_START_0      8
#define BM_IPU_DC_UGDE0_0_COD_EV_START_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE0_0_COD_EV_START_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_UGDE0_0_COD_EV_START_0)
#else
#define BF_IPU_DC_UGDE0_0_COD_EV_START_0(v)   (((v) << 8) & BM_IPU_DC_UGDE0_0_COD_EV_START_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EV_START_0 field to a new value.
#define BW_IPU_DC_UGDE0_0_COD_EV_START_0(v)   BF_CS1(IPU_DC_UGDE0_0, COD_EV_START_0, v)
#endif

/* --- Register HW_IPU_DC_UGDE0_0, field COD_ODD_START_0 (RW)
 *
 * This field holds a pointer in the microcode holding the routine to be performed following the
 * user general event #0. When ODD_MODE is enabled, only the odd events will use this pointer When
 * ODD_MODE is disabled this field is ignored
 */

#define BP_IPU_DC_UGDE0_0_COD_ODD_START_0      16
#define BM_IPU_DC_UGDE0_0_COD_ODD_START_0      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE0_0_COD_ODD_START_0(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_UGDE0_0_COD_ODD_START_0)
#else
#define BF_IPU_DC_UGDE0_0_COD_ODD_START_0(v)   (((v) << 16) & BM_IPU_DC_UGDE0_0_COD_ODD_START_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_ODD_START_0 field to a new value.
#define BW_IPU_DC_UGDE0_0_COD_ODD_START_0(v)   BF_CS1(IPU_DC_UGDE0_0, COD_ODD_START_0, v)
#endif

/* --- Register HW_IPU_DC_UGDE0_0, field ODD_EN_0 (RW)
 *
 * The user's general event #0 may be split into 2 internal signals. One one mode all the events are
 * sent on one signal, on the second mode odd events are sent over one signal while even events are
 * sent over the other signal (ODD_MODE)
 *
 * Values:
 * 1 - ODD_MODE is enabled
 * 0 - ODD_MODE is disabled
 */

#define BP_IPU_DC_UGDE0_0_ODD_EN_0      25
#define BM_IPU_DC_UGDE0_0_ODD_EN_0      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE0_0_ODD_EN_0(v)   ((((reg32_t) v) << 25) & BM_IPU_DC_UGDE0_0_ODD_EN_0)
#else
#define BF_IPU_DC_UGDE0_0_ODD_EN_0(v)   (((v) << 25) & BM_IPU_DC_UGDE0_0_ODD_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODD_EN_0 field to a new value.
#define BW_IPU_DC_UGDE0_0_ODD_EN_0(v)   BF_CS1(IPU_DC_UGDE0_0, ODD_EN_0, v)
#endif


/* --- Register HW_IPU_DC_UGDE0_0, field AUTORESTART_0 (RW)
 *
 * User's general event #0 auto restart mode
 *
 * Values:
 * 0 - disable
 * 1 - User's general event #0's counter is automatically restarted.
 */

#define BP_IPU_DC_UGDE0_0_AUTORESTART_0      26
#define BM_IPU_DC_UGDE0_0_AUTORESTART_0      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE0_0_AUTORESTART_0(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_UGDE0_0_AUTORESTART_0)
#else
#define BF_IPU_DC_UGDE0_0_AUTORESTART_0(v)   (((v) << 26) & BM_IPU_DC_UGDE0_0_AUTORESTART_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the AUTORESTART_0 field to a new value.
#define BW_IPU_DC_UGDE0_0_AUTORESTART_0(v)   BF_CS1(IPU_DC_UGDE0_0, AUTORESTART_0, v)
#endif


/* --- Register HW_IPU_DC_UGDE0_0, field NF_NL_0 (RW)
 *
 * the user may attach his general event #0 to New-line New-Frame and New-field events. One of these
 * event triggers the user's general event #0's counter. The actual internal trigger is the pixel
 * following the occurrence of the selected event.
 *
 * Values:
 * 00 - New Line
 * 01 - New Frame
 * 10 - New Field
 * 11 - Reserved
 */

#define BP_IPU_DC_UGDE0_0_NF_NL_0      27
#define BM_IPU_DC_UGDE0_0_NF_NL_0      0x18000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE0_0_NF_NL_0(v)   ((((reg32_t) v) << 27) & BM_IPU_DC_UGDE0_0_NF_NL_0)
#else
#define BF_IPU_DC_UGDE0_0_NF_NL_0(v)   (((v) << 27) & BM_IPU_DC_UGDE0_0_NF_NL_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the NF_NL_0 field to a new value.
#define BW_IPU_DC_UGDE0_0_NF_NL_0(v)   BF_CS1(IPU_DC_UGDE0_0, NF_NL_0, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE0_1 - DC User General Data Event 0 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned STEP_0 : 29; //!< This field holds the pre defined value that the counter counts too.
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde0_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE0_1 register
 */
#define HW_IPU_DC_UGDE0_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x58178)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE0_1(x)           (*(volatile hw_ipu_dc_ugde0_1_t *) HW_IPU_DC_UGDE0_1_ADDR(x))
#define HW_IPU_DC_UGDE0_1_RD(x)        (HW_IPU_DC_UGDE0_1(x).U)
#define HW_IPU_DC_UGDE0_1_WR(x, v)     (HW_IPU_DC_UGDE0_1(x).U = (v))
#define HW_IPU_DC_UGDE0_1_SET(x, v)    (HW_IPU_DC_UGDE0_1_WR(x, HW_IPU_DC_UGDE0_1_RD(x) |  (v)))
#define HW_IPU_DC_UGDE0_1_CLR(x, v)    (HW_IPU_DC_UGDE0_1_WR(x, HW_IPU_DC_UGDE0_1_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE0_1_TOG(x, v)    (HW_IPU_DC_UGDE0_1_WR(x, HW_IPU_DC_UGDE0_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE0_1 bitfields
 */

/* --- Register HW_IPU_DC_UGDE0_1, field STEP_0 (RW)
 *
 * This field holds the pre defined value that the counter counts too.
 */

#define BP_IPU_DC_UGDE0_1_STEP_0      0
#define BM_IPU_DC_UGDE0_1_STEP_0      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE0_1_STEP_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE0_1_STEP_0)
#else
#define BF_IPU_DC_UGDE0_1_STEP_0(v)   (((v) << 0) & BM_IPU_DC_UGDE0_1_STEP_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the STEP_0 field to a new value.
#define BW_IPU_DC_UGDE0_1_STEP_0(v)   BF_CS1(IPU_DC_UGDE0_1, STEP_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE0_2 - DC User General Data Event 0 Register2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned OFFSET_DT_0 : 29; //!< This field defines the offset value from which the counter of user general event #0 will start counting from
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde0_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE0_2 register
 */
#define HW_IPU_DC_UGDE0_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x5817c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE0_2(x)           (*(volatile hw_ipu_dc_ugde0_2_t *) HW_IPU_DC_UGDE0_2_ADDR(x))
#define HW_IPU_DC_UGDE0_2_RD(x)        (HW_IPU_DC_UGDE0_2(x).U)
#define HW_IPU_DC_UGDE0_2_WR(x, v)     (HW_IPU_DC_UGDE0_2(x).U = (v))
#define HW_IPU_DC_UGDE0_2_SET(x, v)    (HW_IPU_DC_UGDE0_2_WR(x, HW_IPU_DC_UGDE0_2_RD(x) |  (v)))
#define HW_IPU_DC_UGDE0_2_CLR(x, v)    (HW_IPU_DC_UGDE0_2_WR(x, HW_IPU_DC_UGDE0_2_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE0_2_TOG(x, v)    (HW_IPU_DC_UGDE0_2_WR(x, HW_IPU_DC_UGDE0_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE0_2 bitfields
 */

/* --- Register HW_IPU_DC_UGDE0_2, field OFFSET_DT_0 (RW)
 *
 * This field defines the offset value from which the counter of user general event #0 will start
 * counting from
 */

#define BP_IPU_DC_UGDE0_2_OFFSET_DT_0      0
#define BM_IPU_DC_UGDE0_2_OFFSET_DT_0      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE0_2_OFFSET_DT_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE0_2_OFFSET_DT_0)
#else
#define BF_IPU_DC_UGDE0_2_OFFSET_DT_0(v)   (((v) << 0) & BM_IPU_DC_UGDE0_2_OFFSET_DT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OFFSET_DT_0 field to a new value.
#define BW_IPU_DC_UGDE0_2_OFFSET_DT_0(v)   BF_CS1(IPU_DC_UGDE0_2, OFFSET_DT_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE0_3 - DC User General Data Event 0 Register 3 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned STEP_REPEAT_0 : 29; //!< When auto reload mode is disabled this field defines the number of events that will be generated by the user general event #0 mechanism
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde0_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE0_3 register
 */
#define HW_IPU_DC_UGDE0_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x58180)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE0_3(x)           (*(volatile hw_ipu_dc_ugde0_3_t *) HW_IPU_DC_UGDE0_3_ADDR(x))
#define HW_IPU_DC_UGDE0_3_RD(x)        (HW_IPU_DC_UGDE0_3(x).U)
#define HW_IPU_DC_UGDE0_3_WR(x, v)     (HW_IPU_DC_UGDE0_3(x).U = (v))
#define HW_IPU_DC_UGDE0_3_SET(x, v)    (HW_IPU_DC_UGDE0_3_WR(x, HW_IPU_DC_UGDE0_3_RD(x) |  (v)))
#define HW_IPU_DC_UGDE0_3_CLR(x, v)    (HW_IPU_DC_UGDE0_3_WR(x, HW_IPU_DC_UGDE0_3_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE0_3_TOG(x, v)    (HW_IPU_DC_UGDE0_3_WR(x, HW_IPU_DC_UGDE0_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE0_3 bitfields
 */

/* --- Register HW_IPU_DC_UGDE0_3, field STEP_REPEAT_0 (RW)
 *
 * When auto reload mode is disabled this field defines the number of events that will be generated
 * by the user general event #0 mechanism
 */

#define BP_IPU_DC_UGDE0_3_STEP_REPEAT_0      0
#define BM_IPU_DC_UGDE0_3_STEP_REPEAT_0      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE0_3_STEP_REPEAT_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE0_3_STEP_REPEAT_0)
#else
#define BF_IPU_DC_UGDE0_3_STEP_REPEAT_0(v)   (((v) << 0) & BM_IPU_DC_UGDE0_3_STEP_REPEAT_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the STEP_REPEAT_0 field to a new value.
#define BW_IPU_DC_UGDE0_3_STEP_REPEAT_0(v)   BF_CS1(IPU_DC_UGDE0_3, STEP_REPEAT_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE1_0 - DC User General Data Event 1Register0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned ID_CODED_1 : 3; //!< This field defines the number of DC channel number that user's general event #1 will be associated to
        unsigned COD_EV_PRIORITY_1 : 4; //!< This field defines the priority of the user general event #1 The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned COD_EV_START_1 : 8; //!< This field holds a pointer in the microcode holding the routine to be performed following the user general event #1. When ODD_MODE is enabled, only the even events will use this pointer When ODD_MODE is disabled, all the events will use this pointer
        unsigned COD_ODD_START_1 : 8; //!< This field holds a pointer in the microcode holding the routine to be performed following the user general event #1. When ODD_MODE is enabled, only the odd events will use this pointer When ODD_MODE is disabled this field is ignored
        unsigned RESERVED1 : 1; //!< Reserved.
        unsigned ODD_EN_1 : 1; //!< The user's general event #1 may be split into 2 internal signals. One one mode all the events are sent on one signal, on the second mode odd events are sent over one signal while even events are sent over the other signal (ODD_MODE)
        unsigned AUTORESTART_1 : 1; //!< User's general event #1 auto restart mode
        unsigned NF_NL_1 : 2; //!< the user may attach his general event #1 to New-line New-Frame and New-field events. One of these event triggers the user's general event #1's counter. The actual internal trigger is the pixel following the occurrence of the selected event.
        unsigned RESERVED2 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde1_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE1_0 register
 */
#define HW_IPU_DC_UGDE1_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x58184)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE1_0(x)           (*(volatile hw_ipu_dc_ugde1_0_t *) HW_IPU_DC_UGDE1_0_ADDR(x))
#define HW_IPU_DC_UGDE1_0_RD(x)        (HW_IPU_DC_UGDE1_0(x).U)
#define HW_IPU_DC_UGDE1_0_WR(x, v)     (HW_IPU_DC_UGDE1_0(x).U = (v))
#define HW_IPU_DC_UGDE1_0_SET(x, v)    (HW_IPU_DC_UGDE1_0_WR(x, HW_IPU_DC_UGDE1_0_RD(x) |  (v)))
#define HW_IPU_DC_UGDE1_0_CLR(x, v)    (HW_IPU_DC_UGDE1_0_WR(x, HW_IPU_DC_UGDE1_0_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE1_0_TOG(x, v)    (HW_IPU_DC_UGDE1_0_WR(x, HW_IPU_DC_UGDE1_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE1_0 bitfields
 */

/* --- Register HW_IPU_DC_UGDE1_0, field ID_CODED_1 (RW)
 *
 * This field defines the number of DC channel number that user's general event #1 will be
 * associated to
 *
 * Values:
 * 000 - DC channel_0
 * 001 - DC channel_1
 * 010 - DC channel_2
 * 011 - DC channel_5 (DP_SYNC)
 * 100 - DC channel_6 (DP ASYNC)
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DC_UGDE1_0_ID_CODED_1      0
#define BM_IPU_DC_UGDE1_0_ID_CODED_1      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE1_0_ID_CODED_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE1_0_ID_CODED_1)
#else
#define BF_IPU_DC_UGDE1_0_ID_CODED_1(v)   (((v) << 0) & BM_IPU_DC_UGDE1_0_ID_CODED_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ID_CODED_1 field to a new value.
#define BW_IPU_DC_UGDE1_0_ID_CODED_1(v)   BF_CS1(IPU_DC_UGDE1_0, ID_CODED_1, v)
#endif


/* --- Register HW_IPU_DC_UGDE1_0, field COD_EV_PRIORITY_1 (RW)
 *
 * This field defines the priority of the user general event #1 The priority between the events
 * should be set to a unique value. i.e. two events must not have the same priority (except 0000 -
 * disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_UGDE1_0_COD_EV_PRIORITY_1      3
#define BM_IPU_DC_UGDE1_0_COD_EV_PRIORITY_1      0x00000078

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE1_0_COD_EV_PRIORITY_1(v)   ((((reg32_t) v) << 3) & BM_IPU_DC_UGDE1_0_COD_EV_PRIORITY_1)
#else
#define BF_IPU_DC_UGDE1_0_COD_EV_PRIORITY_1(v)   (((v) << 3) & BM_IPU_DC_UGDE1_0_COD_EV_PRIORITY_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EV_PRIORITY_1 field to a new value.
#define BW_IPU_DC_UGDE1_0_COD_EV_PRIORITY_1(v)   BF_CS1(IPU_DC_UGDE1_0, COD_EV_PRIORITY_1, v)
#endif


/* --- Register HW_IPU_DC_UGDE1_0, field COD_EV_START_1 (RW)
 *
 * This field holds a pointer in the microcode holding the routine to be performed following the
 * user general event #1. When ODD_MODE is enabled, only the even events will use this pointer When
 * ODD_MODE is disabled, all the events will use this pointer
 */

#define BP_IPU_DC_UGDE1_0_COD_EV_START_1      8
#define BM_IPU_DC_UGDE1_0_COD_EV_START_1      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE1_0_COD_EV_START_1(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_UGDE1_0_COD_EV_START_1)
#else
#define BF_IPU_DC_UGDE1_0_COD_EV_START_1(v)   (((v) << 8) & BM_IPU_DC_UGDE1_0_COD_EV_START_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EV_START_1 field to a new value.
#define BW_IPU_DC_UGDE1_0_COD_EV_START_1(v)   BF_CS1(IPU_DC_UGDE1_0, COD_EV_START_1, v)
#endif

/* --- Register HW_IPU_DC_UGDE1_0, field COD_ODD_START_1 (RW)
 *
 * This field holds a pointer in the microcode holding the routine to be performed following the
 * user general event #1. When ODD_MODE is enabled, only the odd events will use this pointer When
 * ODD_MODE is disabled this field is ignored
 */

#define BP_IPU_DC_UGDE1_0_COD_ODD_START_1      16
#define BM_IPU_DC_UGDE1_0_COD_ODD_START_1      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE1_0_COD_ODD_START_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_UGDE1_0_COD_ODD_START_1)
#else
#define BF_IPU_DC_UGDE1_0_COD_ODD_START_1(v)   (((v) << 16) & BM_IPU_DC_UGDE1_0_COD_ODD_START_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_ODD_START_1 field to a new value.
#define BW_IPU_DC_UGDE1_0_COD_ODD_START_1(v)   BF_CS1(IPU_DC_UGDE1_0, COD_ODD_START_1, v)
#endif

/* --- Register HW_IPU_DC_UGDE1_0, field ODD_EN_1 (RW)
 *
 * The user's general event #1 may be split into 2 internal signals. One one mode all the events are
 * sent on one signal, on the second mode odd events are sent over one signal while even events are
 * sent over the other signal (ODD_MODE)
 *
 * Values:
 * 1 - ODD_MODE is enabled
 * 0 - ODD_MODE is disabled
 */

#define BP_IPU_DC_UGDE1_0_ODD_EN_1      25
#define BM_IPU_DC_UGDE1_0_ODD_EN_1      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE1_0_ODD_EN_1(v)   ((((reg32_t) v) << 25) & BM_IPU_DC_UGDE1_0_ODD_EN_1)
#else
#define BF_IPU_DC_UGDE1_0_ODD_EN_1(v)   (((v) << 25) & BM_IPU_DC_UGDE1_0_ODD_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODD_EN_1 field to a new value.
#define BW_IPU_DC_UGDE1_0_ODD_EN_1(v)   BF_CS1(IPU_DC_UGDE1_0, ODD_EN_1, v)
#endif


/* --- Register HW_IPU_DC_UGDE1_0, field AUTORESTART_1 (RW)
 *
 * User's general event #1 auto restart mode
 *
 * Values:
 * 0 - disable
 * 1 - User's general event #1's counter is automatically restarted.
 */

#define BP_IPU_DC_UGDE1_0_AUTORESTART_1      26
#define BM_IPU_DC_UGDE1_0_AUTORESTART_1      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE1_0_AUTORESTART_1(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_UGDE1_0_AUTORESTART_1)
#else
#define BF_IPU_DC_UGDE1_0_AUTORESTART_1(v)   (((v) << 26) & BM_IPU_DC_UGDE1_0_AUTORESTART_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the AUTORESTART_1 field to a new value.
#define BW_IPU_DC_UGDE1_0_AUTORESTART_1(v)   BF_CS1(IPU_DC_UGDE1_0, AUTORESTART_1, v)
#endif


/* --- Register HW_IPU_DC_UGDE1_0, field NF_NL_1 (RW)
 *
 * the user may attach his general event #1 to New-line New-Frame and New-field events. One of these
 * event triggers the user's general event #1's counter. The actual internal trigger is the pixel
 * following the occurrence of the selected event.
 *
 * Values:
 * 00 - New Line
 * 01 - New Frame
 * 10 - New Field
 * 11 - Reserved
 */

#define BP_IPU_DC_UGDE1_0_NF_NL_1      27
#define BM_IPU_DC_UGDE1_0_NF_NL_1      0x18000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE1_0_NF_NL_1(v)   ((((reg32_t) v) << 27) & BM_IPU_DC_UGDE1_0_NF_NL_1)
#else
#define BF_IPU_DC_UGDE1_0_NF_NL_1(v)   (((v) << 27) & BM_IPU_DC_UGDE1_0_NF_NL_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the NF_NL_1 field to a new value.
#define BW_IPU_DC_UGDE1_0_NF_NL_1(v)   BF_CS1(IPU_DC_UGDE1_0, NF_NL_1, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE1_1 - DC User General Data Event 1 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned STEP_1 : 29; //!< This field hold the pre defined value that the counter counts too
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde1_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE1_1 register
 */
#define HW_IPU_DC_UGDE1_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x58188)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE1_1(x)           (*(volatile hw_ipu_dc_ugde1_1_t *) HW_IPU_DC_UGDE1_1_ADDR(x))
#define HW_IPU_DC_UGDE1_1_RD(x)        (HW_IPU_DC_UGDE1_1(x).U)
#define HW_IPU_DC_UGDE1_1_WR(x, v)     (HW_IPU_DC_UGDE1_1(x).U = (v))
#define HW_IPU_DC_UGDE1_1_SET(x, v)    (HW_IPU_DC_UGDE1_1_WR(x, HW_IPU_DC_UGDE1_1_RD(x) |  (v)))
#define HW_IPU_DC_UGDE1_1_CLR(x, v)    (HW_IPU_DC_UGDE1_1_WR(x, HW_IPU_DC_UGDE1_1_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE1_1_TOG(x, v)    (HW_IPU_DC_UGDE1_1_WR(x, HW_IPU_DC_UGDE1_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE1_1 bitfields
 */

/* --- Register HW_IPU_DC_UGDE1_1, field STEP_1 (RW)
 *
 * This field hold the pre defined value that the counter counts too
 */

#define BP_IPU_DC_UGDE1_1_STEP_1      0
#define BM_IPU_DC_UGDE1_1_STEP_1      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE1_1_STEP_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE1_1_STEP_1)
#else
#define BF_IPU_DC_UGDE1_1_STEP_1(v)   (((v) << 0) & BM_IPU_DC_UGDE1_1_STEP_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the STEP_1 field to a new value.
#define BW_IPU_DC_UGDE1_1_STEP_1(v)   BF_CS1(IPU_DC_UGDE1_1, STEP_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE1_2 - DC User General Data Event 1Register 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned OFFSET_DT_1 : 29; //!< This field defines the offset value from which the counter of user general event #1 will start counting from
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde1_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE1_2 register
 */
#define HW_IPU_DC_UGDE1_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x5818c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE1_2(x)           (*(volatile hw_ipu_dc_ugde1_2_t *) HW_IPU_DC_UGDE1_2_ADDR(x))
#define HW_IPU_DC_UGDE1_2_RD(x)        (HW_IPU_DC_UGDE1_2(x).U)
#define HW_IPU_DC_UGDE1_2_WR(x, v)     (HW_IPU_DC_UGDE1_2(x).U = (v))
#define HW_IPU_DC_UGDE1_2_SET(x, v)    (HW_IPU_DC_UGDE1_2_WR(x, HW_IPU_DC_UGDE1_2_RD(x) |  (v)))
#define HW_IPU_DC_UGDE1_2_CLR(x, v)    (HW_IPU_DC_UGDE1_2_WR(x, HW_IPU_DC_UGDE1_2_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE1_2_TOG(x, v)    (HW_IPU_DC_UGDE1_2_WR(x, HW_IPU_DC_UGDE1_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE1_2 bitfields
 */

/* --- Register HW_IPU_DC_UGDE1_2, field OFFSET_DT_1 (RW)
 *
 * This field defines the offset value from which the counter of user general event #1 will start
 * counting from
 */

#define BP_IPU_DC_UGDE1_2_OFFSET_DT_1      0
#define BM_IPU_DC_UGDE1_2_OFFSET_DT_1      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE1_2_OFFSET_DT_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE1_2_OFFSET_DT_1)
#else
#define BF_IPU_DC_UGDE1_2_OFFSET_DT_1(v)   (((v) << 0) & BM_IPU_DC_UGDE1_2_OFFSET_DT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OFFSET_DT_1 field to a new value.
#define BW_IPU_DC_UGDE1_2_OFFSET_DT_1(v)   BF_CS1(IPU_DC_UGDE1_2, OFFSET_DT_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE1_3 - DC User General Data Event 1Register 3 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned STEP_REPEAT_1 : 29; //!< When auto reload mode is disabled this field defines the number of events that will be generated by the user general event #1 mechanism
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde1_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE1_3 register
 */
#define HW_IPU_DC_UGDE1_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x58190)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE1_3(x)           (*(volatile hw_ipu_dc_ugde1_3_t *) HW_IPU_DC_UGDE1_3_ADDR(x))
#define HW_IPU_DC_UGDE1_3_RD(x)        (HW_IPU_DC_UGDE1_3(x).U)
#define HW_IPU_DC_UGDE1_3_WR(x, v)     (HW_IPU_DC_UGDE1_3(x).U = (v))
#define HW_IPU_DC_UGDE1_3_SET(x, v)    (HW_IPU_DC_UGDE1_3_WR(x, HW_IPU_DC_UGDE1_3_RD(x) |  (v)))
#define HW_IPU_DC_UGDE1_3_CLR(x, v)    (HW_IPU_DC_UGDE1_3_WR(x, HW_IPU_DC_UGDE1_3_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE1_3_TOG(x, v)    (HW_IPU_DC_UGDE1_3_WR(x, HW_IPU_DC_UGDE1_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE1_3 bitfields
 */

/* --- Register HW_IPU_DC_UGDE1_3, field STEP_REPEAT_1 (RW)
 *
 * When auto reload mode is disabled this field defines the number of events that will be generated
 * by the user general event #1 mechanism
 */

#define BP_IPU_DC_UGDE1_3_STEP_REPEAT_1      0
#define BM_IPU_DC_UGDE1_3_STEP_REPEAT_1      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE1_3_STEP_REPEAT_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE1_3_STEP_REPEAT_1)
#else
#define BF_IPU_DC_UGDE1_3_STEP_REPEAT_1(v)   (((v) << 0) & BM_IPU_DC_UGDE1_3_STEP_REPEAT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the STEP_REPEAT_1 field to a new value.
#define BW_IPU_DC_UGDE1_3_STEP_REPEAT_1(v)   BF_CS1(IPU_DC_UGDE1_3, STEP_REPEAT_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE2_0 - DC User General Data Event 2 Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned ID_CODED_2 : 3; //!< This field defines the number of DC channel number that user's general event #2 will be associated to
        unsigned COD_EV_PRIORITY_2 : 4; //!< This field defines the priority of the user general event #2 The priority between the events should be set to a unique value. i.e. two events must not have the same priority (except 0000 - disable)
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned COD_EV_START_2 : 8; //!< This field holds a pointer in the microcode holding the routine to be performed following the user general event #2. When ODD_MODE is enabled, only the even events will use this pointer When ODD_MODE is disabled, all the events will use this pointer
        unsigned COD_ODD_START_2 : 8; //!< This field holds a pointer in the microcode holding the routine to be performed following the user general event #2 When ODD_MODE is enabled, only the odd events will use this pointer When ODD_MODE is disabled this field is ignored
        unsigned RESERVED1 : 1; //!< Reserved.
        unsigned ODD_EN_2 : 1; //!< The user's general event #2 may be split into 2 internal signals. One one mode all the events are sent on one signal, on the second mode odd events are sent over one signal while even events are sent over the other signal (ODD_MODE)
        unsigned AUTORESTART_2 : 1; //!< User's general event #2 auto restart mode
        unsigned NF_NL_2 : 2; //!< the user may attach his general event #2 to New-line New-Frame and New-field events. One of these event triggers the user's general event #2's counter. The actual internal trigger is the pixel following the occurrence of the selected event.
        unsigned RESERVED2 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde2_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE2_0 register
 */
#define HW_IPU_DC_UGDE2_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x58194)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE2_0(x)           (*(volatile hw_ipu_dc_ugde2_0_t *) HW_IPU_DC_UGDE2_0_ADDR(x))
#define HW_IPU_DC_UGDE2_0_RD(x)        (HW_IPU_DC_UGDE2_0(x).U)
#define HW_IPU_DC_UGDE2_0_WR(x, v)     (HW_IPU_DC_UGDE2_0(x).U = (v))
#define HW_IPU_DC_UGDE2_0_SET(x, v)    (HW_IPU_DC_UGDE2_0_WR(x, HW_IPU_DC_UGDE2_0_RD(x) |  (v)))
#define HW_IPU_DC_UGDE2_0_CLR(x, v)    (HW_IPU_DC_UGDE2_0_WR(x, HW_IPU_DC_UGDE2_0_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE2_0_TOG(x, v)    (HW_IPU_DC_UGDE2_0_WR(x, HW_IPU_DC_UGDE2_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE2_0 bitfields
 */

/* --- Register HW_IPU_DC_UGDE2_0, field ID_CODED_2 (RW)
 *
 * This field defines the number of DC channel number that user's general event #2 will be
 * associated to
 *
 * Values:
 * 000 - DC channel_0
 * 001 - DC channel_1
 * 010 - DC channel_2
 * 011 - DC channel_5 (DP_SYNC)
 * 100 - DC channel_6 (DP ASYNC)
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved
 */

#define BP_IPU_DC_UGDE2_0_ID_CODED_2      0
#define BM_IPU_DC_UGDE2_0_ID_CODED_2      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE2_0_ID_CODED_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE2_0_ID_CODED_2)
#else
#define BF_IPU_DC_UGDE2_0_ID_CODED_2(v)   (((v) << 0) & BM_IPU_DC_UGDE2_0_ID_CODED_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ID_CODED_2 field to a new value.
#define BW_IPU_DC_UGDE2_0_ID_CODED_2(v)   BF_CS1(IPU_DC_UGDE2_0, ID_CODED_2, v)
#endif


/* --- Register HW_IPU_DC_UGDE2_0, field COD_EV_PRIORITY_2 (RW)
 *
 * This field defines the priority of the user general event #2 The priority between the events
 * should be set to a unique value. i.e. two events must not have the same priority (except 0000 -
 * disable)
 *
 * Values:
 * 0000 - disable
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_UGDE2_0_COD_EV_PRIORITY_2      3
#define BM_IPU_DC_UGDE2_0_COD_EV_PRIORITY_2      0x00000078

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE2_0_COD_EV_PRIORITY_2(v)   ((((reg32_t) v) << 3) & BM_IPU_DC_UGDE2_0_COD_EV_PRIORITY_2)
#else
#define BF_IPU_DC_UGDE2_0_COD_EV_PRIORITY_2(v)   (((v) << 3) & BM_IPU_DC_UGDE2_0_COD_EV_PRIORITY_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EV_PRIORITY_2 field to a new value.
#define BW_IPU_DC_UGDE2_0_COD_EV_PRIORITY_2(v)   BF_CS1(IPU_DC_UGDE2_0, COD_EV_PRIORITY_2, v)
#endif


/* --- Register HW_IPU_DC_UGDE2_0, field COD_EV_START_2 (RW)
 *
 * This field holds a pointer in the microcode holding the routine to be performed following the
 * user general event #2. When ODD_MODE is enabled, only the even events will use this pointer When
 * ODD_MODE is disabled, all the events will use this pointer
 */

#define BP_IPU_DC_UGDE2_0_COD_EV_START_2      8
#define BM_IPU_DC_UGDE2_0_COD_EV_START_2      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE2_0_COD_EV_START_2(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_UGDE2_0_COD_EV_START_2)
#else
#define BF_IPU_DC_UGDE2_0_COD_EV_START_2(v)   (((v) << 8) & BM_IPU_DC_UGDE2_0_COD_EV_START_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EV_START_2 field to a new value.
#define BW_IPU_DC_UGDE2_0_COD_EV_START_2(v)   BF_CS1(IPU_DC_UGDE2_0, COD_EV_START_2, v)
#endif

/* --- Register HW_IPU_DC_UGDE2_0, field COD_ODD_START_2 (RW)
 *
 * This field holds a pointer in the microcode holding the routine to be performed following the
 * user general event #2 When ODD_MODE is enabled, only the odd events will use this pointer When
 * ODD_MODE is disabled this field is ignored
 */

#define BP_IPU_DC_UGDE2_0_COD_ODD_START_2      16
#define BM_IPU_DC_UGDE2_0_COD_ODD_START_2      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE2_0_COD_ODD_START_2(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_UGDE2_0_COD_ODD_START_2)
#else
#define BF_IPU_DC_UGDE2_0_COD_ODD_START_2(v)   (((v) << 16) & BM_IPU_DC_UGDE2_0_COD_ODD_START_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_ODD_START_2 field to a new value.
#define BW_IPU_DC_UGDE2_0_COD_ODD_START_2(v)   BF_CS1(IPU_DC_UGDE2_0, COD_ODD_START_2, v)
#endif

/* --- Register HW_IPU_DC_UGDE2_0, field ODD_EN_2 (RW)
 *
 * The user's general event #2 may be split into 2 internal signals. One one mode all the events are
 * sent on one signal, on the second mode odd events are sent over one signal while even events are
 * sent over the other signal (ODD_MODE)
 *
 * Values:
 * 1 - ODD_MODE is enabled
 * 0 - ODD_MODE is disabled
 */

#define BP_IPU_DC_UGDE2_0_ODD_EN_2      25
#define BM_IPU_DC_UGDE2_0_ODD_EN_2      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE2_0_ODD_EN_2(v)   ((((reg32_t) v) << 25) & BM_IPU_DC_UGDE2_0_ODD_EN_2)
#else
#define BF_IPU_DC_UGDE2_0_ODD_EN_2(v)   (((v) << 25) & BM_IPU_DC_UGDE2_0_ODD_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODD_EN_2 field to a new value.
#define BW_IPU_DC_UGDE2_0_ODD_EN_2(v)   BF_CS1(IPU_DC_UGDE2_0, ODD_EN_2, v)
#endif


/* --- Register HW_IPU_DC_UGDE2_0, field AUTORESTART_2 (RW)
 *
 * User's general event #2 auto restart mode
 *
 * Values:
 * 0 - disable
 * 1 - User's general event #2's counter is automatically restarted.
 */

#define BP_IPU_DC_UGDE2_0_AUTORESTART_2      26
#define BM_IPU_DC_UGDE2_0_AUTORESTART_2      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE2_0_AUTORESTART_2(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_UGDE2_0_AUTORESTART_2)
#else
#define BF_IPU_DC_UGDE2_0_AUTORESTART_2(v)   (((v) << 26) & BM_IPU_DC_UGDE2_0_AUTORESTART_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the AUTORESTART_2 field to a new value.
#define BW_IPU_DC_UGDE2_0_AUTORESTART_2(v)   BF_CS1(IPU_DC_UGDE2_0, AUTORESTART_2, v)
#endif


/* --- Register HW_IPU_DC_UGDE2_0, field NF_NL_2 (RW)
 *
 * the user may attach his general event #2 to New-line New-Frame and New-field events. One of these
 * event triggers the user's general event #2's counter. The actual internal trigger is the pixel
 * following the occurrence of the selected event.
 *
 * Values:
 * 00 - New Line
 * 01 - New Frame
 * 10 - New Field
 * 11 - Reserved
 */

#define BP_IPU_DC_UGDE2_0_NF_NL_2      27
#define BM_IPU_DC_UGDE2_0_NF_NL_2      0x18000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE2_0_NF_NL_2(v)   ((((reg32_t) v) << 27) & BM_IPU_DC_UGDE2_0_NF_NL_2)
#else
#define BF_IPU_DC_UGDE2_0_NF_NL_2(v)   (((v) << 27) & BM_IPU_DC_UGDE2_0_NF_NL_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the NF_NL_2 field to a new value.
#define BW_IPU_DC_UGDE2_0_NF_NL_2(v)   BF_CS1(IPU_DC_UGDE2_0, NF_NL_2, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE2_1 - DC User General Data Event 2 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned STEP_2 : 29; //!< This field hold the pre defined value that the counter counts too
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde2_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE2_1 register
 */
#define HW_IPU_DC_UGDE2_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x58198)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE2_1(x)           (*(volatile hw_ipu_dc_ugde2_1_t *) HW_IPU_DC_UGDE2_1_ADDR(x))
#define HW_IPU_DC_UGDE2_1_RD(x)        (HW_IPU_DC_UGDE2_1(x).U)
#define HW_IPU_DC_UGDE2_1_WR(x, v)     (HW_IPU_DC_UGDE2_1(x).U = (v))
#define HW_IPU_DC_UGDE2_1_SET(x, v)    (HW_IPU_DC_UGDE2_1_WR(x, HW_IPU_DC_UGDE2_1_RD(x) |  (v)))
#define HW_IPU_DC_UGDE2_1_CLR(x, v)    (HW_IPU_DC_UGDE2_1_WR(x, HW_IPU_DC_UGDE2_1_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE2_1_TOG(x, v)    (HW_IPU_DC_UGDE2_1_WR(x, HW_IPU_DC_UGDE2_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE2_1 bitfields
 */

/* --- Register HW_IPU_DC_UGDE2_1, field STEP_2 (RW)
 *
 * This field hold the pre defined value that the counter counts too
 */

#define BP_IPU_DC_UGDE2_1_STEP_2      0
#define BM_IPU_DC_UGDE2_1_STEP_2      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE2_1_STEP_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE2_1_STEP_2)
#else
#define BF_IPU_DC_UGDE2_1_STEP_2(v)   (((v) << 0) & BM_IPU_DC_UGDE2_1_STEP_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the STEP_2 field to a new value.
#define BW_IPU_DC_UGDE2_1_STEP_2(v)   BF_CS1(IPU_DC_UGDE2_1, STEP_2, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE2_2 - DC User General Data Event 2Register 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned OFFSET_DT_2 : 29; //!< This field defines the offset value from which the counter of user general event #2 will start counting from
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde2_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE2_2 register
 */
#define HW_IPU_DC_UGDE2_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x5819c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE2_2(x)           (*(volatile hw_ipu_dc_ugde2_2_t *) HW_IPU_DC_UGDE2_2_ADDR(x))
#define HW_IPU_DC_UGDE2_2_RD(x)        (HW_IPU_DC_UGDE2_2(x).U)
#define HW_IPU_DC_UGDE2_2_WR(x, v)     (HW_IPU_DC_UGDE2_2(x).U = (v))
#define HW_IPU_DC_UGDE2_2_SET(x, v)    (HW_IPU_DC_UGDE2_2_WR(x, HW_IPU_DC_UGDE2_2_RD(x) |  (v)))
#define HW_IPU_DC_UGDE2_2_CLR(x, v)    (HW_IPU_DC_UGDE2_2_WR(x, HW_IPU_DC_UGDE2_2_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE2_2_TOG(x, v)    (HW_IPU_DC_UGDE2_2_WR(x, HW_IPU_DC_UGDE2_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE2_2 bitfields
 */

/* --- Register HW_IPU_DC_UGDE2_2, field OFFSET_DT_2 (RW)
 *
 * This field defines the offset value from which the counter of user general event #2 will start
 * counting from
 */

#define BP_IPU_DC_UGDE2_2_OFFSET_DT_2      0
#define BM_IPU_DC_UGDE2_2_OFFSET_DT_2      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE2_2_OFFSET_DT_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE2_2_OFFSET_DT_2)
#else
#define BF_IPU_DC_UGDE2_2_OFFSET_DT_2(v)   (((v) << 0) & BM_IPU_DC_UGDE2_2_OFFSET_DT_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OFFSET_DT_2 field to a new value.
#define BW_IPU_DC_UGDE2_2_OFFSET_DT_2(v)   BF_CS1(IPU_DC_UGDE2_2, OFFSET_DT_2, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE2_3 - DC User General Data Event 2Register 3 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned STEP_REPEAT_2 : 29; //!< When auto reload mode is disabled this field defines the number of events that will be generated by the user general event #2 mechanism
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde2_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE2_3 register
 */
#define HW_IPU_DC_UGDE2_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x581a0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE2_3(x)           (*(volatile hw_ipu_dc_ugde2_3_t *) HW_IPU_DC_UGDE2_3_ADDR(x))
#define HW_IPU_DC_UGDE2_3_RD(x)        (HW_IPU_DC_UGDE2_3(x).U)
#define HW_IPU_DC_UGDE2_3_WR(x, v)     (HW_IPU_DC_UGDE2_3(x).U = (v))
#define HW_IPU_DC_UGDE2_3_SET(x, v)    (HW_IPU_DC_UGDE2_3_WR(x, HW_IPU_DC_UGDE2_3_RD(x) |  (v)))
#define HW_IPU_DC_UGDE2_3_CLR(x, v)    (HW_IPU_DC_UGDE2_3_WR(x, HW_IPU_DC_UGDE2_3_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE2_3_TOG(x, v)    (HW_IPU_DC_UGDE2_3_WR(x, HW_IPU_DC_UGDE2_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE2_3 bitfields
 */

/* --- Register HW_IPU_DC_UGDE2_3, field STEP_REPEAT_2 (RW)
 *
 * When auto reload mode is disabled this field defines the number of events that will be generated
 * by the user general event #2 mechanism
 */

#define BP_IPU_DC_UGDE2_3_STEP_REPEAT_2      0
#define BM_IPU_DC_UGDE2_3_STEP_REPEAT_2      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE2_3_STEP_REPEAT_2(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE2_3_STEP_REPEAT_2)
#else
#define BF_IPU_DC_UGDE2_3_STEP_REPEAT_2(v)   (((v) << 0) & BM_IPU_DC_UGDE2_3_STEP_REPEAT_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the STEP_REPEAT_2 field to a new value.
#define BW_IPU_DC_UGDE2_3_STEP_REPEAT_2(v)   BF_CS1(IPU_DC_UGDE2_3, STEP_REPEAT_2, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE3_0 - DC User General Data Event 3Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned ID_CODED_3 : 3; //!< This field defines the number of DC channel number that user's general event #3 will be associated to
        unsigned COD_EV_PRIORITY_3 : 4; //!< This field defines the priority of the user general event #3
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned COD_EV_START_3 : 8; //!< This field holds a pointer in the microcode holding the routine to be performed following the user general event #3. When ODD_MODE is enabled, only the even events will use this pointer When ODD_MODE is disabled, all the events will use this pointer
        unsigned COD_ODD_START_3 : 8; //!< This field holds a pointer in the microcode holding the routine to be performed following the user general event #3. When ODD_MODE is enabled, only the odd events will use this pointer When ODD_MODE is disabled this field is ignored
        unsigned RESERVED1 : 1; //!< Reserved.
        unsigned ODD_EN_3 : 1; //!< The user's general event #3 may be split into 2 internal signals. One one mode all the events are sent on one signal, on the second mode odd events are sent over one signal while even events are sent over the other signal (ODD_MODE)
        unsigned AUTORESTART_3 : 1; //!< User's general event #3 auto restart mode
        unsigned NF_NL_3 : 2; //!< the user may attach his general event #3 to New-line New-Frame and New-field events. One of these event triggers the user's general event #3's counter. The actual internal trigger is the pixel following the occurrence of the selected event.
        unsigned RESERVED2 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde3_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE3_0 register
 */
#define HW_IPU_DC_UGDE3_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x581a4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE3_0(x)           (*(volatile hw_ipu_dc_ugde3_0_t *) HW_IPU_DC_UGDE3_0_ADDR(x))
#define HW_IPU_DC_UGDE3_0_RD(x)        (HW_IPU_DC_UGDE3_0(x).U)
#define HW_IPU_DC_UGDE3_0_WR(x, v)     (HW_IPU_DC_UGDE3_0(x).U = (v))
#define HW_IPU_DC_UGDE3_0_SET(x, v)    (HW_IPU_DC_UGDE3_0_WR(x, HW_IPU_DC_UGDE3_0_RD(x) |  (v)))
#define HW_IPU_DC_UGDE3_0_CLR(x, v)    (HW_IPU_DC_UGDE3_0_WR(x, HW_IPU_DC_UGDE3_0_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE3_0_TOG(x, v)    (HW_IPU_DC_UGDE3_0_WR(x, HW_IPU_DC_UGDE3_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE3_0 bitfields
 */

/* --- Register HW_IPU_DC_UGDE3_0, field ID_CODED_3 (RW)
 *
 * This field defines the number of DC channel number that user's general event #3 will be
 * associated to
 *
 * Values:
 * 000 - DC channel_0
 * 001 - DC channel_1
 * 010 - DC channel_2
 * 011 - DC channel_5 (DP_SYNC)
 * 100 - DC channel_6 (DP ASYNC)
 * 101 - Reserved
 * 110 - Reserved
 * 111 - Reserved.
 */

#define BP_IPU_DC_UGDE3_0_ID_CODED_3      0
#define BM_IPU_DC_UGDE3_0_ID_CODED_3      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE3_0_ID_CODED_3(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE3_0_ID_CODED_3)
#else
#define BF_IPU_DC_UGDE3_0_ID_CODED_3(v)   (((v) << 0) & BM_IPU_DC_UGDE3_0_ID_CODED_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ID_CODED_3 field to a new value.
#define BW_IPU_DC_UGDE3_0_ID_CODED_3(v)   BF_CS1(IPU_DC_UGDE3_0, ID_CODED_3, v)
#endif


/* --- Register HW_IPU_DC_UGDE3_0, field COD_EV_PRIORITY_3 (RW)
 *
 * This field defines the priority of the user general event #3
 *
 * Values:
 * 0000 - disable The priority between the events should be set to a unique value. i.e. two events must not
 *     have the same priority (except 0000 - disable)
 * 0001 - Priority #1 (lowest)
 * 0010 - Priority #2
 * 1101 - Priority #13 (highest)
 * 1110 - Reserved
 * 1111 - Reserved
 */

#define BP_IPU_DC_UGDE3_0_COD_EV_PRIORITY_3      3
#define BM_IPU_DC_UGDE3_0_COD_EV_PRIORITY_3      0x00000078

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE3_0_COD_EV_PRIORITY_3(v)   ((((reg32_t) v) << 3) & BM_IPU_DC_UGDE3_0_COD_EV_PRIORITY_3)
#else
#define BF_IPU_DC_UGDE3_0_COD_EV_PRIORITY_3(v)   (((v) << 3) & BM_IPU_DC_UGDE3_0_COD_EV_PRIORITY_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EV_PRIORITY_3 field to a new value.
#define BW_IPU_DC_UGDE3_0_COD_EV_PRIORITY_3(v)   BF_CS1(IPU_DC_UGDE3_0, COD_EV_PRIORITY_3, v)
#endif


/* --- Register HW_IPU_DC_UGDE3_0, field COD_EV_START_3 (RW)
 *
 * This field holds a pointer in the microcode holding the routine to be performed following the
 * user general event #3. When ODD_MODE is enabled, only the even events will use this pointer When
 * ODD_MODE is disabled, all the events will use this pointer
 */

#define BP_IPU_DC_UGDE3_0_COD_EV_START_3      8
#define BM_IPU_DC_UGDE3_0_COD_EV_START_3      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE3_0_COD_EV_START_3(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_UGDE3_0_COD_EV_START_3)
#else
#define BF_IPU_DC_UGDE3_0_COD_EV_START_3(v)   (((v) << 8) & BM_IPU_DC_UGDE3_0_COD_EV_START_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_EV_START_3 field to a new value.
#define BW_IPU_DC_UGDE3_0_COD_EV_START_3(v)   BF_CS1(IPU_DC_UGDE3_0, COD_EV_START_3, v)
#endif

/* --- Register HW_IPU_DC_UGDE3_0, field COD_ODD_START_3 (RW)
 *
 * This field holds a pointer in the microcode holding the routine to be performed following the
 * user general event #3. When ODD_MODE is enabled, only the odd events will use this pointer When
 * ODD_MODE is disabled this field is ignored
 */

#define BP_IPU_DC_UGDE3_0_COD_ODD_START_3      16
#define BM_IPU_DC_UGDE3_0_COD_ODD_START_3      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE3_0_COD_ODD_START_3(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_UGDE3_0_COD_ODD_START_3)
#else
#define BF_IPU_DC_UGDE3_0_COD_ODD_START_3(v)   (((v) << 16) & BM_IPU_DC_UGDE3_0_COD_ODD_START_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the COD_ODD_START_3 field to a new value.
#define BW_IPU_DC_UGDE3_0_COD_ODD_START_3(v)   BF_CS1(IPU_DC_UGDE3_0, COD_ODD_START_3, v)
#endif

/* --- Register HW_IPU_DC_UGDE3_0, field ODD_EN_3 (RW)
 *
 * The user's general event #3 may be split into 2 internal signals. One one mode all the events are
 * sent on one signal, on the second mode odd events are sent over one signal while even events are
 * sent over the other signal (ODD_MODE)
 *
 * Values:
 * 1 - ODD_MODE is enabled
 * 0 - ODD_MODE is disabled
 */

#define BP_IPU_DC_UGDE3_0_ODD_EN_3      25
#define BM_IPU_DC_UGDE3_0_ODD_EN_3      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE3_0_ODD_EN_3(v)   ((((reg32_t) v) << 25) & BM_IPU_DC_UGDE3_0_ODD_EN_3)
#else
#define BF_IPU_DC_UGDE3_0_ODD_EN_3(v)   (((v) << 25) & BM_IPU_DC_UGDE3_0_ODD_EN_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ODD_EN_3 field to a new value.
#define BW_IPU_DC_UGDE3_0_ODD_EN_3(v)   BF_CS1(IPU_DC_UGDE3_0, ODD_EN_3, v)
#endif


/* --- Register HW_IPU_DC_UGDE3_0, field AUTORESTART_3 (RW)
 *
 * User's general event #3 auto restart mode
 *
 * Values:
 * 0 - disable
 * 1 - User's general event #3's counter is automatically restarted.
 */

#define BP_IPU_DC_UGDE3_0_AUTORESTART_3      26
#define BM_IPU_DC_UGDE3_0_AUTORESTART_3      0x04000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE3_0_AUTORESTART_3(v)   ((((reg32_t) v) << 26) & BM_IPU_DC_UGDE3_0_AUTORESTART_3)
#else
#define BF_IPU_DC_UGDE3_0_AUTORESTART_3(v)   (((v) << 26) & BM_IPU_DC_UGDE3_0_AUTORESTART_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the AUTORESTART_3 field to a new value.
#define BW_IPU_DC_UGDE3_0_AUTORESTART_3(v)   BF_CS1(IPU_DC_UGDE3_0, AUTORESTART_3, v)
#endif


/* --- Register HW_IPU_DC_UGDE3_0, field NF_NL_3 (RW)
 *
 * the user may attach his general event #3 to New-line New-Frame and New-field events. One of these
 * event triggers the user's general event #3's counter. The actual internal trigger is the pixel
 * following the occurrence of the selected event.
 *
 * Values:
 * 00 - New Line
 * 01 - New Frame
 * 10 - New Field
 * 11 - Reserved
 */

#define BP_IPU_DC_UGDE3_0_NF_NL_3      27
#define BM_IPU_DC_UGDE3_0_NF_NL_3      0x18000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE3_0_NF_NL_3(v)   ((((reg32_t) v) << 27) & BM_IPU_DC_UGDE3_0_NF_NL_3)
#else
#define BF_IPU_DC_UGDE3_0_NF_NL_3(v)   (((v) << 27) & BM_IPU_DC_UGDE3_0_NF_NL_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the NF_NL_3 field to a new value.
#define BW_IPU_DC_UGDE3_0_NF_NL_3(v)   BF_CS1(IPU_DC_UGDE3_0, NF_NL_3, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE3_1 - DC User General Data Event 3Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned STEP_3 : 29; //!< This field hold the pre defined value that the counter counts too
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde3_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE3_1 register
 */
#define HW_IPU_DC_UGDE3_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x581a8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE3_1(x)           (*(volatile hw_ipu_dc_ugde3_1_t *) HW_IPU_DC_UGDE3_1_ADDR(x))
#define HW_IPU_DC_UGDE3_1_RD(x)        (HW_IPU_DC_UGDE3_1(x).U)
#define HW_IPU_DC_UGDE3_1_WR(x, v)     (HW_IPU_DC_UGDE3_1(x).U = (v))
#define HW_IPU_DC_UGDE3_1_SET(x, v)    (HW_IPU_DC_UGDE3_1_WR(x, HW_IPU_DC_UGDE3_1_RD(x) |  (v)))
#define HW_IPU_DC_UGDE3_1_CLR(x, v)    (HW_IPU_DC_UGDE3_1_WR(x, HW_IPU_DC_UGDE3_1_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE3_1_TOG(x, v)    (HW_IPU_DC_UGDE3_1_WR(x, HW_IPU_DC_UGDE3_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE3_1 bitfields
 */

/* --- Register HW_IPU_DC_UGDE3_1, field STEP_3 (RW)
 *
 * This field hold the pre defined value that the counter counts too
 */

#define BP_IPU_DC_UGDE3_1_STEP_3      0
#define BM_IPU_DC_UGDE3_1_STEP_3      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE3_1_STEP_3(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE3_1_STEP_3)
#else
#define BF_IPU_DC_UGDE3_1_STEP_3(v)   (((v) << 0) & BM_IPU_DC_UGDE3_1_STEP_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the STEP_3 field to a new value.
#define BW_IPU_DC_UGDE3_1_STEP_3(v)   BF_CS1(IPU_DC_UGDE3_1, STEP_3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE3_2 - DC User General Data Event 3Register 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned OFFSET_DT_3 : 29; //!< This field defines the offset value from which the counter of user general event #3 will start counting from
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde3_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE3_2 register
 */
#define HW_IPU_DC_UGDE3_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x581ac)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE3_2(x)           (*(volatile hw_ipu_dc_ugde3_2_t *) HW_IPU_DC_UGDE3_2_ADDR(x))
#define HW_IPU_DC_UGDE3_2_RD(x)        (HW_IPU_DC_UGDE3_2(x).U)
#define HW_IPU_DC_UGDE3_2_WR(x, v)     (HW_IPU_DC_UGDE3_2(x).U = (v))
#define HW_IPU_DC_UGDE3_2_SET(x, v)    (HW_IPU_DC_UGDE3_2_WR(x, HW_IPU_DC_UGDE3_2_RD(x) |  (v)))
#define HW_IPU_DC_UGDE3_2_CLR(x, v)    (HW_IPU_DC_UGDE3_2_WR(x, HW_IPU_DC_UGDE3_2_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE3_2_TOG(x, v)    (HW_IPU_DC_UGDE3_2_WR(x, HW_IPU_DC_UGDE3_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE3_2 bitfields
 */

/* --- Register HW_IPU_DC_UGDE3_2, field OFFSET_DT_3 (RW)
 *
 * This field defines the offset value from which the counter of user general event #3 will start
 * counting from
 */

#define BP_IPU_DC_UGDE3_2_OFFSET_DT_3      0
#define BM_IPU_DC_UGDE3_2_OFFSET_DT_3      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE3_2_OFFSET_DT_3(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE3_2_OFFSET_DT_3)
#else
#define BF_IPU_DC_UGDE3_2_OFFSET_DT_3(v)   (((v) << 0) & BM_IPU_DC_UGDE3_2_OFFSET_DT_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the OFFSET_DT_3 field to a new value.
#define BW_IPU_DC_UGDE3_2_OFFSET_DT_3(v)   BF_CS1(IPU_DC_UGDE3_2, OFFSET_DT_3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_UGDE3_3 - DC User General Data Event 3Register 2 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned STEP_REPEAT_3 : 29; //!< When auto reload mode is disabled this field defines the number of events that will be generated by the user general event #3 mechanism
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_ugde3_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_UGDE3_3 register
 */
#define HW_IPU_DC_UGDE3_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x581b0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_UGDE3_3(x)           (*(volatile hw_ipu_dc_ugde3_3_t *) HW_IPU_DC_UGDE3_3_ADDR(x))
#define HW_IPU_DC_UGDE3_3_RD(x)        (HW_IPU_DC_UGDE3_3(x).U)
#define HW_IPU_DC_UGDE3_3_WR(x, v)     (HW_IPU_DC_UGDE3_3(x).U = (v))
#define HW_IPU_DC_UGDE3_3_SET(x, v)    (HW_IPU_DC_UGDE3_3_WR(x, HW_IPU_DC_UGDE3_3_RD(x) |  (v)))
#define HW_IPU_DC_UGDE3_3_CLR(x, v)    (HW_IPU_DC_UGDE3_3_WR(x, HW_IPU_DC_UGDE3_3_RD(x) & ~(v)))
#define HW_IPU_DC_UGDE3_3_TOG(x, v)    (HW_IPU_DC_UGDE3_3_WR(x, HW_IPU_DC_UGDE3_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_UGDE3_3 bitfields
 */

/* --- Register HW_IPU_DC_UGDE3_3, field STEP_REPEAT_3 (RW)
 *
 * When auto reload mode is disabled this field defines the number of events that will be generated
 * by the user general event #3 mechanism
 */

#define BP_IPU_DC_UGDE3_3_STEP_REPEAT_3      0
#define BM_IPU_DC_UGDE3_3_STEP_REPEAT_3      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_UGDE3_3_STEP_REPEAT_3(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_UGDE3_3_STEP_REPEAT_3)
#else
#define BF_IPU_DC_UGDE3_3_STEP_REPEAT_3(v)   (((v) << 0) & BM_IPU_DC_UGDE3_3_STEP_REPEAT_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the STEP_REPEAT_3 field to a new value.
#define BW_IPU_DC_UGDE3_3_STEP_REPEAT_3(v)   BF_CS1(IPU_DC_UGDE3_3, STEP_REPEAT_3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_LLA0 - DC Low Level Access Control Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MCU_RS_0_0 : 8; //!< This field holds a pointer in the microcode handling the RS_0 routine for the display defined at DISP_ID_8, when in Low level access mode,
        unsigned MCU_RS_1_0 : 8; //!< This field holds a pointer in the microcode handling the RS_1 routine for the display defined at DISP_ID_8, when in Low level access mode,
        unsigned MCU_RS_2_0 : 8; //!< This field holds a pointer in the microcode handling the RS_2 routine for the display defined at DISP_ID_8, when in Low level access mode,
        unsigned MCU_RS_3_0 : 8; //!< This field holds a pointer in the microcode handling the RS_3 routine for the display defined at DISP_ID_8, when in Low level access mode,
    } B;
} hw_ipu_dc_lla0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_LLA0 register
 */
#define HW_IPU_DC_LLA0_ADDR(x)      (REGS_IPU_BASE(x) + 0x581b4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_LLA0(x)           (*(volatile hw_ipu_dc_lla0_t *) HW_IPU_DC_LLA0_ADDR(x))
#define HW_IPU_DC_LLA0_RD(x)        (HW_IPU_DC_LLA0(x).U)
#define HW_IPU_DC_LLA0_WR(x, v)     (HW_IPU_DC_LLA0(x).U = (v))
#define HW_IPU_DC_LLA0_SET(x, v)    (HW_IPU_DC_LLA0_WR(x, HW_IPU_DC_LLA0_RD(x) |  (v)))
#define HW_IPU_DC_LLA0_CLR(x, v)    (HW_IPU_DC_LLA0_WR(x, HW_IPU_DC_LLA0_RD(x) & ~(v)))
#define HW_IPU_DC_LLA0_TOG(x, v)    (HW_IPU_DC_LLA0_WR(x, HW_IPU_DC_LLA0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_LLA0 bitfields
 */

/* --- Register HW_IPU_DC_LLA0, field MCU_RS_0_0 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_0 routine for the display defined at
 * DISP_ID_8, when in Low level access mode,
 */

#define BP_IPU_DC_LLA0_MCU_RS_0_0      0
#define BM_IPU_DC_LLA0_MCU_RS_0_0      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_LLA0_MCU_RS_0_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_LLA0_MCU_RS_0_0)
#else
#define BF_IPU_DC_LLA0_MCU_RS_0_0(v)   (((v) << 0) & BM_IPU_DC_LLA0_MCU_RS_0_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_0_0 field to a new value.
#define BW_IPU_DC_LLA0_MCU_RS_0_0(v)   BF_CS1(IPU_DC_LLA0, MCU_RS_0_0, v)
#endif

/* --- Register HW_IPU_DC_LLA0, field MCU_RS_1_0 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_1 routine for the display defined at
 * DISP_ID_8, when in Low level access mode,
 */

#define BP_IPU_DC_LLA0_MCU_RS_1_0      8
#define BM_IPU_DC_LLA0_MCU_RS_1_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_LLA0_MCU_RS_1_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_LLA0_MCU_RS_1_0)
#else
#define BF_IPU_DC_LLA0_MCU_RS_1_0(v)   (((v) << 8) & BM_IPU_DC_LLA0_MCU_RS_1_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_1_0 field to a new value.
#define BW_IPU_DC_LLA0_MCU_RS_1_0(v)   BF_CS1(IPU_DC_LLA0, MCU_RS_1_0, v)
#endif

/* --- Register HW_IPU_DC_LLA0, field MCU_RS_2_0 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_2 routine for the display defined at
 * DISP_ID_8, when in Low level access mode,
 */

#define BP_IPU_DC_LLA0_MCU_RS_2_0      16
#define BM_IPU_DC_LLA0_MCU_RS_2_0      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_LLA0_MCU_RS_2_0(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_LLA0_MCU_RS_2_0)
#else
#define BF_IPU_DC_LLA0_MCU_RS_2_0(v)   (((v) << 16) & BM_IPU_DC_LLA0_MCU_RS_2_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_2_0 field to a new value.
#define BW_IPU_DC_LLA0_MCU_RS_2_0(v)   BF_CS1(IPU_DC_LLA0, MCU_RS_2_0, v)
#endif

/* --- Register HW_IPU_DC_LLA0, field MCU_RS_3_0 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_3 routine for the display defined at
 * DISP_ID_8, when in Low level access mode,
 */

#define BP_IPU_DC_LLA0_MCU_RS_3_0      24
#define BM_IPU_DC_LLA0_MCU_RS_3_0      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_LLA0_MCU_RS_3_0(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_LLA0_MCU_RS_3_0)
#else
#define BF_IPU_DC_LLA0_MCU_RS_3_0(v)   (((v) << 24) & BM_IPU_DC_LLA0_MCU_RS_3_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_3_0 field to a new value.
#define BW_IPU_DC_LLA0_MCU_RS_3_0(v)   BF_CS1(IPU_DC_LLA0, MCU_RS_3_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_LLA1 - DC Low Level Access Control Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MCU_RS_0_1 : 8; //!< This field holds a pointer in the microcode handling the RS_0 routine for the display defined at DISP_ID_9, when in Low level access mode,
        unsigned MCU_RS_1_1 : 8; //!< This field holds a pointer in the microcode handling the RS_1 routine for the display defined at DISP_ID_9, when in Low level access mode,
        unsigned MCU_RS_2_1 : 8; //!< This field holds a pointer in the microcode handling the RS_2 routine for the display defined at DISP_ID_9, when in Low level access mode,
        unsigned MCU_RS_3_1 : 8; //!< This field holds a pointer in the microcode handling the RS_3 routine for the display defined at DISP_ID_9, when in Low level access mode,
    } B;
} hw_ipu_dc_lla1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_LLA1 register
 */
#define HW_IPU_DC_LLA1_ADDR(x)      (REGS_IPU_BASE(x) + 0x581b8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_LLA1(x)           (*(volatile hw_ipu_dc_lla1_t *) HW_IPU_DC_LLA1_ADDR(x))
#define HW_IPU_DC_LLA1_RD(x)        (HW_IPU_DC_LLA1(x).U)
#define HW_IPU_DC_LLA1_WR(x, v)     (HW_IPU_DC_LLA1(x).U = (v))
#define HW_IPU_DC_LLA1_SET(x, v)    (HW_IPU_DC_LLA1_WR(x, HW_IPU_DC_LLA1_RD(x) |  (v)))
#define HW_IPU_DC_LLA1_CLR(x, v)    (HW_IPU_DC_LLA1_WR(x, HW_IPU_DC_LLA1_RD(x) & ~(v)))
#define HW_IPU_DC_LLA1_TOG(x, v)    (HW_IPU_DC_LLA1_WR(x, HW_IPU_DC_LLA1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_LLA1 bitfields
 */

/* --- Register HW_IPU_DC_LLA1, field MCU_RS_0_1 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_0 routine for the display defined at
 * DISP_ID_9, when in Low level access mode,
 */

#define BP_IPU_DC_LLA1_MCU_RS_0_1      0
#define BM_IPU_DC_LLA1_MCU_RS_0_1      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_LLA1_MCU_RS_0_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_LLA1_MCU_RS_0_1)
#else
#define BF_IPU_DC_LLA1_MCU_RS_0_1(v)   (((v) << 0) & BM_IPU_DC_LLA1_MCU_RS_0_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_0_1 field to a new value.
#define BW_IPU_DC_LLA1_MCU_RS_0_1(v)   BF_CS1(IPU_DC_LLA1, MCU_RS_0_1, v)
#endif

/* --- Register HW_IPU_DC_LLA1, field MCU_RS_1_1 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_1 routine for the display defined at
 * DISP_ID_9, when in Low level access mode,
 */

#define BP_IPU_DC_LLA1_MCU_RS_1_1      8
#define BM_IPU_DC_LLA1_MCU_RS_1_1      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_LLA1_MCU_RS_1_1(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_LLA1_MCU_RS_1_1)
#else
#define BF_IPU_DC_LLA1_MCU_RS_1_1(v)   (((v) << 8) & BM_IPU_DC_LLA1_MCU_RS_1_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_1_1 field to a new value.
#define BW_IPU_DC_LLA1_MCU_RS_1_1(v)   BF_CS1(IPU_DC_LLA1, MCU_RS_1_1, v)
#endif

/* --- Register HW_IPU_DC_LLA1, field MCU_RS_2_1 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_2 routine for the display defined at
 * DISP_ID_9, when in Low level access mode,
 */

#define BP_IPU_DC_LLA1_MCU_RS_2_1      16
#define BM_IPU_DC_LLA1_MCU_RS_2_1      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_LLA1_MCU_RS_2_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_LLA1_MCU_RS_2_1)
#else
#define BF_IPU_DC_LLA1_MCU_RS_2_1(v)   (((v) << 16) & BM_IPU_DC_LLA1_MCU_RS_2_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_2_1 field to a new value.
#define BW_IPU_DC_LLA1_MCU_RS_2_1(v)   BF_CS1(IPU_DC_LLA1, MCU_RS_2_1, v)
#endif

/* --- Register HW_IPU_DC_LLA1, field MCU_RS_3_1 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_3 routine for the display defined at
 * DISP_ID_9, when in Low level access mode,
 */

#define BP_IPU_DC_LLA1_MCU_RS_3_1      24
#define BM_IPU_DC_LLA1_MCU_RS_3_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_LLA1_MCU_RS_3_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_LLA1_MCU_RS_3_1)
#else
#define BF_IPU_DC_LLA1_MCU_RS_3_1(v)   (((v) << 24) & BM_IPU_DC_LLA1_MCU_RS_3_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_3_1 field to a new value.
#define BW_IPU_DC_LLA1_MCU_RS_3_1(v)   BF_CS1(IPU_DC_LLA1, MCU_RS_3_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_R_LLA0 - DC Read Low Level Read Access Control Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MCU_RS_R_0_0 : 8; //!< This field holds a pointer in the microcode handling the RS_0 routine for the display defined at DISP_ID_8, when in Read Low level access mode,
        unsigned MCU_RS_R_1_0 : 8; //!< This field holds a pointer in the microcode handling the RS_1 routine for the display defined at DISP_ID_8, when in Read Low level access mode,
        unsigned MCU_RS_2_0 : 8; //!< This field holds a pointer in the microcode handling the RS_2 routine for the display defined at DISP_ID_8, when in Read Low level access mode,
        unsigned MCU_RS_3_0 : 8; //!< This field holds a pointer in the microcode handling the RS_3 routine for the display defined at DISP_ID_8, when in Read Low level access mode,
    } B;
} hw_ipu_dc_r_lla0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_R_LLA0 register
 */
#define HW_IPU_DC_R_LLA0_ADDR(x)      (REGS_IPU_BASE(x) + 0x581bc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_R_LLA0(x)           (*(volatile hw_ipu_dc_r_lla0_t *) HW_IPU_DC_R_LLA0_ADDR(x))
#define HW_IPU_DC_R_LLA0_RD(x)        (HW_IPU_DC_R_LLA0(x).U)
#define HW_IPU_DC_R_LLA0_WR(x, v)     (HW_IPU_DC_R_LLA0(x).U = (v))
#define HW_IPU_DC_R_LLA0_SET(x, v)    (HW_IPU_DC_R_LLA0_WR(x, HW_IPU_DC_R_LLA0_RD(x) |  (v)))
#define HW_IPU_DC_R_LLA0_CLR(x, v)    (HW_IPU_DC_R_LLA0_WR(x, HW_IPU_DC_R_LLA0_RD(x) & ~(v)))
#define HW_IPU_DC_R_LLA0_TOG(x, v)    (HW_IPU_DC_R_LLA0_WR(x, HW_IPU_DC_R_LLA0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_R_LLA0 bitfields
 */

/* --- Register HW_IPU_DC_R_LLA0, field MCU_RS_R_0_0 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_0 routine for the display defined at
 * DISP_ID_8, when in Read Low level access mode,
 */

#define BP_IPU_DC_R_LLA0_MCU_RS_R_0_0      0
#define BM_IPU_DC_R_LLA0_MCU_RS_R_0_0      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_R_LLA0_MCU_RS_R_0_0(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_R_LLA0_MCU_RS_R_0_0)
#else
#define BF_IPU_DC_R_LLA0_MCU_RS_R_0_0(v)   (((v) << 0) & BM_IPU_DC_R_LLA0_MCU_RS_R_0_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_R_0_0 field to a new value.
#define BW_IPU_DC_R_LLA0_MCU_RS_R_0_0(v)   BF_CS1(IPU_DC_R_LLA0, MCU_RS_R_0_0, v)
#endif

/* --- Register HW_IPU_DC_R_LLA0, field MCU_RS_R_1_0 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_1 routine for the display defined at
 * DISP_ID_8, when in Read Low level access mode,
 */

#define BP_IPU_DC_R_LLA0_MCU_RS_R_1_0      8
#define BM_IPU_DC_R_LLA0_MCU_RS_R_1_0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_R_LLA0_MCU_RS_R_1_0(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_R_LLA0_MCU_RS_R_1_0)
#else
#define BF_IPU_DC_R_LLA0_MCU_RS_R_1_0(v)   (((v) << 8) & BM_IPU_DC_R_LLA0_MCU_RS_R_1_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_R_1_0 field to a new value.
#define BW_IPU_DC_R_LLA0_MCU_RS_R_1_0(v)   BF_CS1(IPU_DC_R_LLA0, MCU_RS_R_1_0, v)
#endif

/* --- Register HW_IPU_DC_R_LLA0, field MCU_RS_2_0 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_2 routine for the display defined at
 * DISP_ID_8, when in Read Low level access mode,
 */

#define BP_IPU_DC_R_LLA0_MCU_RS_2_0      16
#define BM_IPU_DC_R_LLA0_MCU_RS_2_0      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_R_LLA0_MCU_RS_2_0(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_R_LLA0_MCU_RS_2_0)
#else
#define BF_IPU_DC_R_LLA0_MCU_RS_2_0(v)   (((v) << 16) & BM_IPU_DC_R_LLA0_MCU_RS_2_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_2_0 field to a new value.
#define BW_IPU_DC_R_LLA0_MCU_RS_2_0(v)   BF_CS1(IPU_DC_R_LLA0, MCU_RS_2_0, v)
#endif

/* --- Register HW_IPU_DC_R_LLA0, field MCU_RS_3_0 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_3 routine for the display defined at
 * DISP_ID_8, when in Read Low level access mode,
 */

#define BP_IPU_DC_R_LLA0_MCU_RS_3_0      24
#define BM_IPU_DC_R_LLA0_MCU_RS_3_0      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_R_LLA0_MCU_RS_3_0(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_R_LLA0_MCU_RS_3_0)
#else
#define BF_IPU_DC_R_LLA0_MCU_RS_3_0(v)   (((v) << 24) & BM_IPU_DC_R_LLA0_MCU_RS_3_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_3_0 field to a new value.
#define BW_IPU_DC_R_LLA0_MCU_RS_3_0(v)   BF_CS1(IPU_DC_R_LLA0, MCU_RS_3_0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_R_LLA1 - DC Read Low Level Read Access Control Register1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned MCU_RS_R_0_1 : 8; //!< This field holds a pointer in the microcode handling the RS_0 routine for the display defined at DISP_ID_9, when in Read Low level access mode,
        unsigned MCU_RS_R_1_1 : 8; //!< This field holds a pointer in the microcode handling the RS_1 routine for the display defined at DISP_ID_9, when in Read Low level access mode,
        unsigned MCU_RS_R_2_1 : 8; //!< This field holds a pointer in the microcode handling the RS_2 routine for the display defined at DISP_ID_9, when in Read Low level access mode,
        unsigned MCU_RS_R_3_1 : 8; //!< This field holds a pointer in the microcode handling the RS_3 routine for the display defined at DISP_ID_9, when in Read Low level access mode,
    } B;
} hw_ipu_dc_r_lla1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_R_LLA1 register
 */
#define HW_IPU_DC_R_LLA1_ADDR(x)      (REGS_IPU_BASE(x) + 0x581c0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_R_LLA1(x)           (*(volatile hw_ipu_dc_r_lla1_t *) HW_IPU_DC_R_LLA1_ADDR(x))
#define HW_IPU_DC_R_LLA1_RD(x)        (HW_IPU_DC_R_LLA1(x).U)
#define HW_IPU_DC_R_LLA1_WR(x, v)     (HW_IPU_DC_R_LLA1(x).U = (v))
#define HW_IPU_DC_R_LLA1_SET(x, v)    (HW_IPU_DC_R_LLA1_WR(x, HW_IPU_DC_R_LLA1_RD(x) |  (v)))
#define HW_IPU_DC_R_LLA1_CLR(x, v)    (HW_IPU_DC_R_LLA1_WR(x, HW_IPU_DC_R_LLA1_RD(x) & ~(v)))
#define HW_IPU_DC_R_LLA1_TOG(x, v)    (HW_IPU_DC_R_LLA1_WR(x, HW_IPU_DC_R_LLA1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_R_LLA1 bitfields
 */

/* --- Register HW_IPU_DC_R_LLA1, field MCU_RS_R_0_1 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_0 routine for the display defined at
 * DISP_ID_9, when in Read Low level access mode,
 */

#define BP_IPU_DC_R_LLA1_MCU_RS_R_0_1      0
#define BM_IPU_DC_R_LLA1_MCU_RS_R_0_1      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_R_LLA1_MCU_RS_R_0_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_R_LLA1_MCU_RS_R_0_1)
#else
#define BF_IPU_DC_R_LLA1_MCU_RS_R_0_1(v)   (((v) << 0) & BM_IPU_DC_R_LLA1_MCU_RS_R_0_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_R_0_1 field to a new value.
#define BW_IPU_DC_R_LLA1_MCU_RS_R_0_1(v)   BF_CS1(IPU_DC_R_LLA1, MCU_RS_R_0_1, v)
#endif

/* --- Register HW_IPU_DC_R_LLA1, field MCU_RS_R_1_1 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_1 routine for the display defined at
 * DISP_ID_9, when in Read Low level access mode,
 */

#define BP_IPU_DC_R_LLA1_MCU_RS_R_1_1      8
#define BM_IPU_DC_R_LLA1_MCU_RS_R_1_1      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_R_LLA1_MCU_RS_R_1_1(v)   ((((reg32_t) v) << 8) & BM_IPU_DC_R_LLA1_MCU_RS_R_1_1)
#else
#define BF_IPU_DC_R_LLA1_MCU_RS_R_1_1(v)   (((v) << 8) & BM_IPU_DC_R_LLA1_MCU_RS_R_1_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_R_1_1 field to a new value.
#define BW_IPU_DC_R_LLA1_MCU_RS_R_1_1(v)   BF_CS1(IPU_DC_R_LLA1, MCU_RS_R_1_1, v)
#endif

/* --- Register HW_IPU_DC_R_LLA1, field MCU_RS_R_2_1 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_2 routine for the display defined at
 * DISP_ID_9, when in Read Low level access mode,
 */

#define BP_IPU_DC_R_LLA1_MCU_RS_R_2_1      16
#define BM_IPU_DC_R_LLA1_MCU_RS_R_2_1      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_R_LLA1_MCU_RS_R_2_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DC_R_LLA1_MCU_RS_R_2_1)
#else
#define BF_IPU_DC_R_LLA1_MCU_RS_R_2_1(v)   (((v) << 16) & BM_IPU_DC_R_LLA1_MCU_RS_R_2_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_R_2_1 field to a new value.
#define BW_IPU_DC_R_LLA1_MCU_RS_R_2_1(v)   BF_CS1(IPU_DC_R_LLA1, MCU_RS_R_2_1, v)
#endif

/* --- Register HW_IPU_DC_R_LLA1, field MCU_RS_R_3_1 (RW)
 *
 * This field holds a pointer in the microcode handling the RS_3 routine for the display defined at
 * DISP_ID_9, when in Read Low level access mode,
 */

#define BP_IPU_DC_R_LLA1_MCU_RS_R_3_1      24
#define BM_IPU_DC_R_LLA1_MCU_RS_R_3_1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_R_LLA1_MCU_RS_R_3_1(v)   ((((reg32_t) v) << 24) & BM_IPU_DC_R_LLA1_MCU_RS_R_3_1)
#else
#define BF_IPU_DC_R_LLA1_MCU_RS_R_3_1(v)   (((v) << 24) & BM_IPU_DC_R_LLA1_MCU_RS_R_3_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the MCU_RS_R_3_1 field to a new value.
#define BW_IPU_DC_R_LLA1_MCU_RS_R_3_1(v)   BF_CS1(IPU_DC_R_LLA1, MCU_RS_R_3_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_WR_CH_ADDR_5_ALT - DC Write Channel 5 Configuration Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned ST_ADDR_5_ALT : 29; //!< This field defines the start address within the display's memory space where the write transactions will be done to for channel #5, when alternate flow is performed via channel #5
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_wr_ch_addr_5_alt_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_WR_CH_ADDR_5_ALT register
 */
#define HW_IPU_DC_WR_CH_ADDR_5_ALT_ADDR(x)      (REGS_IPU_BASE(x) + 0x581c4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_WR_CH_ADDR_5_ALT(x)           (*(volatile hw_ipu_dc_wr_ch_addr_5_alt_t *) HW_IPU_DC_WR_CH_ADDR_5_ALT_ADDR(x))
#define HW_IPU_DC_WR_CH_ADDR_5_ALT_RD(x)        (HW_IPU_DC_WR_CH_ADDR_5_ALT(x).U)
#define HW_IPU_DC_WR_CH_ADDR_5_ALT_WR(x, v)     (HW_IPU_DC_WR_CH_ADDR_5_ALT(x).U = (v))
#define HW_IPU_DC_WR_CH_ADDR_5_ALT_SET(x, v)    (HW_IPU_DC_WR_CH_ADDR_5_ALT_WR(x, HW_IPU_DC_WR_CH_ADDR_5_ALT_RD(x) |  (v)))
#define HW_IPU_DC_WR_CH_ADDR_5_ALT_CLR(x, v)    (HW_IPU_DC_WR_CH_ADDR_5_ALT_WR(x, HW_IPU_DC_WR_CH_ADDR_5_ALT_RD(x) & ~(v)))
#define HW_IPU_DC_WR_CH_ADDR_5_ALT_TOG(x, v)    (HW_IPU_DC_WR_CH_ADDR_5_ALT_WR(x, HW_IPU_DC_WR_CH_ADDR_5_ALT_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_WR_CH_ADDR_5_ALT bitfields
 */

/* --- Register HW_IPU_DC_WR_CH_ADDR_5_ALT, field ST_ADDR_5_ALT (RW)
 *
 * This field defines the start address within the display's memory space where the write
 * transactions will be done to for channel #5, when alternate flow is performed via channel #5
 */

#define BP_IPU_DC_WR_CH_ADDR_5_ALT_ST_ADDR_5_ALT      0
#define BM_IPU_DC_WR_CH_ADDR_5_ALT_ST_ADDR_5_ALT      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_WR_CH_ADDR_5_ALT_ST_ADDR_5_ALT(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_WR_CH_ADDR_5_ALT_ST_ADDR_5_ALT)
#else
#define BF_IPU_DC_WR_CH_ADDR_5_ALT_ST_ADDR_5_ALT(v)   (((v) << 0) & BM_IPU_DC_WR_CH_ADDR_5_ALT_ST_ADDR_5_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the ST_ADDR_5_ALT field to a new value.
#define BW_IPU_DC_WR_CH_ADDR_5_ALT_ST_ADDR_5_ALT(v)   BF_CS1(IPU_DC_WR_CH_ADDR_5_ALT, ST_ADDR_5_ALT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_STAT - DC Status Register (RO)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DC_TRIPLE_BUF_CNT_FULL_0 : 1; //!< This bit indicates a FIFO full state on the DC FIFO accessing DI0 when write to the display flow is used
        unsigned DC_TRIPLE_BUF_CNT_EMPTY_0 : 1; //!< This bit indicates a FIFO empty state on the DC FIFO accessing DI0 when write to the display flow is used
        unsigned DC_TRIPLE_BUF_DATA_FULL_0 : 1; //!< This bit indicates a FIFO full state on the DC FIFO accessing DI0 when read from the display flow is used
        unsigned DC_TRIPLE_BUF_DATA_EMPTY_0 : 1; //!< This bit indicates a FIFO empty state on the DC FIFO accessing DI0 when read from the display flow is used
        unsigned DC_TRIPLE_BUF_CNT_FULL_1 : 1; //!< This bit indicates a FIFO full state on the DC FIFO accessing DI1 when write to the display flow is used
        unsigned DC_TRIPLE_BUF_CNT_EMPTY_1 : 1; //!< This bit indicates a FIFO empty state on the DC FIFO accessing DI1 when write to the display flow is used
        unsigned DC_TRIPLE_BUF_DATA_FULL_1 : 1; //!< This bit indicates a FIFO empty state on the DC FIFO accessing DI1 when read from the display flow is used
        unsigned DC_TRIPLE_BUF_DATA_EMPTY_1 : 1; //!< This bit indicates a FIFO full state on the DC FIFO accessing DI1 when write to the display flow is used
        unsigned RESERVED0 : 24; //!< Reserved.
    } B;
} hw_ipu_dc_stat_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_STAT register
 */
#define HW_IPU_DC_STAT_ADDR(x)      (REGS_IPU_BASE(x) + 0x581c8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_STAT(x)           (*(volatile hw_ipu_dc_stat_t *) HW_IPU_DC_STAT_ADDR(x))
#define HW_IPU_DC_STAT_RD(x)        (HW_IPU_DC_STAT(x).U)
#endif

/*
 * constants & macros for individual IPU_DC_STAT bitfields
 */

/* --- Register HW_IPU_DC_STAT, field DC_TRIPLE_BUF_CNT_FULL_0 (RO)
 *
 * This bit indicates a FIFO full state on the DC FIFO accessing DI0 when write to the display flow
 * is used
 */

#define BP_IPU_DC_STAT_DC_TRIPLE_BUF_CNT_FULL_0      0
#define BM_IPU_DC_STAT_DC_TRIPLE_BUF_CNT_FULL_0      0x00000001

/* --- Register HW_IPU_DC_STAT, field DC_TRIPLE_BUF_CNT_EMPTY_0 (RO)
 *
 * This bit indicates a FIFO empty state on the DC FIFO accessing DI0 when write to the display flow
 * is used
 */

#define BP_IPU_DC_STAT_DC_TRIPLE_BUF_CNT_EMPTY_0      1
#define BM_IPU_DC_STAT_DC_TRIPLE_BUF_CNT_EMPTY_0      0x00000002

/* --- Register HW_IPU_DC_STAT, field DC_TRIPLE_BUF_DATA_FULL_0 (RO)
 *
 * This bit indicates a FIFO full state on the DC FIFO accessing DI0 when read from the display flow
 * is used
 */

#define BP_IPU_DC_STAT_DC_TRIPLE_BUF_DATA_FULL_0      2
#define BM_IPU_DC_STAT_DC_TRIPLE_BUF_DATA_FULL_0      0x00000004

/* --- Register HW_IPU_DC_STAT, field DC_TRIPLE_BUF_DATA_EMPTY_0 (RO)
 *
 * This bit indicates a FIFO empty state on the DC FIFO accessing DI0 when read from the display
 * flow is used
 */

#define BP_IPU_DC_STAT_DC_TRIPLE_BUF_DATA_EMPTY_0      3
#define BM_IPU_DC_STAT_DC_TRIPLE_BUF_DATA_EMPTY_0      0x00000008

/* --- Register HW_IPU_DC_STAT, field DC_TRIPLE_BUF_CNT_FULL_1 (RO)
 *
 * This bit indicates a FIFO full state on the DC FIFO accessing DI1 when write to the display flow
 * is used
 */

#define BP_IPU_DC_STAT_DC_TRIPLE_BUF_CNT_FULL_1      4
#define BM_IPU_DC_STAT_DC_TRIPLE_BUF_CNT_FULL_1      0x00000010

/* --- Register HW_IPU_DC_STAT, field DC_TRIPLE_BUF_CNT_EMPTY_1 (RO)
 *
 * This bit indicates a FIFO empty state on the DC FIFO accessing DI1 when write to the display flow
 * is used
 */

#define BP_IPU_DC_STAT_DC_TRIPLE_BUF_CNT_EMPTY_1      5
#define BM_IPU_DC_STAT_DC_TRIPLE_BUF_CNT_EMPTY_1      0x00000020

/* --- Register HW_IPU_DC_STAT, field DC_TRIPLE_BUF_DATA_FULL_1 (RO)
 *
 * This bit indicates a FIFO empty state on the DC FIFO accessing DI1 when read from the display
 * flow is used
 */

#define BP_IPU_DC_STAT_DC_TRIPLE_BUF_DATA_FULL_1      6
#define BM_IPU_DC_STAT_DC_TRIPLE_BUF_DATA_FULL_1      0x00000040

/* --- Register HW_IPU_DC_STAT, field DC_TRIPLE_BUF_DATA_EMPTY_1 (RO)
 *
 * This bit indicates a FIFO full state on the DC FIFO accessing DI1 when write to the display flow
 * is used
 */

#define BP_IPU_DC_STAT_DC_TRIPLE_BUF_DATA_EMPTY_1      7
#define BM_IPU_DC_STAT_DC_TRIPLE_BUF_DATA_EMPTY_1      0x00000080

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DC_DISP_CONF2_1 - DC Display Configuration 2 Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SL_1 : 29; //!< Stride line of display 1
        unsigned RESERVED0 : 3; //!< Reserved.
    } B;
} hw_ipu_dc_disp_conf2_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DC_DISP_CONF2_1 register
 */
#define HW_IPU_DC_DISP_CONF2_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x590ec)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DC_DISP_CONF2_1(x)           (*(volatile hw_ipu_dc_disp_conf2_1_t *) HW_IPU_DC_DISP_CONF2_1_ADDR(x))
#define HW_IPU_DC_DISP_CONF2_1_RD(x)        (HW_IPU_DC_DISP_CONF2_1(x).U)
#define HW_IPU_DC_DISP_CONF2_1_WR(x, v)     (HW_IPU_DC_DISP_CONF2_1(x).U = (v))
#define HW_IPU_DC_DISP_CONF2_1_SET(x, v)    (HW_IPU_DC_DISP_CONF2_1_WR(x, HW_IPU_DC_DISP_CONF2_1_RD(x) |  (v)))
#define HW_IPU_DC_DISP_CONF2_1_CLR(x, v)    (HW_IPU_DC_DISP_CONF2_1_WR(x, HW_IPU_DC_DISP_CONF2_1_RD(x) & ~(v)))
#define HW_IPU_DC_DISP_CONF2_1_TOG(x, v)    (HW_IPU_DC_DISP_CONF2_1_WR(x, HW_IPU_DC_DISP_CONF2_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DC_DISP_CONF2_1 bitfields
 */

/* --- Register HW_IPU_DC_DISP_CONF2_1, field SL_1 (RW)
 *
 * Stride line of display 1
 */

#define BP_IPU_DC_DISP_CONF2_1_SL_1      0
#define BM_IPU_DC_DISP_CONF2_1_SL_1      0x1fffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DC_DISP_CONF2_1_SL_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DC_DISP_CONF2_1_SL_1)
#else
#define BF_IPU_DC_DISP_CONF2_1_SL_1(v)   (((v) << 0) & BM_IPU_DC_DISP_CONF2_1_SL_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SL_1 field to a new value.
#define BW_IPU_DC_DISP_CONF2_1_SL_1(v)   BF_CS1(IPU_DC_DISP_CONF2_1, SL_1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_RD_CHAN - DMFC Read Channel Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 6; //!< Reserved.
        unsigned DMFC_BURST_SIZE_0 : 2; //!< Read burst Size This field defines the burst size of the DMFC's read accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
        unsigned RESERVED1 : 9; //!< Reserved.
        unsigned DMFC_WM_EN_0 : 1; //!< Watermark enable. This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_0 : 3; //!< Watermark Set This field defines the watermark's level of the DMFC read FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of free bursts at the FIFO (dmfc_wm_clr_0 > dmfc_wm_set_0)
        unsigned DMFC_WM_CLR_0 : 3; //!< Watermark Clear This field defines the watermark's level of the DMFC read FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of free bursts at the FIFO (dmfc_wm_clr_0 > dmfc_wm_set_0)
        unsigned DMFC_PPW_C : 2; //!< Pixel Per Word coded. This field defines the size of the read data from the display.
        unsigned RESERVED2 : 6; //!< Reserved.
    } B;
} hw_ipu_dmfc_rd_chan_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_RD_CHAN register
 */
#define HW_IPU_DMFC_RD_CHAN_ADDR(x)      (REGS_IPU_BASE(x) + 0x60000)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_RD_CHAN(x)           (*(volatile hw_ipu_dmfc_rd_chan_t *) HW_IPU_DMFC_RD_CHAN_ADDR(x))
#define HW_IPU_DMFC_RD_CHAN_RD(x)        (HW_IPU_DMFC_RD_CHAN(x).U)
#define HW_IPU_DMFC_RD_CHAN_WR(x, v)     (HW_IPU_DMFC_RD_CHAN(x).U = (v))
#define HW_IPU_DMFC_RD_CHAN_SET(x, v)    (HW_IPU_DMFC_RD_CHAN_WR(x, HW_IPU_DMFC_RD_CHAN_RD(x) |  (v)))
#define HW_IPU_DMFC_RD_CHAN_CLR(x, v)    (HW_IPU_DMFC_RD_CHAN_WR(x, HW_IPU_DMFC_RD_CHAN_RD(x) & ~(v)))
#define HW_IPU_DMFC_RD_CHAN_TOG(x, v)    (HW_IPU_DMFC_RD_CHAN_WR(x, HW_IPU_DMFC_RD_CHAN_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_RD_CHAN bitfields
 */

/* --- Register HW_IPU_DMFC_RD_CHAN, field DMFC_BURST_SIZE_0 (RW)
 *
 * Read burst Size This field defines the burst size of the DMFC's read accesses. This settings must
 * match the settings in the corresponding IDMAC channel's settings.
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, going to the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_RD_CHAN_DMFC_BURST_SIZE_0      6
#define BM_IPU_DMFC_RD_CHAN_DMFC_BURST_SIZE_0      0x000000c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_RD_CHAN_DMFC_BURST_SIZE_0(v)   ((((reg32_t) v) << 6) & BM_IPU_DMFC_RD_CHAN_DMFC_BURST_SIZE_0)
#else
#define BF_IPU_DMFC_RD_CHAN_DMFC_BURST_SIZE_0(v)   (((v) << 6) & BM_IPU_DMFC_RD_CHAN_DMFC_BURST_SIZE_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_0 field to a new value.
#define BW_IPU_DMFC_RD_CHAN_DMFC_BURST_SIZE_0(v)   BF_CS1(IPU_DMFC_RD_CHAN, DMFC_BURST_SIZE_0, v)
#endif


/* --- Register HW_IPU_DMFC_RD_CHAN, field DMFC_WM_EN_0 (RW)
 *
 * Watermark enable. This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_RD_CHAN_DMFC_WM_EN_0      17
#define BM_IPU_DMFC_RD_CHAN_DMFC_WM_EN_0      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_RD_CHAN_DMFC_WM_EN_0(v)   ((((reg32_t) v) << 17) & BM_IPU_DMFC_RD_CHAN_DMFC_WM_EN_0)
#else
#define BF_IPU_DMFC_RD_CHAN_DMFC_WM_EN_0(v)   (((v) << 17) & BM_IPU_DMFC_RD_CHAN_DMFC_WM_EN_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_0 field to a new value.
#define BW_IPU_DMFC_RD_CHAN_DMFC_WM_EN_0(v)   BF_CS1(IPU_DMFC_RD_CHAN, DMFC_WM_EN_0, v)
#endif


/* --- Register HW_IPU_DMFC_RD_CHAN, field DMFC_WM_SET_0 (RW)
 *
 * Watermark Set This field defines the watermark's level of the DMFC read FIFO. Crossing this level
 * will send the watermark signal to the IDMAC. The WM level is the amount of free bursts at the
 * FIFO (dmfc_wm_clr_0 > dmfc_wm_set_0)
 */

#define BP_IPU_DMFC_RD_CHAN_DMFC_WM_SET_0      18
#define BM_IPU_DMFC_RD_CHAN_DMFC_WM_SET_0      0x001c0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_RD_CHAN_DMFC_WM_SET_0(v)   ((((reg32_t) v) << 18) & BM_IPU_DMFC_RD_CHAN_DMFC_WM_SET_0)
#else
#define BF_IPU_DMFC_RD_CHAN_DMFC_WM_SET_0(v)   (((v) << 18) & BM_IPU_DMFC_RD_CHAN_DMFC_WM_SET_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_0 field to a new value.
#define BW_IPU_DMFC_RD_CHAN_DMFC_WM_SET_0(v)   BF_CS1(IPU_DMFC_RD_CHAN, DMFC_WM_SET_0, v)
#endif

/* --- Register HW_IPU_DMFC_RD_CHAN, field DMFC_WM_CLR_0 (RW)
 *
 * Watermark Clear This field defines the watermark's level of the DMFC read FIFO. Crossing this
 * level will clear the watermark signal to the IDMAC. The WM level is the amount of free bursts at
 * the FIFO (dmfc_wm_clr_0 > dmfc_wm_set_0)
 */

#define BP_IPU_DMFC_RD_CHAN_DMFC_WM_CLR_0      21
#define BM_IPU_DMFC_RD_CHAN_DMFC_WM_CLR_0      0x00e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_RD_CHAN_DMFC_WM_CLR_0(v)   ((((reg32_t) v) << 21) & BM_IPU_DMFC_RD_CHAN_DMFC_WM_CLR_0)
#else
#define BF_IPU_DMFC_RD_CHAN_DMFC_WM_CLR_0(v)   (((v) << 21) & BM_IPU_DMFC_RD_CHAN_DMFC_WM_CLR_0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_0 field to a new value.
#define BW_IPU_DMFC_RD_CHAN_DMFC_WM_CLR_0(v)   BF_CS1(IPU_DMFC_RD_CHAN, DMFC_WM_CLR_0, v)
#endif

/* --- Register HW_IPU_DMFC_RD_CHAN, field DMFC_PPW_C (RW)
 *
 * Pixel Per Word coded. This field defines the size of the read data from the display.
 *
 * Values:
 * 00 - 8 bit per pixel
 * 01 - 16 bit per pixel
 * 10 - 24 (rgb) bit per pixel or 32 bit per pixel
 * 11 - Reserved
 */

#define BP_IPU_DMFC_RD_CHAN_DMFC_PPW_C      24
#define BM_IPU_DMFC_RD_CHAN_DMFC_PPW_C      0x03000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_RD_CHAN_DMFC_PPW_C(v)   ((((reg32_t) v) << 24) & BM_IPU_DMFC_RD_CHAN_DMFC_PPW_C)
#else
#define BF_IPU_DMFC_RD_CHAN_DMFC_PPW_C(v)   (((v) << 24) & BM_IPU_DMFC_RD_CHAN_DMFC_PPW_C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_PPW_C field to a new value.
#define BW_IPU_DMFC_RD_CHAN_DMFC_PPW_C(v)   BF_CS1(IPU_DMFC_RD_CHAN, DMFC_PPW_C, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_WR_CHAN - DMFC Write Channel Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMFC_ST_ADDR_1 : 3; //!< DMFC Start Address for IDMAC's channel 28 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 28. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the number of the segment
        unsigned DMFC_FIFO_SIZE_1 : 3; //!< DMFC FIFO size for IDMAC's channel 28 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 28
        unsigned DMFC_BURST_SIZE_1 : 2; //!< Burst size of IDMAC's channel 28 This field defines the burst size of the IDMAC's channel 28 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
        unsigned DMFC_ST_ADDR_2 : 3; //!< DMFC Start Address for IDMAC's channel 41 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 41. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the number of the segment
        unsigned DMFC_FIFO_SIZE_2 : 3; //!< DMFC FIFO size for IDMAC's channel 41 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 41
        unsigned DMFC_BURST_SIZE_2 : 2; //!< Burst size of IDMAC's channel 41 This field defines the burst size of the IDMAC's channel 41 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
        unsigned DMFC_ST_ADDR_1C : 3; //!< DMFC Start Address for IDMAC's channel 42 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 42. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the number of the segment
        unsigned DMFC_FIFO_SIZE_1C : 3; //!< DMFC FIFO size for IDMAC's channel 42 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 42
        unsigned DMFC_BURST_SIZE_1C : 2; //!< Burst size of IDMAC's channel 42 This field defines the burst size of the IDMAC's channel 42 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
        unsigned DMFC_ST_ADDR_2C : 3; //!< DMFC Start Address for IDMAC's channel 43 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 43. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the number of the segment
        unsigned DMFC_FIFO_SIZE_2C : 3; //!< DMFC FIFO size for IDMAC's channel 43 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 43
        unsigned DMFC_BURST_SIZE_2C : 2; //!< Burst size of IDMAC's channel 43 This field defines the burst size of the IDMAC's channel 43 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
    } B;
} hw_ipu_dmfc_wr_chan_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_WR_CHAN register
 */
#define HW_IPU_DMFC_WR_CHAN_ADDR(x)      (REGS_IPU_BASE(x) + 0x60004)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_WR_CHAN(x)           (*(volatile hw_ipu_dmfc_wr_chan_t *) HW_IPU_DMFC_WR_CHAN_ADDR(x))
#define HW_IPU_DMFC_WR_CHAN_RD(x)        (HW_IPU_DMFC_WR_CHAN(x).U)
#define HW_IPU_DMFC_WR_CHAN_WR(x, v)     (HW_IPU_DMFC_WR_CHAN(x).U = (v))
#define HW_IPU_DMFC_WR_CHAN_SET(x, v)    (HW_IPU_DMFC_WR_CHAN_WR(x, HW_IPU_DMFC_WR_CHAN_RD(x) |  (v)))
#define HW_IPU_DMFC_WR_CHAN_CLR(x, v)    (HW_IPU_DMFC_WR_CHAN_WR(x, HW_IPU_DMFC_WR_CHAN_RD(x) & ~(v)))
#define HW_IPU_DMFC_WR_CHAN_TOG(x, v)    (HW_IPU_DMFC_WR_CHAN_WR(x, HW_IPU_DMFC_WR_CHAN_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_WR_CHAN bitfields
 */

/* --- Register HW_IPU_DMFC_WR_CHAN, field DMFC_ST_ADDR_1 (RW)
 *
 * DMFC Start Address for IDMAC's channel 28 This field defines the base address at the DMFC's FIFO
 * of the partition allocated to the channel connected to IDMAC's channel 28. The FIFO is
 * partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the
 * number of the segment
 *
 * Values:
 * 000 - Segment 0
 * 001 - Segment 1
 * 111 - Segment 7
 */

#define BP_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1      0
#define BM_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1(v)   ((((reg32_t) v) << 0) & BM_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1)
#else
#define BF_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1(v)   (((v) << 0) & BM_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_ST_ADDR_1 field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1(v)   BF_CS1(IPU_DMFC_WR_CHAN, DMFC_ST_ADDR_1, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN, field DMFC_FIFO_SIZE_1 (RW)
 *
 * DMFC FIFO size for IDMAC's channel 28 This field defines the FIFO partition for the DMFC channel
 * connected to IDMAC's channel 28
 *
 * Values:
 * 000 - All (512X128 words) the DMFC's FIFO is allocated to this channel
 * 001 - 256X128 words are allocated to this channel
 * 010 - 128X128 words are allocated to this channel
 * 011 - 64X128 words are allocated to this channel
 * 100 - 32X128 words are allocated to this channel
 * 101 - 16X128 words are allocated to this channel
 * 110 - 8X128 words are allocated to this channel
 * 111 - 4X128 words are allocated to this channel
 */

#define BP_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1      3
#define BM_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1      0x00000038

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1(v)   ((((reg32_t) v) << 3) & BM_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1)
#else
#define BF_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1(v)   (((v) << 3) & BM_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FIFO_SIZE_1 field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1(v)   BF_CS1(IPU_DMFC_WR_CHAN, DMFC_FIFO_SIZE_1, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN, field DMFC_BURST_SIZE_1 (RW)
 *
 * Burst size of IDMAC's channel 28 This field defines the burst size of the IDMAC's channel 28
 * write accesses. This settings must match the settings in the corresponding IDMAC channel's
 * settings.
 *
 * Values:
 * 00 - 32 words of 1hbit
 */

#define BP_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1      6
#define BM_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1      0x000000c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1(v)   ((((reg32_t) v) << 6) & BM_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1)
#else
#define BF_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1(v)   (((v) << 6) & BM_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_1 field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1(v)   BF_CS1(IPU_DMFC_WR_CHAN, DMFC_BURST_SIZE_1, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN, field DMFC_ST_ADDR_2 (RW)
 *
 * DMFC Start Address for IDMAC's channel 41 This field defines the base address at the DMFC's FIFO
 * of the partition allocated to the channel connected to IDMAC's channel 41. The FIFO is
 * partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the
 * number of the segment
 *
 * Values:
 * 000 - Segment 0
 * 001 - Segment 1
 * 111 - Segment 7
 */

#define BP_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2      8
#define BM_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2      0x00000700

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2(v)   ((((reg32_t) v) << 8) & BM_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2)
#else
#define BF_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2(v)   (((v) << 8) & BM_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_ST_ADDR_2 field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2(v)   BF_CS1(IPU_DMFC_WR_CHAN, DMFC_ST_ADDR_2, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN, field DMFC_FIFO_SIZE_2 (RW)
 *
 * DMFC FIFO size for IDMAC's channel 41 This field defines the FIFO partition for the DMFC channel
 * connected to IDMAC's channel 41
 *
 * Values:
 * 000 - All (512X128 words) the DMFC's FIFO is allocated to this channel
 * 001 - 256X128 words are allocated to this channel
 * 010 - 128X128 words are allocated to this channel
 * 011 - 64X128 words are allocated to this channel
 * 100 - 32X128 words are allocated to this channel
 * 101 - 16X128 words are allocated to this channel
 * 110 - 8X128 words are allocated to this channel
 * 111 - 4X128 words are allocated to this channel
 */

#define BP_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2      11
#define BM_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2      0x00003800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2(v)   ((((reg32_t) v) << 11) & BM_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2)
#else
#define BF_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2(v)   (((v) << 11) & BM_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FIFO_SIZE_2 field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2(v)   BF_CS1(IPU_DMFC_WR_CHAN, DMFC_FIFO_SIZE_2, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN, field DMFC_BURST_SIZE_2 (RW)
 *
 * Burst size of IDMAC's channel 41 This field defines the burst size of the IDMAC's channel 41
 * write accesses. This settings must match the settings in the corresponding IDMAC channel's
 * settings.
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, coming from the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2      14
#define BM_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2(v)   ((((reg32_t) v) << 14) & BM_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2)
#else
#define BF_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2(v)   (((v) << 14) & BM_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_2 field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2(v)   BF_CS1(IPU_DMFC_WR_CHAN, DMFC_BURST_SIZE_2, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN, field DMFC_ST_ADDR_1C (RW)
 *
 * DMFC Start Address for IDMAC's channel 42 This field defines the base address at the DMFC's FIFO
 * of the partition allocated to the channel connected to IDMAC's channel 42. The FIFO is
 * partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the
 * number of the segment
 *
 * Values:
 * 000 - Segment 0
 * 001 - Segment 1
 * 111 - Segment 7
 */

#define BP_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1C      16
#define BM_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1C      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1C(v)   ((((reg32_t) v) << 16) & BM_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1C)
#else
#define BF_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1C(v)   (((v) << 16) & BM_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_ST_ADDR_1C field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_1C(v)   BF_CS1(IPU_DMFC_WR_CHAN, DMFC_ST_ADDR_1C, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN, field DMFC_FIFO_SIZE_1C (RW)
 *
 * DMFC FIFO size for IDMAC's channel 42 This field defines the FIFO partition for the DMFC channel
 * connected to IDMAC's channel 42
 *
 * Values:
 * 000 - All (512X128 words) the DMFC's FIFO is allocated to this channel
 * 001 - 256X128 words are allocated to this channel
 * 010 - 128X128 words are allocated to this channel
 * 011 - 64X128 words are allocated to this channel
 * 100 - 32X128 words are allocated to this channel
 * 101 - 16X128 words are allocated to this channel
 * 110 - 8X128 words are allocated to this channel
 * 111 - 4X128 words are allocated to this channel
 */

#define BP_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1C      19
#define BM_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1C      0x00380000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1C(v)   ((((reg32_t) v) << 19) & BM_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1C)
#else
#define BF_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1C(v)   (((v) << 19) & BM_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FIFO_SIZE_1C field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_1C(v)   BF_CS1(IPU_DMFC_WR_CHAN, DMFC_FIFO_SIZE_1C, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN, field DMFC_BURST_SIZE_1C (RW)
 *
 * Burst size of IDMAC's channel 42 This field defines the burst size of the IDMAC's channel 42
 * write accesses. This settings must match the settings in the corresponding IDMAC channel's
 * settings.
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, coming from the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1C      22
#define BM_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1C      0x00c00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1C(v)   ((((reg32_t) v) << 22) & BM_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1C)
#else
#define BF_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1C(v)   (((v) << 22) & BM_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_1C field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_1C(v)   BF_CS1(IPU_DMFC_WR_CHAN, DMFC_BURST_SIZE_1C, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN, field DMFC_ST_ADDR_2C (RW)
 *
 * DMFC Start Address for IDMAC's channel 43 This field defines the base address at the DMFC's FIFO
 * of the partition allocated to the channel connected to IDMAC's channel 43. The FIFO is
 * partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the
 * number of the segment
 *
 * Values:
 * 000 - Segment 0
 * 001 - Segment 1
 * 111 - Segment 7
 */

#define BP_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2C      24
#define BM_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2C      0x07000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2C(v)   ((((reg32_t) v) << 24) & BM_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2C)
#else
#define BF_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2C(v)   (((v) << 24) & BM_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_ST_ADDR_2C field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DMFC_ST_ADDR_2C(v)   BF_CS1(IPU_DMFC_WR_CHAN, DMFC_ST_ADDR_2C, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN, field DMFC_FIFO_SIZE_2C (RW)
 *
 * DMFC FIFO size for IDMAC's channel 43 This field defines the FIFO partition for the DMFC channel
 * connected to IDMAC's channel 43
 *
 * Values:
 * 000 - All (512X128 words) the DMFC's FIFO is allocated to this channel
 * 001 - 256X128 words are allocated to this channel
 * 010 - 128X128 words are allocated to this channel
 * 011 - 64X128 words are allocated to this channel
 * 100 - 32X128 words are allocated to this channel
 * 101 - 16X128 words are allocated to this channel
 * 110 - 8X128 words are allocated to this channel
 * 111 - 4X128 words are allocated to this channel
 */

#define BP_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2C      27
#define BM_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2C      0x38000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2C(v)   ((((reg32_t) v) << 27) & BM_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2C)
#else
#define BF_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2C(v)   (((v) << 27) & BM_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FIFO_SIZE_2C field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DMFC_FIFO_SIZE_2C(v)   BF_CS1(IPU_DMFC_WR_CHAN, DMFC_FIFO_SIZE_2C, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN, field DMFC_BURST_SIZE_2C (RW)
 *
 * Burst size of IDMAC's channel 43 This field defines the burst size of the IDMAC's channel 43
 * write accesses. This settings must match the settings in the corresponding IDMAC channel's
 * settings.
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, coming from the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2C      30
#define BM_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2C      0xc0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2C(v)   ((((reg32_t) v) << 30) & BM_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2C)
#else
#define BF_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2C(v)   (((v) << 30) & BM_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_2C field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DMFC_BURST_SIZE_2C(v)   BF_CS1(IPU_DMFC_WR_CHAN, DMFC_BURST_SIZE_2C, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_WR_CHAN_DEF - DMFC Write Channel Definition Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DMFC_WM_EN_1 : 1; //!< Watermark enable. This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_1 : 3; //!< Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_1 : 3; //!< Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned DMFC_WM_EN_2 : 1; //!< Watermark enable. This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_2 : 3; //!< Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_2 : 3; //!< Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned DMFC_WM_EN_1C : 1; //!< Watermark enable. This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_1C : 3; //!< Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_1C : 3; //!< Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
        unsigned RESERVED3 : 1; //!< Reserved
        unsigned DMFC_WM_EN_2C : 1; //!< Watermark enable. This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_2C : 3; //!< Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_2C : 3; //!< Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
    } B;
} hw_ipu_dmfc_wr_chan_def_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_WR_CHAN_DEF register
 */
#define HW_IPU_DMFC_WR_CHAN_DEF_ADDR(x)      (REGS_IPU_BASE(x) + 0x60008)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_WR_CHAN_DEF(x)           (*(volatile hw_ipu_dmfc_wr_chan_def_t *) HW_IPU_DMFC_WR_CHAN_DEF_ADDR(x))
#define HW_IPU_DMFC_WR_CHAN_DEF_RD(x)        (HW_IPU_DMFC_WR_CHAN_DEF(x).U)
#define HW_IPU_DMFC_WR_CHAN_DEF_WR(x, v)     (HW_IPU_DMFC_WR_CHAN_DEF(x).U = (v))
#define HW_IPU_DMFC_WR_CHAN_DEF_SET(x, v)    (HW_IPU_DMFC_WR_CHAN_DEF_WR(x, HW_IPU_DMFC_WR_CHAN_DEF_RD(x) |  (v)))
#define HW_IPU_DMFC_WR_CHAN_DEF_CLR(x, v)    (HW_IPU_DMFC_WR_CHAN_DEF_WR(x, HW_IPU_DMFC_WR_CHAN_DEF_RD(x) & ~(v)))
#define HW_IPU_DMFC_WR_CHAN_DEF_TOG(x, v)    (HW_IPU_DMFC_WR_CHAN_DEF_WR(x, HW_IPU_DMFC_WR_CHAN_DEF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_WR_CHAN_DEF bitfields
 */

/* --- Register HW_IPU_DMFC_WR_CHAN_DEF, field DMFC_WM_EN_1 (RW)
 *
 * Watermark enable. This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1      1
#define BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1(v)   ((((reg32_t) v) << 1) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1(v)   (((v) << 1) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_1 field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF, DMFC_WM_EN_1, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN_DEF, field DMFC_WM_SET_1 (RW)
 *
 * Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this
 * level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1      2
#define BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1      0x0000001c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1(v)   ((((reg32_t) v) << 2) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1(v)   (((v) << 2) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_1 field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF, DMFC_WM_SET_1, v)
#endif

/* --- Register HW_IPU_DMFC_WR_CHAN_DEF, field DMFC_WM_CLR_1 (RW)
 *
 * Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this
 * level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1      5
#define BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1      0x000000e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1(v)   ((((reg32_t) v) << 5) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1(v)   (((v) << 5) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_1 field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF, DMFC_WM_CLR_1, v)
#endif

/* --- Register HW_IPU_DMFC_WR_CHAN_DEF, field DMFC_WM_EN_2 (RW)
 *
 * Watermark enable. This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2      9
#define BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2(v)   ((((reg32_t) v) << 9) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2(v)   (((v) << 9) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_2 field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF, DMFC_WM_EN_2, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN_DEF, field DMFC_WM_SET_2 (RW)
 *
 * Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this
 * level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2      10
#define BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2      0x00001c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2(v)   ((((reg32_t) v) << 10) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2(v)   (((v) << 10) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_2 field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF, DMFC_WM_SET_2, v)
#endif

/* --- Register HW_IPU_DMFC_WR_CHAN_DEF, field DMFC_WM_CLR_2 (RW)
 *
 * Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this
 * level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2      13
#define BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2      0x0000e000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2(v)   ((((reg32_t) v) << 13) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2(v)   (((v) << 13) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_2 field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF, DMFC_WM_CLR_2, v)
#endif

/* --- Register HW_IPU_DMFC_WR_CHAN_DEF, field DMFC_WM_EN_1C (RW)
 *
 * Watermark enable. This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1C      17
#define BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1C      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1C(v)   ((((reg32_t) v) << 17) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1C)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1C(v)   (((v) << 17) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_1C field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_1C(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF, DMFC_WM_EN_1C, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN_DEF, field DMFC_WM_SET_1C (RW)
 *
 * Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this
 * level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1C      18
#define BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1C      0x001c0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1C(v)   ((((reg32_t) v) << 18) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1C)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1C(v)   (((v) << 18) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_1C field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_1C(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF, DMFC_WM_SET_1C, v)
#endif

/* --- Register HW_IPU_DMFC_WR_CHAN_DEF, field DMFC_WM_CLR_1C (RW)
 *
 * Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this
 * level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1C      21
#define BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1C      0x00e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1C(v)   ((((reg32_t) v) << 21) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1C)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1C(v)   (((v) << 21) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_1C field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_1C(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF, DMFC_WM_CLR_1C, v)
#endif

/* --- Register HW_IPU_DMFC_WR_CHAN_DEF, field DMFC_WM_EN_2C (RW)
 *
 * Watermark enable. This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2C      25
#define BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2C      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2C(v)   ((((reg32_t) v) << 25) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2C)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2C(v)   (((v) << 25) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_2C field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_EN_2C(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF, DMFC_WM_EN_2C, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN_DEF, field DMFC_WM_SET_2C (RW)
 *
 * Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this
 * level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2C      26
#define BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2C      0x1c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2C(v)   ((((reg32_t) v) << 26) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2C)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2C(v)   (((v) << 26) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_2C field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_SET_2C(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF, DMFC_WM_SET_2C, v)
#endif

/* --- Register HW_IPU_DMFC_WR_CHAN_DEF, field DMFC_WM_CLR_2C (RW)
 *
 * Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this
 * level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2C      29
#define BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2C      0xe0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2C(v)   ((((reg32_t) v) << 29) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2C)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2C(v)   (((v) << 29) & BM_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_2C field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_DMFC_WM_CLR_2C(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF, DMFC_WM_CLR_2C, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_DP_CHAN - DMFC Display Processor Channel Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMFC_ST_ADDR_5B : 3; //!< DMFC Start Address for IDMAC's channel 23 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 23. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the number of the segment
        unsigned DMFC_FIFO_SIZE_5B : 3; //!< DMFC FIFO size for IDMAC's channel 23 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 23
        unsigned DMFC_BURST_SIZE_5B : 2; //!< Burst size of IDMAC's channel 23 This field defines the burst size of the IDMAC's channel 23 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
        unsigned DMFC_ST_ADDR_5F : 3; //!< DMFC Start Address for IDMAC's channel 27 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 27. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the number of the segment
        unsigned DMFC_FIFO_SIZE_5F : 3; //!< DMFC FIFO size for IDMAC's channel 27 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 27
        unsigned DMFC_BURST_SIZE_5F : 2; //!< Burst size of IDMAC's channel 27 This field defines the burst size of the IDMAC's channel 27 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
        unsigned DMFC_ST_ADDR_6B : 3; //!< DMFC Start Address for IDMAC's channel 24 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 24. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the number of the segment
        unsigned DMFC_FIFO_SIZE_6B : 3; //!< DMFC FIFO size for IDMAC's channel 24 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 24
        unsigned DMFC_BURST_SIZE_6B : 2; //!< Burst size of IDMAC's channel 24 This field defines the burst size of the IDMAC's channel 24 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
        unsigned DMFC_ST_ADDR_6F : 3; //!< DMFC Start Address for IDMAC's channel 29 This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 29. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the number of the segment
        unsigned DMFC_FIFO_SIZE_6F : 3; //!< DMFC FIFO size for IDMAC's channel 29 This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 29
        unsigned DMFC_BURST_SIZE_6F : 2; //!< Burst size of IDMAC's channel 29 This field defines the burst size of the IDMAC's channel 29 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
    } B;
} hw_ipu_dmfc_dp_chan_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_DP_CHAN register
 */
#define HW_IPU_DMFC_DP_CHAN_ADDR(x)      (REGS_IPU_BASE(x) + 0x6000c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_DP_CHAN(x)           (*(volatile hw_ipu_dmfc_dp_chan_t *) HW_IPU_DMFC_DP_CHAN_ADDR(x))
#define HW_IPU_DMFC_DP_CHAN_RD(x)        (HW_IPU_DMFC_DP_CHAN(x).U)
#define HW_IPU_DMFC_DP_CHAN_WR(x, v)     (HW_IPU_DMFC_DP_CHAN(x).U = (v))
#define HW_IPU_DMFC_DP_CHAN_SET(x, v)    (HW_IPU_DMFC_DP_CHAN_WR(x, HW_IPU_DMFC_DP_CHAN_RD(x) |  (v)))
#define HW_IPU_DMFC_DP_CHAN_CLR(x, v)    (HW_IPU_DMFC_DP_CHAN_WR(x, HW_IPU_DMFC_DP_CHAN_RD(x) & ~(v)))
#define HW_IPU_DMFC_DP_CHAN_TOG(x, v)    (HW_IPU_DMFC_DP_CHAN_WR(x, HW_IPU_DMFC_DP_CHAN_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_DP_CHAN bitfields
 */

/* --- Register HW_IPU_DMFC_DP_CHAN, field DMFC_ST_ADDR_5B (RW)
 *
 * DMFC Start Address for IDMAC's channel 23 This field defines the base address at the DMFC's FIFO
 * of the partition allocated to the channel connected to IDMAC's channel 23. The FIFO is
 * partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the
 * number of the segment
 *
 * Values:
 * 000 - Segment 0
 * 001 - Segment 1
 * 111 - Segment 7
 */

#define BP_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5B      0
#define BM_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5B      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5B(v)   ((((reg32_t) v) << 0) & BM_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5B)
#else
#define BF_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5B(v)   (((v) << 0) & BM_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_ST_ADDR_5B field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5B(v)   BF_CS1(IPU_DMFC_DP_CHAN, DMFC_ST_ADDR_5B, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN, field DMFC_FIFO_SIZE_5B (RW)
 *
 * DMFC FIFO size for IDMAC's channel 23 This field defines the FIFO partition for the DMFC channel
 * connected to IDMAC's channel 23
 *
 * Values:
 * 000 - All (512X128 words) the DMFC's FIFO is allocated to this channel
 * 001 - 256X128 words are allocated to this channel
 * 010 - 128X128 words are allocated to this channel
 * 011 - 64X128 words are allocated to this channel
 * 100 - 32X128 words are allocated to this channel
 * 101 - 16X128 words are allocated to this channel
 * 110 - 8X128 words are allocated to this channel
 * 111 - 4X128 words are allocated to this channel
 */

#define BP_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5B      3
#define BM_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5B      0x00000038

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5B(v)   ((((reg32_t) v) << 3) & BM_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5B)
#else
#define BF_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5B(v)   (((v) << 3) & BM_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FIFO_SIZE_5B field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5B(v)   BF_CS1(IPU_DMFC_DP_CHAN, DMFC_FIFO_SIZE_5B, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN, field DMFC_BURST_SIZE_5B (RW)
 *
 * Burst size of IDMAC's channel 23 This field defines the burst size of the IDMAC's channel 23
 * write accesses. This settings must match the settings in the corresponding IDMAC channel's
 * settings.
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, coming from the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5B      6
#define BM_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5B      0x000000c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5B(v)   ((((reg32_t) v) << 6) & BM_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5B)
#else
#define BF_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5B(v)   (((v) << 6) & BM_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_5B field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5B(v)   BF_CS1(IPU_DMFC_DP_CHAN, DMFC_BURST_SIZE_5B, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN, field DMFC_ST_ADDR_5F (RW)
 *
 * DMFC Start Address for IDMAC's channel 27 This field defines the base address at the DMFC's FIFO
 * of the partition allocated to the channel connected to IDMAC's channel 27. The FIFO is
 * partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the
 * number of the segment
 *
 * Values:
 * 000 - Segment 0
 * 001 - Segment 1
 * 111 - Segment 7
 */

#define BP_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5F      8
#define BM_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5F      0x00000700

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5F(v)   ((((reg32_t) v) << 8) & BM_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5F)
#else
#define BF_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5F(v)   (((v) << 8) & BM_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_ST_ADDR_5F field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_5F(v)   BF_CS1(IPU_DMFC_DP_CHAN, DMFC_ST_ADDR_5F, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN, field DMFC_FIFO_SIZE_5F (RW)
 *
 * DMFC FIFO size for IDMAC's channel 27 This field defines the FIFO partition for the DMFC channel
 * connected to IDMAC's channel 27
 *
 * Values:
 * 000 - All (512X128 words) the DMFC's FIFO is allocated to this channel
 * 001 - 256X128 words are allocated to this channel
 * 010 - 128X128 words are allocated to this channel
 * 011 - 64X128 words are allocated to this channel
 * 100 - 32X128 words are allocated to this channel
 * 101 - 16X128 words are allocated to this channel
 * 110 - 8X128 words are allocated to this channel
 * 111 - 4X128 words are allocated to this channel
 */

#define BP_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5F      11
#define BM_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5F      0x00003800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5F(v)   ((((reg32_t) v) << 11) & BM_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5F)
#else
#define BF_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5F(v)   (((v) << 11) & BM_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FIFO_SIZE_5F field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_5F(v)   BF_CS1(IPU_DMFC_DP_CHAN, DMFC_FIFO_SIZE_5F, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN, field DMFC_BURST_SIZE_5F (RW)
 *
 * Burst size of IDMAC's channel 27 This field defines the burst size of the IDMAC's channel 27
 * write accesses. This settings must match the settings in the corresponding IDMAC channel's
 * settings.
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, coming from the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5F      14
#define BM_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5F      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5F(v)   ((((reg32_t) v) << 14) & BM_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5F)
#else
#define BF_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5F(v)   (((v) << 14) & BM_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_5F field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_5F(v)   BF_CS1(IPU_DMFC_DP_CHAN, DMFC_BURST_SIZE_5F, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN, field DMFC_ST_ADDR_6B (RW)
 *
 * DMFC Start Address for IDMAC's channel 24 This field defines the base address at the DMFC's FIFO
 * of the partition allocated to the channel connected to IDMAC's channel 24. The FIFO is
 * partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the
 * number of the segment
 *
 * Values:
 * 000 - Segment 0
 * 001 - Segment 1
 * 111 - Segment 7
 */

#define BP_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6B      16
#define BM_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6B      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6B(v)   ((((reg32_t) v) << 16) & BM_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6B)
#else
#define BF_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6B(v)   (((v) << 16) & BM_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_ST_ADDR_6B field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6B(v)   BF_CS1(IPU_DMFC_DP_CHAN, DMFC_ST_ADDR_6B, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN, field DMFC_FIFO_SIZE_6B (RW)
 *
 * DMFC FIFO size for IDMAC's channel 24 This field defines the FIFO partition for the DMFC channel
 * connected to IDMAC's channel 24
 *
 * Values:
 * 000 - All (512X128 words) the DMFC's FIFO is allocated to this channel
 * 001 - 256X128 words are allocated to this channel
 * 010 - 128X128 words are allocated to this channel
 * 011 - 64X128 words are allocated to this channel
 * 100 - 32X128 words are allocated to this channel
 * 101 - 16X128 words are allocated to this channel
 * 110 - 8X128 words are allocated to this channel
 * 111 - 4X128 words are allocated to this channel
 */

#define BP_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6B      19
#define BM_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6B      0x00380000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6B(v)   ((((reg32_t) v) << 19) & BM_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6B)
#else
#define BF_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6B(v)   (((v) << 19) & BM_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FIFO_SIZE_6B field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6B(v)   BF_CS1(IPU_DMFC_DP_CHAN, DMFC_FIFO_SIZE_6B, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN, field DMFC_BURST_SIZE_6B (RW)
 *
 * Burst size of IDMAC's channel 24 This field defines the burst size of the IDMAC's channel 24
 * write accesses. This settings must match the settings in the corresponding IDMAC channel's
 * settings.
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, coming from the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6B      22
#define BM_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6B      0x00c00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6B(v)   ((((reg32_t) v) << 22) & BM_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6B)
#else
#define BF_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6B(v)   (((v) << 22) & BM_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_6B field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6B(v)   BF_CS1(IPU_DMFC_DP_CHAN, DMFC_BURST_SIZE_6B, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN, field DMFC_ST_ADDR_6F (RW)
 *
 * DMFC Start Address for IDMAC's channel 29 This field defines the base address at the DMFC's FIFO
 * of the partition allocated to the channel connected to IDMAC's channel 29. The FIFO is
 * partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the
 * number of the segment
 *
 * Values:
 * 000 - Segment 0
 * 001 - Segment 1
 * 111 - Segment 7
 */

#define BP_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6F      24
#define BM_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6F      0x07000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6F(v)   ((((reg32_t) v) << 24) & BM_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6F)
#else
#define BF_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6F(v)   (((v) << 24) & BM_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_ST_ADDR_6F field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DMFC_ST_ADDR_6F(v)   BF_CS1(IPU_DMFC_DP_CHAN, DMFC_ST_ADDR_6F, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN, field DMFC_FIFO_SIZE_6F (RW)
 *
 * DMFC FIFO size for IDMAC's channel 29 This field defines the FIFO partition for the DMFC channel
 * connected to IDMAC's channel 29
 *
 * Values:
 * 000 - All (512X128 words) the DMFC's FIFO is allocated to this channel
 * 001 - 256X128 words are allocated to this channel
 * 010 - 128X128 words are allocated to this channel
 * 011 - 64X128 words are allocated to this channel
 * 100 - 32X128 words are allocated to this channel
 * 101 - 16X128 words are allocated to this channel
 * 110 - 8X128 words are allocated to this channel
 * 111 - 4X128 words are allocated to this channel
 */

#define BP_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6F      27
#define BM_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6F      0x38000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6F(v)   ((((reg32_t) v) << 27) & BM_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6F)
#else
#define BF_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6F(v)   (((v) << 27) & BM_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FIFO_SIZE_6F field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DMFC_FIFO_SIZE_6F(v)   BF_CS1(IPU_DMFC_DP_CHAN, DMFC_FIFO_SIZE_6F, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN, field DMFC_BURST_SIZE_6F (RW)
 *
 * Burst size of IDMAC's channel 29 This field defines the burst size of the IDMAC's channel 29
 * write accesses. This settings must match the settings in the corresponding IDMAC channel's
 * settings.
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, coming from the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6F      30
#define BM_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6F      0xc0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6F(v)   ((((reg32_t) v) << 30) & BM_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6F)
#else
#define BF_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6F(v)   (((v) << 30) & BM_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_6F field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DMFC_BURST_SIZE_6F(v)   BF_CS1(IPU_DMFC_DP_CHAN, DMFC_BURST_SIZE_6F, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_DP_CHAN_DEF - DMFC Display Processor Channel Definition Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DMFC_WM_EN_5B : 1; //!< Watermark enable. This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_5B : 3; //!< Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_5B : 3; //!< Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned DMFC_WM_EN_5F : 1; //!< Watermark enable. This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_5F : 3; //!< Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_5F : 3; //!< Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned DMFC_WM_EN_6B : 1; //!< Watermark enable. This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_6B : 3; //!< Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_6B : 3; //!< Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
        unsigned RESERVED3 : 1; //!< Reserved
        unsigned DMFC_WM_EN_6F : 1; //!< Watermark enable. This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_6F : 3; //!< Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_6F : 3; //!< Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
    } B;
} hw_ipu_dmfc_dp_chan_def_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_DP_CHAN_DEF register
 */
#define HW_IPU_DMFC_DP_CHAN_DEF_ADDR(x)      (REGS_IPU_BASE(x) + 0x60010)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_DP_CHAN_DEF(x)           (*(volatile hw_ipu_dmfc_dp_chan_def_t *) HW_IPU_DMFC_DP_CHAN_DEF_ADDR(x))
#define HW_IPU_DMFC_DP_CHAN_DEF_RD(x)        (HW_IPU_DMFC_DP_CHAN_DEF(x).U)
#define HW_IPU_DMFC_DP_CHAN_DEF_WR(x, v)     (HW_IPU_DMFC_DP_CHAN_DEF(x).U = (v))
#define HW_IPU_DMFC_DP_CHAN_DEF_SET(x, v)    (HW_IPU_DMFC_DP_CHAN_DEF_WR(x, HW_IPU_DMFC_DP_CHAN_DEF_RD(x) |  (v)))
#define HW_IPU_DMFC_DP_CHAN_DEF_CLR(x, v)    (HW_IPU_DMFC_DP_CHAN_DEF_WR(x, HW_IPU_DMFC_DP_CHAN_DEF_RD(x) & ~(v)))
#define HW_IPU_DMFC_DP_CHAN_DEF_TOG(x, v)    (HW_IPU_DMFC_DP_CHAN_DEF_WR(x, HW_IPU_DMFC_DP_CHAN_DEF_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_DP_CHAN_DEF bitfields
 */

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF, field DMFC_WM_EN_5B (RW)
 *
 * Watermark enable. This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5B      1
#define BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5B      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5B(v)   ((((reg32_t) v) << 1) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5B)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5B(v)   (((v) << 1) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_5B field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5B(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF, DMFC_WM_EN_5B, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_DEF, field DMFC_WM_SET_5B (RW)
 *
 * Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this
 * level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5B      2
#define BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5B      0x0000001c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5B(v)   ((((reg32_t) v) << 2) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5B)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5B(v)   (((v) << 2) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_5B field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5B(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF, DMFC_WM_SET_5B, v)
#endif

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF, field DMFC_WM_CLR_5B (RW)
 *
 * Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this
 * level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5B      5
#define BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5B      0x000000e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5B(v)   ((((reg32_t) v) << 5) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5B)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5B(v)   (((v) << 5) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_5B field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5B(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF, DMFC_WM_CLR_5B, v)
#endif

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF, field DMFC_WM_EN_5F (RW)
 *
 * Watermark enable. This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5F      9
#define BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5F      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5F(v)   ((((reg32_t) v) << 9) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5F)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5F(v)   (((v) << 9) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_5F field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_5F(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF, DMFC_WM_EN_5F, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_DEF, field DMFC_WM_SET_5F (RW)
 *
 * Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this
 * level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5F      10
#define BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5F      0x00001c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5F(v)   ((((reg32_t) v) << 10) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5F)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5F(v)   (((v) << 10) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_5F field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_5F(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF, DMFC_WM_SET_5F, v)
#endif

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF, field DMFC_WM_CLR_5F (RW)
 *
 * Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this
 * level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5F      13
#define BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5F      0x0000e000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5F(v)   ((((reg32_t) v) << 13) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5F)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5F(v)   (((v) << 13) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_5F field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_5F(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF, DMFC_WM_CLR_5F, v)
#endif

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF, field DMFC_WM_EN_6B (RW)
 *
 * Watermark enable. This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6B      17
#define BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6B      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6B(v)   ((((reg32_t) v) << 17) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6B)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6B(v)   (((v) << 17) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_6B field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6B(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF, DMFC_WM_EN_6B, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_DEF, field DMFC_WM_SET_6B (RW)
 *
 * Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this
 * level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6B      18
#define BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6B      0x001c0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6B(v)   ((((reg32_t) v) << 18) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6B)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6B(v)   (((v) << 18) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_6B field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6B(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF, DMFC_WM_SET_6B, v)
#endif

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF, field DMFC_WM_CLR_6B (RW)
 *
 * Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this
 * level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6B      21
#define BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6B      0x00e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6B(v)   ((((reg32_t) v) << 21) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6B)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6B(v)   (((v) << 21) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_6B field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6B(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF, DMFC_WM_CLR_6B, v)
#endif

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF, field DMFC_WM_EN_6F (RW)
 *
 * Watermark enable. This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6F      25
#define BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6F      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6F(v)   ((((reg32_t) v) << 25) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6F)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6F(v)   (((v) << 25) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_6F field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_EN_6F(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF, DMFC_WM_EN_6F, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_DEF, field DMFC_WM_SET_6F (RW)
 *
 * Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this
 * level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6F      26
#define BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6F      0x1c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6F(v)   ((((reg32_t) v) << 26) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6F)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6F(v)   (((v) << 26) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_6F field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_SET_6F(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF, DMFC_WM_SET_6F, v)
#endif

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF, field DMFC_WM_CLR_6F (RW)
 *
 * Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this
 * level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6F      29
#define BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6F      0xe0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6F(v)   ((((reg32_t) v) << 29) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6F)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6F(v)   (((v) << 29) & BM_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_6F field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_DMFC_WM_CLR_6F(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF, DMFC_WM_CLR_6F, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_GENERAL_1 - DMFC General 1 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMFC_DCDP_SYNC_PR : 2; //!< DMFC's memory access priority settings for simultaneous synchronous flows from DC & DP
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned DMFC_BURST_SIZE_9 : 2; //!< Burst size of IDMAC's channel 44 This field defines the burst size of the IDMAC's channel 44 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings. This channel is targeted for MASK - the FIFO size is always 32X128; The base address is always the upper half of the 8th segment
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned DMFC_WM_EN_9 : 1; //!< Watermark enable. This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_9 : 3; //!< Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_9 : 3; //!< Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
        unsigned WAIT4EOT_1 : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned WAIT4EOT_2 : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned WAIT4EOT_3 : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned WAIT4EOT_4 : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned WAIT4EOT_5B : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned WAIT4EOT_5F : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned WAIT4EOT_6B : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned WAIT4EOT_6F : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned WAIT4EOT_9 : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned RESERVED3 : 7; //!< Reserved.
    } B;
} hw_ipu_dmfc_general_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_GENERAL_1 register
 */
#define HW_IPU_DMFC_GENERAL_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x60014)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_GENERAL_1(x)           (*(volatile hw_ipu_dmfc_general_1_t *) HW_IPU_DMFC_GENERAL_1_ADDR(x))
#define HW_IPU_DMFC_GENERAL_1_RD(x)        (HW_IPU_DMFC_GENERAL_1(x).U)
#define HW_IPU_DMFC_GENERAL_1_WR(x, v)     (HW_IPU_DMFC_GENERAL_1(x).U = (v))
#define HW_IPU_DMFC_GENERAL_1_SET(x, v)    (HW_IPU_DMFC_GENERAL_1_WR(x, HW_IPU_DMFC_GENERAL_1_RD(x) |  (v)))
#define HW_IPU_DMFC_GENERAL_1_CLR(x, v)    (HW_IPU_DMFC_GENERAL_1_WR(x, HW_IPU_DMFC_GENERAL_1_RD(x) & ~(v)))
#define HW_IPU_DMFC_GENERAL_1_TOG(x, v)    (HW_IPU_DMFC_GENERAL_1_WR(x, HW_IPU_DMFC_GENERAL_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_GENERAL_1 bitfields
 */

/* --- Register HW_IPU_DMFC_GENERAL_1, field DMFC_DCDP_SYNC_PR (RW)
 *
 * DMFC's memory access priority settings for simultaneous synchronous flows from DC & DP
 *
 * Values:
 * 00 - Forbidden - should not be used.
 * 01 - DC has higher priority over DP
 * 10 - DP has higher priority over DC
 * 11 - Round Robin
 */

#define BP_IPU_DMFC_GENERAL_1_DMFC_DCDP_SYNC_PR      0
#define BM_IPU_DMFC_GENERAL_1_DMFC_DCDP_SYNC_PR      0x00000003

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_DMFC_DCDP_SYNC_PR(v)   ((((reg32_t) v) << 0) & BM_IPU_DMFC_GENERAL_1_DMFC_DCDP_SYNC_PR)
#else
#define BF_IPU_DMFC_GENERAL_1_DMFC_DCDP_SYNC_PR(v)   (((v) << 0) & BM_IPU_DMFC_GENERAL_1_DMFC_DCDP_SYNC_PR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_DCDP_SYNC_PR field to a new value.
#define BW_IPU_DMFC_GENERAL_1_DMFC_DCDP_SYNC_PR(v)   BF_CS1(IPU_DMFC_GENERAL_1, DMFC_DCDP_SYNC_PR, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL_1, field DMFC_BURST_SIZE_9 (RW)
 *
 * Burst size of IDMAC's channel 44 This field defines the burst size of the IDMAC's channel 44
 * write accesses. This settings must match the settings in the corresponding IDMAC channel's
 * settings. This channel is targeted for MASK - the FIFO size is always 32X128; The base address is
 * always the upper half of the 8th segment
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, coming from the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_GENERAL_1_DMFC_BURST_SIZE_9      5
#define BM_IPU_DMFC_GENERAL_1_DMFC_BURST_SIZE_9      0x00000060

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_DMFC_BURST_SIZE_9(v)   ((((reg32_t) v) << 5) & BM_IPU_DMFC_GENERAL_1_DMFC_BURST_SIZE_9)
#else
#define BF_IPU_DMFC_GENERAL_1_DMFC_BURST_SIZE_9(v)   (((v) << 5) & BM_IPU_DMFC_GENERAL_1_DMFC_BURST_SIZE_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_9 field to a new value.
#define BW_IPU_DMFC_GENERAL_1_DMFC_BURST_SIZE_9(v)   BF_CS1(IPU_DMFC_GENERAL_1, DMFC_BURST_SIZE_9, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL_1, field DMFC_WM_EN_9 (RW)
 *
 * Watermark enable. This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_GENERAL_1_DMFC_WM_EN_9      9
#define BM_IPU_DMFC_GENERAL_1_DMFC_WM_EN_9      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_DMFC_WM_EN_9(v)   ((((reg32_t) v) << 9) & BM_IPU_DMFC_GENERAL_1_DMFC_WM_EN_9)
#else
#define BF_IPU_DMFC_GENERAL_1_DMFC_WM_EN_9(v)   (((v) << 9) & BM_IPU_DMFC_GENERAL_1_DMFC_WM_EN_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_9 field to a new value.
#define BW_IPU_DMFC_GENERAL_1_DMFC_WM_EN_9(v)   BF_CS1(IPU_DMFC_GENERAL_1, DMFC_WM_EN_9, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL_1, field DMFC_WM_SET_9 (RW)
 *
 * Watermark Set This field defines the watermark's level of the DMFC write FIFO. Crossing this
 * level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_GENERAL_1_DMFC_WM_SET_9      10
#define BM_IPU_DMFC_GENERAL_1_DMFC_WM_SET_9      0x00001c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_DMFC_WM_SET_9(v)   ((((reg32_t) v) << 10) & BM_IPU_DMFC_GENERAL_1_DMFC_WM_SET_9)
#else
#define BF_IPU_DMFC_GENERAL_1_DMFC_WM_SET_9(v)   (((v) << 10) & BM_IPU_DMFC_GENERAL_1_DMFC_WM_SET_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_9 field to a new value.
#define BW_IPU_DMFC_GENERAL_1_DMFC_WM_SET_9(v)   BF_CS1(IPU_DMFC_GENERAL_1, DMFC_WM_SET_9, v)
#endif

/* --- Register HW_IPU_DMFC_GENERAL_1, field DMFC_WM_CLR_9 (RW)
 *
 * Watermark Clear This field defines the watermark's level of the DMFC's write FIFO. Crossing this
 * level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts
 * at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_GENERAL_1_DMFC_WM_CLR_9      13
#define BM_IPU_DMFC_GENERAL_1_DMFC_WM_CLR_9      0x0000e000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_DMFC_WM_CLR_9(v)   ((((reg32_t) v) << 13) & BM_IPU_DMFC_GENERAL_1_DMFC_WM_CLR_9)
#else
#define BF_IPU_DMFC_GENERAL_1_DMFC_WM_CLR_9(v)   (((v) << 13) & BM_IPU_DMFC_GENERAL_1_DMFC_WM_CLR_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_9 field to a new value.
#define BW_IPU_DMFC_GENERAL_1_DMFC_WM_CLR_9(v)   BF_CS1(IPU_DMFC_GENERAL_1, DMFC_WM_CLR_9, v)
#endif

/* --- Register HW_IPU_DMFC_GENERAL_1, field WAIT4EOT_1 (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #1 is in wait4eot mode
 * 0 - FIFO #1 is in normal mode
 */

#define BP_IPU_DMFC_GENERAL_1_WAIT4EOT_1      16
#define BM_IPU_DMFC_GENERAL_1_WAIT4EOT_1      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_1(v)   ((((reg32_t) v) << 16) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_1)
#else
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_1(v)   (((v) << 16) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_1 field to a new value.
#define BW_IPU_DMFC_GENERAL_1_WAIT4EOT_1(v)   BF_CS1(IPU_DMFC_GENERAL_1, WAIT4EOT_1, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL_1, field WAIT4EOT_2 (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #2 is in wait4eot mode
 * 0 - FIFO #2 is in normal mode
 */

#define BP_IPU_DMFC_GENERAL_1_WAIT4EOT_2      17
#define BM_IPU_DMFC_GENERAL_1_WAIT4EOT_2      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_2(v)   ((((reg32_t) v) << 17) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_2)
#else
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_2(v)   (((v) << 17) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_2 field to a new value.
#define BW_IPU_DMFC_GENERAL_1_WAIT4EOT_2(v)   BF_CS1(IPU_DMFC_GENERAL_1, WAIT4EOT_2, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL_1, field WAIT4EOT_3 (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #3 is in wait4eot mode
 * 0 - FIFO #3 is in normal mode
 */

#define BP_IPU_DMFC_GENERAL_1_WAIT4EOT_3      18
#define BM_IPU_DMFC_GENERAL_1_WAIT4EOT_3      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_3(v)   ((((reg32_t) v) << 18) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_3)
#else
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_3(v)   (((v) << 18) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_3 field to a new value.
#define BW_IPU_DMFC_GENERAL_1_WAIT4EOT_3(v)   BF_CS1(IPU_DMFC_GENERAL_1, WAIT4EOT_3, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL_1, field WAIT4EOT_4 (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #4 is in wait4eot mode
 * 0 - FIFO #4 is in normal mode
 */

#define BP_IPU_DMFC_GENERAL_1_WAIT4EOT_4      19
#define BM_IPU_DMFC_GENERAL_1_WAIT4EOT_4      0x00080000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_4(v)   ((((reg32_t) v) << 19) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_4)
#else
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_4(v)   (((v) << 19) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_4)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_4 field to a new value.
#define BW_IPU_DMFC_GENERAL_1_WAIT4EOT_4(v)   BF_CS1(IPU_DMFC_GENERAL_1, WAIT4EOT_4, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL_1, field WAIT4EOT_5B (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #5B is in wait4eot mode
 * 0 - FIFO #5B is in normal mode
 */

#define BP_IPU_DMFC_GENERAL_1_WAIT4EOT_5B      20
#define BM_IPU_DMFC_GENERAL_1_WAIT4EOT_5B      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_5B(v)   ((((reg32_t) v) << 20) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_5B)
#else
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_5B(v)   (((v) << 20) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_5B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_5B field to a new value.
#define BW_IPU_DMFC_GENERAL_1_WAIT4EOT_5B(v)   BF_CS1(IPU_DMFC_GENERAL_1, WAIT4EOT_5B, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL_1, field WAIT4EOT_5F (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #5F is in wait4eot mode
 * 0 - FIFO #5F is in normal mode
 */

#define BP_IPU_DMFC_GENERAL_1_WAIT4EOT_5F      21
#define BM_IPU_DMFC_GENERAL_1_WAIT4EOT_5F      0x00200000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_5F(v)   ((((reg32_t) v) << 21) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_5F)
#else
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_5F(v)   (((v) << 21) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_5F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_5F field to a new value.
#define BW_IPU_DMFC_GENERAL_1_WAIT4EOT_5F(v)   BF_CS1(IPU_DMFC_GENERAL_1, WAIT4EOT_5F, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL_1, field WAIT4EOT_6B (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #6B is in wait4eot mode
 * 0 - FIFO #6B is in normal mode
 */

#define BP_IPU_DMFC_GENERAL_1_WAIT4EOT_6B      22
#define BM_IPU_DMFC_GENERAL_1_WAIT4EOT_6B      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_6B(v)   ((((reg32_t) v) << 22) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_6B)
#else
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_6B(v)   (((v) << 22) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_6B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_6B field to a new value.
#define BW_IPU_DMFC_GENERAL_1_WAIT4EOT_6B(v)   BF_CS1(IPU_DMFC_GENERAL_1, WAIT4EOT_6B, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL_1, field WAIT4EOT_6F (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #6F is in wait4eot mode
 * 0 - FIFO #6F is in normal mode
 */

#define BP_IPU_DMFC_GENERAL_1_WAIT4EOT_6F      23
#define BM_IPU_DMFC_GENERAL_1_WAIT4EOT_6F      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_6F(v)   ((((reg32_t) v) << 23) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_6F)
#else
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_6F(v)   (((v) << 23) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_6F)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_6F field to a new value.
#define BW_IPU_DMFC_GENERAL_1_WAIT4EOT_6F(v)   BF_CS1(IPU_DMFC_GENERAL_1, WAIT4EOT_6F, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL_1, field WAIT4EOT_9 (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #9 is in wait4eot mode
 * 0 - FIFO #9 is in normal mode
 */

#define BP_IPU_DMFC_GENERAL_1_WAIT4EOT_9      24
#define BM_IPU_DMFC_GENERAL_1_WAIT4EOT_9      0x01000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_9(v)   ((((reg32_t) v) << 24) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_9)
#else
#define BF_IPU_DMFC_GENERAL_1_WAIT4EOT_9(v)   (((v) << 24) & BM_IPU_DMFC_GENERAL_1_WAIT4EOT_9)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_9 field to a new value.
#define BW_IPU_DMFC_GENERAL_1_WAIT4EOT_9(v)   BF_CS1(IPU_DMFC_GENERAL_1, WAIT4EOT_9, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_GENERAL_2 - DMFC General 2 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMFC_FRAME_WIDTH_RD : 13; //!< Frame width for read channel from the display to the IDMAC; Units are pixels
        unsigned RESERVED0 : 3; //!< Reserved.
        unsigned DMFC_FRAME_HEIGHT_RD : 13; //!< Frame height for read channel from the display to the IDMAC; Units are pixels
        unsigned RESERVED1 : 3; //!< Reserved.
    } B;
} hw_ipu_dmfc_general_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_GENERAL_2 register
 */
#define HW_IPU_DMFC_GENERAL_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x60018)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_GENERAL_2(x)           (*(volatile hw_ipu_dmfc_general_2_t *) HW_IPU_DMFC_GENERAL_2_ADDR(x))
#define HW_IPU_DMFC_GENERAL_2_RD(x)        (HW_IPU_DMFC_GENERAL_2(x).U)
#define HW_IPU_DMFC_GENERAL_2_WR(x, v)     (HW_IPU_DMFC_GENERAL_2(x).U = (v))
#define HW_IPU_DMFC_GENERAL_2_SET(x, v)    (HW_IPU_DMFC_GENERAL_2_WR(x, HW_IPU_DMFC_GENERAL_2_RD(x) |  (v)))
#define HW_IPU_DMFC_GENERAL_2_CLR(x, v)    (HW_IPU_DMFC_GENERAL_2_WR(x, HW_IPU_DMFC_GENERAL_2_RD(x) & ~(v)))
#define HW_IPU_DMFC_GENERAL_2_TOG(x, v)    (HW_IPU_DMFC_GENERAL_2_WR(x, HW_IPU_DMFC_GENERAL_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_GENERAL_2 bitfields
 */

/* --- Register HW_IPU_DMFC_GENERAL_2, field DMFC_FRAME_WIDTH_RD (RW)
 *
 * Frame width for read channel from the display to the IDMAC; Units are pixels
 */

#define BP_IPU_DMFC_GENERAL_2_DMFC_FRAME_WIDTH_RD      0
#define BM_IPU_DMFC_GENERAL_2_DMFC_FRAME_WIDTH_RD      0x00001fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_2_DMFC_FRAME_WIDTH_RD(v)   ((((reg32_t) v) << 0) & BM_IPU_DMFC_GENERAL_2_DMFC_FRAME_WIDTH_RD)
#else
#define BF_IPU_DMFC_GENERAL_2_DMFC_FRAME_WIDTH_RD(v)   (((v) << 0) & BM_IPU_DMFC_GENERAL_2_DMFC_FRAME_WIDTH_RD)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FRAME_WIDTH_RD field to a new value.
#define BW_IPU_DMFC_GENERAL_2_DMFC_FRAME_WIDTH_RD(v)   BF_CS1(IPU_DMFC_GENERAL_2, DMFC_FRAME_WIDTH_RD, v)
#endif

/* --- Register HW_IPU_DMFC_GENERAL_2, field DMFC_FRAME_HEIGHT_RD (RW)
 *
 * Frame height for read channel from the display to the IDMAC; Units are pixels
 */

#define BP_IPU_DMFC_GENERAL_2_DMFC_FRAME_HEIGHT_RD      16
#define BM_IPU_DMFC_GENERAL_2_DMFC_FRAME_HEIGHT_RD      0x1fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL_2_DMFC_FRAME_HEIGHT_RD(v)   ((((reg32_t) v) << 16) & BM_IPU_DMFC_GENERAL_2_DMFC_FRAME_HEIGHT_RD)
#else
#define BF_IPU_DMFC_GENERAL_2_DMFC_FRAME_HEIGHT_RD(v)   (((v) << 16) & BM_IPU_DMFC_GENERAL_2_DMFC_FRAME_HEIGHT_RD)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FRAME_HEIGHT_RD field to a new value.
#define BW_IPU_DMFC_GENERAL_2_DMFC_FRAME_HEIGHT_RD(v)   BF_CS1(IPU_DMFC_GENERAL_2, DMFC_FRAME_HEIGHT_RD, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_IC_CTRL - DMFC IC Interface Control Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMFC_IC_IN_PORT : 3; //!< DMFC input port When data is coming from the IC, the IC channel replaces one of the IDMAC's channels connected to the DMFC. This field defines which IDMAC's channel is replaced by the IC channel.
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DMFC_IC_PPW_C : 2; //!< Pixel Per Word coded from IC. This field defines the size of the data coming from the IC.
        unsigned DMFC_IC_FRAME_WIDTH_RD : 13; //!< Frame's width for the channel coming from IC. Units are pixels
        unsigned DMFC_IC_FRAME_HEIGHT_RD : 13; //!< Frame's height for the channel coming from IC. Units are lines
    } B;
} hw_ipu_dmfc_ic_ctrl_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_IC_CTRL register
 */
#define HW_IPU_DMFC_IC_CTRL_ADDR(x)      (REGS_IPU_BASE(x) + 0x6001c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_IC_CTRL(x)           (*(volatile hw_ipu_dmfc_ic_ctrl_t *) HW_IPU_DMFC_IC_CTRL_ADDR(x))
#define HW_IPU_DMFC_IC_CTRL_RD(x)        (HW_IPU_DMFC_IC_CTRL(x).U)
#define HW_IPU_DMFC_IC_CTRL_WR(x, v)     (HW_IPU_DMFC_IC_CTRL(x).U = (v))
#define HW_IPU_DMFC_IC_CTRL_SET(x, v)    (HW_IPU_DMFC_IC_CTRL_WR(x, HW_IPU_DMFC_IC_CTRL_RD(x) |  (v)))
#define HW_IPU_DMFC_IC_CTRL_CLR(x, v)    (HW_IPU_DMFC_IC_CTRL_WR(x, HW_IPU_DMFC_IC_CTRL_RD(x) & ~(v)))
#define HW_IPU_DMFC_IC_CTRL_TOG(x, v)    (HW_IPU_DMFC_IC_CTRL_WR(x, HW_IPU_DMFC_IC_CTRL_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_IC_CTRL bitfields
 */

/* --- Register HW_IPU_DMFC_IC_CTRL, field DMFC_IC_IN_PORT (RW)
 *
 * DMFC input port When data is coming from the IC, the IC channel replaces one of the IDMAC's
 * channels connected to the DMFC. This field defines which IDMAC's channel is replaced by the IC
 * channel.
 *
 * Values:
 * 000 - CH28
 * 001 - CH41
 * 010 - Reserved, IC channel is disabled
 * 011 - Reserved, IC channel is disabled
 * 100 - CH23
 * 101 - CH27
 * 110 - CH24
 * 111 - CH29
 */

#define BP_IPU_DMFC_IC_CTRL_DMFC_IC_IN_PORT      0
#define BM_IPU_DMFC_IC_CTRL_DMFC_IC_IN_PORT      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_IC_CTRL_DMFC_IC_IN_PORT(v)   ((((reg32_t) v) << 0) & BM_IPU_DMFC_IC_CTRL_DMFC_IC_IN_PORT)
#else
#define BF_IPU_DMFC_IC_CTRL_DMFC_IC_IN_PORT(v)   (((v) << 0) & BM_IPU_DMFC_IC_CTRL_DMFC_IC_IN_PORT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_IC_IN_PORT field to a new value.
#define BW_IPU_DMFC_IC_CTRL_DMFC_IC_IN_PORT(v)   BF_CS1(IPU_DMFC_IC_CTRL, DMFC_IC_IN_PORT, v)
#endif


/* --- Register HW_IPU_DMFC_IC_CTRL, field DMFC_IC_PPW_C (RW)
 *
 * Pixel Per Word coded from IC. This field defines the size of the data coming from the IC.
 *
 * Values:
 * 00 - 8 bit per pixel
 * 01 - 16 bit per pixel
 * 10 - 24 bit per pixel
 * 11 - Reserved
 */

#define BP_IPU_DMFC_IC_CTRL_DMFC_IC_PPW_C      4
#define BM_IPU_DMFC_IC_CTRL_DMFC_IC_PPW_C      0x00000030

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_IC_CTRL_DMFC_IC_PPW_C(v)   ((((reg32_t) v) << 4) & BM_IPU_DMFC_IC_CTRL_DMFC_IC_PPW_C)
#else
#define BF_IPU_DMFC_IC_CTRL_DMFC_IC_PPW_C(v)   (((v) << 4) & BM_IPU_DMFC_IC_CTRL_DMFC_IC_PPW_C)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_IC_PPW_C field to a new value.
#define BW_IPU_DMFC_IC_CTRL_DMFC_IC_PPW_C(v)   BF_CS1(IPU_DMFC_IC_CTRL, DMFC_IC_PPW_C, v)
#endif


/* --- Register HW_IPU_DMFC_IC_CTRL, field DMFC_IC_FRAME_WIDTH_RD (RW)
 *
 * Frame's width for the channel coming from IC. Units are pixels
 */

#define BP_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_WIDTH_RD      6
#define BM_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_WIDTH_RD      0x0007ffc0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_WIDTH_RD(v)   ((((reg32_t) v) << 6) & BM_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_WIDTH_RD)
#else
#define BF_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_WIDTH_RD(v)   (((v) << 6) & BM_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_WIDTH_RD)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_IC_FRAME_WIDTH_RD field to a new value.
#define BW_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_WIDTH_RD(v)   BF_CS1(IPU_DMFC_IC_CTRL, DMFC_IC_FRAME_WIDTH_RD, v)
#endif

/* --- Register HW_IPU_DMFC_IC_CTRL, field DMFC_IC_FRAME_HEIGHT_RD (RW)
 *
 * Frame's height for the channel coming from IC. Units are lines
 */

#define BP_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_HEIGHT_RD      19
#define BM_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_HEIGHT_RD      0xfff80000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_HEIGHT_RD(v)   ((((reg32_t) v) << 19) & BM_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_HEIGHT_RD)
#else
#define BF_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_HEIGHT_RD(v)   (((v) << 19) & BM_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_HEIGHT_RD)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_IC_FRAME_HEIGHT_RD field to a new value.
#define BW_IPU_DMFC_IC_CTRL_DMFC_IC_FRAME_HEIGHT_RD(v)   BF_CS1(IPU_DMFC_IC_CTRL, DMFC_IC_FRAME_HEIGHT_RD, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_WR_CHAN_ALT - DMFC Write Channel Alternate Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 8; //!< Reserved
        unsigned DMFC_ST_ADDR_2_ALT : 3; //!< DMFC Start Address for IDMAC's channel 41 (for alternate flow) This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 41. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the number of the segment
        unsigned DMFC_FIFO_SIZE_2_ALT : 3; //!< DMFC FIFO size for IDMAC's channel 41 (for alternate flow) This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 41
        unsigned DMFC_BURST_SIZE_2_ALT : 2; //!< Burst size of IDMAC's channel 41 (for alternate flow) This field defines the burst size of the IDMAC's channel 41 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
        unsigned RESERVED1 : 16; //!< Reserved
    } B;
} hw_ipu_dmfc_wr_chan_alt_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_WR_CHAN_ALT register
 */
#define HW_IPU_DMFC_WR_CHAN_ALT_ADDR(x)      (REGS_IPU_BASE(x) + 0x60020)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_WR_CHAN_ALT(x)           (*(volatile hw_ipu_dmfc_wr_chan_alt_t *) HW_IPU_DMFC_WR_CHAN_ALT_ADDR(x))
#define HW_IPU_DMFC_WR_CHAN_ALT_RD(x)        (HW_IPU_DMFC_WR_CHAN_ALT(x).U)
#define HW_IPU_DMFC_WR_CHAN_ALT_WR(x, v)     (HW_IPU_DMFC_WR_CHAN_ALT(x).U = (v))
#define HW_IPU_DMFC_WR_CHAN_ALT_SET(x, v)    (HW_IPU_DMFC_WR_CHAN_ALT_WR(x, HW_IPU_DMFC_WR_CHAN_ALT_RD(x) |  (v)))
#define HW_IPU_DMFC_WR_CHAN_ALT_CLR(x, v)    (HW_IPU_DMFC_WR_CHAN_ALT_WR(x, HW_IPU_DMFC_WR_CHAN_ALT_RD(x) & ~(v)))
#define HW_IPU_DMFC_WR_CHAN_ALT_TOG(x, v)    (HW_IPU_DMFC_WR_CHAN_ALT_WR(x, HW_IPU_DMFC_WR_CHAN_ALT_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_WR_CHAN_ALT bitfields
 */

/* --- Register HW_IPU_DMFC_WR_CHAN_ALT, field DMFC_ST_ADDR_2_ALT (RW)
 *
 * DMFC Start Address for IDMAC's channel 41 (for alternate flow) This field defines the base
 * address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel
 * 41. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this
 * field is the number of the segment
 *
 * Values:
 * 000 - Segment 0
 * 001 - Segment 1
 * 111 - Segment 7
 */

#define BP_IPU_DMFC_WR_CHAN_ALT_DMFC_ST_ADDR_2_ALT      8
#define BM_IPU_DMFC_WR_CHAN_ALT_DMFC_ST_ADDR_2_ALT      0x00000700

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_ALT_DMFC_ST_ADDR_2_ALT(v)   ((((reg32_t) v) << 8) & BM_IPU_DMFC_WR_CHAN_ALT_DMFC_ST_ADDR_2_ALT)
#else
#define BF_IPU_DMFC_WR_CHAN_ALT_DMFC_ST_ADDR_2_ALT(v)   (((v) << 8) & BM_IPU_DMFC_WR_CHAN_ALT_DMFC_ST_ADDR_2_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_ST_ADDR_2_ALT field to a new value.
#define BW_IPU_DMFC_WR_CHAN_ALT_DMFC_ST_ADDR_2_ALT(v)   BF_CS1(IPU_DMFC_WR_CHAN_ALT, DMFC_ST_ADDR_2_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN_ALT, field DMFC_FIFO_SIZE_2_ALT (RW)
 *
 * DMFC FIFO size for IDMAC's channel 41 (for alternate flow) This field defines the FIFO partition
 * for the DMFC channel connected to IDMAC's channel 41
 *
 * Values:
 * 000 - All (512X128 words) the DMFC's FIFO is allocated to this channel
 * 001 - 256X128 words are allocated to this channel
 * 010 - 128X128 words are allocated to this channel
 * 011 - 64X128 words are allocated to this channel
 * 100 - 32X128 words are allocated to this channel
 * 101 - 16X128 words are allocated to this channel
 * 110 - 8X128 words are allocated to this channel
 * 111 - 4X128 words are allocated to this channel
 */

#define BP_IPU_DMFC_WR_CHAN_ALT_DMFC_FIFO_SIZE_2_ALT      11
#define BM_IPU_DMFC_WR_CHAN_ALT_DMFC_FIFO_SIZE_2_ALT      0x00003800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_ALT_DMFC_FIFO_SIZE_2_ALT(v)   ((((reg32_t) v) << 11) & BM_IPU_DMFC_WR_CHAN_ALT_DMFC_FIFO_SIZE_2_ALT)
#else
#define BF_IPU_DMFC_WR_CHAN_ALT_DMFC_FIFO_SIZE_2_ALT(v)   (((v) << 11) & BM_IPU_DMFC_WR_CHAN_ALT_DMFC_FIFO_SIZE_2_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FIFO_SIZE_2_ALT field to a new value.
#define BW_IPU_DMFC_WR_CHAN_ALT_DMFC_FIFO_SIZE_2_ALT(v)   BF_CS1(IPU_DMFC_WR_CHAN_ALT, DMFC_FIFO_SIZE_2_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN_ALT, field DMFC_BURST_SIZE_2_ALT (RW)
 *
 * Burst size of IDMAC's channel 41 (for alternate flow) This field defines the burst size of the
 * IDMAC's channel 41 write accesses. This settings must match the settings in the corresponding
 * IDMAC channel's settings.
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, coming from the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_WR_CHAN_ALT_DMFC_BURST_SIZE_2_ALT      14
#define BM_IPU_DMFC_WR_CHAN_ALT_DMFC_BURST_SIZE_2_ALT      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_ALT_DMFC_BURST_SIZE_2_ALT(v)   ((((reg32_t) v) << 14) & BM_IPU_DMFC_WR_CHAN_ALT_DMFC_BURST_SIZE_2_ALT)
#else
#define BF_IPU_DMFC_WR_CHAN_ALT_DMFC_BURST_SIZE_2_ALT(v)   (((v) << 14) & BM_IPU_DMFC_WR_CHAN_ALT_DMFC_BURST_SIZE_2_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_2_ALT field to a new value.
#define BW_IPU_DMFC_WR_CHAN_ALT_DMFC_BURST_SIZE_2_ALT(v)   BF_CS1(IPU_DMFC_WR_CHAN_ALT, DMFC_BURST_SIZE_2_ALT, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_WR_CHAN_DEF_ALT - DMFC Write Channel Definition Alternate Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 9; //!< Reserved
        unsigned DMFC_WM_EN_2_ALT : 1; //!< Watermark enable. (for alternate flow) This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_2_ALT : 3; //!< Watermark Set (for alternate flow) This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_2_ALT : 3; //!< Watermark Clear (for alternate flow) This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
        unsigned RESERVED1 : 16; //!< Reserved
    } B;
} hw_ipu_dmfc_wr_chan_def_alt_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_WR_CHAN_DEF_ALT register
 */
#define HW_IPU_DMFC_WR_CHAN_DEF_ALT_ADDR(x)      (REGS_IPU_BASE(x) + 0x60024)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_WR_CHAN_DEF_ALT(x)           (*(volatile hw_ipu_dmfc_wr_chan_def_alt_t *) HW_IPU_DMFC_WR_CHAN_DEF_ALT_ADDR(x))
#define HW_IPU_DMFC_WR_CHAN_DEF_ALT_RD(x)        (HW_IPU_DMFC_WR_CHAN_DEF_ALT(x).U)
#define HW_IPU_DMFC_WR_CHAN_DEF_ALT_WR(x, v)     (HW_IPU_DMFC_WR_CHAN_DEF_ALT(x).U = (v))
#define HW_IPU_DMFC_WR_CHAN_DEF_ALT_SET(x, v)    (HW_IPU_DMFC_WR_CHAN_DEF_ALT_WR(x, HW_IPU_DMFC_WR_CHAN_DEF_ALT_RD(x) |  (v)))
#define HW_IPU_DMFC_WR_CHAN_DEF_ALT_CLR(x, v)    (HW_IPU_DMFC_WR_CHAN_DEF_ALT_WR(x, HW_IPU_DMFC_WR_CHAN_DEF_ALT_RD(x) & ~(v)))
#define HW_IPU_DMFC_WR_CHAN_DEF_ALT_TOG(x, v)    (HW_IPU_DMFC_WR_CHAN_DEF_ALT_WR(x, HW_IPU_DMFC_WR_CHAN_DEF_ALT_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_WR_CHAN_DEF_ALT bitfields
 */

/* --- Register HW_IPU_DMFC_WR_CHAN_DEF_ALT, field DMFC_WM_EN_2_ALT (RW)
 *
 * Watermark enable. (for alternate flow) This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_EN_2_ALT      9
#define BM_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_EN_2_ALT      0x00000200

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_EN_2_ALT(v)   ((((reg32_t) v) << 9) & BM_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_EN_2_ALT)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_EN_2_ALT(v)   (((v) << 9) & BM_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_EN_2_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_2_ALT field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_EN_2_ALT(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF_ALT, DMFC_WM_EN_2_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_WR_CHAN_DEF_ALT, field DMFC_WM_SET_2_ALT (RW)
 *
 * Watermark Set (for alternate flow) This field defines the watermark's level of the DMFC write
 * FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount
 * of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_SET_2_ALT      10
#define BM_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_SET_2_ALT      0x00001c00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_SET_2_ALT(v)   ((((reg32_t) v) << 10) & BM_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_SET_2_ALT)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_SET_2_ALT(v)   (((v) << 10) & BM_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_SET_2_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_2_ALT field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_SET_2_ALT(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF_ALT, DMFC_WM_SET_2_ALT, v)
#endif

/* --- Register HW_IPU_DMFC_WR_CHAN_DEF_ALT, field DMFC_WM_CLR_2_ALT (RW)
 *
 * Watermark Clear (for alternate flow) This field defines the watermark's level of the DMFC's write
 * FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the
 * amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_CLR_2_ALT      13
#define BM_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_CLR_2_ALT      0x0000e000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_CLR_2_ALT(v)   ((((reg32_t) v) << 13) & BM_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_CLR_2_ALT)
#else
#define BF_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_CLR_2_ALT(v)   (((v) << 13) & BM_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_CLR_2_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_2_ALT field to a new value.
#define BW_IPU_DMFC_WR_CHAN_DEF_ALT_DMFC_WM_CLR_2_ALT(v)   BF_CS1(IPU_DMFC_WR_CHAN_DEF_ALT, DMFC_WM_CLR_2_ALT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_DP_CHAN_ALT - DMFC MFC Display Processor Channel Alternate Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMFC_ST_ADDR_5B_ALT : 3; //!< DMFC Start Address for IDMAC's channel 23 (for alternate flow) This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 23. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the number of the segment
        unsigned DMFC_FIFO_SIZE_5B_ALT : 3; //!< DMFC FIFO size for IDMAC's channel 23 (for alternate flow) This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 23
        unsigned DMFC_BURST_SIZE_5B_ALT : 2; //!< Burst size of IDMAC's channel 23 (for alternate flow) This field defines the burst size of the IDMAC's channel 23 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
        unsigned RESERVED0 : 8; //!< Reserved
        unsigned DMFC_ST_ADDR_6B_ALT : 3; //!< DMFC Start Address for IDMAC's channel 24 (for alternate flow) This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 24. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the number of the segment
        unsigned DMFC_FIFO_SIZE_6B_ALT : 3; //!< DMFC FIFO size for IDMAC's channel 24 (for alternate flow) This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 24
        unsigned DMFC_BURST_SIZE_6B_ALT : 2; //!< Burst size of IDMAC's channel 24 (for alternate flow) This field defines the burst size of the IDMAC's channel 24 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
        unsigned DMFC_ST_ADDR_6F_ALT : 3; //!< DMFC Start Address for IDMAC's channel 29 (for alternate flow) This field defines the base address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel 29. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this field is the number of the segment
        unsigned DMFC_FIFO_SIZE_6F_ALT : 3; //!< DMFC FIFO size for IDMAC's channel 29 (for alternate flow) This field defines the FIFO partition for the DMFC channel connected to IDMAC's channel 29
        unsigned DMFC_BURST_SIZE_6F_ALT : 2; //!< Burst size of IDMAC's channel 29 (for alternate flow) This field defines the burst size of the IDMAC's channel 29 write accesses. This settings must match the settings in the corresponding IDMAC channel's settings.
    } B;
} hw_ipu_dmfc_dp_chan_alt_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_DP_CHAN_ALT register
 */
#define HW_IPU_DMFC_DP_CHAN_ALT_ADDR(x)      (REGS_IPU_BASE(x) + 0x60028)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_DP_CHAN_ALT(x)           (*(volatile hw_ipu_dmfc_dp_chan_alt_t *) HW_IPU_DMFC_DP_CHAN_ALT_ADDR(x))
#define HW_IPU_DMFC_DP_CHAN_ALT_RD(x)        (HW_IPU_DMFC_DP_CHAN_ALT(x).U)
#define HW_IPU_DMFC_DP_CHAN_ALT_WR(x, v)     (HW_IPU_DMFC_DP_CHAN_ALT(x).U = (v))
#define HW_IPU_DMFC_DP_CHAN_ALT_SET(x, v)    (HW_IPU_DMFC_DP_CHAN_ALT_WR(x, HW_IPU_DMFC_DP_CHAN_ALT_RD(x) |  (v)))
#define HW_IPU_DMFC_DP_CHAN_ALT_CLR(x, v)    (HW_IPU_DMFC_DP_CHAN_ALT_WR(x, HW_IPU_DMFC_DP_CHAN_ALT_RD(x) & ~(v)))
#define HW_IPU_DMFC_DP_CHAN_ALT_TOG(x, v)    (HW_IPU_DMFC_DP_CHAN_ALT_WR(x, HW_IPU_DMFC_DP_CHAN_ALT_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_DP_CHAN_ALT bitfields
 */

/* --- Register HW_IPU_DMFC_DP_CHAN_ALT, field DMFC_ST_ADDR_5B_ALT (RW)
 *
 * DMFC Start Address for IDMAC's channel 23 (for alternate flow) This field defines the base
 * address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel
 * 23. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this
 * field is the number of the segment
 *
 * Values:
 * 000 - Segment 0
 * 001 - Segment 1
 * 111 - Segment 7
 */

#define BP_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_5B_ALT      0
#define BM_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_5B_ALT      0x00000007

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_5B_ALT(v)   ((((reg32_t) v) << 0) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_5B_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_5B_ALT(v)   (((v) << 0) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_5B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_ST_ADDR_5B_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_5B_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_ALT, DMFC_ST_ADDR_5B_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_ALT, field DMFC_FIFO_SIZE_5B_ALT (RW)
 *
 * DMFC FIFO size for IDMAC's channel 23 (for alternate flow) This field defines the FIFO partition
 * for the DMFC channel connected to IDMAC's channel 23
 *
 * Values:
 * 000 - All (512X128 words) the DMFC's FIFO is allocated to this channel
 * 001 - 256X128 words are allocated to this channel
 * 010 - 128X128 words are allocated to this channel
 * 011 - 64X128 words are allocated to this channel
 * 100 - 32X128 words are allocated to this channel
 * 101 - 16X128 words are allocated to this channel
 * 110 - 8X128 words are allocated to this channel
 * 111 - 4X128 words are allocated to this channel
 */

#define BP_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_5B_ALT      3
#define BM_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_5B_ALT      0x00000038

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_5B_ALT(v)   ((((reg32_t) v) << 3) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_5B_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_5B_ALT(v)   (((v) << 3) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_5B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FIFO_SIZE_5B_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_5B_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_ALT, DMFC_FIFO_SIZE_5B_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_ALT, field DMFC_BURST_SIZE_5B_ALT (RW)
 *
 * Burst size of IDMAC's channel 23 (for alternate flow) This field defines the burst size of the
 * IDMAC's channel 23 write accesses. This settings must match the settings in the corresponding
 * IDMAC channel's settings.
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, coming from the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_5B_ALT      6
#define BM_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_5B_ALT      0x000000c0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_5B_ALT(v)   ((((reg32_t) v) << 6) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_5B_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_5B_ALT(v)   (((v) << 6) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_5B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_5B_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_5B_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_ALT, DMFC_BURST_SIZE_5B_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_ALT, field DMFC_ST_ADDR_6B_ALT (RW)
 *
 * DMFC Start Address for IDMAC's channel 24 (for alternate flow) This field defines the base
 * address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel
 * 24. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this
 * field is the number of the segment
 *
 * Values:
 * 000 - Segment 0
 * 001 - Segment 1
 * 111 - Segment 7
 */

#define BP_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6B_ALT      16
#define BM_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6B_ALT      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6B_ALT(v)   ((((reg32_t) v) << 16) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6B_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6B_ALT(v)   (((v) << 16) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_ST_ADDR_6B_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6B_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_ALT, DMFC_ST_ADDR_6B_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_ALT, field DMFC_FIFO_SIZE_6B_ALT (RW)
 *
 * DMFC FIFO size for IDMAC's channel 24 (for alternate flow) This field defines the FIFO partition
 * for the DMFC channel connected to IDMAC's channel 24
 *
 * Values:
 * 000 - All (512X128 words) the DMFC's FIFO is allocated to this channel
 * 001 - 256X128 words are allocated to this channel
 * 010 - 128X128 words are allocated to this channel
 * 011 - 64X128 words are allocated to this channel
 * 100 - 32X128 words are allocated to this channel
 * 101 - 16X128 words are allocated to this channel
 * 110 - 8X128 words are allocated to this channel
 * 111 - 4X128 words are allocated to this channel
 */

#define BP_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6B_ALT      19
#define BM_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6B_ALT      0x00380000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6B_ALT(v)   ((((reg32_t) v) << 19) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6B_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6B_ALT(v)   (((v) << 19) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FIFO_SIZE_6B_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6B_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_ALT, DMFC_FIFO_SIZE_6B_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_ALT, field DMFC_BURST_SIZE_6B_ALT (RW)
 *
 * Burst size of IDMAC's channel 24 (for alternate flow) This field defines the burst size of the
 * IDMAC's channel 24 write accesses. This settings must match the settings in the corresponding
 * IDMAC channel's settings.
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, coming from the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6B_ALT      22
#define BM_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6B_ALT      0x00c00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6B_ALT(v)   ((((reg32_t) v) << 22) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6B_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6B_ALT(v)   (((v) << 22) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_6B_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6B_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_ALT, DMFC_BURST_SIZE_6B_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_ALT, field DMFC_ST_ADDR_6F_ALT (RW)
 *
 * DMFC Start Address for IDMAC's channel 29 (for alternate flow) This field defines the base
 * address at the DMFC's FIFO of the partition allocated to the channel connected to IDMAC's channel
 * 29. The FIFO is partitioned to 8 equal segments. Each segment is 64X128 words The value of this
 * field is the number of the segment
 *
 * Values:
 * 000 - Segment 0
 * 001 - Segment 1
 * 111 - Segment 7
 */

#define BP_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6F_ALT      24
#define BM_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6F_ALT      0x07000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6F_ALT(v)   ((((reg32_t) v) << 24) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6F_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6F_ALT(v)   (((v) << 24) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6F_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_ST_ADDR_6F_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_ALT_DMFC_ST_ADDR_6F_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_ALT, DMFC_ST_ADDR_6F_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_ALT, field DMFC_FIFO_SIZE_6F_ALT (RW)
 *
 * DMFC FIFO size for IDMAC's channel 29 (for alternate flow) This field defines the FIFO partition
 * for the DMFC channel connected to IDMAC's channel 29
 *
 * Values:
 * 000 - All (512X128 words) the DMFC's FIFO is allocated to this channel
 * 001 - 256X128 words are allocated to this channel
 * 010 - 128X128 words are allocated to this channel
 * 011 - 64X128 words are allocated to this channel
 * 100 - 32X128 words are allocated to this channel
 * 101 - 16X128 words are allocated to this channel
 * 110 - 8X128 words are allocated to this channel
 * 111 - 4X128 words are allocated to this channel
 */

#define BP_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6F_ALT      27
#define BM_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6F_ALT      0x38000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6F_ALT(v)   ((((reg32_t) v) << 27) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6F_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6F_ALT(v)   (((v) << 27) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6F_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_FIFO_SIZE_6F_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_ALT_DMFC_FIFO_SIZE_6F_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_ALT, DMFC_FIFO_SIZE_6F_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_ALT, field DMFC_BURST_SIZE_6F_ALT (RW)
 *
 * Burst size of IDMAC's channel 29 (for alternate flow) This field defines the burst size of the
 * IDMAC's channel 29 write accesses. This settings must match the settings in the corresponding
 * IDMAC channel's settings.
 *
 * Values:
 * 00 - 32 words of 128 bit (4 pixels of 32 bit each, coming from the IDMAC)
 * 01 - 16 words of 128 bit
 * 10 - 8 words of 128 bit
 * 11 - 4 words of 128 bit
 */

#define BP_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6F_ALT      30
#define BM_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6F_ALT      0xc0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6F_ALT(v)   ((((reg32_t) v) << 30) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6F_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6F_ALT(v)   (((v) << 30) & BM_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6F_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_BURST_SIZE_6F_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_ALT_DMFC_BURST_SIZE_6F_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_ALT, DMFC_BURST_SIZE_6F_ALT, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_DP_CHAN_DEF_ALT - DMFC Display Channel Definition Alternate Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DMFC_WM_EN_5B_ALT : 1; //!< Watermark enable. (for alternate flow) This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_5B_ALT : 3; //!< Watermark Set (for alternate flow) This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_5B_ALT : 3; //!< Watermark Clear (for alternate flow) This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
        unsigned RESERVED1 : 9; //!< Reserved
        unsigned DMFC_WM_EN_6B_ALT : 1; //!< Watermark enable. (for alternate flow) This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_6B_ALT : 3; //!< Watermark Set (for alternate flow) This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_6B_ALT : 3; //!< Watermark Clear (for alternate flow) This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned DMFC_WM_EN_6F_ALT : 1; //!< Watermark enable. (for alternate flow) This bit enables the watermark feature of the FIFO
        unsigned DMFC_WM_SET_6F_ALT : 3; //!< Watermark Set (for alternate flow) This field defines the watermark's level of the DMFC write FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
        unsigned DMFC_WM_CLR_6F_ALT : 3; //!< Watermark Clear (for alternate flow) This field defines the watermark's level of the DMFC's write FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
    } B;
} hw_ipu_dmfc_dp_chan_def_alt_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_DP_CHAN_DEF_ALT register
 */
#define HW_IPU_DMFC_DP_CHAN_DEF_ALT_ADDR(x)      (REGS_IPU_BASE(x) + 0x6002c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_DP_CHAN_DEF_ALT(x)           (*(volatile hw_ipu_dmfc_dp_chan_def_alt_t *) HW_IPU_DMFC_DP_CHAN_DEF_ALT_ADDR(x))
#define HW_IPU_DMFC_DP_CHAN_DEF_ALT_RD(x)        (HW_IPU_DMFC_DP_CHAN_DEF_ALT(x).U)
#define HW_IPU_DMFC_DP_CHAN_DEF_ALT_WR(x, v)     (HW_IPU_DMFC_DP_CHAN_DEF_ALT(x).U = (v))
#define HW_IPU_DMFC_DP_CHAN_DEF_ALT_SET(x, v)    (HW_IPU_DMFC_DP_CHAN_DEF_ALT_WR(x, HW_IPU_DMFC_DP_CHAN_DEF_ALT_RD(x) |  (v)))
#define HW_IPU_DMFC_DP_CHAN_DEF_ALT_CLR(x, v)    (HW_IPU_DMFC_DP_CHAN_DEF_ALT_WR(x, HW_IPU_DMFC_DP_CHAN_DEF_ALT_RD(x) & ~(v)))
#define HW_IPU_DMFC_DP_CHAN_DEF_ALT_TOG(x, v)    (HW_IPU_DMFC_DP_CHAN_DEF_ALT_WR(x, HW_IPU_DMFC_DP_CHAN_DEF_ALT_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_DP_CHAN_DEF_ALT bitfields
 */

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF_ALT, field DMFC_WM_EN_5B_ALT (RW)
 *
 * Watermark enable. (for alternate flow) This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_5B_ALT      1
#define BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_5B_ALT      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_5B_ALT(v)   ((((reg32_t) v) << 1) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_5B_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_5B_ALT(v)   (((v) << 1) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_5B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_5B_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_5B_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF_ALT, DMFC_WM_EN_5B_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_DEF_ALT, field DMFC_WM_SET_5B_ALT (RW)
 *
 * Watermark Set (for alternate flow) This field defines the watermark's level of the DMFC write
 * FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount
 * of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_5B_ALT      2
#define BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_5B_ALT      0x0000001c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_5B_ALT(v)   ((((reg32_t) v) << 2) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_5B_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_5B_ALT(v)   (((v) << 2) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_5B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_5B_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_5B_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF_ALT, DMFC_WM_SET_5B_ALT, v)
#endif

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF_ALT, field DMFC_WM_CLR_5B_ALT (RW)
 *
 * Watermark Clear (for alternate flow) This field defines the watermark's level of the DMFC's write
 * FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the
 * amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_5B_ALT      5
#define BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_5B_ALT      0x000000e0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_5B_ALT(v)   ((((reg32_t) v) << 5) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_5B_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_5B_ALT(v)   (((v) << 5) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_5B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_5B_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_5B_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF_ALT, DMFC_WM_CLR_5B_ALT, v)
#endif

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF_ALT, field DMFC_WM_EN_6B_ALT (RW)
 *
 * Watermark enable. (for alternate flow) This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6B_ALT      17
#define BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6B_ALT      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6B_ALT(v)   ((((reg32_t) v) << 17) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6B_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6B_ALT(v)   (((v) << 17) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_6B_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6B_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF_ALT, DMFC_WM_EN_6B_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_DEF_ALT, field DMFC_WM_SET_6B_ALT (RW)
 *
 * Watermark Set (for alternate flow) This field defines the watermark's level of the DMFC write
 * FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount
 * of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6B_ALT      18
#define BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6B_ALT      0x001c0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6B_ALT(v)   ((((reg32_t) v) << 18) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6B_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6B_ALT(v)   (((v) << 18) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_6B_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6B_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF_ALT, DMFC_WM_SET_6B_ALT, v)
#endif

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF_ALT, field DMFC_WM_CLR_6B_ALT (RW)
 *
 * Watermark Clear (for alternate flow) This field defines the watermark's level of the DMFC's write
 * FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the
 * amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6B_ALT      21
#define BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6B_ALT      0x00e00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6B_ALT(v)   ((((reg32_t) v) << 21) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6B_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6B_ALT(v)   (((v) << 21) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_6B_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6B_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF_ALT, DMFC_WM_CLR_6B_ALT, v)
#endif

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF_ALT, field DMFC_WM_EN_6F_ALT (RW)
 *
 * Watermark enable. (for alternate flow) This bit enables the watermark feature of the FIFO
 *
 * Values:
 * 1 - WM feature is enabled
 * 0 - WM feature is disabled
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6F_ALT      25
#define BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6F_ALT      0x02000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6F_ALT(v)   ((((reg32_t) v) << 25) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6F_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6F_ALT(v)   (((v) << 25) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6F_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_EN_6F_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_EN_6F_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF_ALT, DMFC_WM_EN_6F_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_DP_CHAN_DEF_ALT, field DMFC_WM_SET_6F_ALT (RW)
 *
 * Watermark Set (for alternate flow) This field defines the watermark's level of the DMFC write
 * FIFO. Crossing this level will send the watermark signal to the IDMAC. The WM level is the amount
 * of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6F_ALT      26
#define BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6F_ALT      0x1c000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6F_ALT(v)   ((((reg32_t) v) << 26) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6F_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6F_ALT(v)   (((v) << 26) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6F_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_SET_6F_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_SET_6F_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF_ALT, DMFC_WM_SET_6F_ALT, v)
#endif

/* --- Register HW_IPU_DMFC_DP_CHAN_DEF_ALT, field DMFC_WM_CLR_6F_ALT (RW)
 *
 * Watermark Clear (for alternate flow) This field defines the watermark's level of the DMFC's write
 * FIFO. Crossing this level will clear the watermark signal to the IDMAC. The WM level is the
 * amount of occupied bursts at the FIFO (dmfc_wm_clr > dmfc_wm_set)
 */

#define BP_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6F_ALT      29
#define BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6F_ALT      0xe0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6F_ALT(v)   ((((reg32_t) v) << 29) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6F_ALT)
#else
#define BF_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6F_ALT(v)   (((v) << 29) & BM_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6F_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DMFC_WM_CLR_6F_ALT field to a new value.
#define BW_IPU_DMFC_DP_CHAN_DEF_ALT_DMFC_WM_CLR_6F_ALT(v)   BF_CS1(IPU_DMFC_DP_CHAN_DEF_ALT, DMFC_WM_CLR_6F_ALT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_GENERAL1_ALT - DMFC General 1 Alternate Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 17; //!< Reserved.
        unsigned WAIT4EOT_2_ALT : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned WAIT4EOT_5B_ALT : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned RESERVED2 : 1; //!< Reserved
        unsigned WAIT4EOT_6B_ALT : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned WAIT4EOT_6F_ALT : 1; //!< In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When this bit is set the DMFC sends the request only after the current transfer is terminated, (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in wait4eot mode.
        unsigned RESERVED3 : 8; //!< Reserved.
    } B;
} hw_ipu_dmfc_general1_alt_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_GENERAL1_ALT register
 */
#define HW_IPU_DMFC_GENERAL1_ALT_ADDR(x)      (REGS_IPU_BASE(x) + 0x60030)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_GENERAL1_ALT(x)           (*(volatile hw_ipu_dmfc_general1_alt_t *) HW_IPU_DMFC_GENERAL1_ALT_ADDR(x))
#define HW_IPU_DMFC_GENERAL1_ALT_RD(x)        (HW_IPU_DMFC_GENERAL1_ALT(x).U)
#define HW_IPU_DMFC_GENERAL1_ALT_WR(x, v)     (HW_IPU_DMFC_GENERAL1_ALT(x).U = (v))
#define HW_IPU_DMFC_GENERAL1_ALT_SET(x, v)    (HW_IPU_DMFC_GENERAL1_ALT_WR(x, HW_IPU_DMFC_GENERAL1_ALT_RD(x) |  (v)))
#define HW_IPU_DMFC_GENERAL1_ALT_CLR(x, v)    (HW_IPU_DMFC_GENERAL1_ALT_WR(x, HW_IPU_DMFC_GENERAL1_ALT_RD(x) & ~(v)))
#define HW_IPU_DMFC_GENERAL1_ALT_TOG(x, v)    (HW_IPU_DMFC_GENERAL1_ALT_WR(x, HW_IPU_DMFC_GENERAL1_ALT_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DMFC_GENERAL1_ALT bitfields
 */

/* --- Register HW_IPU_DMFC_GENERAL1_ALT, field WAIT4EOT_2_ALT (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #2 is in wait4eot mode (for alternate flow)
 * 0 - FIFO #2 is in normal mode (for alternate flow)
 */

#define BP_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_2_ALT      17
#define BM_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_2_ALT      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_2_ALT(v)   ((((reg32_t) v) << 17) & BM_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_2_ALT)
#else
#define BF_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_2_ALT(v)   (((v) << 17) & BM_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_2_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_2_ALT field to a new value.
#define BW_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_2_ALT(v)   BF_CS1(IPU_DMFC_GENERAL1_ALT, WAIT4EOT_2_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL1_ALT, field WAIT4EOT_5B_ALT (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #5B is in wait4eot mode (for alternate flow)
 * 0 - FIFO #5B is in normal mode (for alternate flow)
 */

#define BP_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_5B_ALT      20
#define BM_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_5B_ALT      0x00100000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_5B_ALT(v)   ((((reg32_t) v) << 20) & BM_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_5B_ALT)
#else
#define BF_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_5B_ALT(v)   (((v) << 20) & BM_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_5B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_5B_ALT field to a new value.
#define BW_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_5B_ALT(v)   BF_CS1(IPU_DMFC_GENERAL1_ALT, WAIT4EOT_5B_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL1_ALT, field WAIT4EOT_6B_ALT (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #6B is in wait4eot mode (for alternate flow)
 * 0 - FIFO #6B is in normal mode (for alternate flow)
 */

#define BP_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6B_ALT      22
#define BM_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6B_ALT      0x00400000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6B_ALT(v)   ((((reg32_t) v) << 22) & BM_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6B_ALT)
#else
#define BF_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6B_ALT(v)   (((v) << 22) & BM_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6B_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_6B_ALT field to a new value.
#define BW_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6B_ALT(v)   BF_CS1(IPU_DMFC_GENERAL1_ALT, WAIT4EOT_6B_ALT, v)
#endif


/* --- Register HW_IPU_DMFC_GENERAL1_ALT, field WAIT4EOT_6F_ALT (RW)
 *
 * In normal operation the DMFC sends requests to the IDMAC whenever there is room in the FIFO. When
 * this bit is set the DMFC sends the request only after the current transfer is terminated,
 * (wait4eot mode) When the FIFO is larger then the size of the line, the user should work in
 * wait4eot mode.
 *
 * Values:
 * 1 - FIFO #6F is in wait4eot mode (for alternate flow)
 * 0 - FIFO #6F is in normal mode (for alternate flow)
 */

#define BP_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6F_ALT      23
#define BM_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6F_ALT      0x00800000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6F_ALT(v)   ((((reg32_t) v) << 23) & BM_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6F_ALT)
#else
#define BF_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6F_ALT(v)   (((v) << 23) & BM_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6F_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the WAIT4EOT_6F_ALT field to a new value.
#define BW_IPU_DMFC_GENERAL1_ALT_WAIT4EOT_6F_ALT(v)   BF_CS1(IPU_DMFC_GENERAL1_ALT, WAIT4EOT_6F_ALT, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DMFC_STAT - DMFC Status Register (RO)
 *
 * This register contains DMFC's status bits. All the bits in this register are read-only.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DMFC_FIFO_FULL_ : 12; //!< This bit indicates on a DMFC FIFO#<i> full condition. Mapping of these bit to an actual FIFO number is as follows: bit 0 => 0 bit 1=> 1 bit 2 => 2 bit 3 =>1c bit 4 => 2c bit 5 => 5b bit 6 => 5f bit 7 => 6b bit 8 => 6f bit 9 => 9 bit 10 => 10 (ARM platform access) bit 11 => 11 (ARM platform access)
        unsigned DMFC_FIFO_EMPTY_ : 12; //!< This bit indicates on a DMFC FIFO#<i> empty condition. Mapping of these bit to an actual FIFO number is as follows: bit 0 => 0 bit 1=> 1 bit 2 => 2 bit 3 =>1c bit 4 => 2c bit 5 => 5b bit 6 => 5f bit 7 => 6b bit 8 => 6f bit 9 => 9 bit 10 => 10 (ARM platform access) bit 11 => 11 (ARM platform access)
        unsigned DMFC_IC_BUFFER_FULL : 1; //!< This bit indicates on a IC FIFO, inside the DMFC, full condition.
        unsigned DMFC_IC_BUFFER_EMPTY : 1; //!< This bit indicates on a IC FIFO, inside the DMFC, empty condition.
        unsigned RESERVED0 : 6; //!< Reserved
    } B;
} hw_ipu_dmfc_stat_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DMFC_STAT register
 */
#define HW_IPU_DMFC_STAT_ADDR(x)      (REGS_IPU_BASE(x) + 0x60034)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DMFC_STAT(x)           (*(volatile hw_ipu_dmfc_stat_t *) HW_IPU_DMFC_STAT_ADDR(x))
#define HW_IPU_DMFC_STAT_RD(x)        (HW_IPU_DMFC_STAT(x).U)
#endif

/*
 * constants & macros for individual IPU_DMFC_STAT bitfields
 */

/* --- Register HW_IPU_DMFC_STAT, field DMFC_FIFO_FULL_ (RO)
 *
 * This bit indicates on a DMFC FIFO#<i> full condition. Mapping of these bit to an actual FIFO
 * number is as follows: bit 0 => 0 bit 1=> 1 bit 2 => 2 bit 3 =>1c bit 4 => 2c bit 5 => 5b bit 6 =>
 * 5f bit 7 => 6b bit 8 => 6f bit 9 => 9 bit 10 => 10 (ARM platform access) bit 11 => 11 (ARM
 * platform access)
 *
 * Values:
 * 0 - FIFO #<i> is not full
 * 1 - FIFO #<i> is full
 */

#define BP_IPU_DMFC_STAT_DMFC_FIFO_FULL_      0
#define BM_IPU_DMFC_STAT_DMFC_FIFO_FULL_      0x00000fff


/* --- Register HW_IPU_DMFC_STAT, field DMFC_FIFO_EMPTY_ (RO)
 *
 * This bit indicates on a DMFC FIFO#<i> empty condition. Mapping of these bit to an actual FIFO
 * number is as follows: bit 0 => 0 bit 1=> 1 bit 2 => 2 bit 3 =>1c bit 4 => 2c bit 5 => 5b bit 6 =>
 * 5f bit 7 => 6b bit 8 => 6f bit 9 => 9 bit 10 => 10 (ARM platform access) bit 11 => 11 (ARM
 * platform access)
 *
 * Values:
 * 0 - FIFO #<i> is not empty
 * 1 - FIFO #<i> is empty
 */

#define BP_IPU_DMFC_STAT_DMFC_FIFO_EMPTY_      12
#define BM_IPU_DMFC_STAT_DMFC_FIFO_EMPTY_      0x00fff000


/* --- Register HW_IPU_DMFC_STAT, field DMFC_IC_BUFFER_FULL (RO)
 *
 * This bit indicates on a IC FIFO, inside the DMFC, full condition.
 *
 * Values:
 * 0 - IC FIFO not full
 * 1 - IC FIFO is full
 */

#define BP_IPU_DMFC_STAT_DMFC_IC_BUFFER_FULL      24
#define BM_IPU_DMFC_STAT_DMFC_IC_BUFFER_FULL      0x01000000


/* --- Register HW_IPU_DMFC_STAT, field DMFC_IC_BUFFER_EMPTY (RO)
 *
 * This bit indicates on a IC FIFO, inside the DMFC, empty condition.
 *
 * Values:
 * 0 - IC FIFO not empty
 * 1 - IC FIFO is empty
 */

#define BP_IPU_DMFC_STAT_DMFC_IC_BUFFER_EMPTY      25
#define BM_IPU_DMFC_STAT_DMFC_IC_BUFFER_EMPTY      0x02000000


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_VDI_FSIZE - VDI Field Size Register (RW)
 *
 * The register used to control size of VDI  C  input fields.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned VDI_FWIDTH : 11; //!< Frame width. The value to be written to this register is the frame's width minus 1. The Frame width should not be smaller than 16. The width must be even. When VDI_CMB_EN bit is clear The Frame width should not be greater than 720968. When VDI_CMB_EN bit is set: The Frame width should not be greater than 1920.
        unsigned RESERVED0 : 5; //!< Reserved
        unsigned VDI_FHEIGHT : 11; //!< Frame height The value to be written to this register is the frame's height minus 1. The frame height should not be smaller than 16. When VDI_CMB_EN bit is clear: The frame height should not be greater than 1080. The frame's height must be even (which means that both fields have the same height) The frame's height in 4:2:0 format, must be multiple of 4 (which means that both chroma fields have the same height) When VDI_CMB_EN bit is set: The frame height should not be greater than 1200.
        unsigned RESERVED1 : 5; //!< Reserved
    } B;
} hw_ipu_vdi_fsize_t;
#endif

/*
 * constants & macros for entire multi-block IPU_VDI_FSIZE register
 */
#define HW_IPU_VDI_FSIZE_ADDR(x)      (REGS_IPU_BASE(x) + 0x68000)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_VDI_FSIZE(x)           (*(volatile hw_ipu_vdi_fsize_t *) HW_IPU_VDI_FSIZE_ADDR(x))
#define HW_IPU_VDI_FSIZE_RD(x)        (HW_IPU_VDI_FSIZE(x).U)
#define HW_IPU_VDI_FSIZE_WR(x, v)     (HW_IPU_VDI_FSIZE(x).U = (v))
#define HW_IPU_VDI_FSIZE_SET(x, v)    (HW_IPU_VDI_FSIZE_WR(x, HW_IPU_VDI_FSIZE_RD(x) |  (v)))
#define HW_IPU_VDI_FSIZE_CLR(x, v)    (HW_IPU_VDI_FSIZE_WR(x, HW_IPU_VDI_FSIZE_RD(x) & ~(v)))
#define HW_IPU_VDI_FSIZE_TOG(x, v)    (HW_IPU_VDI_FSIZE_WR(x, HW_IPU_VDI_FSIZE_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_VDI_FSIZE bitfields
 */

/* --- Register HW_IPU_VDI_FSIZE, field VDI_FWIDTH (RW)
 *
 * Frame width. The value to be written to this register is the frame's width minus 1. The Frame
 * width should not be smaller than 16. The width must be even. When VDI_CMB_EN bit is clear The
 * Frame width should not be greater than 720968. When VDI_CMB_EN bit is set: The Frame width should
 * not be greater than 1920.
 */

#define BP_IPU_VDI_FSIZE_VDI_FWIDTH      0
#define BM_IPU_VDI_FSIZE_VDI_FWIDTH      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_FSIZE_VDI_FWIDTH(v)   ((((reg32_t) v) << 0) & BM_IPU_VDI_FSIZE_VDI_FWIDTH)
#else
#define BF_IPU_VDI_FSIZE_VDI_FWIDTH(v)   (((v) << 0) & BM_IPU_VDI_FSIZE_VDI_FWIDTH)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_FWIDTH field to a new value.
#define BW_IPU_VDI_FSIZE_VDI_FWIDTH(v)   BF_CS1(IPU_VDI_FSIZE, VDI_FWIDTH, v)
#endif

/* --- Register HW_IPU_VDI_FSIZE, field VDI_FHEIGHT (RW)
 *
 * Frame height The value to be written to this register is the frame's height minus 1. The frame
 * height should not be smaller than 16. When VDI_CMB_EN bit is clear: The frame height should not
 * be greater than 1080. The frame's height must be even (which means that both fields have the same
 * height) The frame's height in 4:2:0 format, must be multiple of 4 (which means that both chroma
 * fields have the same height) When VDI_CMB_EN bit is set: The frame height should not be greater
 * than 1200.
 */

#define BP_IPU_VDI_FSIZE_VDI_FHEIGHT      16
#define BM_IPU_VDI_FSIZE_VDI_FHEIGHT      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_FSIZE_VDI_FHEIGHT(v)   ((((reg32_t) v) << 16) & BM_IPU_VDI_FSIZE_VDI_FHEIGHT)
#else
#define BF_IPU_VDI_FSIZE_VDI_FHEIGHT(v)   (((v) << 16) & BM_IPU_VDI_FSIZE_VDI_FHEIGHT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_FHEIGHT field to a new value.
#define BW_IPU_VDI_FSIZE_VDI_FHEIGHT(v)   BF_CS1(IPU_VDI_FSIZE, VDI_FHEIGHT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_VDI_C - VDI Control Register (RW)
 *
 * The register used to control modes of operations of VDI  C  module.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned VDI_CH_422 : 1; //!< Chroma format at input and output of VDI C .
        unsigned VDI_MOT_SEL : 2; //!< Motion select.
        unsigned VDI_BURST_SIZE1 : 4; //!< Burst Size for channels 1 or 4 (channels 1 and 4 are not working simultaneously). The VDI C 's burst size is restrict by the IDMAC's restriction - This value must match the IDMAC settings and follow the IDMAC's restrictions
        unsigned VDI_BURST_SIZE2 : 4; //!< Burst Size for channel 2. The VDI C 's burst size is restrict by the IDMAC's restriction - This value must match the IDMAC settings and follow the IDMAC's restrictions
        unsigned VDI_BURST_SIZE3 : 4; //!< Burst Size for channel 3. The VDI C 's burst size is restrict by the IDMAC's restriction - This value must match the IDMAC settings and follow the IDMAC's restrictions
        unsigned VDI_VWM1_SET : 3; //!< VDI C WaterMark "set" level for channel 1 or channel 2 (channels 1 and 4 are not working simultaneously).
        unsigned VDI_VWM1_CLR : 3; //!< VDI C WaterMark "clear" level for channel 1 or channel 4 (channels 1 and 4 are not working simultaneously).
        unsigned VDI_VWM3_SET : 3; //!< VDI C WaterMark "set" level for channel 3.
        unsigned VDI_VWM3_CLR : 3; //!< VDI C WaterMark "clear" level for channel 3.
        unsigned RESERVED1 : 2; //!< Reserved
        unsigned RESERVED2 : 1; //!< VDI C top filed (manual) This defines what would be the next top field to be processed when the data is coming from the memory
        unsigned RESERVED3 : 1; //!< VDI C top filed (automatic) This defines what would be the top field to be processed when the data is coming from the CSI
    } B;
} hw_ipu_vdi_c_t;
#endif

/*
 * constants & macros for entire multi-block IPU_VDI_C register
 */
#define HW_IPU_VDI_C_ADDR(x)      (REGS_IPU_BASE(x) + 0x68004)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_VDI_C(x)           (*(volatile hw_ipu_vdi_c_t *) HW_IPU_VDI_C_ADDR(x))
#define HW_IPU_VDI_C_RD(x)        (HW_IPU_VDI_C(x).U)
#define HW_IPU_VDI_C_WR(x, v)     (HW_IPU_VDI_C(x).U = (v))
#define HW_IPU_VDI_C_SET(x, v)    (HW_IPU_VDI_C_WR(x, HW_IPU_VDI_C_RD(x) |  (v)))
#define HW_IPU_VDI_C_CLR(x, v)    (HW_IPU_VDI_C_WR(x, HW_IPU_VDI_C_RD(x) & ~(v)))
#define HW_IPU_VDI_C_TOG(x, v)    (HW_IPU_VDI_C_WR(x, HW_IPU_VDI_C_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_VDI_C bitfields
 */

/* --- Register HW_IPU_VDI_C, field VDI_CH_422 (RW)
 *
 * Chroma format at input and output of VDI C .
 *
 * Values:
 * 0 - Chroma format is 420.
 * 1 - Chroma format is 422.
 */

#define BP_IPU_VDI_C_VDI_CH_422      1
#define BM_IPU_VDI_C_VDI_CH_422      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C_VDI_CH_422(v)   ((((reg32_t) v) << 1) & BM_IPU_VDI_C_VDI_CH_422)
#else
#define BF_IPU_VDI_C_VDI_CH_422(v)   (((v) << 1) & BM_IPU_VDI_C_VDI_CH_422)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_CH_422 field to a new value.
#define BW_IPU_VDI_C_VDI_CH_422(v)   BF_CS1(IPU_VDI_C, VDI_CH_422, v)
#endif


/* --- Register HW_IPU_VDI_C, field VDI_MOT_SEL (RW)
 *
 * Motion select.
 *
 * Values:
 * 0 - Motion determined by ROM "1" (shared toward medium/high motion).
 * 1 - Motion determined by ROM "2" (This option will not work well for high motion).
 * 2 - Full motion, only vertical filter is used
 * 3 - Forbidden.
 */

#define BP_IPU_VDI_C_VDI_MOT_SEL      2
#define BM_IPU_VDI_C_VDI_MOT_SEL      0x0000000c

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C_VDI_MOT_SEL(v)   ((((reg32_t) v) << 2) & BM_IPU_VDI_C_VDI_MOT_SEL)
#else
#define BF_IPU_VDI_C_VDI_MOT_SEL(v)   (((v) << 2) & BM_IPU_VDI_C_VDI_MOT_SEL)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_MOT_SEL field to a new value.
#define BW_IPU_VDI_C_VDI_MOT_SEL(v)   BF_CS1(IPU_VDI_C, VDI_MOT_SEL, v)
#endif


/* --- Register HW_IPU_VDI_C, field VDI_BURST_SIZE1 (RW)
 *
 * Burst Size for channels 1 or 4 (channels 1 and 4 are not working simultaneously). The VDI C 's
 * burst size is restrict by the IDMAC's restriction - This value must match the IDMAC settings and
 * follow the IDMAC's restrictions
 *
 * Values:
 * 0 - Burst size is 1 access.
 * 1 - Burst size is 2 accesses.
 * 15 - Burst size is 16 accesses.
 */

#define BP_IPU_VDI_C_VDI_BURST_SIZE1      4
#define BM_IPU_VDI_C_VDI_BURST_SIZE1      0x000000f0

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C_VDI_BURST_SIZE1(v)   ((((reg32_t) v) << 4) & BM_IPU_VDI_C_VDI_BURST_SIZE1)
#else
#define BF_IPU_VDI_C_VDI_BURST_SIZE1(v)   (((v) << 4) & BM_IPU_VDI_C_VDI_BURST_SIZE1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_BURST_SIZE1 field to a new value.
#define BW_IPU_VDI_C_VDI_BURST_SIZE1(v)   BF_CS1(IPU_VDI_C, VDI_BURST_SIZE1, v)
#endif


/* --- Register HW_IPU_VDI_C, field VDI_BURST_SIZE2 (RW)
 *
 * Burst Size for channel 2. The VDI C 's burst size is restrict by the IDMAC's restriction - This
 * value must match the IDMAC settings and follow the IDMAC's restrictions
 *
 * Values:
 * 0 - Burst size is 1 access.
 * 1 - Burst size is 2 accesses.
 * 15 - Burst size is 16 accesses.
 */

#define BP_IPU_VDI_C_VDI_BURST_SIZE2      8
#define BM_IPU_VDI_C_VDI_BURST_SIZE2      0x00000f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C_VDI_BURST_SIZE2(v)   ((((reg32_t) v) << 8) & BM_IPU_VDI_C_VDI_BURST_SIZE2)
#else
#define BF_IPU_VDI_C_VDI_BURST_SIZE2(v)   (((v) << 8) & BM_IPU_VDI_C_VDI_BURST_SIZE2)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_BURST_SIZE2 field to a new value.
#define BW_IPU_VDI_C_VDI_BURST_SIZE2(v)   BF_CS1(IPU_VDI_C, VDI_BURST_SIZE2, v)
#endif


/* --- Register HW_IPU_VDI_C, field VDI_BURST_SIZE3 (RW)
 *
 * Burst Size for channel 3. The VDI C 's burst size is restrict by the IDMAC's restriction - This
 * value must match the IDMAC settings and follow the IDMAC's restrictions
 *
 * Values:
 * 0 - Burst size is 1 access.
 * 1 - Burst size is 2 accesses.
 * 15 - Burst size is 16 accesses.
 */

#define BP_IPU_VDI_C_VDI_BURST_SIZE3      12
#define BM_IPU_VDI_C_VDI_BURST_SIZE3      0x0000f000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C_VDI_BURST_SIZE3(v)   ((((reg32_t) v) << 12) & BM_IPU_VDI_C_VDI_BURST_SIZE3)
#else
#define BF_IPU_VDI_C_VDI_BURST_SIZE3(v)   (((v) << 12) & BM_IPU_VDI_C_VDI_BURST_SIZE3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_BURST_SIZE3 field to a new value.
#define BW_IPU_VDI_C_VDI_BURST_SIZE3(v)   BF_CS1(IPU_VDI_C, VDI_BURST_SIZE3, v)
#endif


/* --- Register HW_IPU_VDI_C, field VDI_VWM1_SET (RW)
 *
 * VDI C WaterMark "set" level for channel 1 or channel 2 (channels 1 and 4 are not working
 * simultaneously).
 *
 * Values:
 * 0 - set watermark level when FIFO1 is full on 1/8 of their size.
 * 1 - set watermark level when FIFO1 is full on 2/8 of their size.
 * 7 - set watermark level when FIFO1 is full.
 */

#define BP_IPU_VDI_C_VDI_VWM1_SET      16
#define BM_IPU_VDI_C_VDI_VWM1_SET      0x00070000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C_VDI_VWM1_SET(v)   ((((reg32_t) v) << 16) & BM_IPU_VDI_C_VDI_VWM1_SET)
#else
#define BF_IPU_VDI_C_VDI_VWM1_SET(v)   (((v) << 16) & BM_IPU_VDI_C_VDI_VWM1_SET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_VWM1_SET field to a new value.
#define BW_IPU_VDI_C_VDI_VWM1_SET(v)   BF_CS1(IPU_VDI_C, VDI_VWM1_SET, v)
#endif


/* --- Register HW_IPU_VDI_C, field VDI_VWM1_CLR (RW)
 *
 * VDI C WaterMark "clear" level for channel 1 or channel 4 (channels 1 and 4 are not working
 * simultaneously).
 *
 * Values:
 * 0 - clear watermark level when FIFO1 is full on 1/8 of their size.
 * 1 - clear watermark level when FIFO1 is full on 2/8 of their size.
 * 7 - clear watermark level when FIFO1 is full.
 */

#define BP_IPU_VDI_C_VDI_VWM1_CLR      19
#define BM_IPU_VDI_C_VDI_VWM1_CLR      0x00380000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C_VDI_VWM1_CLR(v)   ((((reg32_t) v) << 19) & BM_IPU_VDI_C_VDI_VWM1_CLR)
#else
#define BF_IPU_VDI_C_VDI_VWM1_CLR(v)   (((v) << 19) & BM_IPU_VDI_C_VDI_VWM1_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_VWM1_CLR field to a new value.
#define BW_IPU_VDI_C_VDI_VWM1_CLR(v)   BF_CS1(IPU_VDI_C, VDI_VWM1_CLR, v)
#endif


/* --- Register HW_IPU_VDI_C, field VDI_VWM3_SET (RW)
 *
 * VDI C WaterMark "set" level for channel 3.
 *
 * Values:
 * 0 - set watermark level when FIFO3 is full on 1/8 of their size.
 * 1 - set watermark level when FIFO3 is full on 2/8 of their size.
 * 7 - set watermark level when FIFO3 is full.
 */

#define BP_IPU_VDI_C_VDI_VWM3_SET      22
#define BM_IPU_VDI_C_VDI_VWM3_SET      0x01c00000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C_VDI_VWM3_SET(v)   ((((reg32_t) v) << 22) & BM_IPU_VDI_C_VDI_VWM3_SET)
#else
#define BF_IPU_VDI_C_VDI_VWM3_SET(v)   (((v) << 22) & BM_IPU_VDI_C_VDI_VWM3_SET)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_VWM3_SET field to a new value.
#define BW_IPU_VDI_C_VDI_VWM3_SET(v)   BF_CS1(IPU_VDI_C, VDI_VWM3_SET, v)
#endif


/* --- Register HW_IPU_VDI_C, field VDI_VWM3_CLR (RW)
 *
 * VDI C WaterMark "clear" level for channel 3.
 *
 * Values:
 * 0 - clear watermark level when FIFO3 is full on 1/8 of their size.
 * 1 - clear watermark level when FIFO3 is full on 2/8 of their size.
 * 7 - clear watermark level when FIFO3 is full.
 */

#define BP_IPU_VDI_C_VDI_VWM3_CLR      25
#define BM_IPU_VDI_C_VDI_VWM3_CLR      0x0e000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C_VDI_VWM3_CLR(v)   ((((reg32_t) v) << 25) & BM_IPU_VDI_C_VDI_VWM3_CLR)
#else
#define BF_IPU_VDI_C_VDI_VWM3_CLR(v)   (((v) << 25) & BM_IPU_VDI_C_VDI_VWM3_CLR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_VWM3_CLR field to a new value.
#define BW_IPU_VDI_C_VDI_VWM3_CLR(v)   BF_CS1(IPU_VDI_C, VDI_VWM3_CLR, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_VDI_C2_ - VDI Control Register 2 (RW)
 *
 * The register used to control modes of operations of VDIC module.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned VDI_CMB_EN : 1; //!< Combining enable
        unsigned VDI_KEY_COLOR_EN : 1; //!< Key Color Enable
        unsigned VDI_GLB_A_EN : 1; //!< Global alpha enable
        unsigned VDI_PLANE_1_EN : 1; //!< Plane 1 enable
        unsigned RESERVED0 : 28; //!< Reserved
    } B;
} hw_ipu_vdi_c2__t;
#endif

/*
 * constants & macros for entire multi-block IPU_VDI_C2_ register
 */
#define HW_IPU_VDI_C2__ADDR(x)      (REGS_IPU_BASE(x) + 0x68008)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_VDI_C2_(x)           (*(volatile hw_ipu_vdi_c2__t *) HW_IPU_VDI_C2__ADDR(x))
#define HW_IPU_VDI_C2__RD(x)        (HW_IPU_VDI_C2_(x).U)
#define HW_IPU_VDI_C2__WR(x, v)     (HW_IPU_VDI_C2_(x).U = (v))
#define HW_IPU_VDI_C2__SET(x, v)    (HW_IPU_VDI_C2__WR(x, HW_IPU_VDI_C2__RD(x) |  (v)))
#define HW_IPU_VDI_C2__CLR(x, v)    (HW_IPU_VDI_C2__WR(x, HW_IPU_VDI_C2__RD(x) & ~(v)))
#define HW_IPU_VDI_C2__TOG(x, v)    (HW_IPU_VDI_C2__WR(x, HW_IPU_VDI_C2__RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_VDI_C2_ bitfields
 */

/* --- Register HW_IPU_VDI_C2_, field VDI_CMB_EN (RW)
 *
 * Combining enable
 *
 * Values:
 * 0 - Combining disabled. The VDIC works in de-interlacing mode
 * 1 - Combining enabled. The de-interlacing mode is not functional
 */

#define BP_IPU_VDI_C2__VDI_CMB_EN      0
#define BM_IPU_VDI_C2__VDI_CMB_EN      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C2__VDI_CMB_EN(v)   ((((reg32_t) v) << 0) & BM_IPU_VDI_C2__VDI_CMB_EN)
#else
#define BF_IPU_VDI_C2__VDI_CMB_EN(v)   (((v) << 0) & BM_IPU_VDI_C2__VDI_CMB_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_CMB_EN field to a new value.
#define BW_IPU_VDI_C2__VDI_CMB_EN(v)   BF_CS1(IPU_VDI_C2_, VDI_CMB_EN, v)
#endif


/* --- Register HW_IPU_VDI_C2_, field VDI_KEY_COLOR_EN (RW)
 *
 * Key Color Enable
 *
 * Values:
 * 0 - Key Color disabled.
 * 1 - Key color enabled
 */

#define BP_IPU_VDI_C2__VDI_KEY_COLOR_EN      1
#define BM_IPU_VDI_C2__VDI_KEY_COLOR_EN      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C2__VDI_KEY_COLOR_EN(v)   ((((reg32_t) v) << 1) & BM_IPU_VDI_C2__VDI_KEY_COLOR_EN)
#else
#define BF_IPU_VDI_C2__VDI_KEY_COLOR_EN(v)   (((v) << 1) & BM_IPU_VDI_C2__VDI_KEY_COLOR_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_KEY_COLOR_EN field to a new value.
#define BW_IPU_VDI_C2__VDI_KEY_COLOR_EN(v)   BF_CS1(IPU_VDI_C2_, VDI_KEY_COLOR_EN, v)
#endif


/* --- Register HW_IPU_VDI_C2_, field VDI_GLB_A_EN (RW)
 *
 * Global alpha enable
 *
 * Values:
 * 0 - Alpha is local
 * 1 - Alpha is global
 */

#define BP_IPU_VDI_C2__VDI_GLB_A_EN      2
#define BM_IPU_VDI_C2__VDI_GLB_A_EN      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C2__VDI_GLB_A_EN(v)   ((((reg32_t) v) << 2) & BM_IPU_VDI_C2__VDI_GLB_A_EN)
#else
#define BF_IPU_VDI_C2__VDI_GLB_A_EN(v)   (((v) << 2) & BM_IPU_VDI_C2__VDI_GLB_A_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_GLB_A_EN field to a new value.
#define BW_IPU_VDI_C2__VDI_GLB_A_EN(v)   BF_CS1(IPU_VDI_C2_, VDI_GLB_A_EN, v)
#endif


/* --- Register HW_IPU_VDI_C2_, field VDI_PLANE_1_EN (RW)
 *
 * Plane 1 enable
 *
 * Values:
 * 0 - plane #1 is disabled
 * 1 - plane #1 is enabled
 */

#define BP_IPU_VDI_C2__VDI_PLANE_1_EN      3
#define BM_IPU_VDI_C2__VDI_PLANE_1_EN      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_C2__VDI_PLANE_1_EN(v)   ((((reg32_t) v) << 3) & BM_IPU_VDI_C2__VDI_PLANE_1_EN)
#else
#define BF_IPU_VDI_C2__VDI_PLANE_1_EN(v)   (((v) << 3) & BM_IPU_VDI_C2__VDI_PLANE_1_EN)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_PLANE_1_EN field to a new value.
#define BW_IPU_VDI_C2__VDI_PLANE_1_EN(v)   BF_CS1(IPU_VDI_C2_, VDI_PLANE_1_EN, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_VDI_CMDP_1 - VDI Combining Parameters Register 1 (RW)
 *
 * The register holds combining paramemters.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned VDI_KEY_COLOR_B : 8; //!< Blue component of Key Color
        unsigned VDI_KEY_COLOR_G : 8; //!< Green component of Key Color
        unsigned VDI_KEY_COLOR_R : 8; //!< Red component of Key Color
        unsigned VDI_ALPHA : 8; //!< Global Alpha Actual value of the alpha is VDI_ALPHA + VDI_ALPHA[7]
    } B;
} hw_ipu_vdi_cmdp_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_VDI_CMDP_1 register
 */
#define HW_IPU_VDI_CMDP_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x6800c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_VDI_CMDP_1(x)           (*(volatile hw_ipu_vdi_cmdp_1_t *) HW_IPU_VDI_CMDP_1_ADDR(x))
#define HW_IPU_VDI_CMDP_1_RD(x)        (HW_IPU_VDI_CMDP_1(x).U)
#define HW_IPU_VDI_CMDP_1_WR(x, v)     (HW_IPU_VDI_CMDP_1(x).U = (v))
#define HW_IPU_VDI_CMDP_1_SET(x, v)    (HW_IPU_VDI_CMDP_1_WR(x, HW_IPU_VDI_CMDP_1_RD(x) |  (v)))
#define HW_IPU_VDI_CMDP_1_CLR(x, v)    (HW_IPU_VDI_CMDP_1_WR(x, HW_IPU_VDI_CMDP_1_RD(x) & ~(v)))
#define HW_IPU_VDI_CMDP_1_TOG(x, v)    (HW_IPU_VDI_CMDP_1_WR(x, HW_IPU_VDI_CMDP_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_VDI_CMDP_1 bitfields
 */

/* --- Register HW_IPU_VDI_CMDP_1, field VDI_KEY_COLOR_B (RW)
 *
 * Blue component of Key Color
 */

#define BP_IPU_VDI_CMDP_1_VDI_KEY_COLOR_B      0
#define BM_IPU_VDI_CMDP_1_VDI_KEY_COLOR_B      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_CMDP_1_VDI_KEY_COLOR_B(v)   ((((reg32_t) v) << 0) & BM_IPU_VDI_CMDP_1_VDI_KEY_COLOR_B)
#else
#define BF_IPU_VDI_CMDP_1_VDI_KEY_COLOR_B(v)   (((v) << 0) & BM_IPU_VDI_CMDP_1_VDI_KEY_COLOR_B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_KEY_COLOR_B field to a new value.
#define BW_IPU_VDI_CMDP_1_VDI_KEY_COLOR_B(v)   BF_CS1(IPU_VDI_CMDP_1, VDI_KEY_COLOR_B, v)
#endif

/* --- Register HW_IPU_VDI_CMDP_1, field VDI_KEY_COLOR_G (RW)
 *
 * Green component of Key Color
 */

#define BP_IPU_VDI_CMDP_1_VDI_KEY_COLOR_G      8
#define BM_IPU_VDI_CMDP_1_VDI_KEY_COLOR_G      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_CMDP_1_VDI_KEY_COLOR_G(v)   ((((reg32_t) v) << 8) & BM_IPU_VDI_CMDP_1_VDI_KEY_COLOR_G)
#else
#define BF_IPU_VDI_CMDP_1_VDI_KEY_COLOR_G(v)   (((v) << 8) & BM_IPU_VDI_CMDP_1_VDI_KEY_COLOR_G)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_KEY_COLOR_G field to a new value.
#define BW_IPU_VDI_CMDP_1_VDI_KEY_COLOR_G(v)   BF_CS1(IPU_VDI_CMDP_1, VDI_KEY_COLOR_G, v)
#endif

/* --- Register HW_IPU_VDI_CMDP_1, field VDI_KEY_COLOR_R (RW)
 *
 * Red component of Key Color
 */

#define BP_IPU_VDI_CMDP_1_VDI_KEY_COLOR_R      16
#define BM_IPU_VDI_CMDP_1_VDI_KEY_COLOR_R      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_CMDP_1_VDI_KEY_COLOR_R(v)   ((((reg32_t) v) << 16) & BM_IPU_VDI_CMDP_1_VDI_KEY_COLOR_R)
#else
#define BF_IPU_VDI_CMDP_1_VDI_KEY_COLOR_R(v)   (((v) << 16) & BM_IPU_VDI_CMDP_1_VDI_KEY_COLOR_R)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_KEY_COLOR_R field to a new value.
#define BW_IPU_VDI_CMDP_1_VDI_KEY_COLOR_R(v)   BF_CS1(IPU_VDI_CMDP_1, VDI_KEY_COLOR_R, v)
#endif

/* --- Register HW_IPU_VDI_CMDP_1, field VDI_ALPHA (RW)
 *
 * Global Alpha Actual value of the alpha is VDI_ALPHA + VDI_ALPHA[7]
 */

#define BP_IPU_VDI_CMDP_1_VDI_ALPHA      24
#define BM_IPU_VDI_CMDP_1_VDI_ALPHA      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_CMDP_1_VDI_ALPHA(v)   ((((reg32_t) v) << 24) & BM_IPU_VDI_CMDP_1_VDI_ALPHA)
#else
#define BF_IPU_VDI_CMDP_1_VDI_ALPHA(v)   (((v) << 24) & BM_IPU_VDI_CMDP_1_VDI_ALPHA)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_ALPHA field to a new value.
#define BW_IPU_VDI_CMDP_1_VDI_ALPHA(v)   BF_CS1(IPU_VDI_CMDP_1, VDI_ALPHA, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_VDI_CMDP_2 - VDI Combining Parameters Register 2 (RW)
 *
 * The register holds combining paramemters.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned VDI_KEY_COLOR_B : 8; //!< Blue component of background Color
        unsigned VDI_KEY_COLOR_G : 8; //!< Green component of background Color
        unsigned VDI_KEY_COLOR_R : 8; //!< Red component of background Color
        unsigned RESERVED0 : 8; //!< Reserved
    } B;
} hw_ipu_vdi_cmdp_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_VDI_CMDP_2 register
 */
#define HW_IPU_VDI_CMDP_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x68010)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_VDI_CMDP_2(x)           (*(volatile hw_ipu_vdi_cmdp_2_t *) HW_IPU_VDI_CMDP_2_ADDR(x))
#define HW_IPU_VDI_CMDP_2_RD(x)        (HW_IPU_VDI_CMDP_2(x).U)
#define HW_IPU_VDI_CMDP_2_WR(x, v)     (HW_IPU_VDI_CMDP_2(x).U = (v))
#define HW_IPU_VDI_CMDP_2_SET(x, v)    (HW_IPU_VDI_CMDP_2_WR(x, HW_IPU_VDI_CMDP_2_RD(x) |  (v)))
#define HW_IPU_VDI_CMDP_2_CLR(x, v)    (HW_IPU_VDI_CMDP_2_WR(x, HW_IPU_VDI_CMDP_2_RD(x) & ~(v)))
#define HW_IPU_VDI_CMDP_2_TOG(x, v)    (HW_IPU_VDI_CMDP_2_WR(x, HW_IPU_VDI_CMDP_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_VDI_CMDP_2 bitfields
 */

/* --- Register HW_IPU_VDI_CMDP_2, field VDI_KEY_COLOR_B (RW)
 *
 * Blue component of background Color
 */

#define BP_IPU_VDI_CMDP_2_VDI_KEY_COLOR_B      0
#define BM_IPU_VDI_CMDP_2_VDI_KEY_COLOR_B      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_CMDP_2_VDI_KEY_COLOR_B(v)   ((((reg32_t) v) << 0) & BM_IPU_VDI_CMDP_2_VDI_KEY_COLOR_B)
#else
#define BF_IPU_VDI_CMDP_2_VDI_KEY_COLOR_B(v)   (((v) << 0) & BM_IPU_VDI_CMDP_2_VDI_KEY_COLOR_B)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_KEY_COLOR_B field to a new value.
#define BW_IPU_VDI_CMDP_2_VDI_KEY_COLOR_B(v)   BF_CS1(IPU_VDI_CMDP_2, VDI_KEY_COLOR_B, v)
#endif

/* --- Register HW_IPU_VDI_CMDP_2, field VDI_KEY_COLOR_G (RW)
 *
 * Green component of background Color
 */

#define BP_IPU_VDI_CMDP_2_VDI_KEY_COLOR_G      8
#define BM_IPU_VDI_CMDP_2_VDI_KEY_COLOR_G      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_CMDP_2_VDI_KEY_COLOR_G(v)   ((((reg32_t) v) << 8) & BM_IPU_VDI_CMDP_2_VDI_KEY_COLOR_G)
#else
#define BF_IPU_VDI_CMDP_2_VDI_KEY_COLOR_G(v)   (((v) << 8) & BM_IPU_VDI_CMDP_2_VDI_KEY_COLOR_G)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_KEY_COLOR_G field to a new value.
#define BW_IPU_VDI_CMDP_2_VDI_KEY_COLOR_G(v)   BF_CS1(IPU_VDI_CMDP_2, VDI_KEY_COLOR_G, v)
#endif

/* --- Register HW_IPU_VDI_CMDP_2, field VDI_KEY_COLOR_R (RW)
 *
 * Red component of background Color
 */

#define BP_IPU_VDI_CMDP_2_VDI_KEY_COLOR_R      16
#define BM_IPU_VDI_CMDP_2_VDI_KEY_COLOR_R      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_CMDP_2_VDI_KEY_COLOR_R(v)   ((((reg32_t) v) << 16) & BM_IPU_VDI_CMDP_2_VDI_KEY_COLOR_R)
#else
#define BF_IPU_VDI_CMDP_2_VDI_KEY_COLOR_R(v)   (((v) << 16) & BM_IPU_VDI_CMDP_2_VDI_KEY_COLOR_R)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_KEY_COLOR_R field to a new value.
#define BW_IPU_VDI_CMDP_2_VDI_KEY_COLOR_R(v)   BF_CS1(IPU_VDI_CMDP_2, VDI_KEY_COLOR_R, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_VDI_PS_1 - VDI Plane Size Register 1 (RW)
 *
 * The register holds the plane size's paramemters.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned VDI_FWIDTH1 : 11; //!< Plane 1 width. The value to be written to this register is the plane's width minus 1. The Plane width should not be smaller than 16. The Plane width should not be greater than 1920. The width must be even.
        unsigned RESERVED0 : 5; //!< Reserved
        unsigned VDI_FHEIGHT1 : 11; //!< Plane 1 height The value to be written to this register is the plane's height minus 1. The Plane height should not be smaller than 16. The Plane height should not be greater than 1200. The Plane's height must be even
        unsigned RESERVED1 : 5; //!< Reserved.
    } B;
} hw_ipu_vdi_ps_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_VDI_PS_1 register
 */
#define HW_IPU_VDI_PS_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x68014)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_VDI_PS_1(x)           (*(volatile hw_ipu_vdi_ps_1_t *) HW_IPU_VDI_PS_1_ADDR(x))
#define HW_IPU_VDI_PS_1_RD(x)        (HW_IPU_VDI_PS_1(x).U)
#define HW_IPU_VDI_PS_1_WR(x, v)     (HW_IPU_VDI_PS_1(x).U = (v))
#define HW_IPU_VDI_PS_1_SET(x, v)    (HW_IPU_VDI_PS_1_WR(x, HW_IPU_VDI_PS_1_RD(x) |  (v)))
#define HW_IPU_VDI_PS_1_CLR(x, v)    (HW_IPU_VDI_PS_1_WR(x, HW_IPU_VDI_PS_1_RD(x) & ~(v)))
#define HW_IPU_VDI_PS_1_TOG(x, v)    (HW_IPU_VDI_PS_1_WR(x, HW_IPU_VDI_PS_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_VDI_PS_1 bitfields
 */

/* --- Register HW_IPU_VDI_PS_1, field VDI_FWIDTH1 (RW)
 *
 * Plane 1 width. The value to be written to this register is the plane's width minus 1. The Plane
 * width should not be smaller than 16. The Plane width should not be greater than 1920. The width
 * must be even.
 */

#define BP_IPU_VDI_PS_1_VDI_FWIDTH1      0
#define BM_IPU_VDI_PS_1_VDI_FWIDTH1      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_PS_1_VDI_FWIDTH1(v)   ((((reg32_t) v) << 0) & BM_IPU_VDI_PS_1_VDI_FWIDTH1)
#else
#define BF_IPU_VDI_PS_1_VDI_FWIDTH1(v)   (((v) << 0) & BM_IPU_VDI_PS_1_VDI_FWIDTH1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_FWIDTH1 field to a new value.
#define BW_IPU_VDI_PS_1_VDI_FWIDTH1(v)   BF_CS1(IPU_VDI_PS_1, VDI_FWIDTH1, v)
#endif

/* --- Register HW_IPU_VDI_PS_1, field VDI_FHEIGHT1 (RW)
 *
 * Plane 1 height The value to be written to this register is the plane's height minus 1. The Plane
 * height should not be smaller than 16. The Plane height should not be greater than 1200. The
 * Plane's height must be even
 */

#define BP_IPU_VDI_PS_1_VDI_FHEIGHT1      16
#define BM_IPU_VDI_PS_1_VDI_FHEIGHT1      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_PS_1_VDI_FHEIGHT1(v)   ((((reg32_t) v) << 16) & BM_IPU_VDI_PS_1_VDI_FHEIGHT1)
#else
#define BF_IPU_VDI_PS_1_VDI_FHEIGHT1(v)   (((v) << 16) & BM_IPU_VDI_PS_1_VDI_FHEIGHT1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_FHEIGHT1 field to a new value.
#define BW_IPU_VDI_PS_1_VDI_FHEIGHT1(v)   BF_CS1(IPU_VDI_PS_1, VDI_FHEIGHT1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_VDI_PS_2 - VDI Plane Size Register 2 (RW)
 *
 * The register holds the plane's offset paramemters.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned VDI_OFFSET_HOR1 : 11; //!< Horizontal offset of plane 1
        unsigned RESERVED0 : 5; //!< Reserved
        unsigned VDI_OFFSET_VER1 : 11; //!< Vertical offset of plane 1
        unsigned RESERVED1 : 5; //!< Reserved.
    } B;
} hw_ipu_vdi_ps_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_VDI_PS_2 register
 */
#define HW_IPU_VDI_PS_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x68018)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_VDI_PS_2(x)           (*(volatile hw_ipu_vdi_ps_2_t *) HW_IPU_VDI_PS_2_ADDR(x))
#define HW_IPU_VDI_PS_2_RD(x)        (HW_IPU_VDI_PS_2(x).U)
#define HW_IPU_VDI_PS_2_WR(x, v)     (HW_IPU_VDI_PS_2(x).U = (v))
#define HW_IPU_VDI_PS_2_SET(x, v)    (HW_IPU_VDI_PS_2_WR(x, HW_IPU_VDI_PS_2_RD(x) |  (v)))
#define HW_IPU_VDI_PS_2_CLR(x, v)    (HW_IPU_VDI_PS_2_WR(x, HW_IPU_VDI_PS_2_RD(x) & ~(v)))
#define HW_IPU_VDI_PS_2_TOG(x, v)    (HW_IPU_VDI_PS_2_WR(x, HW_IPU_VDI_PS_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_VDI_PS_2 bitfields
 */

/* --- Register HW_IPU_VDI_PS_2, field VDI_OFFSET_HOR1 (RW)
 *
 * Horizontal offset of plane 1
 */

#define BP_IPU_VDI_PS_2_VDI_OFFSET_HOR1      0
#define BM_IPU_VDI_PS_2_VDI_OFFSET_HOR1      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_PS_2_VDI_OFFSET_HOR1(v)   ((((reg32_t) v) << 0) & BM_IPU_VDI_PS_2_VDI_OFFSET_HOR1)
#else
#define BF_IPU_VDI_PS_2_VDI_OFFSET_HOR1(v)   (((v) << 0) & BM_IPU_VDI_PS_2_VDI_OFFSET_HOR1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_OFFSET_HOR1 field to a new value.
#define BW_IPU_VDI_PS_2_VDI_OFFSET_HOR1(v)   BF_CS1(IPU_VDI_PS_2, VDI_OFFSET_HOR1, v)
#endif

/* --- Register HW_IPU_VDI_PS_2, field VDI_OFFSET_VER1 (RW)
 *
 * Vertical offset of plane 1
 */

#define BP_IPU_VDI_PS_2_VDI_OFFSET_VER1      16
#define BM_IPU_VDI_PS_2_VDI_OFFSET_VER1      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_PS_2_VDI_OFFSET_VER1(v)   ((((reg32_t) v) << 16) & BM_IPU_VDI_PS_2_VDI_OFFSET_VER1)
#else
#define BF_IPU_VDI_PS_2_VDI_OFFSET_VER1(v)   (((v) << 16) & BM_IPU_VDI_PS_2_VDI_OFFSET_VER1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_OFFSET_VER1 field to a new value.
#define BW_IPU_VDI_PS_2_VDI_OFFSET_VER1(v)   BF_CS1(IPU_VDI_PS_2, VDI_OFFSET_VER1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_VDI_PS_3 - VDI Plane Size Register 3 (RW)
 *
 * The register holds the plane size's paramemters.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned VDI_FWIDTH3 : 11; //!< Plane 3 width. The value to be written to this register is the plane's width minus 1. The Plane width should not be smaller than 16. The Plane width should not be greater than 1920. The width must be even.
        unsigned RESERVED0 : 5; //!< Reserved
        unsigned VDI_FHEIGHT3 : 11; //!< Plane 3 height The value to be written to this register is the plane's height minus 1. The Plane height should not be smaller than 16. The Plane height should not be greater than 1200. The Plane's height must be even
        unsigned RESERVED1 : 5; //!< Reserved.
    } B;
} hw_ipu_vdi_ps_3_t;
#endif

/*
 * constants & macros for entire multi-block IPU_VDI_PS_3 register
 */
#define HW_IPU_VDI_PS_3_ADDR(x)      (REGS_IPU_BASE(x) + 0x6801c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_VDI_PS_3(x)           (*(volatile hw_ipu_vdi_ps_3_t *) HW_IPU_VDI_PS_3_ADDR(x))
#define HW_IPU_VDI_PS_3_RD(x)        (HW_IPU_VDI_PS_3(x).U)
#define HW_IPU_VDI_PS_3_WR(x, v)     (HW_IPU_VDI_PS_3(x).U = (v))
#define HW_IPU_VDI_PS_3_SET(x, v)    (HW_IPU_VDI_PS_3_WR(x, HW_IPU_VDI_PS_3_RD(x) |  (v)))
#define HW_IPU_VDI_PS_3_CLR(x, v)    (HW_IPU_VDI_PS_3_WR(x, HW_IPU_VDI_PS_3_RD(x) & ~(v)))
#define HW_IPU_VDI_PS_3_TOG(x, v)    (HW_IPU_VDI_PS_3_WR(x, HW_IPU_VDI_PS_3_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_VDI_PS_3 bitfields
 */

/* --- Register HW_IPU_VDI_PS_3, field VDI_FWIDTH3 (RW)
 *
 * Plane 3 width. The value to be written to this register is the plane's width minus 1. The Plane
 * width should not be smaller than 16. The Plane width should not be greater than 1920. The width
 * must be even.
 */

#define BP_IPU_VDI_PS_3_VDI_FWIDTH3      0
#define BM_IPU_VDI_PS_3_VDI_FWIDTH3      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_PS_3_VDI_FWIDTH3(v)   ((((reg32_t) v) << 0) & BM_IPU_VDI_PS_3_VDI_FWIDTH3)
#else
#define BF_IPU_VDI_PS_3_VDI_FWIDTH3(v)   (((v) << 0) & BM_IPU_VDI_PS_3_VDI_FWIDTH3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_FWIDTH3 field to a new value.
#define BW_IPU_VDI_PS_3_VDI_FWIDTH3(v)   BF_CS1(IPU_VDI_PS_3, VDI_FWIDTH3, v)
#endif

/* --- Register HW_IPU_VDI_PS_3, field VDI_FHEIGHT3 (RW)
 *
 * Plane 3 height The value to be written to this register is the plane's height minus 1. The Plane
 * height should not be smaller than 16. The Plane height should not be greater than 1200. The
 * Plane's height must be even
 */

#define BP_IPU_VDI_PS_3_VDI_FHEIGHT3      16
#define BM_IPU_VDI_PS_3_VDI_FHEIGHT3      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_PS_3_VDI_FHEIGHT3(v)   ((((reg32_t) v) << 16) & BM_IPU_VDI_PS_3_VDI_FHEIGHT3)
#else
#define BF_IPU_VDI_PS_3_VDI_FHEIGHT3(v)   (((v) << 16) & BM_IPU_VDI_PS_3_VDI_FHEIGHT3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_FHEIGHT3 field to a new value.
#define BW_IPU_VDI_PS_3_VDI_FHEIGHT3(v)   BF_CS1(IPU_VDI_PS_3, VDI_FHEIGHT3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_VDI_PS_4 - VDI Plane Size Register 4 (RW)
 *
 * The register holds the plane's offset paramemters.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned VDI_OFFSET_HOR3 : 11; //!< Horizontal offset of plane 3
        unsigned RESERVED0 : 5; //!< Reserved
        unsigned VDI_OFFSET_VER3 : 11; //!< Vertical offset of plane 3
        unsigned RESERVED1 : 5; //!< Reserved.
    } B;
} hw_ipu_vdi_ps_4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_VDI_PS_4 register
 */
#define HW_IPU_VDI_PS_4_ADDR(x)      (REGS_IPU_BASE(x) + 0x68020)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_VDI_PS_4(x)           (*(volatile hw_ipu_vdi_ps_4_t *) HW_IPU_VDI_PS_4_ADDR(x))
#define HW_IPU_VDI_PS_4_RD(x)        (HW_IPU_VDI_PS_4(x).U)
#define HW_IPU_VDI_PS_4_WR(x, v)     (HW_IPU_VDI_PS_4(x).U = (v))
#define HW_IPU_VDI_PS_4_SET(x, v)    (HW_IPU_VDI_PS_4_WR(x, HW_IPU_VDI_PS_4_RD(x) |  (v)))
#define HW_IPU_VDI_PS_4_CLR(x, v)    (HW_IPU_VDI_PS_4_WR(x, HW_IPU_VDI_PS_4_RD(x) & ~(v)))
#define HW_IPU_VDI_PS_4_TOG(x, v)    (HW_IPU_VDI_PS_4_WR(x, HW_IPU_VDI_PS_4_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_VDI_PS_4 bitfields
 */

/* --- Register HW_IPU_VDI_PS_4, field VDI_OFFSET_HOR3 (RW)
 *
 * Horizontal offset of plane 3
 */

#define BP_IPU_VDI_PS_4_VDI_OFFSET_HOR3      0
#define BM_IPU_VDI_PS_4_VDI_OFFSET_HOR3      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_PS_4_VDI_OFFSET_HOR3(v)   ((((reg32_t) v) << 0) & BM_IPU_VDI_PS_4_VDI_OFFSET_HOR3)
#else
#define BF_IPU_VDI_PS_4_VDI_OFFSET_HOR3(v)   (((v) << 0) & BM_IPU_VDI_PS_4_VDI_OFFSET_HOR3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_OFFSET_HOR3 field to a new value.
#define BW_IPU_VDI_PS_4_VDI_OFFSET_HOR3(v)   BF_CS1(IPU_VDI_PS_4, VDI_OFFSET_HOR3, v)
#endif

/* --- Register HW_IPU_VDI_PS_4, field VDI_OFFSET_VER3 (RW)
 *
 * Vertical offset of plane 3
 */

#define BP_IPU_VDI_PS_4_VDI_OFFSET_VER3      16
#define BM_IPU_VDI_PS_4_VDI_OFFSET_VER3      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_VDI_PS_4_VDI_OFFSET_VER3(v)   ((((reg32_t) v) << 16) & BM_IPU_VDI_PS_4_VDI_OFFSET_VER3)
#else
#define BF_IPU_VDI_PS_4_VDI_OFFSET_VER3(v)   (((v) << 16) & BM_IPU_VDI_PS_4_VDI_OFFSET_VER3)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the VDI_OFFSET_VER3 field to a new value.
#define BW_IPU_VDI_PS_4_VDI_OFFSET_VER3(v)   BF_CS1(IPU_VDI_PS_4, VDI_OFFSET_VER3, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_SUB_ADDR_0 - IDMAC Channel Alternate Address 0 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_SUB_ADDR : 32; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
    } B;
} hw_ipu_idmac_sub_addr_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_SUB_ADDR_0 register
 */
#define HW_IPU_IDMAC_SUB_ADDR_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x8028c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_SUB_ADDR_0(x)           (*(volatile hw_ipu_idmac_sub_addr_0_t *) HW_IPU_IDMAC_SUB_ADDR_0_ADDR(x))
#define HW_IPU_IDMAC_SUB_ADDR_0_RD(x)        (HW_IPU_IDMAC_SUB_ADDR_0(x).U)
#define HW_IPU_IDMAC_SUB_ADDR_0_WR(x, v)     (HW_IPU_IDMAC_SUB_ADDR_0(x).U = (v))
#define HW_IPU_IDMAC_SUB_ADDR_0_SET(x, v)    (HW_IPU_IDMAC_SUB_ADDR_0_WR(x, HW_IPU_IDMAC_SUB_ADDR_0_RD(x) |  (v)))
#define HW_IPU_IDMAC_SUB_ADDR_0_CLR(x, v)    (HW_IPU_IDMAC_SUB_ADDR_0_WR(x, HW_IPU_IDMAC_SUB_ADDR_0_RD(x) & ~(v)))
#define HW_IPU_IDMAC_SUB_ADDR_0_TOG(x, v)    (HW_IPU_IDMAC_SUB_ADDR_0_WR(x, HW_IPU_IDMAC_SUB_ADDR_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_SUB_ADDR_0 bitfields
 */

/* --- Register HW_IPU_IDMAC_SUB_ADDR_0, field IDMAC_SUB_ADDR (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_0_IDMAC_SUB_ADDR      0
#define BM_IPU_IDMAC_SUB_ADDR_0_IDMAC_SUB_ADDR      0xffffffff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_0_IDMAC_SUB_ADDR(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_SUB_ADDR_0_IDMAC_SUB_ADDR)
#else
#define BF_IPU_IDMAC_SUB_ADDR_0_IDMAC_SUB_ADDR(v)   (((v) << 0) & BM_IPU_IDMAC_SUB_ADDR_0_IDMAC_SUB_ADDR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_0_IDMAC_SUB_ADDR(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_0, IDMAC_SUB_ADDR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_SUB_ADDR_4 - IDMAC Channel Alternate Address 4 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_SUB_ADDR_28 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_SUB_ADDR_8 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED1 : 1; //!< Reserved.
        unsigned IDMAC_SUB_ADDR_21 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED2 : 9; //!< Reserved.
    } B;
} hw_ipu_idmac_sub_addr_4_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_SUB_ADDR_4 register
 */
#define HW_IPU_IDMAC_SUB_ADDR_4_ADDR(x)      (REGS_IPU_BASE(x) + 0x8030c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_SUB_ADDR_4(x)           (*(volatile hw_ipu_idmac_sub_addr_4_t *) HW_IPU_IDMAC_SUB_ADDR_4_ADDR(x))
#define HW_IPU_IDMAC_SUB_ADDR_4_RD(x)        (HW_IPU_IDMAC_SUB_ADDR_4(x).U)
#define HW_IPU_IDMAC_SUB_ADDR_4_WR(x, v)     (HW_IPU_IDMAC_SUB_ADDR_4(x).U = (v))
#define HW_IPU_IDMAC_SUB_ADDR_4_SET(x, v)    (HW_IPU_IDMAC_SUB_ADDR_4_WR(x, HW_IPU_IDMAC_SUB_ADDR_4_RD(x) |  (v)))
#define HW_IPU_IDMAC_SUB_ADDR_4_CLR(x, v)    (HW_IPU_IDMAC_SUB_ADDR_4_WR(x, HW_IPU_IDMAC_SUB_ADDR_4_RD(x) & ~(v)))
#define HW_IPU_IDMAC_SUB_ADDR_4_TOG(x, v)    (HW_IPU_IDMAC_SUB_ADDR_4_WR(x, HW_IPU_IDMAC_SUB_ADDR_4_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_SUB_ADDR_4 bitfields
 */

/* --- Register HW_IPU_IDMAC_SUB_ADDR_4, field IDMAC_SUB_ADDR_28 (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_28      0
#define BM_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_28      0x0000007f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_28(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_28)
#else
#define BF_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_28(v)   (((v) << 0) & BM_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_28)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR_28 field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_28(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_4, IDMAC_SUB_ADDR_28, v)
#endif

/* --- Register HW_IPU_IDMAC_SUB_ADDR_4, field IDMAC_SUB_ADDR_8 (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_8      8
#define BM_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_8      0x00007f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_8(v)   ((((reg32_t) v) << 8) & BM_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_8)
#else
#define BF_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_8(v)   (((v) << 8) & BM_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_8)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR_8 field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_8(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_4, IDMAC_SUB_ADDR_8, v)
#endif

/* --- Register HW_IPU_IDMAC_SUB_ADDR_4, field IDMAC_SUB_ADDR_21 (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_21      16
#define BM_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_21      0x007f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_21(v)   ((((reg32_t) v) << 16) & BM_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_21)
#else
#define BF_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_21(v)   (((v) << 16) & BM_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_21)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR_21 field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_4_IDMAC_SUB_ADDR_21(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_4, IDMAC_SUB_ADDR_21, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_SUB_ADDR_1 - IDMAC Channel Alternate Address 1 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned IDMAC_SUB_ADDR : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED0 : 1; //!< Reserved.
        unsigned IDMAC_SUB_ADDR1 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED1 : 1; //!< Reserved.
        unsigned IDMAC_SUB_ADDR2 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED2 : 1; //!< Reserved.
        unsigned IDMAC_SUB_ADDR3 : 7; //!< The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel. Alternative CPMEM entry is relevant only for channels supporting alternate flows.
        unsigned RESERVED3 : 1; //!< Reserved.
    } B;
} hw_ipu_idmac_sub_addr_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_SUB_ADDR_1 register
 */
#define HW_IPU_IDMAC_SUB_ADDR_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x802c30)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_SUB_ADDR_1(x)           (*(volatile hw_ipu_idmac_sub_addr_1_t *) HW_IPU_IDMAC_SUB_ADDR_1_ADDR(x))
#define HW_IPU_IDMAC_SUB_ADDR_1_RD(x)        (HW_IPU_IDMAC_SUB_ADDR_1(x).U)
#define HW_IPU_IDMAC_SUB_ADDR_1_WR(x, v)     (HW_IPU_IDMAC_SUB_ADDR_1(x).U = (v))
#define HW_IPU_IDMAC_SUB_ADDR_1_SET(x, v)    (HW_IPU_IDMAC_SUB_ADDR_1_WR(x, HW_IPU_IDMAC_SUB_ADDR_1_RD(x) |  (v)))
#define HW_IPU_IDMAC_SUB_ADDR_1_CLR(x, v)    (HW_IPU_IDMAC_SUB_ADDR_1_WR(x, HW_IPU_IDMAC_SUB_ADDR_1_RD(x) & ~(v)))
#define HW_IPU_IDMAC_SUB_ADDR_1_TOG(x, v)    (HW_IPU_IDMAC_SUB_ADDR_1_WR(x, HW_IPU_IDMAC_SUB_ADDR_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_SUB_ADDR_1 bitfields
 */

/* --- Register HW_IPU_IDMAC_SUB_ADDR_1, field IDMAC_SUB_ADDR (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR      0
#define BM_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR      0x0000007f

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR)
#else
#define BF_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR(v)   (((v) << 0) & BM_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_1, IDMAC_SUB_ADDR, v)
#endif

/* --- Register HW_IPU_IDMAC_SUB_ADDR_1, field IDMAC_SUB_ADDR (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR      8
#define BM_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR      0x00007f00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR(v)   ((((reg32_t) v) << 8) & BM_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR)
#else
#define BF_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR(v)   (((v) << 8) & BM_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_1, IDMAC_SUB_ADDR, v)
#endif

/* --- Register HW_IPU_IDMAC_SUB_ADDR_1, field IDMAC_SUB_ADDR (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR      16
#define BM_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR      0x007f0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR(v)   ((((reg32_t) v) << 16) & BM_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR)
#else
#define BF_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR(v)   (((v) << 16) & BM_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_1, IDMAC_SUB_ADDR, v)
#endif

/* --- Register HW_IPU_IDMAC_SUB_ADDR_1, field IDMAC_SUB_ADDR (RW)
 *
 * The CPMEM alternative entry [i] holds the parameters of the channel that is number appears in
 * IDMAC_SUB_ADDR[i]. The user must set each IDMAC_SUB_ADDR[i] field to a unique channel.
 * Alternative CPMEM entry is relevant only for channels supporting alternate flows.
 */

#define BP_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR      24
#define BM_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR      0x7f000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR(v)   ((((reg32_t) v) << 24) & BM_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR)
#else
#define BF_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR(v)   (((v) << 24) & BM_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_SUB_ADDR field to a new value.
#define BW_IPU_IDMAC_SUB_ADDR_1_IDMAC_SUB_ADDR(v)   BF_CS1(IPU_IDMAC_SUB_ADDR_1, IDMAC_SUB_ADDR, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_COM_CONF_SYNC - DP Common Configuration Sync Flow Register (RW)
 *
 * This register contains common configuration parameters for the DP.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_FG_EN_SYNC : 1; //!< FG_EN - partial plane Enable. This bit enables the partial plane channel.
        unsigned DP_GWSEL_SYNC : 1; //!< GWSEL - Graphic Window Select Select graphic window to be on partial plane or full plane.
        unsigned DP_GWAM_SYNC : 1; //!< GWAM - Graphic Window Alpha Mode Select the use of Alpha to be global or local.
        unsigned DP_GWCKE_SYNC : 1; //!< GWCKE - Graphic Window Color Keying Enable Enable or disable graphic window color keying.
        unsigned DP_COC_SYNC : 3; //!< COC - Cursor Operation Control Controls the format of the cursor and the type of arithmetic operations
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DP_CSC_DEF_SYNC : 2; //!< CSC_DEF Enable or disable Color Space Conversion.
        unsigned DP_CSC_GAMUT_SAT_EN_SYNC : 1; //!< CSC_GAMUT_SAT_EN Indicate if GAMUT saturation is enabled
        unsigned DP_CSC_YUV_SAT_MODE_SYNC : 1; //!< CSC_YUV_SAT_MODE YUV saturation mode for color space conversion
        unsigned DP_GAMMA_EN_SYNC : 1; //!< GAMMA_EN - Gamma correction block enable bit
        unsigned DP_GAMMA_YUV_EN_SYNC : 1; //!< GAMMA's YUV mode enable for sync flow
        unsigned RESERVED1 : 18; //!< Reserved
    } B;
} hw_ipu_dp_com_conf_sync_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_COM_CONF_SYNC register
 */
#define HW_IPU_DP_COM_CONF_SYNC_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040000)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_COM_CONF_SYNC(x)           (*(volatile hw_ipu_dp_com_conf_sync_t *) HW_IPU_DP_COM_CONF_SYNC_ADDR(x))
#define HW_IPU_DP_COM_CONF_SYNC_RD(x)        (HW_IPU_DP_COM_CONF_SYNC(x).U)
#define HW_IPU_DP_COM_CONF_SYNC_WR(x, v)     (HW_IPU_DP_COM_CONF_SYNC(x).U = (v))
#define HW_IPU_DP_COM_CONF_SYNC_SET(x, v)    (HW_IPU_DP_COM_CONF_SYNC_WR(x, HW_IPU_DP_COM_CONF_SYNC_RD(x) |  (v)))
#define HW_IPU_DP_COM_CONF_SYNC_CLR(x, v)    (HW_IPU_DP_COM_CONF_SYNC_WR(x, HW_IPU_DP_COM_CONF_SYNC_RD(x) & ~(v)))
#define HW_IPU_DP_COM_CONF_SYNC_TOG(x, v)    (HW_IPU_DP_COM_CONF_SYNC_WR(x, HW_IPU_DP_COM_CONF_SYNC_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_COM_CONF_SYNC bitfields
 */

/* --- Register HW_IPU_DP_COM_CONF_SYNC, field DP_FG_EN_SYNC (RW)
 *
 * FG_EN - partial plane Enable. This bit enables the partial plane channel.
 *
 * Values:
 * 1 - partial plane channel is enabled.
 * 0 - partial plane channel is disabled.
 */

#define BP_IPU_DP_COM_CONF_SYNC_DP_FG_EN_SYNC      0
#define BM_IPU_DP_COM_CONF_SYNC_DP_FG_EN_SYNC      0x00000001

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_SYNC_DP_FG_EN_SYNC(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_COM_CONF_SYNC_DP_FG_EN_SYNC)
#else
#define BF_IPU_DP_COM_CONF_SYNC_DP_FG_EN_SYNC(v)   (((v) << 0) & BM_IPU_DP_COM_CONF_SYNC_DP_FG_EN_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_FG_EN_SYNC field to a new value.
#define BW_IPU_DP_COM_CONF_SYNC_DP_FG_EN_SYNC(v)   BF_CS1(IPU_DP_COM_CONF_SYNC, DP_FG_EN_SYNC, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_SYNC, field DP_GWSEL_SYNC (RW)
 *
 * GWSEL - Graphic Window Select Select graphic window to be on partial plane or full plane.
 *
 * Values:
 * 1 - Graphic window is partial plane.
 * 0 - Graphic window is full plane.
 */

#define BP_IPU_DP_COM_CONF_SYNC_DP_GWSEL_SYNC      1
#define BM_IPU_DP_COM_CONF_SYNC_DP_GWSEL_SYNC      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_SYNC_DP_GWSEL_SYNC(v)   ((((reg32_t) v) << 1) & BM_IPU_DP_COM_CONF_SYNC_DP_GWSEL_SYNC)
#else
#define BF_IPU_DP_COM_CONF_SYNC_DP_GWSEL_SYNC(v)   (((v) << 1) & BM_IPU_DP_COM_CONF_SYNC_DP_GWSEL_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWSEL_SYNC field to a new value.
#define BW_IPU_DP_COM_CONF_SYNC_DP_GWSEL_SYNC(v)   BF_CS1(IPU_DP_COM_CONF_SYNC, DP_GWSEL_SYNC, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_SYNC, field DP_GWAM_SYNC (RW)
 *
 * GWAM - Graphic Window Alpha Mode Select the use of Alpha to be global or local.
 *
 * Values:
 * 1 - Global Alpha.
 * 0 - Local Alpha.
 */

#define BP_IPU_DP_COM_CONF_SYNC_DP_GWAM_SYNC      2
#define BM_IPU_DP_COM_CONF_SYNC_DP_GWAM_SYNC      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_SYNC_DP_GWAM_SYNC(v)   ((((reg32_t) v) << 2) & BM_IPU_DP_COM_CONF_SYNC_DP_GWAM_SYNC)
#else
#define BF_IPU_DP_COM_CONF_SYNC_DP_GWAM_SYNC(v)   (((v) << 2) & BM_IPU_DP_COM_CONF_SYNC_DP_GWAM_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWAM_SYNC field to a new value.
#define BW_IPU_DP_COM_CONF_SYNC_DP_GWAM_SYNC(v)   BF_CS1(IPU_DP_COM_CONF_SYNC, DP_GWAM_SYNC, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_SYNC, field DP_GWCKE_SYNC (RW)
 *
 * GWCKE - Graphic Window Color Keying Enable Enable or disable graphic window color keying.
 *
 * Values:
 * 1 - Enable color keying of graphic window
 * 0 - Disable color keying of graphic window
 */

#define BP_IPU_DP_COM_CONF_SYNC_DP_GWCKE_SYNC      3
#define BM_IPU_DP_COM_CONF_SYNC_DP_GWCKE_SYNC      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_SYNC_DP_GWCKE_SYNC(v)   ((((reg32_t) v) << 3) & BM_IPU_DP_COM_CONF_SYNC_DP_GWCKE_SYNC)
#else
#define BF_IPU_DP_COM_CONF_SYNC_DP_GWCKE_SYNC(v)   (((v) << 3) & BM_IPU_DP_COM_CONF_SYNC_DP_GWCKE_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWCKE_SYNC field to a new value.
#define BW_IPU_DP_COM_CONF_SYNC_DP_GWCKE_SYNC(v)   BF_CS1(IPU_DP_COM_CONF_SYNC, DP_GWCKE_SYNC, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_SYNC, field DP_COC_SYNC (RW)
 *
 * COC - Cursor Operation Control Controls the format of the cursor and the type of arithmetic
 * operations
 *
 * Values:
 * 000 - Transparent, cursor is disabled.
 * 001 - Full cursor.
 * 010 - Reversed cursor.
 * 011 - AND between full plane and cursor.
 * 100 - Reserved
 * 101 - OR between full plane and cursor.
 * 110 - XOR between full plane and cursor.
 * 111 - Reserved.
 */

#define BP_IPU_DP_COM_CONF_SYNC_DP_COC_SYNC      4
#define BM_IPU_DP_COM_CONF_SYNC_DP_COC_SYNC      0x00000070

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_SYNC_DP_COC_SYNC(v)   ((((reg32_t) v) << 4) & BM_IPU_DP_COM_CONF_SYNC_DP_COC_SYNC)
#else
#define BF_IPU_DP_COM_CONF_SYNC_DP_COC_SYNC(v)   (((v) << 4) & BM_IPU_DP_COM_CONF_SYNC_DP_COC_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_COC_SYNC field to a new value.
#define BW_IPU_DP_COM_CONF_SYNC_DP_COC_SYNC(v)   BF_CS1(IPU_DP_COM_CONF_SYNC, DP_COC_SYNC, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_SYNC, field DP_CSC_DEF_SYNC (RW)
 *
 * CSC_DEF Enable or disable Color Space Conversion.
 *
 * Values:
 * 00 - CSC disable
 * 01 - CSC enable after combining
 * 10 - CSC enable before combining on BG channel
 * 11 - CSC enable before combining on FG channel
 */

#define BP_IPU_DP_COM_CONF_SYNC_DP_CSC_DEF_SYNC      8
#define BM_IPU_DP_COM_CONF_SYNC_DP_CSC_DEF_SYNC      0x00000300

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_SYNC_DP_CSC_DEF_SYNC(v)   ((((reg32_t) v) << 8) & BM_IPU_DP_COM_CONF_SYNC_DP_CSC_DEF_SYNC)
#else
#define BF_IPU_DP_COM_CONF_SYNC_DP_CSC_DEF_SYNC(v)   (((v) << 8) & BM_IPU_DP_COM_CONF_SYNC_DP_CSC_DEF_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_DEF_SYNC field to a new value.
#define BW_IPU_DP_COM_CONF_SYNC_DP_CSC_DEF_SYNC(v)   BF_CS1(IPU_DP_COM_CONF_SYNC, DP_CSC_DEF_SYNC, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_SYNC, field DP_CSC_GAMUT_SAT_EN_SYNC (RW)
 *
 * CSC_GAMUT_SAT_EN Indicate if GAMUT saturation is enabled
 *
 * Values:
 * 0 - disable GAMUT mapping
 * 1 - enable GAMUT mapping
 */

#define BP_IPU_DP_COM_CONF_SYNC_DP_CSC_GAMUT_SAT_EN_SYNC      10
#define BM_IPU_DP_COM_CONF_SYNC_DP_CSC_GAMUT_SAT_EN_SYNC      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_SYNC_DP_CSC_GAMUT_SAT_EN_SYNC(v)   ((((reg32_t) v) << 10) & BM_IPU_DP_COM_CONF_SYNC_DP_CSC_GAMUT_SAT_EN_SYNC)
#else
#define BF_IPU_DP_COM_CONF_SYNC_DP_CSC_GAMUT_SAT_EN_SYNC(v)   (((v) << 10) & BM_IPU_DP_COM_CONF_SYNC_DP_CSC_GAMUT_SAT_EN_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_GAMUT_SAT_EN_SYNC field to a new value.
#define BW_IPU_DP_COM_CONF_SYNC_DP_CSC_GAMUT_SAT_EN_SYNC(v)   BF_CS1(IPU_DP_COM_CONF_SYNC, DP_CSC_GAMUT_SAT_EN_SYNC, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_SYNC, field DP_CSC_YUV_SAT_MODE_SYNC (RW)
 *
 * CSC_YUV_SAT_MODE YUV saturation mode for color space conversion
 *
 * Values:
 * 0 - Y/U/V range 0 -255
 * 1 - Y range 16-235, U/V range 16-240
 */

#define BP_IPU_DP_COM_CONF_SYNC_DP_CSC_YUV_SAT_MODE_SYNC      11
#define BM_IPU_DP_COM_CONF_SYNC_DP_CSC_YUV_SAT_MODE_SYNC      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_SYNC_DP_CSC_YUV_SAT_MODE_SYNC(v)   ((((reg32_t) v) << 11) & BM_IPU_DP_COM_CONF_SYNC_DP_CSC_YUV_SAT_MODE_SYNC)
#else
#define BF_IPU_DP_COM_CONF_SYNC_DP_CSC_YUV_SAT_MODE_SYNC(v)   (((v) << 11) & BM_IPU_DP_COM_CONF_SYNC_DP_CSC_YUV_SAT_MODE_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_YUV_SAT_MODE_SYNC field to a new value.
#define BW_IPU_DP_COM_CONF_SYNC_DP_CSC_YUV_SAT_MODE_SYNC(v)   BF_CS1(IPU_DP_COM_CONF_SYNC, DP_CSC_YUV_SAT_MODE_SYNC, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_SYNC, field DP_GAMMA_EN_SYNC (RW)
 *
 * GAMMA_EN - Gamma correction block enable bit
 *
 * Values:
 * 0 - disable
 * 1 - enable
 */

#define BP_IPU_DP_COM_CONF_SYNC_DP_GAMMA_EN_SYNC      12
#define BM_IPU_DP_COM_CONF_SYNC_DP_GAMMA_EN_SYNC      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_SYNC_DP_GAMMA_EN_SYNC(v)   ((((reg32_t) v) << 12) & BM_IPU_DP_COM_CONF_SYNC_DP_GAMMA_EN_SYNC)
#else
#define BF_IPU_DP_COM_CONF_SYNC_DP_GAMMA_EN_SYNC(v)   (((v) << 12) & BM_IPU_DP_COM_CONF_SYNC_DP_GAMMA_EN_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_EN_SYNC field to a new value.
#define BW_IPU_DP_COM_CONF_SYNC_DP_GAMMA_EN_SYNC(v)   BF_CS1(IPU_DP_COM_CONF_SYNC, DP_GAMMA_EN_SYNC, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_SYNC, field DP_GAMMA_YUV_EN_SYNC (RW)
 *
 * GAMMA's YUV mode enable for sync flow
 *
 * Values:
 * 0 - YUV mode is OFF.
 * 1 - YUV mode is ON.
 */

#define BP_IPU_DP_COM_CONF_SYNC_DP_GAMMA_YUV_EN_SYNC      13
#define BM_IPU_DP_COM_CONF_SYNC_DP_GAMMA_YUV_EN_SYNC      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_SYNC_DP_GAMMA_YUV_EN_SYNC(v)   ((((reg32_t) v) << 13) & BM_IPU_DP_COM_CONF_SYNC_DP_GAMMA_YUV_EN_SYNC)
#else
#define BF_IPU_DP_COM_CONF_SYNC_DP_GAMMA_YUV_EN_SYNC(v)   (((v) << 13) & BM_IPU_DP_COM_CONF_SYNC_DP_GAMMA_YUV_EN_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_YUV_EN_SYNC field to a new value.
#define BW_IPU_DP_COM_CONF_SYNC_DP_GAMMA_YUV_EN_SYNC(v)   BF_CS1(IPU_DP_COM_CONF_SYNC, DP_GAMMA_YUV_EN_SYNC, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_GRAPH_WIND_CTRL_SYNC - DP Graphic Window Control Sync Flow Register (RW)
 *
 * This register contains common configuration parameters for the DP.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_GWCKB_SYNC : 8; //!< GWCKB - Graphic Window Color Keying Blue Component Defines the blue component of graphic window color keying.
        unsigned DP_GWCKG_SYNC : 8; //!< GWCKG - Graphic Window Color Keying Green Component Defines the green component of graphic window color keying.
        unsigned DP_GWCKR_SYNC : 8; //!< GWCKR - Graphic Window Color Keying Red Component Defines the red component of graphic window color keying.
        unsigned DP_GWAV_SYNC : 8; //!< GWAV - Graphic Window Alpha Value Defines the alpha value of graphic window used for alpha blending between graphic window and full plane. The Value the number that writing to GWAV register. The Actual Value the number, that insert to calculation in Combining Module. If Value = < 0.5- 1/256 (01111111) then Actual Value = Value. If Value >= 0.5 (10000000), then Actual Value = Value + 1/256.
    } B;
} hw_ipu_dp_graph_wind_ctrl_sync_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_GRAPH_WIND_CTRL_SYNC register
 */
#define HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040004)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_GRAPH_WIND_CTRL_SYNC(x)           (*(volatile hw_ipu_dp_graph_wind_ctrl_sync_t *) HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_ADDR(x))
#define HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_RD(x)        (HW_IPU_DP_GRAPH_WIND_CTRL_SYNC(x).U)
#define HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_WR(x, v)     (HW_IPU_DP_GRAPH_WIND_CTRL_SYNC(x).U = (v))
#define HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_SET(x, v)    (HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_WR(x, HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_RD(x) |  (v)))
#define HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_CLR(x, v)    (HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_WR(x, HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_RD(x) & ~(v)))
#define HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_TOG(x, v)    (HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_WR(x, HW_IPU_DP_GRAPH_WIND_CTRL_SYNC_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_GRAPH_WIND_CTRL_SYNC bitfields
 */

/* --- Register HW_IPU_DP_GRAPH_WIND_CTRL_SYNC, field DP_GWCKB_SYNC (RW)
 *
 * GWCKB - Graphic Window Color Keying Blue Component Defines the blue component of graphic window
 * color keying.
 *
 * Values:
 * 00000000 - No blue
 * 11111111 - Full blue
 */

#define BP_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKB_SYNC      0
#define BM_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKB_SYNC      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKB_SYNC(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKB_SYNC)
#else
#define BF_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKB_SYNC(v)   (((v) << 0) & BM_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKB_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWCKB_SYNC field to a new value.
#define BW_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKB_SYNC(v)   BF_CS1(IPU_DP_GRAPH_WIND_CTRL_SYNC, DP_GWCKB_SYNC, v)
#endif


/* --- Register HW_IPU_DP_GRAPH_WIND_CTRL_SYNC, field DP_GWCKG_SYNC (RW)
 *
 * GWCKG - Graphic Window Color Keying Green Component Defines the green component of graphic window
 * color keying.
 *
 * Values:
 * 00000000 - No Green
 * 11111111 - Full Green
 */

#define BP_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKG_SYNC      8
#define BM_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKG_SYNC      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKG_SYNC(v)   ((((reg32_t) v) << 8) & BM_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKG_SYNC)
#else
#define BF_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKG_SYNC(v)   (((v) << 8) & BM_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKG_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWCKG_SYNC field to a new value.
#define BW_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKG_SYNC(v)   BF_CS1(IPU_DP_GRAPH_WIND_CTRL_SYNC, DP_GWCKG_SYNC, v)
#endif


/* --- Register HW_IPU_DP_GRAPH_WIND_CTRL_SYNC, field DP_GWCKR_SYNC (RW)
 *
 * GWCKR - Graphic Window Color Keying Red Component Defines the red component of graphic window
 * color keying.
 *
 * Values:
 * 00000000 - No red
 * 11111111 - Full red
 */

#define BP_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKR_SYNC      16
#define BM_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKR_SYNC      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKR_SYNC(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKR_SYNC)
#else
#define BF_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKR_SYNC(v)   (((v) << 16) & BM_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKR_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWCKR_SYNC field to a new value.
#define BW_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWCKR_SYNC(v)   BF_CS1(IPU_DP_GRAPH_WIND_CTRL_SYNC, DP_GWCKR_SYNC, v)
#endif


/* --- Register HW_IPU_DP_GRAPH_WIND_CTRL_SYNC, field DP_GWAV_SYNC (RW)
 *
 * GWAV - Graphic Window Alpha Value Defines the alpha value of graphic window used for alpha
 * blending between graphic window and full plane. The Value the number that writing to GWAV
 * register. The Actual Value the number, that insert to calculation in Combining Module. If Value =
 * < 0.5- 1/256 (01111111) then Actual Value = Value. If Value >= 0.5 (10000000), then Actual Value
 * = Value + 1/256.
 *
 * Values:
 * 00000000 - Actual value is 00000000; Graphic window totally opaque i.e. overlay on LCD screen
 * 01111111 - Actual value is 01111111;
 * 10000000 - Actual value is 10000001
 * 10000001 - Actual value is 10000010
 * 11111110 - Actual value is 11111111
 * 11111111 - Actual value is 100000000;Graphic window totally transparent i.e. not displayed on LCD screen
 */

#define BP_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWAV_SYNC      24
#define BM_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWAV_SYNC      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWAV_SYNC(v)   ((((reg32_t) v) << 24) & BM_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWAV_SYNC)
#else
#define BF_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWAV_SYNC(v)   (((v) << 24) & BM_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWAV_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWAV_SYNC field to a new value.
#define BW_IPU_DP_GRAPH_WIND_CTRL_SYNC_DP_GWAV_SYNC(v)   BF_CS1(IPU_DP_GRAPH_WIND_CTRL_SYNC, DP_GWAV_SYNC, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_FG_POS_SYNC - DP Partial Plane Window Position Sync Flow Register (RW)
 *
 * The DP partial plane Window Position Register is used to determine the starting position of the
 * partial plane window relative to BG window position.  This Register is used for the synchronous
 * flow only.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_FGYP_SYNC : 11; //!< FGYP partial plane window Y position partial plane Window Y Position - Specifies the number of lines between the start of full plane windows Y position and the beginning of the first data.
        unsigned RESERVED0 : 5; //!< Reserved
        unsigned DP_FGXP_SYNC : 11; //!< FGXP partial plane Window X Position. partial plane Window X Position - Specifies the number of pixels between the start of full plane window X position and the beginning of the first data of new line.
        unsigned RESERVED1 : 5; //!< Reserved
    } B;
} hw_ipu_dp_fg_pos_sync_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_FG_POS_SYNC register
 */
#define HW_IPU_DP_FG_POS_SYNC_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040008)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_FG_POS_SYNC(x)           (*(volatile hw_ipu_dp_fg_pos_sync_t *) HW_IPU_DP_FG_POS_SYNC_ADDR(x))
#define HW_IPU_DP_FG_POS_SYNC_RD(x)        (HW_IPU_DP_FG_POS_SYNC(x).U)
#define HW_IPU_DP_FG_POS_SYNC_WR(x, v)     (HW_IPU_DP_FG_POS_SYNC(x).U = (v))
#define HW_IPU_DP_FG_POS_SYNC_SET(x, v)    (HW_IPU_DP_FG_POS_SYNC_WR(x, HW_IPU_DP_FG_POS_SYNC_RD(x) |  (v)))
#define HW_IPU_DP_FG_POS_SYNC_CLR(x, v)    (HW_IPU_DP_FG_POS_SYNC_WR(x, HW_IPU_DP_FG_POS_SYNC_RD(x) & ~(v)))
#define HW_IPU_DP_FG_POS_SYNC_TOG(x, v)    (HW_IPU_DP_FG_POS_SYNC_WR(x, HW_IPU_DP_FG_POS_SYNC_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_FG_POS_SYNC bitfields
 */

/* --- Register HW_IPU_DP_FG_POS_SYNC, field DP_FGYP_SYNC (RW)
 *
 * FGYP partial plane window Y position partial plane Window Y Position - Specifies the number of
 * lines between the start of full plane windows Y position and the beginning of the first data.
 */

#define BP_IPU_DP_FG_POS_SYNC_DP_FGYP_SYNC      0
#define BM_IPU_DP_FG_POS_SYNC_DP_FGYP_SYNC      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_FG_POS_SYNC_DP_FGYP_SYNC(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_FG_POS_SYNC_DP_FGYP_SYNC)
#else
#define BF_IPU_DP_FG_POS_SYNC_DP_FGYP_SYNC(v)   (((v) << 0) & BM_IPU_DP_FG_POS_SYNC_DP_FGYP_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_FGYP_SYNC field to a new value.
#define BW_IPU_DP_FG_POS_SYNC_DP_FGYP_SYNC(v)   BF_CS1(IPU_DP_FG_POS_SYNC, DP_FGYP_SYNC, v)
#endif

/* --- Register HW_IPU_DP_FG_POS_SYNC, field DP_FGXP_SYNC (RW)
 *
 * FGXP partial plane Window X Position. partial plane Window X Position - Specifies the number of
 * pixels between the start of full plane window X position and the beginning of the first data of
 * new line.
 */

#define BP_IPU_DP_FG_POS_SYNC_DP_FGXP_SYNC      16
#define BM_IPU_DP_FG_POS_SYNC_DP_FGXP_SYNC      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_FG_POS_SYNC_DP_FGXP_SYNC(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_FG_POS_SYNC_DP_FGXP_SYNC)
#else
#define BF_IPU_DP_FG_POS_SYNC_DP_FGXP_SYNC(v)   (((v) << 16) & BM_IPU_DP_FG_POS_SYNC_DP_FGXP_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_FGXP_SYNC field to a new value.
#define BW_IPU_DP_FG_POS_SYNC_DP_FGXP_SYNC(v)   BF_CS1(IPU_DP_FG_POS_SYNC, DP_FGXP_SYNC, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CUR_POS_SYNC - DP Cursor Position and Size Sync Flow Register (RW)
 *
 * The LCD Cursor Position Register is used to determine the starting position of the cursor
 * relative to BG windows position.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CXW_SYNC : 11; //!< CXW - Cursor Width. Specifies the width of the hardware cursor in pixels.
        unsigned DP_CXP_SYNC : 5; //!< CXP - Cursor X Position Represents the cursors horizontal starting position X in pixel count (from 0 to CXW).
        unsigned DP_CYH_SYNC : 11; //!< CYH - Cursor Height Specifies the height of the hardware cursor in pixels.
        unsigned DP_CYP_SYNC : 5; //!< CYP - Cursor Y Position Represents the cursors vertical starting position Y in pixel count (from 0 to CYH).Live View Resolution Mode.
    } B;
} hw_ipu_dp_cur_pos_sync_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CUR_POS_SYNC register
 */
#define HW_IPU_DP_CUR_POS_SYNC_ADDR(x)      (REGS_IPU_BASE(x) + 0x104000c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CUR_POS_SYNC(x)           (*(volatile hw_ipu_dp_cur_pos_sync_t *) HW_IPU_DP_CUR_POS_SYNC_ADDR(x))
#define HW_IPU_DP_CUR_POS_SYNC_RD(x)        (HW_IPU_DP_CUR_POS_SYNC(x).U)
#define HW_IPU_DP_CUR_POS_SYNC_WR(x, v)     (HW_IPU_DP_CUR_POS_SYNC(x).U = (v))
#define HW_IPU_DP_CUR_POS_SYNC_SET(x, v)    (HW_IPU_DP_CUR_POS_SYNC_WR(x, HW_IPU_DP_CUR_POS_SYNC_RD(x) |  (v)))
#define HW_IPU_DP_CUR_POS_SYNC_CLR(x, v)    (HW_IPU_DP_CUR_POS_SYNC_WR(x, HW_IPU_DP_CUR_POS_SYNC_RD(x) & ~(v)))
#define HW_IPU_DP_CUR_POS_SYNC_TOG(x, v)    (HW_IPU_DP_CUR_POS_SYNC_WR(x, HW_IPU_DP_CUR_POS_SYNC_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CUR_POS_SYNC bitfields
 */

/* --- Register HW_IPU_DP_CUR_POS_SYNC, field DP_CXW_SYNC (RW)
 *
 * CXW - Cursor Width. Specifies the width of the hardware cursor in pixels.
 */

#define BP_IPU_DP_CUR_POS_SYNC_DP_CXW_SYNC      0
#define BM_IPU_DP_CUR_POS_SYNC_DP_CXW_SYNC      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_SYNC_DP_CXW_SYNC(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CUR_POS_SYNC_DP_CXW_SYNC)
#else
#define BF_IPU_DP_CUR_POS_SYNC_DP_CXW_SYNC(v)   (((v) << 0) & BM_IPU_DP_CUR_POS_SYNC_DP_CXW_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CXW_SYNC field to a new value.
#define BW_IPU_DP_CUR_POS_SYNC_DP_CXW_SYNC(v)   BF_CS1(IPU_DP_CUR_POS_SYNC, DP_CXW_SYNC, v)
#endif

/* --- Register HW_IPU_DP_CUR_POS_SYNC, field DP_CXP_SYNC (RW)
 *
 * CXP - Cursor X Position Represents the cursors horizontal starting position X in pixel count
 * (from 0 to CXW).
 */

#define BP_IPU_DP_CUR_POS_SYNC_DP_CXP_SYNC      11
#define BM_IPU_DP_CUR_POS_SYNC_DP_CXP_SYNC      0x0000f800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_SYNC_DP_CXP_SYNC(v)   ((((reg32_t) v) << 11) & BM_IPU_DP_CUR_POS_SYNC_DP_CXP_SYNC)
#else
#define BF_IPU_DP_CUR_POS_SYNC_DP_CXP_SYNC(v)   (((v) << 11) & BM_IPU_DP_CUR_POS_SYNC_DP_CXP_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CXP_SYNC field to a new value.
#define BW_IPU_DP_CUR_POS_SYNC_DP_CXP_SYNC(v)   BF_CS1(IPU_DP_CUR_POS_SYNC, DP_CXP_SYNC, v)
#endif

/* --- Register HW_IPU_DP_CUR_POS_SYNC, field DP_CYH_SYNC (RW)
 *
 * CYH - Cursor Height Specifies the height of the hardware cursor in pixels.
 */

#define BP_IPU_DP_CUR_POS_SYNC_DP_CYH_SYNC      16
#define BM_IPU_DP_CUR_POS_SYNC_DP_CYH_SYNC      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_SYNC_DP_CYH_SYNC(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CUR_POS_SYNC_DP_CYH_SYNC)
#else
#define BF_IPU_DP_CUR_POS_SYNC_DP_CYH_SYNC(v)   (((v) << 16) & BM_IPU_DP_CUR_POS_SYNC_DP_CYH_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CYH_SYNC field to a new value.
#define BW_IPU_DP_CUR_POS_SYNC_DP_CYH_SYNC(v)   BF_CS1(IPU_DP_CUR_POS_SYNC, DP_CYH_SYNC, v)
#endif

/* --- Register HW_IPU_DP_CUR_POS_SYNC, field DP_CYP_SYNC (RW)
 *
 * CYP - Cursor Y Position Represents the cursors vertical starting position Y in pixel count (from
 * 0 to CYH).Live View Resolution Mode.
 */

#define BP_IPU_DP_CUR_POS_SYNC_DP_CYP_SYNC      27
#define BM_IPU_DP_CUR_POS_SYNC_DP_CYP_SYNC      0xf8000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_SYNC_DP_CYP_SYNC(v)   ((((reg32_t) v) << 27) & BM_IPU_DP_CUR_POS_SYNC_DP_CYP_SYNC)
#else
#define BF_IPU_DP_CUR_POS_SYNC_DP_CYP_SYNC(v)   (((v) << 27) & BM_IPU_DP_CUR_POS_SYNC_DP_CYP_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CYP_SYNC field to a new value.
#define BW_IPU_DP_CUR_POS_SYNC_DP_CYP_SYNC(v)   BF_CS1(IPU_DP_CUR_POS_SYNC, DP_CYP_SYNC, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CUR_MAP_SYNC - DP Color Cursor Mapping Sync Flow Register (RW)
 *
 * The LCD Color Cursor Mapping Register defines the color of the cursor in passive or TFT color
 * modes.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CUR_COL_R_SYNC : 8; //!< CUR_COL_B - Cursor Red Field Defines the Red component of the cursor color in color mode
        unsigned DP_CUR_COL_G_SYNC : 8; //!< CUR_COL_G - Cursor Green Field Defines the Green component of the cursor color in color mode
        unsigned DP_CUR_COL_B_SYNC : 8; //!< CUR_COL_B - Cursor Blue Field Defines the Blue component of the cursor color in color mode
        unsigned RESERVED0 : 8; //!< Reserved
    } B;
} hw_ipu_dp_cur_map_sync_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CUR_MAP_SYNC register
 */
#define HW_IPU_DP_CUR_MAP_SYNC_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040010)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CUR_MAP_SYNC(x)           (*(volatile hw_ipu_dp_cur_map_sync_t *) HW_IPU_DP_CUR_MAP_SYNC_ADDR(x))
#define HW_IPU_DP_CUR_MAP_SYNC_RD(x)        (HW_IPU_DP_CUR_MAP_SYNC(x).U)
#define HW_IPU_DP_CUR_MAP_SYNC_WR(x, v)     (HW_IPU_DP_CUR_MAP_SYNC(x).U = (v))
#define HW_IPU_DP_CUR_MAP_SYNC_SET(x, v)    (HW_IPU_DP_CUR_MAP_SYNC_WR(x, HW_IPU_DP_CUR_MAP_SYNC_RD(x) |  (v)))
#define HW_IPU_DP_CUR_MAP_SYNC_CLR(x, v)    (HW_IPU_DP_CUR_MAP_SYNC_WR(x, HW_IPU_DP_CUR_MAP_SYNC_RD(x) & ~(v)))
#define HW_IPU_DP_CUR_MAP_SYNC_TOG(x, v)    (HW_IPU_DP_CUR_MAP_SYNC_WR(x, HW_IPU_DP_CUR_MAP_SYNC_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CUR_MAP_SYNC bitfields
 */

/* --- Register HW_IPU_DP_CUR_MAP_SYNC, field DP_CUR_COL_R_SYNC (RW)
 *
 * CUR_COL_B - Cursor Red Field Defines the Red component of the cursor color in color mode
 *
 * Values:
 * 00000000 - No Red.
 * 11111111 - Full Red.
 */

#define BP_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_R_SYNC      0
#define BM_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_R_SYNC      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_R_SYNC(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_R_SYNC)
#else
#define BF_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_R_SYNC(v)   (((v) << 0) & BM_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_R_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CUR_COL_R_SYNC field to a new value.
#define BW_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_R_SYNC(v)   BF_CS1(IPU_DP_CUR_MAP_SYNC, DP_CUR_COL_R_SYNC, v)
#endif


/* --- Register HW_IPU_DP_CUR_MAP_SYNC, field DP_CUR_COL_G_SYNC (RW)
 *
 * CUR_COL_G - Cursor Green Field Defines the Green component of the cursor color in color mode
 *
 * Values:
 * 00000000 - No Green.
 * 11111111 - Full Green.
 */

#define BP_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_G_SYNC      8
#define BM_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_G_SYNC      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_G_SYNC(v)   ((((reg32_t) v) << 8) & BM_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_G_SYNC)
#else
#define BF_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_G_SYNC(v)   (((v) << 8) & BM_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_G_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CUR_COL_G_SYNC field to a new value.
#define BW_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_G_SYNC(v)   BF_CS1(IPU_DP_CUR_MAP_SYNC, DP_CUR_COL_G_SYNC, v)
#endif


/* --- Register HW_IPU_DP_CUR_MAP_SYNC, field DP_CUR_COL_B_SYNC (RW)
 *
 * CUR_COL_B - Cursor Blue Field Defines the Blue component of the cursor color in color mode
 *
 * Values:
 * 00000000 - No Blue.
 * 11111111 - Full Blue.
 */

#define BP_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_B_SYNC      16
#define BM_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_B_SYNC      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_B_SYNC(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_B_SYNC)
#else
#define BF_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_B_SYNC(v)   (((v) << 16) & BM_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_B_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CUR_COL_B_SYNC field to a new value.
#define BW_IPU_DP_CUR_MAP_SYNC_DP_CUR_COL_B_SYNC(v)   BF_CS1(IPU_DP_CUR_MAP_SYNC, DP_CUR_COL_B_SYNC, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_GAMMA_C_SYNC_I - DP Gamma Constants Sync Flow Register i (RW)
 *
 * This registers contains CONSTANTi parameters used for gamma correction inside the display
 * processor (DP).
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_GAMMA_C_SYNC_ : 9; //!< CONSTANTi parameter of Gamma Correction.
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DP_GAMMA_C_SYNC_1 : 9; //!< CONSTANTi+1 parameter of Gamma Correction.
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_dp_gamma_c_sync_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_GAMMA_C_SYNC_I register
 */
#define HW_IPU_DP_GAMMA_C_SYNC_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040014)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_GAMMA_C_SYNC_I(x)           (*(volatile hw_ipu_dp_gamma_c_sync_i_t *) HW_IPU_DP_GAMMA_C_SYNC_I_ADDR(x))
#define HW_IPU_DP_GAMMA_C_SYNC_I_RD(x)        (HW_IPU_DP_GAMMA_C_SYNC_I(x).U)
#define HW_IPU_DP_GAMMA_C_SYNC_I_WR(x, v)     (HW_IPU_DP_GAMMA_C_SYNC_I(x).U = (v))
#define HW_IPU_DP_GAMMA_C_SYNC_I_SET(x, v)    (HW_IPU_DP_GAMMA_C_SYNC_I_WR(x, HW_IPU_DP_GAMMA_C_SYNC_I_RD(x) |  (v)))
#define HW_IPU_DP_GAMMA_C_SYNC_I_CLR(x, v)    (HW_IPU_DP_GAMMA_C_SYNC_I_WR(x, HW_IPU_DP_GAMMA_C_SYNC_I_RD(x) & ~(v)))
#define HW_IPU_DP_GAMMA_C_SYNC_I_TOG(x, v)    (HW_IPU_DP_GAMMA_C_SYNC_I_WR(x, HW_IPU_DP_GAMMA_C_SYNC_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_GAMMA_C_SYNC_I bitfields
 */

/* --- Register HW_IPU_DP_GAMMA_C_SYNC_I, field DP_GAMMA_C_SYNC_ (RW)
 *
 * CONSTANTi parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_      0
#define BM_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_)
#else
#define BF_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_(v)   (((v) << 0) & BM_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_C_SYNC_ field to a new value.
#define BW_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_(v)   BF_CS1(IPU_DP_GAMMA_C_SYNC_I, DP_GAMMA_C_SYNC_, v)
#endif

/* --- Register HW_IPU_DP_GAMMA_C_SYNC_I, field DP_GAMMA_C_SYNC_ (RW)
 *
 * CONSTANTi+1 parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_      16
#define BM_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_)
#else
#define BF_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_(v)   (((v) << 16) & BM_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_C_SYNC_ field to a new value.
#define BW_IPU_DP_GAMMA_C_SYNC_I_DP_GAMMA_C_SYNC_(v)   BF_CS1(IPU_DP_GAMMA_C_SYNC_I, DP_GAMMA_C_SYNC_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_GAMMA_S_SYNC_I - DP Gamma Correction Slope Sync Flow Register i (RW)
 *
 * This registers contains SLOPEi parameters used for Gamma Correction inside the display processor
 * (DP).
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_GAMMA_S_SYNC_ : 8; //!< SLOPE<4*i> parameter of Gamma Correction.
        unsigned DP_GAMMA_S_SYNC_1 : 8; //!< SLOPE<4*i+1> parameter of Gamma Correction.
        unsigned DP_GAMMA_S_SYNC_2 : 8; //!< SLOPE<4*i+2> parameter of Gamma Correction.
        unsigned DP_GAMMA_S_SYNC_3 : 8; //!< SLOPE<4*i+3> parameter of Gamma Correction.
    } B;
} hw_ipu_dp_gamma_s_sync_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_GAMMA_S_SYNC_I register
 */
#define HW_IPU_DP_GAMMA_S_SYNC_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040034)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_GAMMA_S_SYNC_I(x)           (*(volatile hw_ipu_dp_gamma_s_sync_i_t *) HW_IPU_DP_GAMMA_S_SYNC_I_ADDR(x))
#define HW_IPU_DP_GAMMA_S_SYNC_I_RD(x)        (HW_IPU_DP_GAMMA_S_SYNC_I(x).U)
#define HW_IPU_DP_GAMMA_S_SYNC_I_WR(x, v)     (HW_IPU_DP_GAMMA_S_SYNC_I(x).U = (v))
#define HW_IPU_DP_GAMMA_S_SYNC_I_SET(x, v)    (HW_IPU_DP_GAMMA_S_SYNC_I_WR(x, HW_IPU_DP_GAMMA_S_SYNC_I_RD(x) |  (v)))
#define HW_IPU_DP_GAMMA_S_SYNC_I_CLR(x, v)    (HW_IPU_DP_GAMMA_S_SYNC_I_WR(x, HW_IPU_DP_GAMMA_S_SYNC_I_RD(x) & ~(v)))
#define HW_IPU_DP_GAMMA_S_SYNC_I_TOG(x, v)    (HW_IPU_DP_GAMMA_S_SYNC_I_WR(x, HW_IPU_DP_GAMMA_S_SYNC_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_GAMMA_S_SYNC_I bitfields
 */

/* --- Register HW_IPU_DP_GAMMA_S_SYNC_I, field DP_GAMMA_S_SYNC_ (RW)
 *
 * SLOPE<4*i> parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_      0
#define BM_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_)
#else
#define BF_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_(v)   (((v) << 0) & BM_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_S_SYNC_ field to a new value.
#define BW_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_(v)   BF_CS1(IPU_DP_GAMMA_S_SYNC_I, DP_GAMMA_S_SYNC_, v)
#endif

/* --- Register HW_IPU_DP_GAMMA_S_SYNC_I, field DP_GAMMA_S_SYNC_ (RW)
 *
 * SLOPE<4*i+1> parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_      8
#define BM_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_(v)   ((((reg32_t) v) << 8) & BM_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_)
#else
#define BF_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_(v)   (((v) << 8) & BM_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_S_SYNC_ field to a new value.
#define BW_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_(v)   BF_CS1(IPU_DP_GAMMA_S_SYNC_I, DP_GAMMA_S_SYNC_, v)
#endif

/* --- Register HW_IPU_DP_GAMMA_S_SYNC_I, field DP_GAMMA_S_SYNC_ (RW)
 *
 * SLOPE<4*i+2> parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_      16
#define BM_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_)
#else
#define BF_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_(v)   (((v) << 16) & BM_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_S_SYNC_ field to a new value.
#define BW_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_(v)   BF_CS1(IPU_DP_GAMMA_S_SYNC_I, DP_GAMMA_S_SYNC_, v)
#endif

/* --- Register HW_IPU_DP_GAMMA_S_SYNC_I, field DP_GAMMA_S_SYNC_ (RW)
 *
 * SLOPE<4*i+3> parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_      24
#define BM_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_(v)   ((((reg32_t) v) << 24) & BM_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_)
#else
#define BF_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_(v)   (((v) << 24) & BM_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_S_SYNC_ field to a new value.
#define BW_IPU_DP_GAMMA_S_SYNC_I_DP_GAMMA_S_SYNC_(v)   BF_CS1(IPU_DP_GAMMA_S_SYNC_I, DP_GAMMA_S_SYNC_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CSCA_SYNC_I - DP Color Space Conversion Control Sync Flow Registers (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CSC_A_SYNC : 10; //!< A<2*i> parameter of color conversion.
        unsigned RESERVED0 : 6; //!< Reserved.
        unsigned DP_CSC_A_SYNC1 : 10; //!< A<2*i+1> parameter of color conversion
        unsigned RESERVED1 : 6; //!< Reserved.
    } B;
} hw_ipu_dp_csca_sync_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CSCA_SYNC_I register
 */
#define HW_IPU_DP_CSCA_SYNC_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040044)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CSCA_SYNC_I(x)           (*(volatile hw_ipu_dp_csca_sync_i_t *) HW_IPU_DP_CSCA_SYNC_I_ADDR(x))
#define HW_IPU_DP_CSCA_SYNC_I_RD(x)        (HW_IPU_DP_CSCA_SYNC_I(x).U)
#define HW_IPU_DP_CSCA_SYNC_I_WR(x, v)     (HW_IPU_DP_CSCA_SYNC_I(x).U = (v))
#define HW_IPU_DP_CSCA_SYNC_I_SET(x, v)    (HW_IPU_DP_CSCA_SYNC_I_WR(x, HW_IPU_DP_CSCA_SYNC_I_RD(x) |  (v)))
#define HW_IPU_DP_CSCA_SYNC_I_CLR(x, v)    (HW_IPU_DP_CSCA_SYNC_I_WR(x, HW_IPU_DP_CSCA_SYNC_I_RD(x) & ~(v)))
#define HW_IPU_DP_CSCA_SYNC_I_TOG(x, v)    (HW_IPU_DP_CSCA_SYNC_I_WR(x, HW_IPU_DP_CSCA_SYNC_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CSCA_SYNC_I bitfields
 */

/* --- Register HW_IPU_DP_CSCA_SYNC_I, field DP_CSC_A_SYNC (RW)
 *
 * A<2*i> parameter of color conversion.
 */

#define BP_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC      0
#define BM_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC)
#else
#define BF_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC(v)   (((v) << 0) & BM_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_A_SYNC field to a new value.
#define BW_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC(v)   BF_CS1(IPU_DP_CSCA_SYNC_I, DP_CSC_A_SYNC, v)
#endif

/* --- Register HW_IPU_DP_CSCA_SYNC_I, field DP_CSC_A_SYNC (RW)
 *
 * A<2*i+1> parameter of color conversion
 */

#define BP_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC      16
#define BM_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC      0x03ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC)
#else
#define BF_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC(v)   (((v) << 16) & BM_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_A_SYNC field to a new value.
#define BW_IPU_DP_CSCA_SYNC_I_DP_CSC_A_SYNC(v)   BF_CS1(IPU_DP_CSCA_SYNC_I, DP_CSC_A_SYNC, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_SCS_SYNC_0 - DP Color Conversion Control Sync Flow Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CSC_A8_SYNC : 10; //!< A9 parameter of color conversion.
        unsigned RESERVED0 : 6; //!< Reserved.
        unsigned DP_CSC_B0_SYNC : 14; //!< B0 parameter of color conversion.
        unsigned DP_CSC_S0_SYNC : 2; //!< S0 parameter of color conversion.
    } B;
} hw_ipu_dp_scs_sync_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_SCS_SYNC_0 register
 */
#define HW_IPU_DP_SCS_SYNC_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040054)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_SCS_SYNC_0(x)           (*(volatile hw_ipu_dp_scs_sync_0_t *) HW_IPU_DP_SCS_SYNC_0_ADDR(x))
#define HW_IPU_DP_SCS_SYNC_0_RD(x)        (HW_IPU_DP_SCS_SYNC_0(x).U)
#define HW_IPU_DP_SCS_SYNC_0_WR(x, v)     (HW_IPU_DP_SCS_SYNC_0(x).U = (v))
#define HW_IPU_DP_SCS_SYNC_0_SET(x, v)    (HW_IPU_DP_SCS_SYNC_0_WR(x, HW_IPU_DP_SCS_SYNC_0_RD(x) |  (v)))
#define HW_IPU_DP_SCS_SYNC_0_CLR(x, v)    (HW_IPU_DP_SCS_SYNC_0_WR(x, HW_IPU_DP_SCS_SYNC_0_RD(x) & ~(v)))
#define HW_IPU_DP_SCS_SYNC_0_TOG(x, v)    (HW_IPU_DP_SCS_SYNC_0_WR(x, HW_IPU_DP_SCS_SYNC_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_SCS_SYNC_0 bitfields
 */

/* --- Register HW_IPU_DP_SCS_SYNC_0, field DP_CSC_A8_SYNC (RW)
 *
 * A9 parameter of color conversion.
 */

#define BP_IPU_DP_SCS_SYNC_0_DP_CSC_A8_SYNC      0
#define BM_IPU_DP_SCS_SYNC_0_DP_CSC_A8_SYNC      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_SCS_SYNC_0_DP_CSC_A8_SYNC(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_SCS_SYNC_0_DP_CSC_A8_SYNC)
#else
#define BF_IPU_DP_SCS_SYNC_0_DP_CSC_A8_SYNC(v)   (((v) << 0) & BM_IPU_DP_SCS_SYNC_0_DP_CSC_A8_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_A8_SYNC field to a new value.
#define BW_IPU_DP_SCS_SYNC_0_DP_CSC_A8_SYNC(v)   BF_CS1(IPU_DP_SCS_SYNC_0, DP_CSC_A8_SYNC, v)
#endif

/* --- Register HW_IPU_DP_SCS_SYNC_0, field DP_CSC_B0_SYNC (RW)
 *
 * B0 parameter of color conversion.
 */

#define BP_IPU_DP_SCS_SYNC_0_DP_CSC_B0_SYNC      16
#define BM_IPU_DP_SCS_SYNC_0_DP_CSC_B0_SYNC      0x3fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_SCS_SYNC_0_DP_CSC_B0_SYNC(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_SCS_SYNC_0_DP_CSC_B0_SYNC)
#else
#define BF_IPU_DP_SCS_SYNC_0_DP_CSC_B0_SYNC(v)   (((v) << 16) & BM_IPU_DP_SCS_SYNC_0_DP_CSC_B0_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_B0_SYNC field to a new value.
#define BW_IPU_DP_SCS_SYNC_0_DP_CSC_B0_SYNC(v)   BF_CS1(IPU_DP_SCS_SYNC_0, DP_CSC_B0_SYNC, v)
#endif

/* --- Register HW_IPU_DP_SCS_SYNC_0, field DP_CSC_S0_SYNC (RW)
 *
 * S0 parameter of color conversion.
 *
 * Values:
 * 00 - scale factor of 2
 * 01 - scale factor of 1
 * 10 - scale factor of 0
 * 11 - scale factor of -1
 */

#define BP_IPU_DP_SCS_SYNC_0_DP_CSC_S0_SYNC      30
#define BM_IPU_DP_SCS_SYNC_0_DP_CSC_S0_SYNC      0xc0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_SCS_SYNC_0_DP_CSC_S0_SYNC(v)   ((((reg32_t) v) << 30) & BM_IPU_DP_SCS_SYNC_0_DP_CSC_S0_SYNC)
#else
#define BF_IPU_DP_SCS_SYNC_0_DP_CSC_S0_SYNC(v)   (((v) << 30) & BM_IPU_DP_SCS_SYNC_0_DP_CSC_S0_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_S0_SYNC field to a new value.
#define BW_IPU_DP_SCS_SYNC_0_DP_CSC_S0_SYNC(v)   BF_CS1(IPU_DP_SCS_SYNC_0, DP_CSC_S0_SYNC, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_SCS_SYNC_1 - DP Color Conversion Control Sync Flow Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CSC_B1_SYNC : 14; //!< B0 parameter of color conversion.
        unsigned DP_CSC_S1_SYNC : 2; //!< S0 parameter of color conversion.
        unsigned DP_CSC_B2_SYNC : 14; //!< B0 parameter of color conversion.
        unsigned DP_CSC_S2_SYNC : 2; //!< S0 parameter of color conversion.
    } B;
} hw_ipu_dp_scs_sync_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_SCS_SYNC_1 register
 */
#define HW_IPU_DP_SCS_SYNC_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040058)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_SCS_SYNC_1(x)           (*(volatile hw_ipu_dp_scs_sync_1_t *) HW_IPU_DP_SCS_SYNC_1_ADDR(x))
#define HW_IPU_DP_SCS_SYNC_1_RD(x)        (HW_IPU_DP_SCS_SYNC_1(x).U)
#define HW_IPU_DP_SCS_SYNC_1_WR(x, v)     (HW_IPU_DP_SCS_SYNC_1(x).U = (v))
#define HW_IPU_DP_SCS_SYNC_1_SET(x, v)    (HW_IPU_DP_SCS_SYNC_1_WR(x, HW_IPU_DP_SCS_SYNC_1_RD(x) |  (v)))
#define HW_IPU_DP_SCS_SYNC_1_CLR(x, v)    (HW_IPU_DP_SCS_SYNC_1_WR(x, HW_IPU_DP_SCS_SYNC_1_RD(x) & ~(v)))
#define HW_IPU_DP_SCS_SYNC_1_TOG(x, v)    (HW_IPU_DP_SCS_SYNC_1_WR(x, HW_IPU_DP_SCS_SYNC_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_SCS_SYNC_1 bitfields
 */

/* --- Register HW_IPU_DP_SCS_SYNC_1, field DP_CSC_B1_SYNC (RW)
 *
 * B0 parameter of color conversion.
 */

#define BP_IPU_DP_SCS_SYNC_1_DP_CSC_B1_SYNC      0
#define BM_IPU_DP_SCS_SYNC_1_DP_CSC_B1_SYNC      0x00003fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_SCS_SYNC_1_DP_CSC_B1_SYNC(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_SCS_SYNC_1_DP_CSC_B1_SYNC)
#else
#define BF_IPU_DP_SCS_SYNC_1_DP_CSC_B1_SYNC(v)   (((v) << 0) & BM_IPU_DP_SCS_SYNC_1_DP_CSC_B1_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_B1_SYNC field to a new value.
#define BW_IPU_DP_SCS_SYNC_1_DP_CSC_B1_SYNC(v)   BF_CS1(IPU_DP_SCS_SYNC_1, DP_CSC_B1_SYNC, v)
#endif

/* --- Register HW_IPU_DP_SCS_SYNC_1, field DP_CSC_S1_SYNC (RW)
 *
 * S0 parameter of color conversion.
 *
 * Values:
 * 00 - scale factor of 2
 * 01 - scale factor of 1
 * 10 - scale factor of 0 11 scale factor of -1
 */

#define BP_IPU_DP_SCS_SYNC_1_DP_CSC_S1_SYNC      14
#define BM_IPU_DP_SCS_SYNC_1_DP_CSC_S1_SYNC      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_SCS_SYNC_1_DP_CSC_S1_SYNC(v)   ((((reg32_t) v) << 14) & BM_IPU_DP_SCS_SYNC_1_DP_CSC_S1_SYNC)
#else
#define BF_IPU_DP_SCS_SYNC_1_DP_CSC_S1_SYNC(v)   (((v) << 14) & BM_IPU_DP_SCS_SYNC_1_DP_CSC_S1_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_S1_SYNC field to a new value.
#define BW_IPU_DP_SCS_SYNC_1_DP_CSC_S1_SYNC(v)   BF_CS1(IPU_DP_SCS_SYNC_1, DP_CSC_S1_SYNC, v)
#endif


/* --- Register HW_IPU_DP_SCS_SYNC_1, field DP_CSC_B2_SYNC (RW)
 *
 * B0 parameter of color conversion.
 */

#define BP_IPU_DP_SCS_SYNC_1_DP_CSC_B2_SYNC      16
#define BM_IPU_DP_SCS_SYNC_1_DP_CSC_B2_SYNC      0x3fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_SCS_SYNC_1_DP_CSC_B2_SYNC(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_SCS_SYNC_1_DP_CSC_B2_SYNC)
#else
#define BF_IPU_DP_SCS_SYNC_1_DP_CSC_B2_SYNC(v)   (((v) << 16) & BM_IPU_DP_SCS_SYNC_1_DP_CSC_B2_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_B2_SYNC field to a new value.
#define BW_IPU_DP_SCS_SYNC_1_DP_CSC_B2_SYNC(v)   BF_CS1(IPU_DP_SCS_SYNC_1, DP_CSC_B2_SYNC, v)
#endif

/* --- Register HW_IPU_DP_SCS_SYNC_1, field DP_CSC_S2_SYNC (RW)
 *
 * S0 parameter of color conversion.
 *
 * Values:
 * 00 - scale factor of 2
 * 01 - scale factor of 1
 * 10 - scale factor of 0 11 scale factor of -1
 */

#define BP_IPU_DP_SCS_SYNC_1_DP_CSC_S2_SYNC      30
#define BM_IPU_DP_SCS_SYNC_1_DP_CSC_S2_SYNC      0xc0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_SCS_SYNC_1_DP_CSC_S2_SYNC(v)   ((((reg32_t) v) << 30) & BM_IPU_DP_SCS_SYNC_1_DP_CSC_S2_SYNC)
#else
#define BF_IPU_DP_SCS_SYNC_1_DP_CSC_S2_SYNC(v)   (((v) << 30) & BM_IPU_DP_SCS_SYNC_1_DP_CSC_S2_SYNC)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_S2_SYNC field to a new value.
#define BW_IPU_DP_SCS_SYNC_1_DP_CSC_S2_SYNC(v)   BF_CS1(IPU_DP_SCS_SYNC_1, DP_CSC_S2_SYNC, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CUR_POS_ALT - DP Cursor Position and Size Alternate Register (RW)
 *
 * The LCD Cursor Position Register is used to determine the starting position of the cursor
 * relative to BG windows position for the alternative flow.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CXW_SYNC_ALT : 11; //!< CXW_ALT - Cursor Width. Specifies the width of the hardware cursor in pixels for the alternative flow.
        unsigned DP_CXP_SYNC_ALT : 5; //!< CXP_ALT - Cursor X Position Represents the cursors horizontal starting position X in pixel count (from 0 to CXW) for the alternative flow.
        unsigned DP_CYH_SYNC_ALT : 11; //!< CYH_ALT - Cursor Height Specifies the height of the hardware cursor in pixels.
        unsigned DP_CYP_SYNC_ALT : 5; //!< CYP_ALT - Cursor Y Position Represents the cursors vertical starting position Y in pixel count (from 0 to CYH).Live View Resolution Mode for the alternative flow.
    } B;
} hw_ipu_dp_cur_pos_alt_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CUR_POS_ALT register
 */
#define HW_IPU_DP_CUR_POS_ALT_ADDR(x)      (REGS_IPU_BASE(x) + 0x104005c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CUR_POS_ALT(x)           (*(volatile hw_ipu_dp_cur_pos_alt_t *) HW_IPU_DP_CUR_POS_ALT_ADDR(x))
#define HW_IPU_DP_CUR_POS_ALT_RD(x)        (HW_IPU_DP_CUR_POS_ALT(x).U)
#define HW_IPU_DP_CUR_POS_ALT_WR(x, v)     (HW_IPU_DP_CUR_POS_ALT(x).U = (v))
#define HW_IPU_DP_CUR_POS_ALT_SET(x, v)    (HW_IPU_DP_CUR_POS_ALT_WR(x, HW_IPU_DP_CUR_POS_ALT_RD(x) |  (v)))
#define HW_IPU_DP_CUR_POS_ALT_CLR(x, v)    (HW_IPU_DP_CUR_POS_ALT_WR(x, HW_IPU_DP_CUR_POS_ALT_RD(x) & ~(v)))
#define HW_IPU_DP_CUR_POS_ALT_TOG(x, v)    (HW_IPU_DP_CUR_POS_ALT_WR(x, HW_IPU_DP_CUR_POS_ALT_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CUR_POS_ALT bitfields
 */

/* --- Register HW_IPU_DP_CUR_POS_ALT, field DP_CXW_SYNC_ALT (RW)
 *
 * CXW_ALT - Cursor Width. Specifies the width of the hardware cursor in pixels for the alternative
 * flow.
 */

#define BP_IPU_DP_CUR_POS_ALT_DP_CXW_SYNC_ALT      0
#define BM_IPU_DP_CUR_POS_ALT_DP_CXW_SYNC_ALT      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_ALT_DP_CXW_SYNC_ALT(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CUR_POS_ALT_DP_CXW_SYNC_ALT)
#else
#define BF_IPU_DP_CUR_POS_ALT_DP_CXW_SYNC_ALT(v)   (((v) << 0) & BM_IPU_DP_CUR_POS_ALT_DP_CXW_SYNC_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CXW_SYNC_ALT field to a new value.
#define BW_IPU_DP_CUR_POS_ALT_DP_CXW_SYNC_ALT(v)   BF_CS1(IPU_DP_CUR_POS_ALT, DP_CXW_SYNC_ALT, v)
#endif

/* --- Register HW_IPU_DP_CUR_POS_ALT, field DP_CXP_SYNC_ALT (RW)
 *
 * CXP_ALT - Cursor X Position Represents the cursors horizontal starting position X in pixel count
 * (from 0 to CXW) for the alternative flow.
 */

#define BP_IPU_DP_CUR_POS_ALT_DP_CXP_SYNC_ALT      11
#define BM_IPU_DP_CUR_POS_ALT_DP_CXP_SYNC_ALT      0x0000f800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_ALT_DP_CXP_SYNC_ALT(v)   ((((reg32_t) v) << 11) & BM_IPU_DP_CUR_POS_ALT_DP_CXP_SYNC_ALT)
#else
#define BF_IPU_DP_CUR_POS_ALT_DP_CXP_SYNC_ALT(v)   (((v) << 11) & BM_IPU_DP_CUR_POS_ALT_DP_CXP_SYNC_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CXP_SYNC_ALT field to a new value.
#define BW_IPU_DP_CUR_POS_ALT_DP_CXP_SYNC_ALT(v)   BF_CS1(IPU_DP_CUR_POS_ALT, DP_CXP_SYNC_ALT, v)
#endif

/* --- Register HW_IPU_DP_CUR_POS_ALT, field DP_CYH_SYNC_ALT (RW)
 *
 * CYH_ALT - Cursor Height Specifies the height of the hardware cursor in pixels.
 */

#define BP_IPU_DP_CUR_POS_ALT_DP_CYH_SYNC_ALT      16
#define BM_IPU_DP_CUR_POS_ALT_DP_CYH_SYNC_ALT      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_ALT_DP_CYH_SYNC_ALT(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CUR_POS_ALT_DP_CYH_SYNC_ALT)
#else
#define BF_IPU_DP_CUR_POS_ALT_DP_CYH_SYNC_ALT(v)   (((v) << 16) & BM_IPU_DP_CUR_POS_ALT_DP_CYH_SYNC_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CYH_SYNC_ALT field to a new value.
#define BW_IPU_DP_CUR_POS_ALT_DP_CYH_SYNC_ALT(v)   BF_CS1(IPU_DP_CUR_POS_ALT, DP_CYH_SYNC_ALT, v)
#endif

/* --- Register HW_IPU_DP_CUR_POS_ALT, field DP_CYP_SYNC_ALT (RW)
 *
 * CYP_ALT - Cursor Y Position Represents the cursors vertical starting position Y in pixel count
 * (from 0 to CYH).Live View Resolution Mode for the alternative flow.
 */

#define BP_IPU_DP_CUR_POS_ALT_DP_CYP_SYNC_ALT      27
#define BM_IPU_DP_CUR_POS_ALT_DP_CYP_SYNC_ALT      0xf8000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_ALT_DP_CYP_SYNC_ALT(v)   ((((reg32_t) v) << 27) & BM_IPU_DP_CUR_POS_ALT_DP_CYP_SYNC_ALT)
#else
#define BF_IPU_DP_CUR_POS_ALT_DP_CYP_SYNC_ALT(v)   (((v) << 27) & BM_IPU_DP_CUR_POS_ALT_DP_CYP_SYNC_ALT)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CYP_SYNC_ALT field to a new value.
#define BW_IPU_DP_CUR_POS_ALT_DP_CYP_SYNC_ALT(v)   BF_CS1(IPU_DP_CUR_POS_ALT, DP_CYP_SYNC_ALT, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_COM_CONF_ASYNC0 - DP Common Configuration Async 0 Flow Register (RW)
 *
 * This register contains common configuration parameters for the DP.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DP_GWSEL_ASYNC0 : 1; //!< GWSEL - Graphic Window Select Select graphic window to be on partial plane or full plane.
        unsigned DP_GWAM_ASYNC0 : 1; //!< GWAM - Graphic Window Alpha Mode Select the use of Alpha to be global or local.
        unsigned DP_GWCKE_ASYNC0 : 1; //!< GWCKE - Graphic Window Color Keying Enable Enable or disable graphic window color keying.
        unsigned DP_COC_ASYNC0 : 3; //!< COC - Cursor Operation Control Controls the format of the cursor and the type of arithmetic operations
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned DP_CSC_DEF_ASYNC0 : 2; //!< CSC_DEF Enable or disable Color Space Conversion.
        unsigned DP_CSC_GAMUT_SAT_EN_ASYNC0 : 1; //!< CSC_GAMUT_SAT_EN Indicate if GAMUT saturation is enabled
        unsigned DP_CSC_YUV_SAT_MODE_ASYNC0 : 1; //!< CSC_YUV_SAT_MODE YUV saturation mode for color space conversion
        unsigned DP_GAMMA_EN_ASYNC0 : 1; //!< GAMMA_EN - Gamma correction block enable bit
        unsigned DP_GAMMA_YUV_EN_ASYNC0 : 1; //!< GAMMA's YUV mode enable for async flow 0
        unsigned RESERVED2 : 18; //!< Reserved
    } B;
} hw_ipu_dp_com_conf_async0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_COM_CONF_ASYNC0 register
 */
#define HW_IPU_DP_COM_CONF_ASYNC0_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040060)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_COM_CONF_ASYNC0(x)           (*(volatile hw_ipu_dp_com_conf_async0_t *) HW_IPU_DP_COM_CONF_ASYNC0_ADDR(x))
#define HW_IPU_DP_COM_CONF_ASYNC0_RD(x)        (HW_IPU_DP_COM_CONF_ASYNC0(x).U)
#define HW_IPU_DP_COM_CONF_ASYNC0_WR(x, v)     (HW_IPU_DP_COM_CONF_ASYNC0(x).U = (v))
#define HW_IPU_DP_COM_CONF_ASYNC0_SET(x, v)    (HW_IPU_DP_COM_CONF_ASYNC0_WR(x, HW_IPU_DP_COM_CONF_ASYNC0_RD(x) |  (v)))
#define HW_IPU_DP_COM_CONF_ASYNC0_CLR(x, v)    (HW_IPU_DP_COM_CONF_ASYNC0_WR(x, HW_IPU_DP_COM_CONF_ASYNC0_RD(x) & ~(v)))
#define HW_IPU_DP_COM_CONF_ASYNC0_TOG(x, v)    (HW_IPU_DP_COM_CONF_ASYNC0_WR(x, HW_IPU_DP_COM_CONF_ASYNC0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_COM_CONF_ASYNC0 bitfields
 */

/* --- Register HW_IPU_DP_COM_CONF_ASYNC0, field DP_GWSEL_ASYNC0 (RW)
 *
 * GWSEL - Graphic Window Select Select graphic window to be on partial plane or full plane.
 *
 * Values:
 * 1 - Graphic window is partial plane.
 * 0 - Graphic window is full plane.5
 */

#define BP_IPU_DP_COM_CONF_ASYNC0_DP_GWSEL_ASYNC0      1
#define BM_IPU_DP_COM_CONF_ASYNC0_DP_GWSEL_ASYNC0      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_GWSEL_ASYNC0(v)   ((((reg32_t) v) << 1) & BM_IPU_DP_COM_CONF_ASYNC0_DP_GWSEL_ASYNC0)
#else
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_GWSEL_ASYNC0(v)   (((v) << 1) & BM_IPU_DP_COM_CONF_ASYNC0_DP_GWSEL_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWSEL_ASYNC0 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC0_DP_GWSEL_ASYNC0(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC0, DP_GWSEL_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC0, field DP_GWAM_ASYNC0 (RW)
 *
 * GWAM - Graphic Window Alpha Mode Select the use of Alpha to be global or local.
 *
 * Values:
 * 1 - Global Alpha.
 * 0 - Local Alpha.
 */

#define BP_IPU_DP_COM_CONF_ASYNC0_DP_GWAM_ASYNC0      2
#define BM_IPU_DP_COM_CONF_ASYNC0_DP_GWAM_ASYNC0      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_GWAM_ASYNC0(v)   ((((reg32_t) v) << 2) & BM_IPU_DP_COM_CONF_ASYNC0_DP_GWAM_ASYNC0)
#else
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_GWAM_ASYNC0(v)   (((v) << 2) & BM_IPU_DP_COM_CONF_ASYNC0_DP_GWAM_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWAM_ASYNC0 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC0_DP_GWAM_ASYNC0(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC0, DP_GWAM_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC0, field DP_GWCKE_ASYNC0 (RW)
 *
 * GWCKE - Graphic Window Color Keying Enable Enable or disable graphic window color keying.
 *
 * Values:
 * 1 - Enable color keying of graphic window
 * 0 - Disable color keying of graphic window
 */

#define BP_IPU_DP_COM_CONF_ASYNC0_DP_GWCKE_ASYNC0      3
#define BM_IPU_DP_COM_CONF_ASYNC0_DP_GWCKE_ASYNC0      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_GWCKE_ASYNC0(v)   ((((reg32_t) v) << 3) & BM_IPU_DP_COM_CONF_ASYNC0_DP_GWCKE_ASYNC0)
#else
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_GWCKE_ASYNC0(v)   (((v) << 3) & BM_IPU_DP_COM_CONF_ASYNC0_DP_GWCKE_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWCKE_ASYNC0 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC0_DP_GWCKE_ASYNC0(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC0, DP_GWCKE_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC0, field DP_COC_ASYNC0 (RW)
 *
 * COC - Cursor Operation Control Controls the format of the cursor and the type of arithmetic
 * operations
 *
 * Values:
 * 000 - Transparent, cursor is disabled.
 * 001 - Full cursor.
 * 010 - Reversed cursor.
 * 011 - AND between full plane and cursor.
 * 100 - Reserved
 * 101 - OR between full plane and cursor.
 * 110 - XOR between full plane and cursor.
 * 111 - Reserved
 */

#define BP_IPU_DP_COM_CONF_ASYNC0_DP_COC_ASYNC0      4
#define BM_IPU_DP_COM_CONF_ASYNC0_DP_COC_ASYNC0      0x00000070

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_COC_ASYNC0(v)   ((((reg32_t) v) << 4) & BM_IPU_DP_COM_CONF_ASYNC0_DP_COC_ASYNC0)
#else
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_COC_ASYNC0(v)   (((v) << 4) & BM_IPU_DP_COM_CONF_ASYNC0_DP_COC_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_COC_ASYNC0 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC0_DP_COC_ASYNC0(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC0, DP_COC_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC0, field DP_CSC_DEF_ASYNC0 (RW)
 *
 * CSC_DEF Enable or disable Color Space Conversion.
 *
 * Values:
 * 00 - CSC disable
 * 01 - CSC enable after combining
 * 10 - CSC enable before combining on BG channel
 * 11 - CSC enable before combining on FG channel
 */

#define BP_IPU_DP_COM_CONF_ASYNC0_DP_CSC_DEF_ASYNC0      8
#define BM_IPU_DP_COM_CONF_ASYNC0_DP_CSC_DEF_ASYNC0      0x00000300

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_CSC_DEF_ASYNC0(v)   ((((reg32_t) v) << 8) & BM_IPU_DP_COM_CONF_ASYNC0_DP_CSC_DEF_ASYNC0)
#else
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_CSC_DEF_ASYNC0(v)   (((v) << 8) & BM_IPU_DP_COM_CONF_ASYNC0_DP_CSC_DEF_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_DEF_ASYNC0 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC0_DP_CSC_DEF_ASYNC0(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC0, DP_CSC_DEF_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC0, field DP_CSC_GAMUT_SAT_EN_ASYNC0 (RW)
 *
 * CSC_GAMUT_SAT_EN Indicate if GAMUT saturation is enabled
 *
 * Values:
 * 0 - disable GAMUT mapping
 * 1 - enable GAMUT mapping
 */

#define BP_IPU_DP_COM_CONF_ASYNC0_DP_CSC_GAMUT_SAT_EN_ASYNC0      10
#define BM_IPU_DP_COM_CONF_ASYNC0_DP_CSC_GAMUT_SAT_EN_ASYNC0      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_CSC_GAMUT_SAT_EN_ASYNC0(v)   ((((reg32_t) v) << 10) & BM_IPU_DP_COM_CONF_ASYNC0_DP_CSC_GAMUT_SAT_EN_ASYNC0)
#else
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_CSC_GAMUT_SAT_EN_ASYNC0(v)   (((v) << 10) & BM_IPU_DP_COM_CONF_ASYNC0_DP_CSC_GAMUT_SAT_EN_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_GAMUT_SAT_EN_ASYNC0 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC0_DP_CSC_GAMUT_SAT_EN_ASYNC0(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC0, DP_CSC_GAMUT_SAT_EN_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC0, field DP_CSC_YUV_SAT_MODE_ASYNC0 (RW)
 *
 * CSC_YUV_SAT_MODE YUV saturation mode for color space conversion
 *
 * Values:
 * 0 - Y/U/V range 0 -255
 * 1 - Y range 16-235, U/V range 16-240
 */

#define BP_IPU_DP_COM_CONF_ASYNC0_DP_CSC_YUV_SAT_MODE_ASYNC0      11
#define BM_IPU_DP_COM_CONF_ASYNC0_DP_CSC_YUV_SAT_MODE_ASYNC0      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_CSC_YUV_SAT_MODE_ASYNC0(v)   ((((reg32_t) v) << 11) & BM_IPU_DP_COM_CONF_ASYNC0_DP_CSC_YUV_SAT_MODE_ASYNC0)
#else
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_CSC_YUV_SAT_MODE_ASYNC0(v)   (((v) << 11) & BM_IPU_DP_COM_CONF_ASYNC0_DP_CSC_YUV_SAT_MODE_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_YUV_SAT_MODE_ASYNC0 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC0_DP_CSC_YUV_SAT_MODE_ASYNC0(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC0, DP_CSC_YUV_SAT_MODE_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC0, field DP_GAMMA_EN_ASYNC0 (RW)
 *
 * GAMMA_EN - Gamma correction block enable bit
 *
 * Values:
 * 0 - disable
 * 1 - enable
 */

#define BP_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_EN_ASYNC0      12
#define BM_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_EN_ASYNC0      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_EN_ASYNC0(v)   ((((reg32_t) v) << 12) & BM_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_EN_ASYNC0)
#else
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_EN_ASYNC0(v)   (((v) << 12) & BM_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_EN_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_EN_ASYNC0 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_EN_ASYNC0(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC0, DP_GAMMA_EN_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC0, field DP_GAMMA_YUV_EN_ASYNC0 (RW)
 *
 * GAMMA's YUV mode enable for async flow 0
 *
 * Values:
 * 0 - YUV mode is OFF.
 * 1 - YUV mode is ON.
 */

#define BP_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_YUV_EN_ASYNC0      13
#define BM_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_YUV_EN_ASYNC0      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_YUV_EN_ASYNC0(v)   ((((reg32_t) v) << 13) & BM_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_YUV_EN_ASYNC0)
#else
#define BF_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_YUV_EN_ASYNC0(v)   (((v) << 13) & BM_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_YUV_EN_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_YUV_EN_ASYNC0 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC0_DP_GAMMA_YUV_EN_ASYNC0(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC0, DP_GAMMA_YUV_EN_ASYNC0, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0 - DP Graphic Window Control Async 0 Flow Register (RW)
 *
 * This register contains common configuration parameters for the DP.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_GWCKB_ASYNC0 : 8; //!< GWCKB - Graphic Window Color Keying Blue Component Defines the blue component of graphic window color keying.
        unsigned DP_GWCKG_ASYNC0 : 8; //!< GWCKG - Graphic Window Color Keying Green Component Defines the green component of graphic window color keying.
        unsigned DP_GWCKR_ASYNC0 : 8; //!< GWCKR - Graphic Window Color Keying Red Component Defines the red component of graphic window color keying.
        unsigned DP_GWAV_ASYNC0 : 8; //!< GWAV - Graphic Window Alpha Value Defines the alpha value of graphic window used for alpha blending between graphic window and full plane. The Value the number that writing to GWAV register. The Actual Value the number, that insert to calculation in Combining Module. If Value = < 0.5- 1/256 (01111111) then Actual Value = Value. If Value >= 0.5 (10000000), then Actual Value = Value + 1/256.
    } B;
} hw_ipu_dp_graph_wind_ctrl_async0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_GRAPH_WIND_CTRL_ASYNC0 register
 */
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040064)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0(x)           (*(volatile hw_ipu_dp_graph_wind_ctrl_async0_t *) HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_ADDR(x))
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_RD(x)        (HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0(x).U)
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_WR(x, v)     (HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0(x).U = (v))
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_SET(x, v)    (HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_WR(x, HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_RD(x) |  (v)))
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_CLR(x, v)    (HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_WR(x, HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_RD(x) & ~(v)))
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_TOG(x, v)    (HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_WR(x, HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_GRAPH_WIND_CTRL_ASYNC0 bitfields
 */

/* --- Register HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0, field DP_GWCKB_ASYNC0 (RW)
 *
 * GWCKB - Graphic Window Color Keying Blue Component Defines the blue component of graphic window
 * color keying.
 *
 * Values:
 * 00000000 - No blue
 * 11111111 - Full blue
 */

#define BP_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKB_ASYNC0      0
#define BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKB_ASYNC0      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKB_ASYNC0(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKB_ASYNC0)
#else
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKB_ASYNC0(v)   (((v) << 0) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKB_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWCKB_ASYNC0 field to a new value.
#define BW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKB_ASYNC0(v)   BF_CS1(IPU_DP_GRAPH_WIND_CTRL_ASYNC0, DP_GWCKB_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0, field DP_GWCKG_ASYNC0 (RW)
 *
 * GWCKG - Graphic Window Color Keying Green Component Defines the green component of graphic window
 * color keying.
 *
 * Values:
 * 00000000 - No Green
 * 11111111 - Full Green
 */

#define BP_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKG_ASYNC0      8
#define BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKG_ASYNC0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKG_ASYNC0(v)   ((((reg32_t) v) << 8) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKG_ASYNC0)
#else
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKG_ASYNC0(v)   (((v) << 8) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKG_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWCKG_ASYNC0 field to a new value.
#define BW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKG_ASYNC0(v)   BF_CS1(IPU_DP_GRAPH_WIND_CTRL_ASYNC0, DP_GWCKG_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0, field DP_GWCKR_ASYNC0 (RW)
 *
 * GWCKR - Graphic Window Color Keying Red Component Defines the red component of graphic window
 * color keying.
 *
 * Values:
 * 00000000 - No red
 * 11111111 - Full red
 */

#define BP_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKR_ASYNC0      16
#define BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKR_ASYNC0      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKR_ASYNC0(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKR_ASYNC0)
#else
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKR_ASYNC0(v)   (((v) << 16) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKR_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWCKR_ASYNC0 field to a new value.
#define BW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWCKR_ASYNC0(v)   BF_CS1(IPU_DP_GRAPH_WIND_CTRL_ASYNC0, DP_GWCKR_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0, field DP_GWAV_ASYNC0 (RW)
 *
 * GWAV - Graphic Window Alpha Value Defines the alpha value of graphic window used for alpha
 * blending between graphic window and full plane. The Value the number that writing to GWAV
 * register. The Actual Value the number, that insert to calculation in Combining Module. If Value =
 * < 0.5- 1/256 (01111111) then Actual Value = Value. If Value >= 0.5 (10000000), then Actual Value
 * = Value + 1/256.
 *
 * Values:
 * 00000000 - Actual value is 00000000; Graphic window totally opaque i.e. overlay on LCD screen
 * 01111111 - Actual value is 01111111;
 * 10000000 - Actual value is 10000001
 * 10000001 - Actual value is 10000010
 * 11111110 - Actual value is 11111111
 * 11111111 - Actual value is 100000000;Graphic window totally transparent i.e. not displayed on LCD screen
 */

#define BP_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWAV_ASYNC0      24
#define BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWAV_ASYNC0      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWAV_ASYNC0(v)   ((((reg32_t) v) << 24) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWAV_ASYNC0)
#else
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWAV_ASYNC0(v)   (((v) << 24) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWAV_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWAV_ASYNC0 field to a new value.
#define BW_IPU_DP_GRAPH_WIND_CTRL_ASYNC0_DP_GWAV_ASYNC0(v)   BF_CS1(IPU_DP_GRAPH_WIND_CTRL_ASYNC0, DP_GWAV_ASYNC0, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_FG_POS_ASYNC0 - DP Partial Plane Window Position Async 0 Flow Register (RW)
 *
 * The DP partial plane Window Position Register is used to determine the starting position of the
 * partial plane window relative to BG window position.  This Register is used for the synchronous
 * flow only.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_FGYP_ASYNC0 : 11; //!< FGYP partial plane window Y position partial plane Window Y Position - Specifies the number of lines between the start of full plane windows Y position and the beginning of the first data.
        unsigned RESERVED0 : 5; //!< Reserved
        unsigned DP_FGXP_ASYNC0 : 11; //!< FGXP partial plane Window X Position. partial plane Window X Position - Specifies the number of pixels between the start of full plane window X position and the beginning of the first data of new line.
        unsigned RESERVED1 : 5; //!< Reserved
    } B;
} hw_ipu_dp_fg_pos_async0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_FG_POS_ASYNC0 register
 */
#define HW_IPU_DP_FG_POS_ASYNC0_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040068)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_FG_POS_ASYNC0(x)           (*(volatile hw_ipu_dp_fg_pos_async0_t *) HW_IPU_DP_FG_POS_ASYNC0_ADDR(x))
#define HW_IPU_DP_FG_POS_ASYNC0_RD(x)        (HW_IPU_DP_FG_POS_ASYNC0(x).U)
#define HW_IPU_DP_FG_POS_ASYNC0_WR(x, v)     (HW_IPU_DP_FG_POS_ASYNC0(x).U = (v))
#define HW_IPU_DP_FG_POS_ASYNC0_SET(x, v)    (HW_IPU_DP_FG_POS_ASYNC0_WR(x, HW_IPU_DP_FG_POS_ASYNC0_RD(x) |  (v)))
#define HW_IPU_DP_FG_POS_ASYNC0_CLR(x, v)    (HW_IPU_DP_FG_POS_ASYNC0_WR(x, HW_IPU_DP_FG_POS_ASYNC0_RD(x) & ~(v)))
#define HW_IPU_DP_FG_POS_ASYNC0_TOG(x, v)    (HW_IPU_DP_FG_POS_ASYNC0_WR(x, HW_IPU_DP_FG_POS_ASYNC0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_FG_POS_ASYNC0 bitfields
 */

/* --- Register HW_IPU_DP_FG_POS_ASYNC0, field DP_FGYP_ASYNC0 (RW)
 *
 * FGYP partial plane window Y position partial plane Window Y Position - Specifies the number of
 * lines between the start of full plane windows Y position and the beginning of the first data.
 */

#define BP_IPU_DP_FG_POS_ASYNC0_DP_FGYP_ASYNC0      0
#define BM_IPU_DP_FG_POS_ASYNC0_DP_FGYP_ASYNC0      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_FG_POS_ASYNC0_DP_FGYP_ASYNC0(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_FG_POS_ASYNC0_DP_FGYP_ASYNC0)
#else
#define BF_IPU_DP_FG_POS_ASYNC0_DP_FGYP_ASYNC0(v)   (((v) << 0) & BM_IPU_DP_FG_POS_ASYNC0_DP_FGYP_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_FGYP_ASYNC0 field to a new value.
#define BW_IPU_DP_FG_POS_ASYNC0_DP_FGYP_ASYNC0(v)   BF_CS1(IPU_DP_FG_POS_ASYNC0, DP_FGYP_ASYNC0, v)
#endif

/* --- Register HW_IPU_DP_FG_POS_ASYNC0, field DP_FGXP_ASYNC0 (RW)
 *
 * FGXP partial plane Window X Position. partial plane Window X Position - Specifies the number of
 * pixels between the start of full plane window X position and the beginning of the first data of
 * new line.
 */

#define BP_IPU_DP_FG_POS_ASYNC0_DP_FGXP_ASYNC0      16
#define BM_IPU_DP_FG_POS_ASYNC0_DP_FGXP_ASYNC0      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_FG_POS_ASYNC0_DP_FGXP_ASYNC0(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_FG_POS_ASYNC0_DP_FGXP_ASYNC0)
#else
#define BF_IPU_DP_FG_POS_ASYNC0_DP_FGXP_ASYNC0(v)   (((v) << 16) & BM_IPU_DP_FG_POS_ASYNC0_DP_FGXP_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_FGXP_ASYNC0 field to a new value.
#define BW_IPU_DP_FG_POS_ASYNC0_DP_FGXP_ASYNC0(v)   BF_CS1(IPU_DP_FG_POS_ASYNC0, DP_FGXP_ASYNC0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CUR_POS_ASYNC0 - DP Cursor Position and Size Async 0 Flow Register (RW)
 *
 * The LCD Cursor Position Register is used to determine the starting position of the cursor
 * relative to BG windows position.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CXW_ASYNC0 : 11; //!< CXW - Cursor Width. Specifies the width of the hardware cursor in pixels.
        unsigned DP_CXP_ASYNC0 : 5; //!< CXP - Cursor X Position Represents the cursors horizontal starting position X in pixel count (from 0 to CXW).
        unsigned DP_CYH_ASYNC0 : 11; //!< CYH - Cursor Height Specifies the height of the hardware cursor in pixels.
        unsigned DP_CYP_ASYNC0 : 5; //!< CYP - Cursor Y Position Represents the cursors vertical starting position Y in pixel count (from 0 to CYH).Live View Resolution Mode.
    } B;
} hw_ipu_dp_cur_pos_async0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CUR_POS_ASYNC0 register
 */
#define HW_IPU_DP_CUR_POS_ASYNC0_ADDR(x)      (REGS_IPU_BASE(x) + 0x104006c)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CUR_POS_ASYNC0(x)           (*(volatile hw_ipu_dp_cur_pos_async0_t *) HW_IPU_DP_CUR_POS_ASYNC0_ADDR(x))
#define HW_IPU_DP_CUR_POS_ASYNC0_RD(x)        (HW_IPU_DP_CUR_POS_ASYNC0(x).U)
#define HW_IPU_DP_CUR_POS_ASYNC0_WR(x, v)     (HW_IPU_DP_CUR_POS_ASYNC0(x).U = (v))
#define HW_IPU_DP_CUR_POS_ASYNC0_SET(x, v)    (HW_IPU_DP_CUR_POS_ASYNC0_WR(x, HW_IPU_DP_CUR_POS_ASYNC0_RD(x) |  (v)))
#define HW_IPU_DP_CUR_POS_ASYNC0_CLR(x, v)    (HW_IPU_DP_CUR_POS_ASYNC0_WR(x, HW_IPU_DP_CUR_POS_ASYNC0_RD(x) & ~(v)))
#define HW_IPU_DP_CUR_POS_ASYNC0_TOG(x, v)    (HW_IPU_DP_CUR_POS_ASYNC0_WR(x, HW_IPU_DP_CUR_POS_ASYNC0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CUR_POS_ASYNC0 bitfields
 */

/* --- Register HW_IPU_DP_CUR_POS_ASYNC0, field DP_CXW_ASYNC0 (RW)
 *
 * CXW - Cursor Width. Specifies the width of the hardware cursor in pixels.
 */

#define BP_IPU_DP_CUR_POS_ASYNC0_DP_CXW_ASYNC0      0
#define BM_IPU_DP_CUR_POS_ASYNC0_DP_CXW_ASYNC0      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_ASYNC0_DP_CXW_ASYNC0(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CUR_POS_ASYNC0_DP_CXW_ASYNC0)
#else
#define BF_IPU_DP_CUR_POS_ASYNC0_DP_CXW_ASYNC0(v)   (((v) << 0) & BM_IPU_DP_CUR_POS_ASYNC0_DP_CXW_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CXW_ASYNC0 field to a new value.
#define BW_IPU_DP_CUR_POS_ASYNC0_DP_CXW_ASYNC0(v)   BF_CS1(IPU_DP_CUR_POS_ASYNC0, DP_CXW_ASYNC0, v)
#endif

/* --- Register HW_IPU_DP_CUR_POS_ASYNC0, field DP_CXP_ASYNC0 (RW)
 *
 * CXP - Cursor X Position Represents the cursors horizontal starting position X in pixel count
 * (from 0 to CXW).
 */

#define BP_IPU_DP_CUR_POS_ASYNC0_DP_CXP_ASYNC0      11
#define BM_IPU_DP_CUR_POS_ASYNC0_DP_CXP_ASYNC0      0x0000f800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_ASYNC0_DP_CXP_ASYNC0(v)   ((((reg32_t) v) << 11) & BM_IPU_DP_CUR_POS_ASYNC0_DP_CXP_ASYNC0)
#else
#define BF_IPU_DP_CUR_POS_ASYNC0_DP_CXP_ASYNC0(v)   (((v) << 11) & BM_IPU_DP_CUR_POS_ASYNC0_DP_CXP_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CXP_ASYNC0 field to a new value.
#define BW_IPU_DP_CUR_POS_ASYNC0_DP_CXP_ASYNC0(v)   BF_CS1(IPU_DP_CUR_POS_ASYNC0, DP_CXP_ASYNC0, v)
#endif

/* --- Register HW_IPU_DP_CUR_POS_ASYNC0, field DP_CYH_ASYNC0 (RW)
 *
 * CYH - Cursor Height Specifies the height of the hardware cursor in pixels.
 */

#define BP_IPU_DP_CUR_POS_ASYNC0_DP_CYH_ASYNC0      16
#define BM_IPU_DP_CUR_POS_ASYNC0_DP_CYH_ASYNC0      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_ASYNC0_DP_CYH_ASYNC0(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CUR_POS_ASYNC0_DP_CYH_ASYNC0)
#else
#define BF_IPU_DP_CUR_POS_ASYNC0_DP_CYH_ASYNC0(v)   (((v) << 16) & BM_IPU_DP_CUR_POS_ASYNC0_DP_CYH_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CYH_ASYNC0 field to a new value.
#define BW_IPU_DP_CUR_POS_ASYNC0_DP_CYH_ASYNC0(v)   BF_CS1(IPU_DP_CUR_POS_ASYNC0, DP_CYH_ASYNC0, v)
#endif

/* --- Register HW_IPU_DP_CUR_POS_ASYNC0, field DP_CYP_ASYNC0 (RW)
 *
 * CYP - Cursor Y Position Represents the cursors vertical starting position Y in pixel count (from
 * 0 to CYH).Live View Resolution Mode.
 */

#define BP_IPU_DP_CUR_POS_ASYNC0_DP_CYP_ASYNC0      27
#define BM_IPU_DP_CUR_POS_ASYNC0_DP_CYP_ASYNC0      0xf8000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_ASYNC0_DP_CYP_ASYNC0(v)   ((((reg32_t) v) << 27) & BM_IPU_DP_CUR_POS_ASYNC0_DP_CYP_ASYNC0)
#else
#define BF_IPU_DP_CUR_POS_ASYNC0_DP_CYP_ASYNC0(v)   (((v) << 27) & BM_IPU_DP_CUR_POS_ASYNC0_DP_CYP_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CYP_ASYNC0 field to a new value.
#define BW_IPU_DP_CUR_POS_ASYNC0_DP_CYP_ASYNC0(v)   BF_CS1(IPU_DP_CUR_POS_ASYNC0, DP_CYP_ASYNC0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CUR_MAP_ASYNC0 - DP Color Cursor Mapping Async 0 Flow Register (RW)
 *
 * The LCD Color Cursor Mapping Register defines the color of the cursor in passive or TFT color
 * modes.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CUR_COL_R_ASYNC0 : 8; //!< CUR_COL_R - Cursor Red Field Defines the Red component of the cursor color in color mode
        unsigned DP_CUR_COL_G_ASYNC0 : 8; //!< CUR_COL_G - Cursor Green Field Defines the Green component of the cursor color in color mode
        unsigned DP_CUR_COL_B_ASYNC0 : 8; //!< CUR_COL_B - Cursor Blue Field Defines the Blue component of the cursor color in color mode
        unsigned RESERVED0 : 8; //!< Reserved
    } B;
} hw_ipu_dp_cur_map_async0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CUR_MAP_ASYNC0 register
 */
#define HW_IPU_DP_CUR_MAP_ASYNC0_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040070)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CUR_MAP_ASYNC0(x)           (*(volatile hw_ipu_dp_cur_map_async0_t *) HW_IPU_DP_CUR_MAP_ASYNC0_ADDR(x))
#define HW_IPU_DP_CUR_MAP_ASYNC0_RD(x)        (HW_IPU_DP_CUR_MAP_ASYNC0(x).U)
#define HW_IPU_DP_CUR_MAP_ASYNC0_WR(x, v)     (HW_IPU_DP_CUR_MAP_ASYNC0(x).U = (v))
#define HW_IPU_DP_CUR_MAP_ASYNC0_SET(x, v)    (HW_IPU_DP_CUR_MAP_ASYNC0_WR(x, HW_IPU_DP_CUR_MAP_ASYNC0_RD(x) |  (v)))
#define HW_IPU_DP_CUR_MAP_ASYNC0_CLR(x, v)    (HW_IPU_DP_CUR_MAP_ASYNC0_WR(x, HW_IPU_DP_CUR_MAP_ASYNC0_RD(x) & ~(v)))
#define HW_IPU_DP_CUR_MAP_ASYNC0_TOG(x, v)    (HW_IPU_DP_CUR_MAP_ASYNC0_WR(x, HW_IPU_DP_CUR_MAP_ASYNC0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CUR_MAP_ASYNC0 bitfields
 */

/* --- Register HW_IPU_DP_CUR_MAP_ASYNC0, field DP_CUR_COL_R_ASYNC0 (RW)
 *
 * CUR_COL_R - Cursor Red Field Defines the Red component of the cursor color in color mode
 *
 * Values:
 * 00000000 - No Red.
 * 11111111 - Full Red.
 */

#define BP_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_R_ASYNC0      0
#define BM_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_R_ASYNC0      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_R_ASYNC0(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_R_ASYNC0)
#else
#define BF_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_R_ASYNC0(v)   (((v) << 0) & BM_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_R_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CUR_COL_R_ASYNC0 field to a new value.
#define BW_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_R_ASYNC0(v)   BF_CS1(IPU_DP_CUR_MAP_ASYNC0, DP_CUR_COL_R_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_CUR_MAP_ASYNC0, field DP_CUR_COL_G_ASYNC0 (RW)
 *
 * CUR_COL_G - Cursor Green Field Defines the Green component of the cursor color in color mode
 *
 * Values:
 * 00000000 - No Green.
 * 11111111 - Full Green.
 */

#define BP_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_G_ASYNC0      8
#define BM_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_G_ASYNC0      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_G_ASYNC0(v)   ((((reg32_t) v) << 8) & BM_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_G_ASYNC0)
#else
#define BF_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_G_ASYNC0(v)   (((v) << 8) & BM_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_G_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CUR_COL_G_ASYNC0 field to a new value.
#define BW_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_G_ASYNC0(v)   BF_CS1(IPU_DP_CUR_MAP_ASYNC0, DP_CUR_COL_G_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_CUR_MAP_ASYNC0, field DP_CUR_COL_B_ASYNC0 (RW)
 *
 * CUR_COL_B - Cursor Blue Field Defines the Blue component of the cursor color in color mode
 *
 * Values:
 * 00000000 - No Blue.
 * 11111111 - Full Blue.
 */

#define BP_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_B_ASYNC0      16
#define BM_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_B_ASYNC0      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_B_ASYNC0(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_B_ASYNC0)
#else
#define BF_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_B_ASYNC0(v)   (((v) << 16) & BM_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_B_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CUR_COL_B_ASYNC0 field to a new value.
#define BW_IPU_DP_CUR_MAP_ASYNC0_DP_CUR_COL_B_ASYNC0(v)   BF_CS1(IPU_DP_CUR_MAP_ASYNC0, DP_CUR_COL_B_ASYNC0, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_GAMMA_C_ASYNC0_I - DP Gamma Constant Async 0 Flow Register i (RW)
 *
 * This registers contains CONSTANTi parameters used for gamma correction inside the display
 * processor (DP).
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_GAMMA_C_ASYNC0_ : 9; //!< CONSTANTi parameter of Gamma Correction.
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DP_GAMMA_C_ASYNC0_1 : 12; //!< CONSTANTi+1 parameter of Gamma Correction.
        unsigned RESERVED1 : 4; //!< Reserved.
    } B;
} hw_ipu_dp_gamma_c_async0_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_GAMMA_C_ASYNC0_I register
 */
#define HW_IPU_DP_GAMMA_C_ASYNC0_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040074)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_GAMMA_C_ASYNC0_I(x)           (*(volatile hw_ipu_dp_gamma_c_async0_i_t *) HW_IPU_DP_GAMMA_C_ASYNC0_I_ADDR(x))
#define HW_IPU_DP_GAMMA_C_ASYNC0_I_RD(x)        (HW_IPU_DP_GAMMA_C_ASYNC0_I(x).U)
#define HW_IPU_DP_GAMMA_C_ASYNC0_I_WR(x, v)     (HW_IPU_DP_GAMMA_C_ASYNC0_I(x).U = (v))
#define HW_IPU_DP_GAMMA_C_ASYNC0_I_SET(x, v)    (HW_IPU_DP_GAMMA_C_ASYNC0_I_WR(x, HW_IPU_DP_GAMMA_C_ASYNC0_I_RD(x) |  (v)))
#define HW_IPU_DP_GAMMA_C_ASYNC0_I_CLR(x, v)    (HW_IPU_DP_GAMMA_C_ASYNC0_I_WR(x, HW_IPU_DP_GAMMA_C_ASYNC0_I_RD(x) & ~(v)))
#define HW_IPU_DP_GAMMA_C_ASYNC0_I_TOG(x, v)    (HW_IPU_DP_GAMMA_C_ASYNC0_I_WR(x, HW_IPU_DP_GAMMA_C_ASYNC0_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_GAMMA_C_ASYNC0_I bitfields
 */

/* --- Register HW_IPU_DP_GAMMA_C_ASYNC0_I, field DP_GAMMA_C_ASYNC0_ (RW)
 *
 * CONSTANTi parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_      0
#define BM_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_)
#else
#define BF_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_(v)   (((v) << 0) & BM_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_C_ASYNC0_ field to a new value.
#define BW_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_(v)   BF_CS1(IPU_DP_GAMMA_C_ASYNC0_I, DP_GAMMA_C_ASYNC0_, v)
#endif

/* --- Register HW_IPU_DP_GAMMA_C_ASYNC0_I, field DP_GAMMA_C_ASYNC0_ (RW)
 *
 * CONSTANTi+1 parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_      16
#define BM_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_)
#else
#define BF_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_(v)   (((v) << 16) & BM_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_C_ASYNC0_ field to a new value.
#define BW_IPU_DP_GAMMA_C_ASYNC0_I_DP_GAMMA_C_ASYNC0_(v)   BF_CS1(IPU_DP_GAMMA_C_ASYNC0_I, DP_GAMMA_C_ASYNC0_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_GAMMA_S_ASYNC0_I - DP Gamma Correction Slope Async 0 Flow Register i (RW)
 *
 * This registers contains SLOPEi parameters used for Gamma Correction inside the display processor
 * (DP).
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_GAMMA_S_ASYNC0_ : 8; //!< SLOPE<4*i> parameter of Gamma Correction.
        unsigned DP_GAMMA_S_ASYNC0_1 : 8; //!< SLOPE<4*i+1> parameter of Gamma Correction.
        unsigned DP_GAMMA_S_ASYNC0_2 : 8; //!< SLOPE<4*i+2> parameter of Gamma Correction.
        unsigned DP_GAMMA_S_ASYNC0_3 : 8; //!< SLOPE<4*i+3> parameter of Gamma Correction.
    } B;
} hw_ipu_dp_gamma_s_async0_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_GAMMA_S_ASYNC0_I register
 */
#define HW_IPU_DP_GAMMA_S_ASYNC0_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040094)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_GAMMA_S_ASYNC0_I(x)           (*(volatile hw_ipu_dp_gamma_s_async0_i_t *) HW_IPU_DP_GAMMA_S_ASYNC0_I_ADDR(x))
#define HW_IPU_DP_GAMMA_S_ASYNC0_I_RD(x)        (HW_IPU_DP_GAMMA_S_ASYNC0_I(x).U)
#define HW_IPU_DP_GAMMA_S_ASYNC0_I_WR(x, v)     (HW_IPU_DP_GAMMA_S_ASYNC0_I(x).U = (v))
#define HW_IPU_DP_GAMMA_S_ASYNC0_I_SET(x, v)    (HW_IPU_DP_GAMMA_S_ASYNC0_I_WR(x, HW_IPU_DP_GAMMA_S_ASYNC0_I_RD(x) |  (v)))
#define HW_IPU_DP_GAMMA_S_ASYNC0_I_CLR(x, v)    (HW_IPU_DP_GAMMA_S_ASYNC0_I_WR(x, HW_IPU_DP_GAMMA_S_ASYNC0_I_RD(x) & ~(v)))
#define HW_IPU_DP_GAMMA_S_ASYNC0_I_TOG(x, v)    (HW_IPU_DP_GAMMA_S_ASYNC0_I_WR(x, HW_IPU_DP_GAMMA_S_ASYNC0_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_GAMMA_S_ASYNC0_I bitfields
 */

/* --- Register HW_IPU_DP_GAMMA_S_ASYNC0_I, field DP_GAMMA_S_ASYNC0_ (RW)
 *
 * SLOPE<4*i> parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_      0
#define BM_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_)
#else
#define BF_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_(v)   (((v) << 0) & BM_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_S_ASYNC0_ field to a new value.
#define BW_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_(v)   BF_CS1(IPU_DP_GAMMA_S_ASYNC0_I, DP_GAMMA_S_ASYNC0_, v)
#endif

/* --- Register HW_IPU_DP_GAMMA_S_ASYNC0_I, field DP_GAMMA_S_ASYNC0_ (RW)
 *
 * SLOPE<4*i+1> parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_      8
#define BM_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_(v)   ((((reg32_t) v) << 8) & BM_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_)
#else
#define BF_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_(v)   (((v) << 8) & BM_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_S_ASYNC0_ field to a new value.
#define BW_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_(v)   BF_CS1(IPU_DP_GAMMA_S_ASYNC0_I, DP_GAMMA_S_ASYNC0_, v)
#endif

/* --- Register HW_IPU_DP_GAMMA_S_ASYNC0_I, field DP_GAMMA_S_ASYNC0_ (RW)
 *
 * SLOPE<4*i+2> parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_      16
#define BM_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_)
#else
#define BF_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_(v)   (((v) << 16) & BM_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_S_ASYNC0_ field to a new value.
#define BW_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_(v)   BF_CS1(IPU_DP_GAMMA_S_ASYNC0_I, DP_GAMMA_S_ASYNC0_, v)
#endif

/* --- Register HW_IPU_DP_GAMMA_S_ASYNC0_I, field DP_GAMMA_S_ASYNC0_ (RW)
 *
 * SLOPE<4*i+3> parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_      24
#define BM_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_(v)   ((((reg32_t) v) << 24) & BM_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_)
#else
#define BF_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_(v)   (((v) << 24) & BM_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_S_ASYNC0_ field to a new value.
#define BW_IPU_DP_GAMMA_S_ASYNC0_I_DP_GAMMA_S_ASYNC0_(v)   BF_CS1(IPU_DP_GAMMA_S_ASYNC0_I, DP_GAMMA_S_ASYNC0_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CSCA_ASYNC0_I - DP Color Space Conversion Control Async 0 Flow Register i (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CSC_A_ASYNC0 : 10; //!< A<2*i> parameter of color conversion.
        unsigned RESERVED0 : 6; //!< Reserved.
        unsigned DP_CSC_A_ASYNC01 : 10; //!< A<2*i+1> parameter of color conversion
        unsigned RESERVED1 : 6; //!< Reserved.
    } B;
} hw_ipu_dp_csca_async0_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CSCA_ASYNC0_I register
 */
#define HW_IPU_DP_CSCA_ASYNC0_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x10400a4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CSCA_ASYNC0_I(x)           (*(volatile hw_ipu_dp_csca_async0_i_t *) HW_IPU_DP_CSCA_ASYNC0_I_ADDR(x))
#define HW_IPU_DP_CSCA_ASYNC0_I_RD(x)        (HW_IPU_DP_CSCA_ASYNC0_I(x).U)
#define HW_IPU_DP_CSCA_ASYNC0_I_WR(x, v)     (HW_IPU_DP_CSCA_ASYNC0_I(x).U = (v))
#define HW_IPU_DP_CSCA_ASYNC0_I_SET(x, v)    (HW_IPU_DP_CSCA_ASYNC0_I_WR(x, HW_IPU_DP_CSCA_ASYNC0_I_RD(x) |  (v)))
#define HW_IPU_DP_CSCA_ASYNC0_I_CLR(x, v)    (HW_IPU_DP_CSCA_ASYNC0_I_WR(x, HW_IPU_DP_CSCA_ASYNC0_I_RD(x) & ~(v)))
#define HW_IPU_DP_CSCA_ASYNC0_I_TOG(x, v)    (HW_IPU_DP_CSCA_ASYNC0_I_WR(x, HW_IPU_DP_CSCA_ASYNC0_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CSCA_ASYNC0_I bitfields
 */

/* --- Register HW_IPU_DP_CSCA_ASYNC0_I, field DP_CSC_A_ASYNC0 (RW)
 *
 * A<2*i> parameter of color conversion.
 */

#define BP_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0      0
#define BM_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0)
#else
#define BF_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0(v)   (((v) << 0) & BM_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_A_ASYNC0 field to a new value.
#define BW_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0(v)   BF_CS1(IPU_DP_CSCA_ASYNC0_I, DP_CSC_A_ASYNC0, v)
#endif

/* --- Register HW_IPU_DP_CSCA_ASYNC0_I, field DP_CSC_A_ASYNC0 (RW)
 *
 * A<2*i+1> parameter of color conversion
 */

#define BP_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0      16
#define BM_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0      0x03ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0)
#else
#define BF_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0(v)   (((v) << 16) & BM_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_A_ASYNC0 field to a new value.
#define BW_IPU_DP_CSCA_ASYNC0_I_DP_CSC_A_ASYNC0(v)   BF_CS1(IPU_DP_CSCA_ASYNC0_I, DP_CSC_A_ASYNC0, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CSC_ASYNC0_0 - DP Color Conversion Control Async 0 Flow Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CSC_A8_ASYNC0 : 10; //!< A9 parameter of color conversion.
        unsigned RESERVED0 : 6; //!< Reserved.
        unsigned DP_CSC_B0_ASYNC0 : 14; //!< B0 parameter of color conversion.
        unsigned DP_CSC_S0_ASYNC0 : 2; //!< S0 parameter of color conversion.
    } B;
} hw_ipu_dp_csc_async0_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CSC_ASYNC0_0 register
 */
#define HW_IPU_DP_CSC_ASYNC0_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x10400b4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CSC_ASYNC0_0(x)           (*(volatile hw_ipu_dp_csc_async0_0_t *) HW_IPU_DP_CSC_ASYNC0_0_ADDR(x))
#define HW_IPU_DP_CSC_ASYNC0_0_RD(x)        (HW_IPU_DP_CSC_ASYNC0_0(x).U)
#define HW_IPU_DP_CSC_ASYNC0_0_WR(x, v)     (HW_IPU_DP_CSC_ASYNC0_0(x).U = (v))
#define HW_IPU_DP_CSC_ASYNC0_0_SET(x, v)    (HW_IPU_DP_CSC_ASYNC0_0_WR(x, HW_IPU_DP_CSC_ASYNC0_0_RD(x) |  (v)))
#define HW_IPU_DP_CSC_ASYNC0_0_CLR(x, v)    (HW_IPU_DP_CSC_ASYNC0_0_WR(x, HW_IPU_DP_CSC_ASYNC0_0_RD(x) & ~(v)))
#define HW_IPU_DP_CSC_ASYNC0_0_TOG(x, v)    (HW_IPU_DP_CSC_ASYNC0_0_WR(x, HW_IPU_DP_CSC_ASYNC0_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CSC_ASYNC0_0 bitfields
 */

/* --- Register HW_IPU_DP_CSC_ASYNC0_0, field DP_CSC_A8_ASYNC0 (RW)
 *
 * A9 parameter of color conversion.
 */

#define BP_IPU_DP_CSC_ASYNC0_0_DP_CSC_A8_ASYNC0      0
#define BM_IPU_DP_CSC_ASYNC0_0_DP_CSC_A8_ASYNC0      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC0_0_DP_CSC_A8_ASYNC0(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CSC_ASYNC0_0_DP_CSC_A8_ASYNC0)
#else
#define BF_IPU_DP_CSC_ASYNC0_0_DP_CSC_A8_ASYNC0(v)   (((v) << 0) & BM_IPU_DP_CSC_ASYNC0_0_DP_CSC_A8_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_A8_ASYNC0 field to a new value.
#define BW_IPU_DP_CSC_ASYNC0_0_DP_CSC_A8_ASYNC0(v)   BF_CS1(IPU_DP_CSC_ASYNC0_0, DP_CSC_A8_ASYNC0, v)
#endif

/* --- Register HW_IPU_DP_CSC_ASYNC0_0, field DP_CSC_B0_ASYNC0 (RW)
 *
 * B0 parameter of color conversion.
 */

#define BP_IPU_DP_CSC_ASYNC0_0_DP_CSC_B0_ASYNC0      16
#define BM_IPU_DP_CSC_ASYNC0_0_DP_CSC_B0_ASYNC0      0x3fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC0_0_DP_CSC_B0_ASYNC0(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CSC_ASYNC0_0_DP_CSC_B0_ASYNC0)
#else
#define BF_IPU_DP_CSC_ASYNC0_0_DP_CSC_B0_ASYNC0(v)   (((v) << 16) & BM_IPU_DP_CSC_ASYNC0_0_DP_CSC_B0_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_B0_ASYNC0 field to a new value.
#define BW_IPU_DP_CSC_ASYNC0_0_DP_CSC_B0_ASYNC0(v)   BF_CS1(IPU_DP_CSC_ASYNC0_0, DP_CSC_B0_ASYNC0, v)
#endif

/* --- Register HW_IPU_DP_CSC_ASYNC0_0, field DP_CSC_S0_ASYNC0 (RW)
 *
 * S0 parameter of color conversion.
 *
 * Values:
 * 00 - scale factor of 2
 * 01 - scale factor of 1
 * 10 - scale factor of 0
 * 11 - scale factor of -1
 */

#define BP_IPU_DP_CSC_ASYNC0_0_DP_CSC_S0_ASYNC0      30
#define BM_IPU_DP_CSC_ASYNC0_0_DP_CSC_S0_ASYNC0      0xc0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC0_0_DP_CSC_S0_ASYNC0(v)   ((((reg32_t) v) << 30) & BM_IPU_DP_CSC_ASYNC0_0_DP_CSC_S0_ASYNC0)
#else
#define BF_IPU_DP_CSC_ASYNC0_0_DP_CSC_S0_ASYNC0(v)   (((v) << 30) & BM_IPU_DP_CSC_ASYNC0_0_DP_CSC_S0_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_S0_ASYNC0 field to a new value.
#define BW_IPU_DP_CSC_ASYNC0_0_DP_CSC_S0_ASYNC0(v)   BF_CS1(IPU_DP_CSC_ASYNC0_0, DP_CSC_S0_ASYNC0, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CSC_ASYNC_1 - DP Color Conversion Control Async 1 Flow Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CSC_B1_ASYNC0 : 14; //!< B0 parameter of color conversion.
        unsigned DP_CSC_S1_ASYNC0 : 2; //!< S0 parameter of color conversion.
        unsigned DP_CSC_B2_ASYNC0 : 14; //!< B0 parameter of color conversion.
        unsigned DP_CSC_S2_ASYNC0 : 2; //!< S0 parameter of color conversion.
    } B;
} hw_ipu_dp_csc_async_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CSC_ASYNC_1 register
 */
#define HW_IPU_DP_CSC_ASYNC_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x10400b8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CSC_ASYNC_1(x)           (*(volatile hw_ipu_dp_csc_async_1_t *) HW_IPU_DP_CSC_ASYNC_1_ADDR(x))
#define HW_IPU_DP_CSC_ASYNC_1_RD(x)        (HW_IPU_DP_CSC_ASYNC_1(x).U)
#define HW_IPU_DP_CSC_ASYNC_1_WR(x, v)     (HW_IPU_DP_CSC_ASYNC_1(x).U = (v))
#define HW_IPU_DP_CSC_ASYNC_1_SET(x, v)    (HW_IPU_DP_CSC_ASYNC_1_WR(x, HW_IPU_DP_CSC_ASYNC_1_RD(x) |  (v)))
#define HW_IPU_DP_CSC_ASYNC_1_CLR(x, v)    (HW_IPU_DP_CSC_ASYNC_1_WR(x, HW_IPU_DP_CSC_ASYNC_1_RD(x) & ~(v)))
#define HW_IPU_DP_CSC_ASYNC_1_TOG(x, v)    (HW_IPU_DP_CSC_ASYNC_1_WR(x, HW_IPU_DP_CSC_ASYNC_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CSC_ASYNC_1 bitfields
 */

/* --- Register HW_IPU_DP_CSC_ASYNC_1, field DP_CSC_B1_ASYNC0 (RW)
 *
 * B0 parameter of color conversion.
 */

#define BP_IPU_DP_CSC_ASYNC_1_DP_CSC_B1_ASYNC0      0
#define BM_IPU_DP_CSC_ASYNC_1_DP_CSC_B1_ASYNC0      0x00003fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC_1_DP_CSC_B1_ASYNC0(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CSC_ASYNC_1_DP_CSC_B1_ASYNC0)
#else
#define BF_IPU_DP_CSC_ASYNC_1_DP_CSC_B1_ASYNC0(v)   (((v) << 0) & BM_IPU_DP_CSC_ASYNC_1_DP_CSC_B1_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_B1_ASYNC0 field to a new value.
#define BW_IPU_DP_CSC_ASYNC_1_DP_CSC_B1_ASYNC0(v)   BF_CS1(IPU_DP_CSC_ASYNC_1, DP_CSC_B1_ASYNC0, v)
#endif

/* --- Register HW_IPU_DP_CSC_ASYNC_1, field DP_CSC_S1_ASYNC0 (RW)
 *
 * S0 parameter of color conversion.
 *
 * Values:
 * 00 - scale factor of 2
 * 01 - scale factor of 1
 * 10 - scale factor of 0 11 scale factor of -1
 */

#define BP_IPU_DP_CSC_ASYNC_1_DP_CSC_S1_ASYNC0      14
#define BM_IPU_DP_CSC_ASYNC_1_DP_CSC_S1_ASYNC0      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC_1_DP_CSC_S1_ASYNC0(v)   ((((reg32_t) v) << 14) & BM_IPU_DP_CSC_ASYNC_1_DP_CSC_S1_ASYNC0)
#else
#define BF_IPU_DP_CSC_ASYNC_1_DP_CSC_S1_ASYNC0(v)   (((v) << 14) & BM_IPU_DP_CSC_ASYNC_1_DP_CSC_S1_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_S1_ASYNC0 field to a new value.
#define BW_IPU_DP_CSC_ASYNC_1_DP_CSC_S1_ASYNC0(v)   BF_CS1(IPU_DP_CSC_ASYNC_1, DP_CSC_S1_ASYNC0, v)
#endif


/* --- Register HW_IPU_DP_CSC_ASYNC_1, field DP_CSC_B2_ASYNC0 (RW)
 *
 * B0 parameter of color conversion.
 */

#define BP_IPU_DP_CSC_ASYNC_1_DP_CSC_B2_ASYNC0      16
#define BM_IPU_DP_CSC_ASYNC_1_DP_CSC_B2_ASYNC0      0x3fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC_1_DP_CSC_B2_ASYNC0(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CSC_ASYNC_1_DP_CSC_B2_ASYNC0)
#else
#define BF_IPU_DP_CSC_ASYNC_1_DP_CSC_B2_ASYNC0(v)   (((v) << 16) & BM_IPU_DP_CSC_ASYNC_1_DP_CSC_B2_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_B2_ASYNC0 field to a new value.
#define BW_IPU_DP_CSC_ASYNC_1_DP_CSC_B2_ASYNC0(v)   BF_CS1(IPU_DP_CSC_ASYNC_1, DP_CSC_B2_ASYNC0, v)
#endif

/* --- Register HW_IPU_DP_CSC_ASYNC_1, field DP_CSC_S2_ASYNC0 (RW)
 *
 * S0 parameter of color conversion.
 *
 * Values:
 * 00 - scale factor of 2
 * 01 - scale factor of 1
 * 10 - scale factor of 0 11 scale factor of -1
 */

#define BP_IPU_DP_CSC_ASYNC_1_DP_CSC_S2_ASYNC0      30
#define BM_IPU_DP_CSC_ASYNC_1_DP_CSC_S2_ASYNC0      0xc0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC_1_DP_CSC_S2_ASYNC0(v)   ((((reg32_t) v) << 30) & BM_IPU_DP_CSC_ASYNC_1_DP_CSC_S2_ASYNC0)
#else
#define BF_IPU_DP_CSC_ASYNC_1_DP_CSC_S2_ASYNC0(v)   (((v) << 30) & BM_IPU_DP_CSC_ASYNC_1_DP_CSC_S2_ASYNC0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_S2_ASYNC0 field to a new value.
#define BW_IPU_DP_CSC_ASYNC_1_DP_CSC_S2_ASYNC0(v)   BF_CS1(IPU_DP_CSC_ASYNC_1, DP_CSC_S2_ASYNC0, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_COM_CONF_ASYNC1 - DP Common Configuration Async 1 Flow Register (RW)
 *
 * This register contains common configuration parameters for the DP.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 1; //!< Reserved
        unsigned DP_GWSEL_ASYNC1 : 1; //!< GWSEL - Graphic Window Select Select graphic window to be on partial plane or full plane.
        unsigned DP_GWAM_ASYNC1 : 1; //!< GWAM - Graphic Window Alpha Mode Select the use of Alpha to be global or local.
        unsigned DP_GWCKE_ASYNC1 : 1; //!< GWCKE - Graphic Window Color Keying Enable Enable or disable graphic window color keying.
        unsigned DP_COC_ASYNC1 : 3; //!< COC - Cursor Operation Control Controls the format of the cursor and the type of arithmetic operations
        unsigned RESERVED1 : 1; //!< Reserved
        unsigned DP_CSC_DEF_ASYNC1 : 2; //!< CSC_DEF Enable or disable Color Space Conversion.
        unsigned DP_CSC_GAMUT_SAT_EN_ASYNC1 : 1; //!< CSC_GAMUT_SAT_EN Indicate if GAMUT saturation is enabled
        unsigned DP_CSC_YUV_SAT_MODE_ASYNC1 : 1; //!< CSC_YUV_SAT_MODE YUV saturation mode for color space conversion
        unsigned DP_GAMMA_EN_ASYNC1 : 1; //!< GAMMA_EN - Gamma correction block enable bit
        unsigned DP_GAMMA_YUV_EN_ASYNC1 : 1; //!< GAMMA's YUV mode enable for async flow 1
        unsigned RESERVED2 : 18; //!< Reserved
    } B;
} hw_ipu_dp_com_conf_async1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_COM_CONF_ASYNC1 register
 */
#define HW_IPU_DP_COM_CONF_ASYNC1_ADDR(x)      (REGS_IPU_BASE(x) + 0x10400bc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_COM_CONF_ASYNC1(x)           (*(volatile hw_ipu_dp_com_conf_async1_t *) HW_IPU_DP_COM_CONF_ASYNC1_ADDR(x))
#define HW_IPU_DP_COM_CONF_ASYNC1_RD(x)        (HW_IPU_DP_COM_CONF_ASYNC1(x).U)
#define HW_IPU_DP_COM_CONF_ASYNC1_WR(x, v)     (HW_IPU_DP_COM_CONF_ASYNC1(x).U = (v))
#define HW_IPU_DP_COM_CONF_ASYNC1_SET(x, v)    (HW_IPU_DP_COM_CONF_ASYNC1_WR(x, HW_IPU_DP_COM_CONF_ASYNC1_RD(x) |  (v)))
#define HW_IPU_DP_COM_CONF_ASYNC1_CLR(x, v)    (HW_IPU_DP_COM_CONF_ASYNC1_WR(x, HW_IPU_DP_COM_CONF_ASYNC1_RD(x) & ~(v)))
#define HW_IPU_DP_COM_CONF_ASYNC1_TOG(x, v)    (HW_IPU_DP_COM_CONF_ASYNC1_WR(x, HW_IPU_DP_COM_CONF_ASYNC1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_COM_CONF_ASYNC1 bitfields
 */

/* --- Register HW_IPU_DP_COM_CONF_ASYNC1, field DP_GWSEL_ASYNC1 (RW)
 *
 * GWSEL - Graphic Window Select Select graphic window to be on partial plane or full plane.
 *
 * Values:
 * 1 - Graphic window is partial plane.
 * 0 - Graphic window is full plane.
 */

#define BP_IPU_DP_COM_CONF_ASYNC1_DP_GWSEL_ASYNC1      1
#define BM_IPU_DP_COM_CONF_ASYNC1_DP_GWSEL_ASYNC1      0x00000002

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_GWSEL_ASYNC1(v)   ((((reg32_t) v) << 1) & BM_IPU_DP_COM_CONF_ASYNC1_DP_GWSEL_ASYNC1)
#else
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_GWSEL_ASYNC1(v)   (((v) << 1) & BM_IPU_DP_COM_CONF_ASYNC1_DP_GWSEL_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWSEL_ASYNC1 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC1_DP_GWSEL_ASYNC1(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC1, DP_GWSEL_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC1, field DP_GWAM_ASYNC1 (RW)
 *
 * GWAM - Graphic Window Alpha Mode Select the use of Alpha to be global or local.
 *
 * Values:
 * 1 - Global Alpha.
 * 0 - Local Alpha.
 */

#define BP_IPU_DP_COM_CONF_ASYNC1_DP_GWAM_ASYNC1      2
#define BM_IPU_DP_COM_CONF_ASYNC1_DP_GWAM_ASYNC1      0x00000004

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_GWAM_ASYNC1(v)   ((((reg32_t) v) << 2) & BM_IPU_DP_COM_CONF_ASYNC1_DP_GWAM_ASYNC1)
#else
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_GWAM_ASYNC1(v)   (((v) << 2) & BM_IPU_DP_COM_CONF_ASYNC1_DP_GWAM_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWAM_ASYNC1 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC1_DP_GWAM_ASYNC1(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC1, DP_GWAM_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC1, field DP_GWCKE_ASYNC1 (RW)
 *
 * GWCKE - Graphic Window Color Keying Enable Enable or disable graphic window color keying.
 *
 * Values:
 * 1 - Enable color keying of graphic window
 * 0 - Disable color keying of graphic window
 */

#define BP_IPU_DP_COM_CONF_ASYNC1_DP_GWCKE_ASYNC1      3
#define BM_IPU_DP_COM_CONF_ASYNC1_DP_GWCKE_ASYNC1      0x00000008

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_GWCKE_ASYNC1(v)   ((((reg32_t) v) << 3) & BM_IPU_DP_COM_CONF_ASYNC1_DP_GWCKE_ASYNC1)
#else
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_GWCKE_ASYNC1(v)   (((v) << 3) & BM_IPU_DP_COM_CONF_ASYNC1_DP_GWCKE_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWCKE_ASYNC1 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC1_DP_GWCKE_ASYNC1(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC1, DP_GWCKE_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC1, field DP_COC_ASYNC1 (RW)
 *
 * COC - Cursor Operation Control Controls the format of the cursor and the type of arithmetic
 * operations
 *
 * Values:
 * 000 - Transparent, cursor is disabled.
 * 001 - Full cursor.
 * 010 - Reversed cursor.
 * 011 - AND between full plane and cursor.
 * 100 - Reserved
 * 101 - OR between full plane and cursor.
 * 110 - XOR between full plane and cursor.
 * 111 - Reserved
 */

#define BP_IPU_DP_COM_CONF_ASYNC1_DP_COC_ASYNC1      4
#define BM_IPU_DP_COM_CONF_ASYNC1_DP_COC_ASYNC1      0x00000070

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_COC_ASYNC1(v)   ((((reg32_t) v) << 4) & BM_IPU_DP_COM_CONF_ASYNC1_DP_COC_ASYNC1)
#else
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_COC_ASYNC1(v)   (((v) << 4) & BM_IPU_DP_COM_CONF_ASYNC1_DP_COC_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_COC_ASYNC1 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC1_DP_COC_ASYNC1(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC1, DP_COC_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC1, field DP_CSC_DEF_ASYNC1 (RW)
 *
 * CSC_DEF Enable or disable Color Space Conversion.
 *
 * Values:
 * 00 - CSC disable
 * 01 - CSC enable after combining
 * 10 - CSC enable before combining on BG channel
 * 11 - CSC enable before combining on FG channel
 */

#define BP_IPU_DP_COM_CONF_ASYNC1_DP_CSC_DEF_ASYNC1      8
#define BM_IPU_DP_COM_CONF_ASYNC1_DP_CSC_DEF_ASYNC1      0x00000300

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_CSC_DEF_ASYNC1(v)   ((((reg32_t) v) << 8) & BM_IPU_DP_COM_CONF_ASYNC1_DP_CSC_DEF_ASYNC1)
#else
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_CSC_DEF_ASYNC1(v)   (((v) << 8) & BM_IPU_DP_COM_CONF_ASYNC1_DP_CSC_DEF_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_DEF_ASYNC1 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC1_DP_CSC_DEF_ASYNC1(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC1, DP_CSC_DEF_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC1, field DP_CSC_GAMUT_SAT_EN_ASYNC1 (RW)
 *
 * CSC_GAMUT_SAT_EN Indicate if GAMUT saturation is enabled
 *
 * Values:
 * 0 - disable GAMUT mapping
 * 1 - enable GAMUT mapping
 */

#define BP_IPU_DP_COM_CONF_ASYNC1_DP_CSC_GAMUT_SAT_EN_ASYNC1      10
#define BM_IPU_DP_COM_CONF_ASYNC1_DP_CSC_GAMUT_SAT_EN_ASYNC1      0x00000400

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_CSC_GAMUT_SAT_EN_ASYNC1(v)   ((((reg32_t) v) << 10) & BM_IPU_DP_COM_CONF_ASYNC1_DP_CSC_GAMUT_SAT_EN_ASYNC1)
#else
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_CSC_GAMUT_SAT_EN_ASYNC1(v)   (((v) << 10) & BM_IPU_DP_COM_CONF_ASYNC1_DP_CSC_GAMUT_SAT_EN_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_GAMUT_SAT_EN_ASYNC1 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC1_DP_CSC_GAMUT_SAT_EN_ASYNC1(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC1, DP_CSC_GAMUT_SAT_EN_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC1, field DP_CSC_YUV_SAT_MODE_ASYNC1 (RW)
 *
 * CSC_YUV_SAT_MODE YUV saturation mode for color space conversion
 *
 * Values:
 * 0 - Y/U/V range 0 -255
 * 1 - Y range 16-235, U/V range 16-240
 */

#define BP_IPU_DP_COM_CONF_ASYNC1_DP_CSC_YUV_SAT_MODE_ASYNC1      11
#define BM_IPU_DP_COM_CONF_ASYNC1_DP_CSC_YUV_SAT_MODE_ASYNC1      0x00000800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_CSC_YUV_SAT_MODE_ASYNC1(v)   ((((reg32_t) v) << 11) & BM_IPU_DP_COM_CONF_ASYNC1_DP_CSC_YUV_SAT_MODE_ASYNC1)
#else
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_CSC_YUV_SAT_MODE_ASYNC1(v)   (((v) << 11) & BM_IPU_DP_COM_CONF_ASYNC1_DP_CSC_YUV_SAT_MODE_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_YUV_SAT_MODE_ASYNC1 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC1_DP_CSC_YUV_SAT_MODE_ASYNC1(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC1, DP_CSC_YUV_SAT_MODE_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC1, field DP_GAMMA_EN_ASYNC1 (RW)
 *
 * GAMMA_EN - Gamma correction block enable bit
 *
 * Values:
 * 0 - disable
 * 1 - enable
 */

#define BP_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_EN_ASYNC1      12
#define BM_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_EN_ASYNC1      0x00001000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_EN_ASYNC1(v)   ((((reg32_t) v) << 12) & BM_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_EN_ASYNC1)
#else
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_EN_ASYNC1(v)   (((v) << 12) & BM_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_EN_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_EN_ASYNC1 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_EN_ASYNC1(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC1, DP_GAMMA_EN_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_COM_CONF_ASYNC1, field DP_GAMMA_YUV_EN_ASYNC1 (RW)
 *
 * GAMMA's YUV mode enable for async flow 1
 *
 * Values:
 * 0 - YUV mode is OFF.
 * 1 - YUV mode is ON.
 */

#define BP_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_YUV_EN_ASYNC1      13
#define BM_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_YUV_EN_ASYNC1      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_YUV_EN_ASYNC1(v)   ((((reg32_t) v) << 13) & BM_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_YUV_EN_ASYNC1)
#else
#define BF_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_YUV_EN_ASYNC1(v)   (((v) << 13) & BM_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_YUV_EN_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_YUV_EN_ASYNC1 field to a new value.
#define BW_IPU_DP_COM_CONF_ASYNC1_DP_GAMMA_YUV_EN_ASYNC1(v)   BF_CS1(IPU_DP_COM_CONF_ASYNC1, DP_GAMMA_YUV_EN_ASYNC1, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1 - DP Graphic Window Control Async 1 Flow Register (RW)
 *
 * This register contains common configuration parameters for the DP.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_GWCKB_ASYNC1 : 8; //!< GWCKB - Graphic Window Color Keying Blue Component Defines the blue component of graphic window color keying.
        unsigned DP_GWCKG_ASYNC1 : 8; //!< GWCKG - Graphic Window Color Keying Green Component Defines the green component of graphic window color keying.
        unsigned DP_GWCKR_ASYNC1 : 8; //!< GWCKR - Graphic Window Color Keying Red Component Defines the red component of graphic window color keying.
        unsigned DP_GWAV_ASYNC1 : 8; //!< GWAV - Graphic Window Alpha Value Defines the alpha value of graphic window used for alpha blending between graphic window and full plane. The Value the number that writing to GWAV register. The Actual Value the number, that insert to calculation in Combining Module. If Value = < 0.5- 1/256 (01111111) then Actual Value = Value. If Value >= 0.5 (10000000), then Actual Value = Value + 1/256.
    } B;
} hw_ipu_dp_graph_wind_ctrl_async1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_GRAPH_WIND_CTRL_ASYNC1 register
 */
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_ADDR(x)      (REGS_IPU_BASE(x) + 0x10400c0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1(x)           (*(volatile hw_ipu_dp_graph_wind_ctrl_async1_t *) HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_ADDR(x))
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_RD(x)        (HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1(x).U)
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_WR(x, v)     (HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1(x).U = (v))
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_SET(x, v)    (HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_WR(x, HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_RD(x) |  (v)))
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_CLR(x, v)    (HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_WR(x, HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_RD(x) & ~(v)))
#define HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_TOG(x, v)    (HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_WR(x, HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_GRAPH_WIND_CTRL_ASYNC1 bitfields
 */

/* --- Register HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1, field DP_GWCKB_ASYNC1 (RW)
 *
 * GWCKB - Graphic Window Color Keying Blue Component Defines the blue component of graphic window
 * color keying.
 *
 * Values:
 * 00000000 - No blue
 * 11111111 - Full blue
 */

#define BP_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKB_ASYNC1      0
#define BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKB_ASYNC1      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKB_ASYNC1(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKB_ASYNC1)
#else
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKB_ASYNC1(v)   (((v) << 0) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKB_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWCKB_ASYNC1 field to a new value.
#define BW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKB_ASYNC1(v)   BF_CS1(IPU_DP_GRAPH_WIND_CTRL_ASYNC1, DP_GWCKB_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1, field DP_GWCKG_ASYNC1 (RW)
 *
 * GWCKG - Graphic Window Color Keying Green Component Defines the green component of graphic window
 * color keying.
 *
 * Values:
 * 00000000 - No Green
 * 11111111 - Full Green
 */

#define BP_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKG_ASYNC1      8
#define BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKG_ASYNC1      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKG_ASYNC1(v)   ((((reg32_t) v) << 8) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKG_ASYNC1)
#else
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKG_ASYNC1(v)   (((v) << 8) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKG_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWCKG_ASYNC1 field to a new value.
#define BW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKG_ASYNC1(v)   BF_CS1(IPU_DP_GRAPH_WIND_CTRL_ASYNC1, DP_GWCKG_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1, field DP_GWCKR_ASYNC1 (RW)
 *
 * GWCKR - Graphic Window Color Keying Red Component Defines the red component of graphic window
 * color keying.
 *
 * Values:
 * 00000000 - No red
 * 11111111 - Full red
 */

#define BP_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKR_ASYNC1      16
#define BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKR_ASYNC1      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKR_ASYNC1(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKR_ASYNC1)
#else
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKR_ASYNC1(v)   (((v) << 16) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKR_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWCKR_ASYNC1 field to a new value.
#define BW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWCKR_ASYNC1(v)   BF_CS1(IPU_DP_GRAPH_WIND_CTRL_ASYNC1, DP_GWCKR_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1, field DP_GWAV_ASYNC1 (RW)
 *
 * GWAV - Graphic Window Alpha Value Defines the alpha value of graphic window used for alpha
 * blending between graphic window and full plane. The Value the number that writing to GWAV
 * register. The Actual Value the number, that insert to calculation in Combining Module. If Value =
 * < 0.5- 1/256 (01111111) then Actual Value = Value. If Value >= 0.5 (10000000), then Actual Value
 * = Value + 1/256.
 *
 * Values:
 * 00000000 - Actual value is 00000000; Graphic window totally opaque i.e. overlay on LCD screen
 * 01111111 - Actual value is 01111111;
 * 10000000 - Actual value is 10000001
 * 10000001 - Actual value is 10000010
 * 11111110 - Actual value is 11111111
 * 11111111 - Actual value is 100000000;Graphic window totally transparent i.e. not displayed on LCD screen
 */

#define BP_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWAV_ASYNC1      24
#define BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWAV_ASYNC1      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWAV_ASYNC1(v)   ((((reg32_t) v) << 24) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWAV_ASYNC1)
#else
#define BF_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWAV_ASYNC1(v)   (((v) << 24) & BM_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWAV_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GWAV_ASYNC1 field to a new value.
#define BW_IPU_DP_GRAPH_WIND_CTRL_ASYNC1_DP_GWAV_ASYNC1(v)   BF_CS1(IPU_DP_GRAPH_WIND_CTRL_ASYNC1, DP_GWAV_ASYNC1, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_FG_POS_ASYNC1 - DP Partial Plane Window Position Async 1 Flow Register (RW)
 *
 * The DP partial plane Window Position Register is used to determine the starting position of the
 * partial plane window relative to BG window position.  This Register is used for the synchronous
 * flow only.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_FGYP_ASYNC1 : 11; //!< FGYP partial plane window Y position partial plane Window Y Position - Specifies the number of lines between the start of full plane windows Y position and the beginning of the first data.
        unsigned RESERVED0 : 5; //!< Reserved
        unsigned DP_FGXP_ASYNC1 : 11; //!< FGXP partial plane Window X Position. partial plane Window X Position - Specifies the number of pixels between the start of full plane window X position and the beginning of the first data of new line.
        unsigned RESERVED1 : 5; //!< Reserved
    } B;
} hw_ipu_dp_fg_pos_async1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_FG_POS_ASYNC1 register
 */
#define HW_IPU_DP_FG_POS_ASYNC1_ADDR(x)      (REGS_IPU_BASE(x) + 0x10400c4)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_FG_POS_ASYNC1(x)           (*(volatile hw_ipu_dp_fg_pos_async1_t *) HW_IPU_DP_FG_POS_ASYNC1_ADDR(x))
#define HW_IPU_DP_FG_POS_ASYNC1_RD(x)        (HW_IPU_DP_FG_POS_ASYNC1(x).U)
#define HW_IPU_DP_FG_POS_ASYNC1_WR(x, v)     (HW_IPU_DP_FG_POS_ASYNC1(x).U = (v))
#define HW_IPU_DP_FG_POS_ASYNC1_SET(x, v)    (HW_IPU_DP_FG_POS_ASYNC1_WR(x, HW_IPU_DP_FG_POS_ASYNC1_RD(x) |  (v)))
#define HW_IPU_DP_FG_POS_ASYNC1_CLR(x, v)    (HW_IPU_DP_FG_POS_ASYNC1_WR(x, HW_IPU_DP_FG_POS_ASYNC1_RD(x) & ~(v)))
#define HW_IPU_DP_FG_POS_ASYNC1_TOG(x, v)    (HW_IPU_DP_FG_POS_ASYNC1_WR(x, HW_IPU_DP_FG_POS_ASYNC1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_FG_POS_ASYNC1 bitfields
 */

/* --- Register HW_IPU_DP_FG_POS_ASYNC1, field DP_FGYP_ASYNC1 (RW)
 *
 * FGYP partial plane window Y position partial plane Window Y Position - Specifies the number of
 * lines between the start of full plane windows Y position and the beginning of the first data.
 */

#define BP_IPU_DP_FG_POS_ASYNC1_DP_FGYP_ASYNC1      0
#define BM_IPU_DP_FG_POS_ASYNC1_DP_FGYP_ASYNC1      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_FG_POS_ASYNC1_DP_FGYP_ASYNC1(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_FG_POS_ASYNC1_DP_FGYP_ASYNC1)
#else
#define BF_IPU_DP_FG_POS_ASYNC1_DP_FGYP_ASYNC1(v)   (((v) << 0) & BM_IPU_DP_FG_POS_ASYNC1_DP_FGYP_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_FGYP_ASYNC1 field to a new value.
#define BW_IPU_DP_FG_POS_ASYNC1_DP_FGYP_ASYNC1(v)   BF_CS1(IPU_DP_FG_POS_ASYNC1, DP_FGYP_ASYNC1, v)
#endif

/* --- Register HW_IPU_DP_FG_POS_ASYNC1, field DP_FGXP_ASYNC1 (RW)
 *
 * FGXP partial plane Window X Position. partial plane Window X Position - Specifies the number of
 * pixels between the start of full plane window X position and the beginning of the first data of
 * new line.
 */

#define BP_IPU_DP_FG_POS_ASYNC1_DP_FGXP_ASYNC1      16
#define BM_IPU_DP_FG_POS_ASYNC1_DP_FGXP_ASYNC1      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_FG_POS_ASYNC1_DP_FGXP_ASYNC1(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_FG_POS_ASYNC1_DP_FGXP_ASYNC1)
#else
#define BF_IPU_DP_FG_POS_ASYNC1_DP_FGXP_ASYNC1(v)   (((v) << 16) & BM_IPU_DP_FG_POS_ASYNC1_DP_FGXP_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_FGXP_ASYNC1 field to a new value.
#define BW_IPU_DP_FG_POS_ASYNC1_DP_FGXP_ASYNC1(v)   BF_CS1(IPU_DP_FG_POS_ASYNC1, DP_FGXP_ASYNC1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CUR_POS_ASYNC1 - DP Cursor Postion and Size Async 1 Flow Register (RW)
 *
 * The LCD Cursor Position Register is used to determine the starting position of the cursor
 * relative to BG windows position.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CXW_ASYNC1 : 11; //!< CXW - Cursor Width. Specifies the width of the hardware cursor in pixels.
        unsigned DP_CXP_ASYNC1 : 5; //!< CXP - Cursor X Position Represents the cursors horizontal starting position X in pixel count (from 0 to CXW).
        unsigned DP_CYH_ASYNC1 : 11; //!< CYH - Cursor Height Specifies the height of the hardware cursor in pixels.
        unsigned DP_CYP_ASYNC1 : 5; //!< CYP - Cursor Y Position Represents the cursors vertical starting position Y in pixel count (from 0 to CYH).Live View Resolution Mode.
    } B;
} hw_ipu_dp_cur_pos_async1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CUR_POS_ASYNC1 register
 */
#define HW_IPU_DP_CUR_POS_ASYNC1_ADDR(x)      (REGS_IPU_BASE(x) + 0x10400c8)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CUR_POS_ASYNC1(x)           (*(volatile hw_ipu_dp_cur_pos_async1_t *) HW_IPU_DP_CUR_POS_ASYNC1_ADDR(x))
#define HW_IPU_DP_CUR_POS_ASYNC1_RD(x)        (HW_IPU_DP_CUR_POS_ASYNC1(x).U)
#define HW_IPU_DP_CUR_POS_ASYNC1_WR(x, v)     (HW_IPU_DP_CUR_POS_ASYNC1(x).U = (v))
#define HW_IPU_DP_CUR_POS_ASYNC1_SET(x, v)    (HW_IPU_DP_CUR_POS_ASYNC1_WR(x, HW_IPU_DP_CUR_POS_ASYNC1_RD(x) |  (v)))
#define HW_IPU_DP_CUR_POS_ASYNC1_CLR(x, v)    (HW_IPU_DP_CUR_POS_ASYNC1_WR(x, HW_IPU_DP_CUR_POS_ASYNC1_RD(x) & ~(v)))
#define HW_IPU_DP_CUR_POS_ASYNC1_TOG(x, v)    (HW_IPU_DP_CUR_POS_ASYNC1_WR(x, HW_IPU_DP_CUR_POS_ASYNC1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CUR_POS_ASYNC1 bitfields
 */

/* --- Register HW_IPU_DP_CUR_POS_ASYNC1, field DP_CXW_ASYNC1 (RW)
 *
 * CXW - Cursor Width. Specifies the width of the hardware cursor in pixels.
 */

#define BP_IPU_DP_CUR_POS_ASYNC1_DP_CXW_ASYNC1      0
#define BM_IPU_DP_CUR_POS_ASYNC1_DP_CXW_ASYNC1      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_ASYNC1_DP_CXW_ASYNC1(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CUR_POS_ASYNC1_DP_CXW_ASYNC1)
#else
#define BF_IPU_DP_CUR_POS_ASYNC1_DP_CXW_ASYNC1(v)   (((v) << 0) & BM_IPU_DP_CUR_POS_ASYNC1_DP_CXW_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CXW_ASYNC1 field to a new value.
#define BW_IPU_DP_CUR_POS_ASYNC1_DP_CXW_ASYNC1(v)   BF_CS1(IPU_DP_CUR_POS_ASYNC1, DP_CXW_ASYNC1, v)
#endif

/* --- Register HW_IPU_DP_CUR_POS_ASYNC1, field DP_CXP_ASYNC1 (RW)
 *
 * CXP - Cursor X Position Represents the cursors horizontal starting position X in pixel count
 * (from 0 to CXW).
 */

#define BP_IPU_DP_CUR_POS_ASYNC1_DP_CXP_ASYNC1      11
#define BM_IPU_DP_CUR_POS_ASYNC1_DP_CXP_ASYNC1      0x0000f800

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_ASYNC1_DP_CXP_ASYNC1(v)   ((((reg32_t) v) << 11) & BM_IPU_DP_CUR_POS_ASYNC1_DP_CXP_ASYNC1)
#else
#define BF_IPU_DP_CUR_POS_ASYNC1_DP_CXP_ASYNC1(v)   (((v) << 11) & BM_IPU_DP_CUR_POS_ASYNC1_DP_CXP_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CXP_ASYNC1 field to a new value.
#define BW_IPU_DP_CUR_POS_ASYNC1_DP_CXP_ASYNC1(v)   BF_CS1(IPU_DP_CUR_POS_ASYNC1, DP_CXP_ASYNC1, v)
#endif

/* --- Register HW_IPU_DP_CUR_POS_ASYNC1, field DP_CYH_ASYNC1 (RW)
 *
 * CYH - Cursor Height Specifies the height of the hardware cursor in pixels.
 */

#define BP_IPU_DP_CUR_POS_ASYNC1_DP_CYH_ASYNC1      16
#define BM_IPU_DP_CUR_POS_ASYNC1_DP_CYH_ASYNC1      0x07ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_ASYNC1_DP_CYH_ASYNC1(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CUR_POS_ASYNC1_DP_CYH_ASYNC1)
#else
#define BF_IPU_DP_CUR_POS_ASYNC1_DP_CYH_ASYNC1(v)   (((v) << 16) & BM_IPU_DP_CUR_POS_ASYNC1_DP_CYH_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CYH_ASYNC1 field to a new value.
#define BW_IPU_DP_CUR_POS_ASYNC1_DP_CYH_ASYNC1(v)   BF_CS1(IPU_DP_CUR_POS_ASYNC1, DP_CYH_ASYNC1, v)
#endif

/* --- Register HW_IPU_DP_CUR_POS_ASYNC1, field DP_CYP_ASYNC1 (RW)
 *
 * CYP - Cursor Y Position Represents the cursors vertical starting position Y in pixel count (from
 * 0 to CYH).Live View Resolution Mode.
 */

#define BP_IPU_DP_CUR_POS_ASYNC1_DP_CYP_ASYNC1      27
#define BM_IPU_DP_CUR_POS_ASYNC1_DP_CYP_ASYNC1      0xf8000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_POS_ASYNC1_DP_CYP_ASYNC1(v)   ((((reg32_t) v) << 27) & BM_IPU_DP_CUR_POS_ASYNC1_DP_CYP_ASYNC1)
#else
#define BF_IPU_DP_CUR_POS_ASYNC1_DP_CYP_ASYNC1(v)   (((v) << 27) & BM_IPU_DP_CUR_POS_ASYNC1_DP_CYP_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CYP_ASYNC1 field to a new value.
#define BW_IPU_DP_CUR_POS_ASYNC1_DP_CYP_ASYNC1(v)   BF_CS1(IPU_DP_CUR_POS_ASYNC1, DP_CYP_ASYNC1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CUR_MAP_ASYNC1 - DP Color Cursor Mapping Async 1 Flow Register (RW)
 *
 * The LCD Color Cursor Mapping Register defines the color of the cursor in passive or TFT color
 * modes.
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CUR_COL_R_ASYNC1 : 8; //!< CUR_COL_R - Cursor Red Field Defines the Red component of the cursor color in color mode
        unsigned DP_CUR_COL_G_ASYNC1 : 8; //!< CUR_COL_G - Cursor Green Field Defines the Green component of the cursor color in color mode
        unsigned DP_CUR_COL_B_ASYNC1 : 8; //!< CUR_COL_B - Cursor Blue Field Defines the Blue component of the cursor color in color mode
        unsigned RESERVED0 : 8; //!< Reserved
    } B;
} hw_ipu_dp_cur_map_async1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CUR_MAP_ASYNC1 register
 */
#define HW_IPU_DP_CUR_MAP_ASYNC1_ADDR(x)      (REGS_IPU_BASE(x) + 0x10400cc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CUR_MAP_ASYNC1(x)           (*(volatile hw_ipu_dp_cur_map_async1_t *) HW_IPU_DP_CUR_MAP_ASYNC1_ADDR(x))
#define HW_IPU_DP_CUR_MAP_ASYNC1_RD(x)        (HW_IPU_DP_CUR_MAP_ASYNC1(x).U)
#define HW_IPU_DP_CUR_MAP_ASYNC1_WR(x, v)     (HW_IPU_DP_CUR_MAP_ASYNC1(x).U = (v))
#define HW_IPU_DP_CUR_MAP_ASYNC1_SET(x, v)    (HW_IPU_DP_CUR_MAP_ASYNC1_WR(x, HW_IPU_DP_CUR_MAP_ASYNC1_RD(x) |  (v)))
#define HW_IPU_DP_CUR_MAP_ASYNC1_CLR(x, v)    (HW_IPU_DP_CUR_MAP_ASYNC1_WR(x, HW_IPU_DP_CUR_MAP_ASYNC1_RD(x) & ~(v)))
#define HW_IPU_DP_CUR_MAP_ASYNC1_TOG(x, v)    (HW_IPU_DP_CUR_MAP_ASYNC1_WR(x, HW_IPU_DP_CUR_MAP_ASYNC1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CUR_MAP_ASYNC1 bitfields
 */

/* --- Register HW_IPU_DP_CUR_MAP_ASYNC1, field DP_CUR_COL_R_ASYNC1 (RW)
 *
 * CUR_COL_R - Cursor Red Field Defines the Red component of the cursor color in color mode
 *
 * Values:
 * 00000000 - No Red.
 * 11111111 - Full Red.
 */

#define BP_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_R_ASYNC1      0
#define BM_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_R_ASYNC1      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_R_ASYNC1(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_R_ASYNC1)
#else
#define BF_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_R_ASYNC1(v)   (((v) << 0) & BM_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_R_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CUR_COL_R_ASYNC1 field to a new value.
#define BW_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_R_ASYNC1(v)   BF_CS1(IPU_DP_CUR_MAP_ASYNC1, DP_CUR_COL_R_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_CUR_MAP_ASYNC1, field DP_CUR_COL_G_ASYNC1 (RW)
 *
 * CUR_COL_G - Cursor Green Field Defines the Green component of the cursor color in color mode
 *
 * Values:
 * 00000000 - No Green.
 * 11111111 - Full Green.
 */

#define BP_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_G_ASYNC1      8
#define BM_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_G_ASYNC1      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_G_ASYNC1(v)   ((((reg32_t) v) << 8) & BM_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_G_ASYNC1)
#else
#define BF_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_G_ASYNC1(v)   (((v) << 8) & BM_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_G_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CUR_COL_G_ASYNC1 field to a new value.
#define BW_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_G_ASYNC1(v)   BF_CS1(IPU_DP_CUR_MAP_ASYNC1, DP_CUR_COL_G_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_CUR_MAP_ASYNC1, field DP_CUR_COL_B_ASYNC1 (RW)
 *
 * CUR_COL_B - Cursor Blue Field Defines the Blue component of the cursor color in color mode
 *
 * Values:
 * 00000000 - No Blue.
 * 11111111 - Full Blue.
 */

#define BP_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_B_ASYNC1      16
#define BM_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_B_ASYNC1      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_B_ASYNC1(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_B_ASYNC1)
#else
#define BF_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_B_ASYNC1(v)   (((v) << 16) & BM_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_B_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CUR_COL_B_ASYNC1 field to a new value.
#define BW_IPU_DP_CUR_MAP_ASYNC1_DP_CUR_COL_B_ASYNC1(v)   BF_CS1(IPU_DP_CUR_MAP_ASYNC1, DP_CUR_COL_B_ASYNC1, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_GAMMA_C_ASYNC1_I - DP Gamma Constants Async 1 Flow Register i (RW)
 *
 * This registers contains CONSTANTi parameters used for gamma correction inside the display
 * processor (DP).
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_GAMMA_C_ASYNC1_ : 9; //!< CONSTANTi parameter of Gamma Correction.
        unsigned RESERVED0 : 7; //!< Reserved.
        unsigned DP_GAMMA_C_ASYNC1_1 : 9; //!< CONSTANTi+1 parameter of Gamma Correction.
        unsigned RESERVED1 : 7; //!< Reserved.
    } B;
} hw_ipu_dp_gamma_c_async1_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_GAMMA_C_ASYNC1_I register
 */
#define HW_IPU_DP_GAMMA_C_ASYNC1_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x10400d0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_GAMMA_C_ASYNC1_I(x)           (*(volatile hw_ipu_dp_gamma_c_async1_i_t *) HW_IPU_DP_GAMMA_C_ASYNC1_I_ADDR(x))
#define HW_IPU_DP_GAMMA_C_ASYNC1_I_RD(x)        (HW_IPU_DP_GAMMA_C_ASYNC1_I(x).U)
#define HW_IPU_DP_GAMMA_C_ASYNC1_I_WR(x, v)     (HW_IPU_DP_GAMMA_C_ASYNC1_I(x).U = (v))
#define HW_IPU_DP_GAMMA_C_ASYNC1_I_SET(x, v)    (HW_IPU_DP_GAMMA_C_ASYNC1_I_WR(x, HW_IPU_DP_GAMMA_C_ASYNC1_I_RD(x) |  (v)))
#define HW_IPU_DP_GAMMA_C_ASYNC1_I_CLR(x, v)    (HW_IPU_DP_GAMMA_C_ASYNC1_I_WR(x, HW_IPU_DP_GAMMA_C_ASYNC1_I_RD(x) & ~(v)))
#define HW_IPU_DP_GAMMA_C_ASYNC1_I_TOG(x, v)    (HW_IPU_DP_GAMMA_C_ASYNC1_I_WR(x, HW_IPU_DP_GAMMA_C_ASYNC1_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_GAMMA_C_ASYNC1_I bitfields
 */

/* --- Register HW_IPU_DP_GAMMA_C_ASYNC1_I, field DP_GAMMA_C_ASYNC1_ (RW)
 *
 * CONSTANTi parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_      0
#define BM_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_      0x000001ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_)
#else
#define BF_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_(v)   (((v) << 0) & BM_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_C_ASYNC1_ field to a new value.
#define BW_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_(v)   BF_CS1(IPU_DP_GAMMA_C_ASYNC1_I, DP_GAMMA_C_ASYNC1_, v)
#endif

/* --- Register HW_IPU_DP_GAMMA_C_ASYNC1_I, field DP_GAMMA_C_ASYNC1_ (RW)
 *
 * CONSTANTi+1 parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_      16
#define BM_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_      0x01ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_)
#else
#define BF_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_(v)   (((v) << 16) & BM_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_C_ASYNC1_ field to a new value.
#define BW_IPU_DP_GAMMA_C_ASYNC1_I_DP_GAMMA_C_ASYNC1_(v)   BF_CS1(IPU_DP_GAMMA_C_ASYNC1_I, DP_GAMMA_C_ASYNC1_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_GAMMA_S_ASYN1_I - DP Gamma Correction Slope Async 1 Flow Register i (RW)
 *
 * This registers contains SLOPEi parameters used for Gamma Correction inside the display processor
 * (DP).
 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_GAMMA_S_ASYNC1_ : 8; //!< SLOPE<4*i> parameter of Gamma Correction.
        unsigned DP_GAMMA_S_ASYNC1_1 : 8; //!< SLOPE<4*i+1> parameter of Gamma Correction.
        unsigned DP_GAMMA_S_ASYNC1_2 : 8; //!< SLOPE<4*i+2> parameter of Gamma Correction.
        unsigned DP_GAMMA_S_ASYNC1_3 : 8; //!< SLOPE<4*i+3> parameter of Gamma Correction.
    } B;
} hw_ipu_dp_gamma_s_asyn1_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_GAMMA_S_ASYN1_I register
 */
#define HW_IPU_DP_GAMMA_S_ASYN1_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x10400f0)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_GAMMA_S_ASYN1_I(x)           (*(volatile hw_ipu_dp_gamma_s_asyn1_i_t *) HW_IPU_DP_GAMMA_S_ASYN1_I_ADDR(x))
#define HW_IPU_DP_GAMMA_S_ASYN1_I_RD(x)        (HW_IPU_DP_GAMMA_S_ASYN1_I(x).U)
#define HW_IPU_DP_GAMMA_S_ASYN1_I_WR(x, v)     (HW_IPU_DP_GAMMA_S_ASYN1_I(x).U = (v))
#define HW_IPU_DP_GAMMA_S_ASYN1_I_SET(x, v)    (HW_IPU_DP_GAMMA_S_ASYN1_I_WR(x, HW_IPU_DP_GAMMA_S_ASYN1_I_RD(x) |  (v)))
#define HW_IPU_DP_GAMMA_S_ASYN1_I_CLR(x, v)    (HW_IPU_DP_GAMMA_S_ASYN1_I_WR(x, HW_IPU_DP_GAMMA_S_ASYN1_I_RD(x) & ~(v)))
#define HW_IPU_DP_GAMMA_S_ASYN1_I_TOG(x, v)    (HW_IPU_DP_GAMMA_S_ASYN1_I_WR(x, HW_IPU_DP_GAMMA_S_ASYN1_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_GAMMA_S_ASYN1_I bitfields
 */

/* --- Register HW_IPU_DP_GAMMA_S_ASYN1_I, field DP_GAMMA_S_ASYNC1_ (RW)
 *
 * SLOPE<4*i> parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_      0
#define BM_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_      0x000000ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_)
#else
#define BF_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_(v)   (((v) << 0) & BM_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_S_ASYNC1_ field to a new value.
#define BW_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_(v)   BF_CS1(IPU_DP_GAMMA_S_ASYN1_I, DP_GAMMA_S_ASYNC1_, v)
#endif

/* --- Register HW_IPU_DP_GAMMA_S_ASYN1_I, field DP_GAMMA_S_ASYNC1_ (RW)
 *
 * SLOPE<4*i+1> parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_      8
#define BM_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_      0x0000ff00

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_(v)   ((((reg32_t) v) << 8) & BM_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_)
#else
#define BF_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_(v)   (((v) << 8) & BM_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_S_ASYNC1_ field to a new value.
#define BW_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_(v)   BF_CS1(IPU_DP_GAMMA_S_ASYN1_I, DP_GAMMA_S_ASYNC1_, v)
#endif

/* --- Register HW_IPU_DP_GAMMA_S_ASYN1_I, field DP_GAMMA_S_ASYNC1_ (RW)
 *
 * SLOPE<4*i+2> parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_      16
#define BM_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_      0x00ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_)
#else
#define BF_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_(v)   (((v) << 16) & BM_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_S_ASYNC1_ field to a new value.
#define BW_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_(v)   BF_CS1(IPU_DP_GAMMA_S_ASYN1_I, DP_GAMMA_S_ASYNC1_, v)
#endif

/* --- Register HW_IPU_DP_GAMMA_S_ASYN1_I, field DP_GAMMA_S_ASYNC1_ (RW)
 *
 * SLOPE<4*i+3> parameter of Gamma Correction.
 */

#define BP_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_      24
#define BM_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_      0xff000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_(v)   ((((reg32_t) v) << 24) & BM_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_)
#else
#define BF_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_(v)   (((v) << 24) & BM_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_GAMMA_S_ASYNC1_ field to a new value.
#define BW_IPU_DP_GAMMA_S_ASYN1_I_DP_GAMMA_S_ASYNC1_(v)   BF_CS1(IPU_DP_GAMMA_S_ASYN1_I, DP_GAMMA_S_ASYNC1_, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CSCA_ASYNC1_I - DP Color Space Converstion Control Async 1 Flow Register i (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CSC_A_ASYNC1 : 10; //!< A<2*i> parameter of color conversion.
        unsigned RESERVED0 : 6; //!< Reserved.
        unsigned DP_CSC_A_ASYNC11 : 10; //!< A<2*i+1> parameter of color conversion.
        unsigned RESERVED1 : 6; //!< Reserved.
    } B;
} hw_ipu_dp_csca_async1_i_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CSCA_ASYNC1_I register
 */
#define HW_IPU_DP_CSCA_ASYNC1_I_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040100)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CSCA_ASYNC1_I(x)           (*(volatile hw_ipu_dp_csca_async1_i_t *) HW_IPU_DP_CSCA_ASYNC1_I_ADDR(x))
#define HW_IPU_DP_CSCA_ASYNC1_I_RD(x)        (HW_IPU_DP_CSCA_ASYNC1_I(x).U)
#define HW_IPU_DP_CSCA_ASYNC1_I_WR(x, v)     (HW_IPU_DP_CSCA_ASYNC1_I(x).U = (v))
#define HW_IPU_DP_CSCA_ASYNC1_I_SET(x, v)    (HW_IPU_DP_CSCA_ASYNC1_I_WR(x, HW_IPU_DP_CSCA_ASYNC1_I_RD(x) |  (v)))
#define HW_IPU_DP_CSCA_ASYNC1_I_CLR(x, v)    (HW_IPU_DP_CSCA_ASYNC1_I_WR(x, HW_IPU_DP_CSCA_ASYNC1_I_RD(x) & ~(v)))
#define HW_IPU_DP_CSCA_ASYNC1_I_TOG(x, v)    (HW_IPU_DP_CSCA_ASYNC1_I_WR(x, HW_IPU_DP_CSCA_ASYNC1_I_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CSCA_ASYNC1_I bitfields
 */

/* --- Register HW_IPU_DP_CSCA_ASYNC1_I, field DP_CSC_A_ASYNC1 (RW)
 *
 * A<2*i> parameter of color conversion.
 */

#define BP_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1      0
#define BM_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1)
#else
#define BF_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1(v)   (((v) << 0) & BM_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_A_ASYNC1 field to a new value.
#define BW_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1(v)   BF_CS1(IPU_DP_CSCA_ASYNC1_I, DP_CSC_A_ASYNC1, v)
#endif

/* --- Register HW_IPU_DP_CSCA_ASYNC1_I, field DP_CSC_A_ASYNC1 (RW)
 *
 * A<2*i+1> parameter of color conversion.
 */

#define BP_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1      16
#define BM_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1      0x03ff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1)
#else
#define BF_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1(v)   (((v) << 16) & BM_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_A_ASYNC1 field to a new value.
#define BW_IPU_DP_CSCA_ASYNC1_I_DP_CSC_A_ASYNC1(v)   BF_CS1(IPU_DP_CSCA_ASYNC1_I, DP_CSC_A_ASYNC1, v)
#endif

#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CSC_ASYNC1_0 - DP Color Conversion Control Async 1 Flow Register 0 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CSC_A8_ASYNC1 : 10; //!< A9 parameter of color conversion.
        unsigned RESERVED0 : 6; //!< Reserved.
        unsigned DP_CSC_B0_ASYNC1 : 14; //!< B0 parameter of color conversion.
        unsigned DP_CSC_S0_ASYNC1 : 2; //!< S0 parameter of color conversion.
    } B;
} hw_ipu_dp_csc_async1_0_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CSC_ASYNC1_0 register
 */
#define HW_IPU_DP_CSC_ASYNC1_0_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040110)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CSC_ASYNC1_0(x)           (*(volatile hw_ipu_dp_csc_async1_0_t *) HW_IPU_DP_CSC_ASYNC1_0_ADDR(x))
#define HW_IPU_DP_CSC_ASYNC1_0_RD(x)        (HW_IPU_DP_CSC_ASYNC1_0(x).U)
#define HW_IPU_DP_CSC_ASYNC1_0_WR(x, v)     (HW_IPU_DP_CSC_ASYNC1_0(x).U = (v))
#define HW_IPU_DP_CSC_ASYNC1_0_SET(x, v)    (HW_IPU_DP_CSC_ASYNC1_0_WR(x, HW_IPU_DP_CSC_ASYNC1_0_RD(x) |  (v)))
#define HW_IPU_DP_CSC_ASYNC1_0_CLR(x, v)    (HW_IPU_DP_CSC_ASYNC1_0_WR(x, HW_IPU_DP_CSC_ASYNC1_0_RD(x) & ~(v)))
#define HW_IPU_DP_CSC_ASYNC1_0_TOG(x, v)    (HW_IPU_DP_CSC_ASYNC1_0_WR(x, HW_IPU_DP_CSC_ASYNC1_0_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CSC_ASYNC1_0 bitfields
 */

/* --- Register HW_IPU_DP_CSC_ASYNC1_0, field DP_CSC_A8_ASYNC1 (RW)
 *
 * A9 parameter of color conversion.
 */

#define BP_IPU_DP_CSC_ASYNC1_0_DP_CSC_A8_ASYNC1      0
#define BM_IPU_DP_CSC_ASYNC1_0_DP_CSC_A8_ASYNC1      0x000003ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC1_0_DP_CSC_A8_ASYNC1(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CSC_ASYNC1_0_DP_CSC_A8_ASYNC1)
#else
#define BF_IPU_DP_CSC_ASYNC1_0_DP_CSC_A8_ASYNC1(v)   (((v) << 0) & BM_IPU_DP_CSC_ASYNC1_0_DP_CSC_A8_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_A8_ASYNC1 field to a new value.
#define BW_IPU_DP_CSC_ASYNC1_0_DP_CSC_A8_ASYNC1(v)   BF_CS1(IPU_DP_CSC_ASYNC1_0, DP_CSC_A8_ASYNC1, v)
#endif

/* --- Register HW_IPU_DP_CSC_ASYNC1_0, field DP_CSC_B0_ASYNC1 (RW)
 *
 * B0 parameter of color conversion.
 */

#define BP_IPU_DP_CSC_ASYNC1_0_DP_CSC_B0_ASYNC1      16
#define BM_IPU_DP_CSC_ASYNC1_0_DP_CSC_B0_ASYNC1      0x3fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC1_0_DP_CSC_B0_ASYNC1(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CSC_ASYNC1_0_DP_CSC_B0_ASYNC1)
#else
#define BF_IPU_DP_CSC_ASYNC1_0_DP_CSC_B0_ASYNC1(v)   (((v) << 16) & BM_IPU_DP_CSC_ASYNC1_0_DP_CSC_B0_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_B0_ASYNC1 field to a new value.
#define BW_IPU_DP_CSC_ASYNC1_0_DP_CSC_B0_ASYNC1(v)   BF_CS1(IPU_DP_CSC_ASYNC1_0, DP_CSC_B0_ASYNC1, v)
#endif

/* --- Register HW_IPU_DP_CSC_ASYNC1_0, field DP_CSC_S0_ASYNC1 (RW)
 *
 * S0 parameter of color conversion.
 *
 * Values:
 * 00 - scale factor of 2
 * 01 - scale factor of 1
 * 10 - scale factor of 0
 * 11 - scale factor of -1
 */

#define BP_IPU_DP_CSC_ASYNC1_0_DP_CSC_S0_ASYNC1      30
#define BM_IPU_DP_CSC_ASYNC1_0_DP_CSC_S0_ASYNC1      0xc0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC1_0_DP_CSC_S0_ASYNC1(v)   ((((reg32_t) v) << 30) & BM_IPU_DP_CSC_ASYNC1_0_DP_CSC_S0_ASYNC1)
#else
#define BF_IPU_DP_CSC_ASYNC1_0_DP_CSC_S0_ASYNC1(v)   (((v) << 30) & BM_IPU_DP_CSC_ASYNC1_0_DP_CSC_S0_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_S0_ASYNC1 field to a new value.
#define BW_IPU_DP_CSC_ASYNC1_0_DP_CSC_S0_ASYNC1(v)   BF_CS1(IPU_DP_CSC_ASYNC1_0, DP_CSC_S0_ASYNC1, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_DP_CSC_ASYNC1_1 - DP Color Conversion Control Async 1 Flow Register 1 (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned DP_CSC_B1_ASYNC1 : 14; //!< B0 parameter of color conversion.
        unsigned DP_CSC_S1_ASYNC1 : 2; //!< S0 parameter of color conversion.
        unsigned DP_CSC_B2_ASYNC1 : 14; //!< B0 parameter of color conversion.
        unsigned DP_CSC_S2_ASYNC1 : 2; //!< S0 parameter of color conversion.
    } B;
} hw_ipu_dp_csc_async1_1_t;
#endif

/*
 * constants & macros for entire multi-block IPU_DP_CSC_ASYNC1_1 register
 */
#define HW_IPU_DP_CSC_ASYNC1_1_ADDR(x)      (REGS_IPU_BASE(x) + 0x1040114)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_DP_CSC_ASYNC1_1(x)           (*(volatile hw_ipu_dp_csc_async1_1_t *) HW_IPU_DP_CSC_ASYNC1_1_ADDR(x))
#define HW_IPU_DP_CSC_ASYNC1_1_RD(x)        (HW_IPU_DP_CSC_ASYNC1_1(x).U)
#define HW_IPU_DP_CSC_ASYNC1_1_WR(x, v)     (HW_IPU_DP_CSC_ASYNC1_1(x).U = (v))
#define HW_IPU_DP_CSC_ASYNC1_1_SET(x, v)    (HW_IPU_DP_CSC_ASYNC1_1_WR(x, HW_IPU_DP_CSC_ASYNC1_1_RD(x) |  (v)))
#define HW_IPU_DP_CSC_ASYNC1_1_CLR(x, v)    (HW_IPU_DP_CSC_ASYNC1_1_WR(x, HW_IPU_DP_CSC_ASYNC1_1_RD(x) & ~(v)))
#define HW_IPU_DP_CSC_ASYNC1_1_TOG(x, v)    (HW_IPU_DP_CSC_ASYNC1_1_WR(x, HW_IPU_DP_CSC_ASYNC1_1_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_DP_CSC_ASYNC1_1 bitfields
 */

/* --- Register HW_IPU_DP_CSC_ASYNC1_1, field DP_CSC_B1_ASYNC1 (RW)
 *
 * B0 parameter of color conversion.
 */

#define BP_IPU_DP_CSC_ASYNC1_1_DP_CSC_B1_ASYNC1      0
#define BM_IPU_DP_CSC_ASYNC1_1_DP_CSC_B1_ASYNC1      0x00003fff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC1_1_DP_CSC_B1_ASYNC1(v)   ((((reg32_t) v) << 0) & BM_IPU_DP_CSC_ASYNC1_1_DP_CSC_B1_ASYNC1)
#else
#define BF_IPU_DP_CSC_ASYNC1_1_DP_CSC_B1_ASYNC1(v)   (((v) << 0) & BM_IPU_DP_CSC_ASYNC1_1_DP_CSC_B1_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_B1_ASYNC1 field to a new value.
#define BW_IPU_DP_CSC_ASYNC1_1_DP_CSC_B1_ASYNC1(v)   BF_CS1(IPU_DP_CSC_ASYNC1_1, DP_CSC_B1_ASYNC1, v)
#endif

/* --- Register HW_IPU_DP_CSC_ASYNC1_1, field DP_CSC_S1_ASYNC1 (RW)
 *
 * S0 parameter of color conversion.
 *
 * Values:
 * 00 - scale factor of 2
 * 01 - scale factor of 1
 * 10 - scale factor of 0 11 scale factor of -1
 */

#define BP_IPU_DP_CSC_ASYNC1_1_DP_CSC_S1_ASYNC1      14
#define BM_IPU_DP_CSC_ASYNC1_1_DP_CSC_S1_ASYNC1      0x0000c000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC1_1_DP_CSC_S1_ASYNC1(v)   ((((reg32_t) v) << 14) & BM_IPU_DP_CSC_ASYNC1_1_DP_CSC_S1_ASYNC1)
#else
#define BF_IPU_DP_CSC_ASYNC1_1_DP_CSC_S1_ASYNC1(v)   (((v) << 14) & BM_IPU_DP_CSC_ASYNC1_1_DP_CSC_S1_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_S1_ASYNC1 field to a new value.
#define BW_IPU_DP_CSC_ASYNC1_1_DP_CSC_S1_ASYNC1(v)   BF_CS1(IPU_DP_CSC_ASYNC1_1, DP_CSC_S1_ASYNC1, v)
#endif


/* --- Register HW_IPU_DP_CSC_ASYNC1_1, field DP_CSC_B2_ASYNC1 (RW)
 *
 * B0 parameter of color conversion.
 */

#define BP_IPU_DP_CSC_ASYNC1_1_DP_CSC_B2_ASYNC1      16
#define BM_IPU_DP_CSC_ASYNC1_1_DP_CSC_B2_ASYNC1      0x3fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC1_1_DP_CSC_B2_ASYNC1(v)   ((((reg32_t) v) << 16) & BM_IPU_DP_CSC_ASYNC1_1_DP_CSC_B2_ASYNC1)
#else
#define BF_IPU_DP_CSC_ASYNC1_1_DP_CSC_B2_ASYNC1(v)   (((v) << 16) & BM_IPU_DP_CSC_ASYNC1_1_DP_CSC_B2_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_B2_ASYNC1 field to a new value.
#define BW_IPU_DP_CSC_ASYNC1_1_DP_CSC_B2_ASYNC1(v)   BF_CS1(IPU_DP_CSC_ASYNC1_1, DP_CSC_B2_ASYNC1, v)
#endif

/* --- Register HW_IPU_DP_CSC_ASYNC1_1, field DP_CSC_S2_ASYNC1 (RW)
 *
 * S0 parameter of color conversion.
 *
 * Values:
 * 00 - scale factor of 2
 * 01 - scale factor of 1
 * 10 - scale factor of 0 11 scale factor of -1
 */

#define BP_IPU_DP_CSC_ASYNC1_1_DP_CSC_S2_ASYNC1      30
#define BM_IPU_DP_CSC_ASYNC1_1_DP_CSC_S2_ASYNC1      0xc0000000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_DP_CSC_ASYNC1_1_DP_CSC_S2_ASYNC1(v)   ((((reg32_t) v) << 30) & BM_IPU_DP_CSC_ASYNC1_1_DP_CSC_S2_ASYNC1)
#else
#define BF_IPU_DP_CSC_ASYNC1_1_DP_CSC_S2_ASYNC1(v)   (((v) << 30) & BM_IPU_DP_CSC_ASYNC1_1_DP_CSC_S2_ASYNC1)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the DP_CSC_S2_ASYNC1 field to a new value.
#define BW_IPU_DP_CSC_ASYNC1_1_DP_CSC_S2_ASYNC1(v)   BF_CS1(IPU_DP_CSC_ASYNC1_1, DP_CSC_S2_ASYNC1, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_BNDM_EN_2 - IDMAC Band Mode Enable 2 Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned RESERVED0 : 13; //!< Reserved.
        unsigned IDMAC_BNDM_EN_45 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned IDMAC_BNDM_EN_46 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned IDMAC_BNDM_EN_47 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned IDMAC_BNDM_EN_48 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned IDMAC_BNDM_EN_49 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned IDMAC_BNDM_EN_50 : 1; //!< IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode. When alternate flow is running via this channel, both the main flow and the alternate flow should have the same band mode configuration.
        unsigned RESERVED1 : 13; //!< Reserved.
    } B;
} hw_ipu_idmac_bndm_en_2_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_BNDM_EN_2 register
 */
#define HW_IPU_IDMAC_BNDM_EN_2_ADDR(x)      (REGS_IPU_BASE(x) + 0x4ca91bc)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_BNDM_EN_2(x)           (*(volatile hw_ipu_idmac_bndm_en_2_t *) HW_IPU_IDMAC_BNDM_EN_2_ADDR(x))
#define HW_IPU_IDMAC_BNDM_EN_2_RD(x)        (HW_IPU_IDMAC_BNDM_EN_2(x).U)
#define HW_IPU_IDMAC_BNDM_EN_2_WR(x, v)     (HW_IPU_IDMAC_BNDM_EN_2(x).U = (v))
#define HW_IPU_IDMAC_BNDM_EN_2_SET(x, v)    (HW_IPU_IDMAC_BNDM_EN_2_WR(x, HW_IPU_IDMAC_BNDM_EN_2_RD(x) |  (v)))
#define HW_IPU_IDMAC_BNDM_EN_2_CLR(x, v)    (HW_IPU_IDMAC_BNDM_EN_2_WR(x, HW_IPU_IDMAC_BNDM_EN_2_RD(x) & ~(v)))
#define HW_IPU_IDMAC_BNDM_EN_2_TOG(x, v)    (HW_IPU_IDMAC_BNDM_EN_2_WR(x, HW_IPU_IDMAC_BNDM_EN_2_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_BNDM_EN_2 bitfields
 */

/* --- Register HW_IPU_IDMAC_BNDM_EN_2, field IDMAC_BNDM_EN_45 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_45      13
#define BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_45      0x00002000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_45(v)   ((((reg32_t) v) << 13) & BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_45)
#else
#define BF_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_45(v)   (((v) << 13) & BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_45)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_45 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_45(v)   BF_CS1(IPU_IDMAC_BNDM_EN_2, IDMAC_BNDM_EN_45, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_2, field IDMAC_BNDM_EN_46 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_46      14
#define BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_46      0x00004000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_46(v)   ((((reg32_t) v) << 14) & BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_46)
#else
#define BF_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_46(v)   (((v) << 14) & BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_46)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_46 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_46(v)   BF_CS1(IPU_IDMAC_BNDM_EN_2, IDMAC_BNDM_EN_46, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_2, field IDMAC_BNDM_EN_47 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_47      15
#define BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_47      0x00008000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_47(v)   ((((reg32_t) v) << 15) & BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_47)
#else
#define BF_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_47(v)   (((v) << 15) & BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_47)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_47 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_47(v)   BF_CS1(IPU_IDMAC_BNDM_EN_2, IDMAC_BNDM_EN_47, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_2, field IDMAC_BNDM_EN_48 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_48      16
#define BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_48      0x00010000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_48(v)   ((((reg32_t) v) << 16) & BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_48)
#else
#define BF_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_48(v)   (((v) << 16) & BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_48)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_48 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_48(v)   BF_CS1(IPU_IDMAC_BNDM_EN_2, IDMAC_BNDM_EN_48, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_2, field IDMAC_BNDM_EN_49 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_49      17
#define BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_49      0x00020000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_49(v)   ((((reg32_t) v) << 17) & BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_49)
#else
#define BF_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_49(v)   (((v) << 17) & BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_49)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_49 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_49(v)   BF_CS1(IPU_IDMAC_BNDM_EN_2, IDMAC_BNDM_EN_49, v)
#endif


/* --- Register HW_IPU_IDMAC_BNDM_EN_2, field IDMAC_BNDM_EN_50 (RW)
 *
 * IDMAC Band Mode Enable bit [i] This bit controls if the channel currently works in band mode.
 * When alternate flow is running via this channel, both the main flow and the alternate flow should
 * have the same band mode configuration.
 *
 * Values:
 * 0 - IDMAC channel [i] is not in band mode
 * 1 - IDMAC channel [i] is in band mode
 */

#define BP_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_50      18
#define BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_50      0x00040000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_50(v)   ((((reg32_t) v) << 18) & BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_50)
#else
#define BF_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_50(v)   (((v) << 18) & BM_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_50)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the IDMAC_BNDM_EN_50 field to a new value.
#define BW_IPU_IDMAC_BNDM_EN_2_IDMAC_BNDM_EN_50(v)   BF_CS1(IPU_IDMAC_BNDM_EN_2, IDMAC_BNDM_EN_50, v)
#endif


#ifndef __LANGUAGE_ASM__
/*!
 * @brief HW_IPU_IDMAC_SC_CORD - IDMAC Scroll Coordinations Register (RW)
 *

 */
typedef union
{
    reg32_t U;
    struct
    {
        unsigned SY0 : 11; //!< Scroll Y coordination This field indicates the Y coordinate of the scroll. This parameter has an affect on continuos scroll mode only. Units are pixels. When the alpha buffer resides in a separate buffer and the alpha is different than 8 BPP this field should be 0.
        unsigned RESERVED0 : 5; //!< Reserved, should be cleared.
        unsigned SX0 : 12; //!< Scroll X coordination This field indicates the X coordinate of the scroll. This parameter has an affect on continuos scroll mode only. Units are pixels. When the alpha buffer resides in a separate buffer and the alpha is different than 8 BPP this field should be 0.
        unsigned RESERVED1 : 4; //!< Reserved, should be cleared.
    } B;
} hw_ipu_idmac_sc_cord_t;
#endif

/*
 * constants & macros for entire multi-block IPU_IDMAC_SC_CORD register
 */
#define HW_IPU_IDMAC_SC_CORD_ADDR(x)      (REGS_IPU_BASE(x) + 0x803c4848)

#ifndef __LANGUAGE_ASM__
#define HW_IPU_IDMAC_SC_CORD(x)           (*(volatile hw_ipu_idmac_sc_cord_t *) HW_IPU_IDMAC_SC_CORD_ADDR(x))
#define HW_IPU_IDMAC_SC_CORD_RD(x)        (HW_IPU_IDMAC_SC_CORD(x).U)
#define HW_IPU_IDMAC_SC_CORD_WR(x, v)     (HW_IPU_IDMAC_SC_CORD(x).U = (v))
#define HW_IPU_IDMAC_SC_CORD_SET(x, v)    (HW_IPU_IDMAC_SC_CORD_WR(x, HW_IPU_IDMAC_SC_CORD_RD(x) |  (v)))
#define HW_IPU_IDMAC_SC_CORD_CLR(x, v)    (HW_IPU_IDMAC_SC_CORD_WR(x, HW_IPU_IDMAC_SC_CORD_RD(x) & ~(v)))
#define HW_IPU_IDMAC_SC_CORD_TOG(x, v)    (HW_IPU_IDMAC_SC_CORD_WR(x, HW_IPU_IDMAC_SC_CORD_RD(x) ^  (v)))
#endif

/*
 * constants & macros for individual IPU_IDMAC_SC_CORD bitfields
 */

/* --- Register HW_IPU_IDMAC_SC_CORD, field SY0 (RW)
 *
 * Scroll Y coordination This field indicates the Y coordinate of the scroll. This parameter has an
 * affect on continuos scroll mode only. Units are pixels. When the alpha buffer resides in a
 * separate buffer and the alpha is different than 8 BPP this field should be 0.
 */

#define BP_IPU_IDMAC_SC_CORD_SY0      0
#define BM_IPU_IDMAC_SC_CORD_SY0      0x000007ff

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SC_CORD_SY0(v)   ((((reg32_t) v) << 0) & BM_IPU_IDMAC_SC_CORD_SY0)
#else
#define BF_IPU_IDMAC_SC_CORD_SY0(v)   (((v) << 0) & BM_IPU_IDMAC_SC_CORD_SY0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SY0 field to a new value.
#define BW_IPU_IDMAC_SC_CORD_SY0(v)   BF_CS1(IPU_IDMAC_SC_CORD, SY0, v)
#endif

/* --- Register HW_IPU_IDMAC_SC_CORD, field SX0 (RW)
 *
 * Scroll X coordination This field indicates the X coordinate of the scroll. This parameter has an
 * affect on continuos scroll mode only. Units are pixels. When the alpha buffer resides in a
 * separate buffer and the alpha is different than 8 BPP this field should be 0.
 */

#define BP_IPU_IDMAC_SC_CORD_SX0      16
#define BM_IPU_IDMAC_SC_CORD_SX0      0x0fff0000

#ifndef __LANGUAGE_ASM__
#define BF_IPU_IDMAC_SC_CORD_SX0(v)   ((((reg32_t) v) << 16) & BM_IPU_IDMAC_SC_CORD_SX0)
#else
#define BF_IPU_IDMAC_SC_CORD_SX0(v)   (((v) << 16) & BM_IPU_IDMAC_SC_CORD_SX0)
#endif
#ifndef __LANGUAGE_ASM__
//! @brief Set the SX0 field to a new value.
#define BW_IPU_IDMAC_SC_CORD_SX0(v)   BF_CS1(IPU_IDMAC_SC_CORD, SX0, v)
#endif


/*!
 * @brief All IPU module registers.
 */
#ifndef __LANGUAGE_ASM__
typedef struct
{
    volatile hw_ipu_conf_t CONF; //!< Configuration Register
    volatile hw_ipu_sisg_ctrl0_t SISG_CTRL0; //!< SISG Control 0 Register
    volatile hw_ipu_sisg_ctrl1_t SISG_CTRL1; //!< SISG Control 1 Register
    volatile hw_ipu_sisg_set_i_t SISG_SET_I; //!< SISG Set<i> Register
    reg32_t _reserved0[5];
    volatile hw_ipu_sisg_clr_i_t SISG_CLR_I; //!< SISG Clear <i> Register
    reg32_t _reserved1[5];
    volatile hw_ipu_int_ctrl_1_t INT_CTRL_1; //!< Interrupt Control Register 1
    volatile hw_ipu_int_ctrl_2_t INT_CTRL_2; //!< Interrupt Control Register 2
    volatile hw_ipu_int_ctrl_3_t INT_CTRL_3; //!< Interrupt Control Register 3
    volatile hw_ipu_int_ctrl_4_t INT_CTRL_4; //!< Interrupt Control Register 4
    volatile hw_ipu_int_ctrl_5_t INT_CTRL_5; //!< Interrupt Control Register 5
    volatile hw_ipu_int_ctrl_6_t INT_CTRL_6; //!< Interrupt Control Register 6
    volatile hw_ipu_int_ctrl_7_t INT_CTRL_7; //!< Interrupt Control Register 7
    volatile hw_ipu_int_ctrl_8_t INT_CTRL_8; //!< Interrupt Control Register 8
    volatile hw_ipu_int_ctrl_9_t INT_CTRL_9; //!< Interrupt Control Register 9
    volatile hw_ipu_int_ctrl_10_t INT_CTRL_10; //!< Interrupt Control Register 10
    volatile hw_ipu_int_ctrl_11_t INT_CTRL_11; //!< Interrupt Control Register 11
    volatile hw_ipu_int_ctrl_12_t INT_CTRL_12; //!< Interrupt Control Register 12
    volatile hw_ipu_int_ctrl_13_t INT_CTRL_13; //!< Interrupt Control Register 13
    volatile hw_ipu_int_ctrl_14_t INT_CTRL_14; //!< Interrupt Control Register 14
    volatile hw_ipu_int_ctrl_15_t INT_CTRL_15; //!< Interrupt Control Register15
    volatile hw_ipu_sdma_event_1_t SDMA_EVENT_1; //!< SDMA Event Control Register 1
    volatile hw_ipu_sdma_event_2_t SDMA_EVENT_2; //!< SDMA Event Control Register 2
    volatile hw_ipu_sdma_event_3_t SDMA_EVENT_3; //!< SDMA Event Control Register 3
    volatile hw_ipu_sdma_event_4_t SDMA_EVENT_4; //!< SDMA Event Control Register 4
    volatile hw_ipu_sdma_event_7_t SDMA_EVENT_7; //!< SDMA Event Control Register 7
    volatile hw_ipu_sdma_event_8_t SDMA_EVENT_8; //!< SDMA Event Control Register 8
    volatile hw_ipu_sdma_event_11_t SDMA_EVENT_11; //!< SDMA Event Control Register 11
    volatile hw_ipu_sdma_event_12_t SDMA_EVENT_12; //!< SDMA Event Control Register 12
    volatile hw_ipu_sdma_event_13_t SDMA_EVENT_13; //!< SDMA Event Control Register 13
    volatile hw_ipu_sdma_event_14_t SDMA_EVENT_14; //!< SDMA Event Control Register 14
    volatile hw_ipu_srm_pri1_t SRM_PRI1; //!< Shadow Registers Memory Priority 1 Register
    volatile hw_ipu_srm_pri2_t SRM_PRI2; //!< Shadow Registers Memory Priority 2 Register
    volatile hw_ipu_fs_proc_flow1_t FS_PROC_FLOW1; //!< FSU Processing Flow 1 Register
    volatile hw_ipu_fs_proc_flow2_t FS_PROC_FLOW2; //!< FSU Processing Flow 2 Register
    reg32_t _reserved2;
    volatile hw_ipu_fs_disp_flow1_t FS_DISP_FLOW1; //!< FSU Displaying Flow 1 Register
    volatile hw_ipu_fs_disp_flow2_t FS_DISP_FLOW2; //!< FSU Displaying Flow 2 Register
    volatile hw_ipu_skip_t SKIP; //!< SKIP Register
    volatile hw_ipu_disp_alt_conf_t DISP_ALT_CONF; //!< Display Alternate Configuration Register
    volatile hw_ipu_disp_gen_t DISP_GEN; //!< Display General Control Register
    volatile hw_ipu_disp_alt1_t DISP_ALT1; //!< Display Alternate Flow Control Register 1
    volatile hw_ipu_disp_alt2_t DISP_ALT2; //!< Display Alternate Flow Control Register 2
    volatile hw_ipu_disp_alt3_t DISP_ALT3; //!< Display Alternate Flow Control Register 3
    volatile hw_ipu_disp_alt4_t DISP_ALT4; //!< Display Alternate Flow Control Register 4
    volatile hw_ipu_snoop_t SNOOP; //!< Autorefresh and Snooping Control Register
    volatile hw_ipu_mem_rst_t MEM_RST; //!< Memory Reset Control Register
    volatile hw_ipu_pm_t PM; //!< Power Modes Control Register
    volatile hw_ipu_gpr_t GPR; //!< General Purpose Register
    reg32_t _reserved3[26];
    volatile hw_ipu_ch_db_mode_sel0_t CH_DB_MODE_SEL0; //!< Channel Double Buffer Mode Select 0 Register
    volatile hw_ipu_ch_db_mode_sel1_t CH_DB_MODE_SEL1; //!< Channel Double Buffer Mode Select 1 Register
    reg32_t _reserved4[4];
    volatile hw_ipu_alt_ch_db_mode_sel0_t ALT_CH_DB_MODE_SEL0; //!< Alternate Channel Double Buffer Mode Select 0 Register
    volatile hw_ipu_alt_ch_db_mode_sel1_t ALT_CH_DB_MODE_SEL1; //!< Alternate Channel Double Buffer Mode Select1 Register
    reg32_t _reserved5[2];
    volatile hw_ipu_alt_ch_trb_mode_sel0_t ALT_CH_TRB_MODE_SEL0; //!< Alternate Channel Triple Buffer Mode Select 0 Register
    volatile hw_ipu_alt_ch_trb_mode_sel1_t ALT_CH_TRB_MODE_SEL1; //!< Alternate Channel Triple Buffer Mode Select 1 Register
    reg32_t _reserved6[32];
    volatile hw_ipu_int_stat_1_t INT_STAT_1; //!< Interrupt Status Register 1
    volatile hw_ipu_int_stat_2_t INT_STAT_2; //!< Interrupt Status Register2
    volatile hw_ipu_int_stat_3_t INT_STAT_3; //!< Interrupt Status Register 3
    reg32_t _reserved7;
    volatile hw_ipu_int_stat_5_t INT_STAT_5; //!< Interrupt Status Register 5
    volatile hw_ipu_int_stat_6_t INT_STAT_6; //!< Interrupt Status Register 6
    volatile hw_ipu_int_stat_7_t INT_STAT_7; //!< Interrupt Status Register7 1
    volatile hw_ipu_int_stat_8_t INT_STAT_8; //!< Interrupt Status Register 8
    volatile hw_ipu_int_stat_9_t INT_STAT_9; //!< Interrupt Status Register 9
    volatile hw_ipu_int_stat_10_t INT_STAT_10; //!< Interrupt Status Register 10
    volatile hw_ipu_int_stat_11_t INT_STAT_11; //!< Interrupt Status Register 11
    volatile hw_ipu_int_stat_12_t INT_STAT_12; //!< Interrupt Status Register 12
    volatile hw_ipu_int_stat_13_t INT_STAT_13; //!< Interrupt Status Register 13
    volatile hw_ipu_int_stat_14_t INT_STAT_14; //!< Interrupt Status Register 14
    volatile hw_ipu_int_stat_15_t INT_STAT_15; //!< Interrupt Status Register 15
    volatile hw_ipu_cur_buf_0_t CUR_BUF_0; //!< Current Buffer Register 0
    volatile hw_ipu_cur_buf_1_t CUR_BUF_1; //!< Current Buffer Register 1
    volatile hw_ipu_alt_cur_0_t ALT_CUR_0; //!< Alternate Current Buffer Register 0
    volatile hw_ipu_alt_cur_1_t ALT_CUR_1; //!< Alternate Current Buffer Register 1
    volatile hw_ipu_srm_stat_t SRM_STAT; //!< Shadow Registers Memory Status Register
    volatile hw_ipu_proc_tasks_stat_t PROC_TASKS_STAT; //!< Processing Status Tasks Register
    volatile hw_ipu_disp_tasks_stat_t DISP_TASKS_STAT; //!< Display Tasks Status Register
    volatile hw_ipu_triple_cur_buf_0_t TRIPLE_CUR_BUF_0; //!< Triple Current Buffer Register 0
    volatile hw_ipu_triple_cur_buf_1_t TRIPLE_CUR_BUF_1; //!< Triple Current Buffer Register 1
    volatile hw_ipu_triple_cur_buf_2_t TRIPLE_CUR_BUF_2; //!< Triple Current Buffer Register 2
    volatile hw_ipu_triple_cur_buf_3_t TRIPLE_CUR_BUF_3; //!< Triple Current Buffer Register 3
    volatile hw_ipu_ch_buf0_rdy0_t CH_BUF0_RDY0; //!< IPU Channels Buffer 0 Ready 0 Register
    volatile hw_ipu_ch_buf0_rdy1_t CH_BUF0_RDY1; //!< IPU Channels Buffer 0 Ready 1 Register
    volatile hw_ipu_ch_buf1_rdy0_t CH_BUF1_RDY0; //!< IPU Channels Buffer 1 Ready 0 Register
    volatile hw_ipu_ch_buf1_rdy1_t CH_BUF1_RDY1; //!< IPU Channels Buffer 1 Ready 1Register
    volatile hw_ipu_alt_ch_buf0_rdy0_t ALT_CH_BUF0_RDY0; //!< IPU Alternate Channels Buffer 0 Ready 0 Register
    volatile hw_ipu_alt_ch_buf0_rdy1_t ALT_CH_BUF0_RDY1; //!< IPU Alternate Channels Buffer 0 Ready 1 Register
    volatile hw_ipu_alt_ch_buf1_rdy0_t ALT_CH_BUF1_RDY0; //!< IPU Alternate Channels Buffer1 Ready 0 Register
    volatile hw_ipu_alt_ch_buf1_rdy1_t ALT_CH_BUF1_RDY1; //!< IPU Alternate Channels Buffer 1 Ready 1 Register
    volatile hw_ipu_ch_buf2_rdy0_t CH_BUF2_RDY0; //!< IPU Channels Buffer 2 Ready 0 Register
    volatile hw_ipu_ch_buf2_rdy1_t CH_BUF2_RDY1; //!< IPU Channels Buffer 2 Ready 1 Register
    reg32_t _reserved8[12];
    volatile hw_ipu_int_stat_4_t INT_STAT_4; //!< Interrupt Status Register 4
    reg32_t _reserved9[1823];
    volatile hw_ipu_idmac_conf_t IDMAC_CONF; //!< IDMAC Configuration Register
    volatile hw_ipu_idmac_ch_en_1_t IDMAC_CH_EN_1; //!< IDMAC Channel Enable 1 Register
    reg16_t _reserved10;
    volatile hw_ipu_idmac_alt_sep_alpha_t IDMAC_ALT_SEP_ALPHA; //!< IDMAC Alternate Separate Alpha Indication Register
    volatile hw_ipu_idmac_ch_pri_1_t IDMAC_CH_PRI_1; //!< IDMAC Channel Priority 1 Register
    volatile hw_ipu_idmac_ch_pri_2_t IDMAC_CH_PRI_2; //!< IDMAC Channel Priority 2 Register
    volatile hw_ipu_idmac_wm_en_2_t IDMAC_WM_EN_2; //!< IDMAC Channel Watermark Enable 2 Register
    volatile hw_ipu_idmac_lock_en_1_t IDMAC_LOCK_EN_1; //!< IDMAC Channel Lock Enable 1Register
    reg16_t _reserved11[35];
    volatile hw_ipu_idmac_ch_busy_1_t IDMAC_CH_BUSY_1; //!< IDMAC Channel Busy 1 Register
    volatile hw_ipu_idmac_ch_busy_2_t IDMAC_CH_BUSY_2; //!< IDMAC Channel Busy 2 Register
    reg32_t _reserved12[6168];
    volatile hw_ipu_idmac_sep_alpha_t IDMAC_SEP_ALPHA; //!< IDMAC Separate Alpha Indication Register
    reg32_t _reserved13[3];
    volatile hw_ipu_idmac_wm_en_1_t IDMAC_WM_EN_1; //!< IDMAC Channel Watermark Enable 1 Register
    reg32_t _reserved14[11];
    volatile hw_ipu_idmac_sc_cord_1_t IDMAC_SC_CORD_1; //!< IDMAC Scroll Coordinations Register 1
    reg32_t _reserved15[11790];
    volatile hw_ipu_idmac_ch_en_2_t IDMAC_CH_EN_2; //!< IDMAC Channel Enable 2 Register
    reg32_t _reserved16[59];
    volatile hw_ipu_idmac_lock_en_2_t IDMAC_LOCK_EN_2; //!< IDMAC Channel Lock Enable 2Register
    reg32_t _reserved17[13];
    volatile hw_ipu_idmac_sub_addr_2_t IDMAC_SUB_ADDR_2; //!< IDMAC Channel Alternate Address 2 Register
    volatile hw_ipu_idmac_sub_addr_3_t IDMAC_SUB_ADDR_3; //!< IDMAC Channel Alternate Address 3 Register
    reg32_t _reserved18[32];
    volatile hw_ipu_idmac_bndm_en_1_t IDMAC_BNDM_EN_1; //!< IDMAC Band Mode Enable 1 Register
    reg32_t _reserved19[4512];
    volatile hw_ipu_dp_debug_cnt_t DP_DEBUG_CNT; //!< DP Debug Control Register
    volatile hw_ipu_dp_debug_stat_t DP_DEBUG_STAT; //!< DP Debug Status Register
    reg32_t _reserved20[8143];
    volatile hw_ipu_ic_conf_t IC_CONF; //!< IC Configuration Register
    volatile hw_ipu_ic_prp_enc_rsc_t IC_PRP_ENC_RSC; //!< IC Preprocessing Encoder Resizing Coefficients Register
    volatile hw_ipu_ic_prp_vf_rsc_t IC_PRP_VF_RSC; //!< IC Preprocessing View-Finder Resizing Coefficients Register
    volatile hw_ipu_ic_pp_rsc_t IC_PP_RSC; //!< IC Postprocessing Encoder Resizing Coefficients Register
    volatile hw_ipu_ic_cmbp_1_t IC_CMBP_1; //!< IC Combining Parameters Register 1
    volatile hw_ipu_ic_cmbp_2_t IC_CMBP_2; //!< IC Combining Parameters Register 2
    volatile hw_ipu_ic_idmac_1_t IC_IDMAC_1; //!< IC IDMAC Parameters 1 Register
    volatile hw_ipu_ic_idmac_2_t IC_IDMAC_2; //!< IC IDMAC Parameters 2 Register
    volatile hw_ipu_ic_idmac_3_t IC_IDMAC_3; //!< IC IDMAC Parameters 3Register
    volatile hw_ipu_ic_idmac_4_t IC_IDMAC_4; //!< IC IDMAC Parameters 4 Register
    reg32_t _reserved21[16374];
    volatile hw_ipu_csi0_sens_conf_t CSI0_SENS_CONF; //!< CSI0 Sensor Configuration Register
    volatile hw_ipu_csi0_sens_frm_size_t CSI0_SENS_FRM_SIZE; //!< CSI0 Sense Frame Size Register
    volatile hw_ipu_csi0_act_frm_size_t CSI0_ACT_FRM_SIZE; //!< CSI0 Actual Frame Size Register
    volatile hw_ipu_csi0_out_frm_ctrl_t CSI0_OUT_FRM_CTRL; //!< CSI0 Output Control Register
    volatile hw_ipu_csi0_tst_ctrl_t CSI0_TST_CTRL; //!< CSIO Test Control Register
    volatile hw_ipu_csi0_ccir_code_1_t CSI0_CCIR_CODE_1; //!< CSIO CCIR Code Register 1
    volatile hw_ipu_csi0_ccir_code_2_t CSI0_CCIR_CODE_2; //!< CSIO CCIR Code Register 2
    volatile hw_ipu_csi0_ccir_code_3_t CSI0_CCIR_CODE_3; //!< CSIO CCIR Code Register 3
    volatile hw_ipu_csi0_di_t CSI0_DI; //!< CSI0 Data Identifier Register
    volatile hw_ipu_csi0_skip_t CSI0_SKIP; //!< CSI0 SKIP Register
    volatile hw_ipu_csio_cpd_ctrl_t CSIO_CPD_CTRL; //!< CSI0 Compander Control Register
    volatile hw_ipu_csio_cpd_rc_i_t CSIO_CPD_RC_I; //!< CSI0 Red Component Compander Constants Register <i>
    reg32_t _reserved22[7];
    volatile hw_ipu_csio_cpd_rs_i_t CSIO_CPD_RS_I; //!< CSI0 Red Component Compander SLOPE Register <i>
    reg32_t _reserved23[3];
    volatile hw_ipu_csio_cpd_grc_i_t CSIO_CPD_GRC_I; //!< CSI0 GR Component Compander Constants Register <i>
    reg32_t _reserved24[7];
    volatile hw_ipu_csio_cpd_grs_i_t CSIO_CPD_GRS_I; //!< CSI0 GR Component Compander SLOPE Register <i>
    reg32_t _reserved25[3];
    volatile hw_ipu_csio_cpd_gbc_i_t CSIO_CPD_GBC_I; //!< CSI0 GB Component Compander Constants Register <i>
    reg32_t _reserved26[7];
    volatile hw_ipu_csio_cpd_gbs_i_t CSIO_CPD_GBS_I; //!< CSI0 GB Component Compander SLOPE Register <i>
    reg32_t _reserved27[3];
    volatile hw_ipu_csio_cpd_bc_i_t CSIO_CPD_BC_I; //!< CSI0 Blue Component Compander Constants Register <i>
    reg32_t _reserved28[7];
    volatile hw_ipu_csio_cpd_bs_i_t CSIO_CPD_BS_I; //!< CSI0 Blue Component Compander SLOPE Register <i>
    reg32_t _reserved29[3];
    volatile hw_ipu_csi0_cpd_offset1_t CSI0_CPD_OFFSET1; //!< CSI0 Compander Offset Register 1
    volatile hw_ipu_csi0_cpd_offset2_t CSI0_CPD_OFFSET2; //!< CSI0 Compander Offset Register 2
    reg32_t _reserved30[8131];
    volatile hw_ipu_csi1_sens_conf_t CSI1_SENS_CONF; //!< CSI1 Sensor Configuration Register
    volatile hw_ipu_csi1_sens_frm_size_t CSI1_SENS_FRM_SIZE; //!< CSI1 Sense Frame Size Register
    volatile hw_ipu_csi1_act_frm_size_t CSI1_ACT_FRM_SIZE; //!< CSI1 Actual Frame Size Register
    volatile hw_ipu_csi1_out_frm_ctrl_t CSI1_OUT_FRM_CTRL; //!< CSI1 Output Control Register
    volatile hw_ipu_csi1_tst_ctrl_t CSI1_TST_CTRL; //!< CSI1 Test Control Register
    volatile hw_ipu_csi1_ccir_code_1_t CSI1_CCIR_CODE_1; //!< CSI1 CCIR Code Register 1
    volatile hw_ipu_csi1_ccir_code_2_t CSI1_CCIR_CODE_2; //!< CSI1 CCIR Code Register 2
    volatile hw_ipu_csi1_ccir_code_3_t CSI1_CCIR_CODE_3; //!< CSI1 CCIR Code Register 3
    volatile hw_ipu_csi1_di_t CSI1_DI; //!< CSI1 Data Identifier Register
    volatile hw_ipu_csi1_skip_t CSI1_SKIP; //!< CSI1 SKIP Register
    volatile hw_ipu_csi1_cpd_ctrl_t CSI1_CPD_CTRL; //!< CSI1 Compander Control Register
    volatile hw_ipu_csi1_cpd_rc_i_t CSI1_CPD_RC_I; //!< CSI1 Red Component Compander Constants Register <i>
    reg32_t _reserved31[7];
    volatile hw_ipu_csi1_cpd_rs_i_t CSI1_CPD_RS_I; //!< CSI1 Red Component Compander SLOPE Register <i>
    reg32_t _reserved32[3];
    volatile hw_ipu_csi1_cpd_grc_i_t CSI1_CPD_GRC_I; //!< CSI1 GR Component Compander Constants Register <i>
    reg32_t _reserved33[7];
    volatile hw_ipu_csi1_cpd_grs_i_t CSI1_CPD_GRS_I; //!< CSI1 GR Component Compander SLOPE Register <i>
    reg32_t _reserved34[3];
    volatile hw_ipu_csi1_cpd_gbc_i_t CSI1_CPD_GBC_I; //!< CSI1 GB Component Compander Constants Register <i>
    reg32_t _reserved35[7];
    volatile hw_ipu_csi1_cpd_gbs_i_t CSI1_CPD_GBS_I; //!< CSI1 GB Component Compander SLOPE Register <i>
    reg32_t _reserved36[3];
    volatile hw_ipu_csi1_cpd_bc_i_t CSI1_CPD_BC_I; //!< CSI1 Blue Component Compander Constants Register <i>
    reg32_t _reserved37[7];
    volatile hw_ipu_csi1_cpd_bs_i_t CSI1_CPD_BS_I; //!< CSI1 Blue Component Compander SLOPE Register <i>
    reg32_t _reserved38[3];
    volatile hw_ipu_csi1_cpd_offset1_t CSI1_CPD_OFFSET1; //!< CSI1 Compander Offset Register 1
    volatile hw_ipu_csi1_cpd_offset2_t CSI1_CPD_OFFSET2; //!< CSI1 Compander Offset Register 2
    reg32_t _reserved39[8131];
    volatile hw_ipu_di0_general_t DI0_GENERAL; //!< DI0 General Register
    volatile hw_ipu_di0_bs_clkgen0_t DI0_BS_CLKGEN0; //!< DI0 Base Sync Clock Gen 0 Register
    volatile hw_ipu_di0_bs_clkgen1_t DI0_BS_CLKGEN1; //!< DI0 Base Sync Clock Gen 1 Register
    volatile hw_ipu_di0_sw_gen0_1_t DI0_SW_GEN0_1; //!< DI0 Sync Wave Gen 1 Register 0
    volatile hw_ipu_di0_sw_gen0_2_t DI0_SW_GEN0_2; //!< DI0 Sync Wave Gen 2 Register 0
    volatile hw_ipu_di0_sw_gen0_3_t DI0_SW_GEN0_3; //!< DI0 Sync Wave Gen 3 Register 0
    volatile hw_ipu_di0_sw_gen0_4_t DI0_SW_GEN0_4; //!< DI0 Sync Wave Gen 4 Register 0
    volatile hw_ipu_di0_sw_gen0_5_t DI0_SW_GEN0_5; //!< DI0 Sync Wave Gen 5 Register 0
    volatile hw_ipu_di0_sw_gen0_6_t DI0_SW_GEN0_6; //!< DI0 Sync Wave Gen 6 Register 0
    volatile hw_ipu_di0_sw_gen0_7_t DI0_SW_GEN0_7; //!< DI0 Sync Wave Gen 7 Register 0
    volatile hw_ipu_di0_sw_gen0_8_t DI0_SW_GEN0_8; //!< DI0 Sync Wave Gen 8 Register 0
    volatile hw_ipu_di0_sw_gen0_9_t DI0_SW_GEN0_9; //!< DI0 Sync Wave Gen 9 Register 0
    volatile hw_ipu_di0_sw_gen1_1_t DI0_SW_GEN1_1; //!< DI0 Sync Wave Gen 1 Register 1
    volatile hw_ipu_di0_sw_gen1_2_t DI0_SW_GEN1_2; //!< DI0 Sync Wave Gen 2 Register 1
    volatile hw_ipu_di0_sw_gen1_3_t DI0_SW_GEN1_3; //!< DI0 Sync Wave Gen 3 Register 1
    volatile hw_ipu_di0_sw_gen1_4_t DI0_SW_GEN1_4; //!< DI0 Sync Wave Gen 4 Register 1
    volatile hw_ipu_di0_sw_gen1_5_t DI0_SW_GEN1_5; //!< DI0 Sync Wave Gen 5 Register 1
    volatile hw_ipu_di0_sw_gen1_6_t DI0_SW_GEN1_6; //!< DI0 Sync Wave Gen 6 Register 1
    volatile hw_ipu_di0_sw_gen1_7_t DI0_SW_GEN1_7; //!< DI0 Sync Wave Gen 7 Register 1
    volatile hw_ipu_di0_sw_gen1_8_t DI0_SW_GEN1_8; //!< DI0 Sync Wave Gen 8 Register 1
    volatile hw_ipu_di0_sw_gen1_9_t DI0_SW_GEN1_9; //!< DI0 Sync Wave Gen 9 Register 1
    volatile hw_ipu_di0_sync_as_gen_t DI0_SYNC_AS_GEN; //!< DI0 Sync Assistance Gen Register
    volatile hw_ipu_di0_dw_gen_i_t DI0_DW_GEN_I; //!< DI0 Data Wave Gen <i> Register
    reg32_t _reserved40[11];
    volatile hw_ipu_di0_dw_set0_i_t DI0_DW_SET0_I; //!< DI0 Data Wave Set 0 <i> Register
    reg32_t _reserved41[11];
    volatile hw_ipu_di0_dw_set1_i_t DI0_DW_SET1_I; //!< DI0 Data Wave Set 1 <i> Register
    reg32_t _reserved42[11];
    volatile hw_ipu_di0_dw_set2_i_t DI0_DW_SET2_I; //!< DI0 Data Wave Set 2 <i> Register
    reg32_t _reserved43[11];
    volatile hw_ipu_di0_dw_set3_i_t DI0_DW_SET3_I; //!< DI0 Data Wave Set 3 <i> Register
    reg32_t _reserved44[11];
    volatile hw_ipu_di0_stp_rep_i_t DI0_STP_REP_I; //!< DI0 Step Repeat <i> Registers
    reg32_t _reserved45[3];
    volatile hw_ipu_di0_stp_rep_9_t DI0_STP_REP_9; //!< DI0 Step Repeat 9 Registers
    volatile hw_ipu_di0_ser_conf_t DI0_SER_CONF; //!< DI0 Serial Display Control Register
    volatile hw_ipu_di0_ssc_t DI0_SSC; //!< DI0 Special Signals Control Register
    volatile hw_ipu_di0_pol_t DI0_POL; //!< DI0 Polarity Register
    volatile hw_ipu_di0_aw0_t DI0_AW0; //!< DI0 Active Window 0 Register
    volatile hw_ipu_di0_aw1_t DI0_AW1; //!< DI0 Active Window 1 Register
    volatile hw_ipu_di0_scr_conf_t DI0_SCR_CONF; //!< DI0 Screen Configuration Register
    volatile hw_ipu_di0_stat_t DI0_STAT; //!< DI0 Status Register
    reg32_t _reserved46[8098];
    volatile hw_ipu_di1_general_t DI1_GENERAL; //!< DI1General Register
    volatile hw_ipu_di1_bs_clkgen0_t DI1_BS_CLKGEN0; //!< DI1 Base Sync Clock Gen 0 Register
    volatile hw_ipu_di1_bs_clkgen1_t DI1_BS_CLKGEN1; //!< DI1 Base Sync Clock Gen 1 Register
    volatile hw_ipu_di1_sw_gen0_1_t DI1_SW_GEN0_1; //!< DI1 Sync Wave Gen 1 Register 0
    volatile hw_ipu_di1_sw_gen0_2_t DI1_SW_GEN0_2; //!< DI1 Sync Wave Gen 2 Register 0
    volatile hw_ipu_di1_sw_gen0_3_t DI1_SW_GEN0_3; //!< DI1 Sync Wave Gen 3 Register 0
    volatile hw_ipu_di1_sw_gen0_4_t DI1_SW_GEN0_4; //!< DI1 Sync Wave Gen 4 Register 0
    volatile hw_ipu_di1_sw_gen0_5_t DI1_SW_GEN0_5; //!< DI1 Sync Wave Gen 5 Register 0
    volatile hw_ipu_di1_sw_gen0_6_t DI1_SW_GEN0_6; //!< DI1 Sync Wave Gen 6 Register 0
    volatile hw_ipu_di1_sw_gen0_7_t DI1_SW_GEN0_7; //!< DI1 Sync Wave Gen 7 Register 0
    volatile hw_ipu_di1_sw_gen0_8_t DI1_SW_GEN0_8; //!< DI1 Sync Wave Gen 8 Register 0
    volatile hw_ipu_di1_sw_gen0_9_t DI1_SW_GEN0_9; //!< DI1Sync Wave Gen 9 Register 0
    volatile hw_ipu_di1_sw_gen1_1_t DI1_SW_GEN1_1; //!< DI1 Sync Wave Gen 1 Register 1
    volatile hw_ipu_di1_sw_gen1_2_t DI1_SW_GEN1_2; //!< DI1 Sync Wave Gen 2 Register 1
    volatile hw_ipu_di1_sw_gen1_3_t DI1_SW_GEN1_3; //!< DI1 Sync Wave Gen 3 Register 1
    volatile hw_ipu_di1_sw_gen1_4_t DI1_SW_GEN1_4; //!< DI1 Sync Wave Gen 4 Register 1
    volatile hw_ipu_di1_sw_gen1_5_t DI1_SW_GEN1_5; //!< DI1 Sync Wave Gen 5 Register 1
    volatile hw_ipu_di1_sw_gen1_6_t DI1_SW_GEN1_6; //!< DI1 Sync Wave Gen 6 Register 1
    volatile hw_ipu_di1_sw_gen1_7_t DI1_SW_GEN1_7; //!< DI1Sync Wave Gen 7 Register 1
    volatile hw_ipu_di1_sw_gen1_8_t DI1_SW_GEN1_8; //!< DI1 Sync Wave Gen 8 Register 1
    volatile hw_ipu_di1_sw_gen1_9_t DI1_SW_GEN1_9; //!< DI1 Sync Wave Gen 9 Register 1
    volatile hw_ipu_di1_sync_as_gen_t DI1_SYNC_AS_GEN; //!< DI1 Sync Assistance Gen Register
    volatile hw_ipu_di1_dw_gen_i_t DI1_DW_GEN_I; //!< DI1 Data Wave Gen <i> Register
    reg32_t _reserved47[11];
    volatile hw_ipu_di1_dw_set0_i_t DI1_DW_SET0_I; //!< DI1 Data Wave Set 0 <i> Register
    reg32_t _reserved48[11];
    volatile hw_ipu_di1_dw_set1_i_t DI1_DW_SET1_I; //!< DI1 Data Wave Set 1 <i> Register
    reg32_t _reserved49[11];
    volatile hw_ipu_di1_dw_set2_i_t DI1_DW_SET2_I; //!< DI1 Data Wave Set 2 <i> Register
    reg32_t _reserved50[11];
    volatile hw_ipu_di1_dw_set3_i_t DI1_DW_SET3_I; //!< DI1 Data Wave Set 3 <i> Register
    reg32_t _reserved51[11];
    volatile hw_ipu_d1_stp_rep_i_t D1_STP_REP_I; //!< DI1 Step Repeat <i> Registers
    reg32_t _reserved52[3];
    volatile hw_ipu_di1_stp_rep_9_t DI1_STP_REP_9; //!< DI1Step Repeat 9 Registers
    volatile hw_ipu_di1_ser_conf_t DI1_SER_CONF; //!< DI1 Serial Display Control Register
    volatile hw_ipu_di1_ssc_t DI1_SSC; //!< DI1 Special Signals Control Register
    volatile hw_ipu_di1_pol_t DI1_POL; //!< DI1 Polarity Register
    volatile hw_ipu_di1_aw0_t DI1_AW0; //!< DI1Active Window 0 Register
    volatile hw_ipu_di1_aw1_t DI1_AW1; //!< DI1 Active Window 1 Register
    volatile hw_ipu_di1_scr_conf_t DI1_SCR_CONF; //!< DI1 Screen Configuration Register
    volatile hw_ipu_di1_stat_t DI1_STAT; //!< DI1 Status Register
    reg32_t _reserved53[8098];
    volatile hw_ipu_smfc_map_t SMFC_MAP; //!< SMFC Mapping Register
    volatile hw_ipu_smfc_wmc_t SMFC_WMC; //!< SMFC Watermark Control Register
    volatile hw_ipu_smfc_bs_t SMFC_BS; //!< SMFC Burst Size Register
    reg32_t _reserved54[8189];
    volatile hw_ipu_dc_read_ch_conf_t DC_READ_CH_CONF; //!< DC Read Channel Configuration Register
    volatile hw_ipu_dc_read_sh_addr_t DC_READ_SH_ADDR; //!< DC Read Channel Start Address Register
    volatile hw_ipu_dc_rl0_ch_0_t DC_RL0_CH_0; //!< DC Routine Link Register 0 Channel 0
    volatile hw_ipu_dc_rl1_ch_0_t DC_RL1_CH_0; //!< DC Routine Link Register 1 Channel 0
    reg32_t _reserved55;
    volatile hw_ipu_dc_rl3_ch_0_t DC_RL3_CH_0; //!< DC Routine Link Registe3 Channel 0
    volatile hw_ipu_dc_rl4_ch_0_t DC_RL4_CH_0; //!< DC Routine Link Register 4 Channel 0
    volatile hw_ipu_dc_wr_ch_conf_1_t DC_WR_CH_CONF_1; //!< DC Write Channel 1 Configuration Register
    volatile hw_ipu_dc_rl2_ch_0_t DC_RL2_CH_0; //!< DC Routine Link Register2 Channel 0
    volatile hw_ipu_dc_rl0_ch_1_t DC_RL0_CH_1; //!< DC Routine Link Register 0 Channel 1
    volatile hw_ipu_dc_rl1_ch_1_t DC_RL1_CH_1; //!< DC Routine Link Register 1 Channel 1
    reg32_t _reserved56;
    volatile hw_ipu_dc_rl2_ch_1_t DC_RL2_CH_1; //!< DC Routine Link Register 2 Channel 1
    volatile hw_ipu_dc_rl3_ch_1_t DC_RL3_CH_1; //!< DC Routine Link Register 3 Channel 1
    volatile hw_ipu_dc_rl4_ch_1_t DC_RL4_CH_1; //!< DC Routine Link Register 4 Channel 1
    volatile hw_ipu_dc_wr_ch_conf_2_t DC_WR_CH_CONF_2; //!< DC Write Channel 2 Configuration Register
    volatile hw_ipu_dc_wr_ch_addr_2_t DC_WR_CH_ADDR_2; //!< DC Write Channel 2 Address Configuration Register
    volatile hw_ipu_dc_rl0_ch_2_t DC_RL0_CH_2; //!< DC Routine Link Register 0 Channel 2
    volatile hw_ipu_dc_rl1_ch_2_t DC_RL1_CH_2; //!< DC Routine Link Register 1 Channel 2
    volatile hw_ipu_dc_rl3_ch_2_t DC_RL3_CH_2; //!< DC Routine Link Register 3 Channel 2
    volatile hw_ipu_dc_rl4_ch_2_t DC_RL4_CH_2; //!< DC Routine Link Register 4 Channel 2
    volatile hw_ipu_dc_cmd_ch_conf_3_t DC_CMD_CH_CONF_3; //!< DC Command Channel 3 Configuration Register
    volatile hw_ipu_dc_cmd_ch_conf_4_t DC_CMD_CH_CONF_4; //!< DC Command Channel 4 Configuration Register
    volatile hw_ipu_dc_wr_ch_conf_5_t DC_WR_CH_CONF_5; //!< DC Write Channel 5Configuration Register
    volatile hw_ipu_dc_wr_ch_addr_5_t DC_WR_CH_ADDR_5; //!< DC Write Channel 5Address Configuration Register
    volatile hw_ipu_dc_rl0_ch_5_t DC_RL0_CH_5; //!< DC Routine Link Register 0 Channel 5
    volatile hw_ipu_dc_rl1_ch_5_t DC_RL1_CH_5; //!< DC Routine Link Register 1 Channel 5
    volatile hw_ipu_dc_rl2_ch_5_t DC_RL2_CH_5; //!< DC Routine Link Register 2 Channel 5
    volatile hw_ipu_dc_rl3_ch_5_t DC_RL3_CH_5; //!< DC Routine Link Register3 Channel 5
    volatile hw_ipu_dc_rl4_ch_5_t DC_RL4_CH_5; //!< DC Routine Link Register 4 Channel 5
    volatile hw_ipu_dc_wr_ch_conf_6_t DC_WR_CH_CONF_6; //!< DC Write Channel 6 Configuration Register
    volatile hw_ipu_dc_wr_ch_addr_6_t DC_WR_CH_ADDR_6; //!< DC Write Channel 6 Address Configuration Register
    volatile hw_ipu_dc_rl0_ch_6_t DC_RL0_CH_6; //!< DC Routine Link Register 0Channel 6
    volatile hw_ipu_dc_rl1_ch_6_t DC_RL1_CH_6; //!< DC Routine Link Register 1 Channel 6
    volatile hw_ipu_dc_rl2_ch_6_t DC_RL2_CH_6; //!< DC Routine Link Register 2 Channel 6
    volatile hw_ipu_dc_rl3_ch_6_t DC_RL3_CH_6; //!< DC Routine Link Register 3 Channel 6
    volatile hw_ipu_dc_rl4_ch_6_t DC_RL4_CH_6; //!< DC Routine Link Register 4 Channel 6
    volatile hw_ipu_dc_wr_ch_conf1_8_t DC_WR_CH_CONF1_8; //!< DC Write Channel 8 Configuration 1Register
    volatile hw_ipu_dc_wr_ch_conf2_8_t DC_WR_CH_CONF2_8; //!< DC Write Channel 8 Configuration 2 Register
    volatile hw_ipu_dc_rl1_ch_8_t DC_RL1_CH_8; //!< DC Routine Link Register 1 Channel 8
    volatile hw_ipu_dc_rl2_ch_8_t DC_RL2_CH_8; //!< DC Routine Link Register 2 Channel 8
    volatile hw_ipu_dc_rl3_ch_8_t DC_RL3_CH_8; //!< DC Routine Link Register 3 Channel 8
    volatile hw_ipu_dc_rl4_ch_8_t DC_RL4_CH_8; //!< DC Routine Link Register 4 Channel 8
    volatile hw_ipu_dc_rl5_ch_8_t DC_RL5_CH_8; //!< DC Routine Link Register 5 Channel 8
    volatile hw_ipu_dc_rl6_ch_8_t DC_RL6_CH_8; //!< DC Routine Link Register 6 Channel 8
    volatile hw_ipu_dc_wr_ch_conf1_9_t DC_WR_CH_CONF1_9; //!< DC Write Channel 9 Configuration 1Register
    volatile hw_ipu_dc_wr_ch_conf2_9_t DC_WR_CH_CONF2_9; //!< DC Write Channel 9Configuration 2Register
    volatile hw_ipu_dc_rl1_ch_9_t DC_RL1_CH_9; //!< DC Routine Link Register 1 Channel 9
    volatile hw_ipu_dc_rl2_ch_9_t DC_RL2_CH_9; //!< DC Routine Link Register 2 Channel 9
    volatile hw_ipu_dc_rl3_ch_9_t DC_RL3_CH_9; //!< DC Routine Link Register 3Channel 9
    volatile hw_ipu_dc_rl4_ch_9_t DC_RL4_CH_9; //!< DC Routine Link Register 4 Channel 9
    volatile hw_ipu_dc_rl5_ch_9_t DC_RL5_CH_9; //!< DC Routine Link Register 5 Channel 9
    volatile hw_ipu_dc_rl6_ch_9_t DC_RL6_CH_9; //!< DC Routine Link Register 6 Channel 9
    volatile hw_ipu_dc_gen_t DC_GEN; //!< DC General Register
    volatile hw_ipu_dc_disp_conf1_0_t DC_DISP_CONF1_0; //!< DC Display Configuration 1 Register 0
    volatile hw_ipu_dc_disp_conf1_1_t DC_DISP_CONF1_1; //!< DC Display Configuration 1 Register 1
    volatile hw_ipu_dc_disp_conf1_2_t DC_DISP_CONF1_2; //!< DC Display Configuration 1 Register 2
    volatile hw_ipu_dc_disp_conf1_3_t DC_DISP_CONF1_3; //!< DC Display Configuration 1 Register 3
    volatile hw_ipu_dc_disp_conf2_0_t DC_DISP_CONF2_0; //!< DC Display Configuration 2 Register 0
    reg32_t _reserved57;
    volatile hw_ipu_dc_disp_conf2_2_t DC_DISP_CONF2_2; //!< DC Display Configuration 2 Register 2
    volatile hw_ipu_dc_disp_conf2_3_t DC_DISP_CONF2_3; //!< DC Display Configuration 2 Register 3
    volatile hw_ipu_dc_di0_conf_1_t DC_DI0_CONF_1; //!< DC DI0Configuration Register 1
    volatile hw_ipu_dc_di0_conf_2_t DC_DI0_CONF_2; //!< DC DI0Configuration Register 2
    volatile hw_ipu_dc_di1_conf_1_t DC_DI1_CONF_1; //!< DC DI1Configuration Register 1
    volatile hw_ipu_dc_di1_conf_2_t DC_DI1_CONF_2; //!< DC DI1Configuration Register 2
    volatile hw_ipu_dc_map_conf_0_t DC_MAP_CONF_0; //!< DC Mapping Configuration Register 0
    volatile hw_ipu_dc_map_conf_1_t DC_MAP_CONF_1; //!< DC Mapping Configuration Register 1
    volatile hw_ipu_dc_map_conf_2_t DC_MAP_CONF_2; //!< DC Mapping Configuration Register 2
    volatile hw_ipu_dc_map_conf_3_t DC_MAP_CONF_3; //!< DC Mapping Configuration Register 3
    volatile hw_ipu_dc_map_conf_4_t DC_MAP_CONF_4; //!< DC Mapping Configuration Register 4
    volatile hw_ipu_dc_map_conf_5_t DC_MAP_CONF_5; //!< DC Mapping Configuration Register 5
    volatile hw_ipu_dc_map_conf_6_t DC_MAP_CONF_6; //!< DC Mapping Configuration Register 6
    volatile hw_ipu_dc_map_conf_7_t DC_MAP_CONF_7; //!< DC Mapping Configuration Register 7
    volatile hw_ipu_dc_map_conf_8_t DC_MAP_CONF_8; //!< DC Mapping Configuration Register 8
    volatile hw_ipu_dc_map_conf_9_t DC_MAP_CONF_9; //!< DC Mapping Configuration Register 9
    volatile hw_ipu_dc_map_conf_10_t DC_MAP_CONF_10; //!< DC Mapping Configuration Register 10
    volatile hw_ipu_dc_map_conf_11_t DC_MAP_CONF_11; //!< DC Mapping Configuration Register 11
    volatile hw_ipu_dc_map_conf_12_t DC_MAP_CONF_12; //!< DC Mapping Configuration Register 12
    volatile hw_ipu_dc_map_conf_13_t DC_MAP_CONF_13; //!< DC Mapping Configuration Register 13
    volatile hw_ipu_dc_map_conf_14_t DC_MAP_CONF_14; //!< DC Mapping Configuration Register 14
    volatile hw_ipu_dc_map_conf_15_t DC_MAP_CONF_15; //!< DC Mapping Configuration Register 15
    volatile hw_ipu_dc_map_conf_16_t DC_MAP_CONF_16; //!< DC Mapping Configuration Register 16
    volatile hw_ipu_dc_map_conf_17_t DC_MAP_CONF_17; //!< DC Mapping Configuration Register 17
    volatile hw_ipu_dc_map_conf_18_t DC_MAP_CONF_18; //!< DC Mapping Configuration Register 18
    volatile hw_ipu_dc_map_conf_19_t DC_MAP_CONF_19; //!< DC Mapping Configuration Register 19
    volatile hw_ipu_dc_map_conf_20_t DC_MAP_CONF_20; //!< DC Mapping Configuration Register 20
    volatile hw_ipu_dc_map_conf_21_t DC_MAP_CONF_21; //!< DC Mapping Configuration Register 21
    volatile hw_ipu_dc_map_conf_22_t DC_MAP_CONF_22; //!< DC Mapping Configuration Register 22
    volatile hw_ipu_dc_map_conf_23_t DC_MAP_CONF_23; //!< DC Mapping Configuration Register 23
    volatile hw_ipu_dc_map_conf_24_t DC_MAP_CONF_24; //!< DC Mapping Configuration Register 24
    volatile hw_ipu_dc_map_conf_25_t DC_MAP_CONF_25; //!< DC Mapping Configuration Register 25
    volatile hw_ipu_dc_map_conf_26_t DC_MAP_CONF_26; //!< DC Mapping Configuration Register 26
    volatile hw_ipu_dc_ugde0_0_t DC_UGDE0_0; //!< DC User General Data Event 0 Register 0
    volatile hw_ipu_dc_ugde0_1_t DC_UGDE0_1; //!< DC User General Data Event 0 Register 1
    volatile hw_ipu_dc_ugde0_2_t DC_UGDE0_2; //!< DC User General Data Event 0 Register2
    volatile hw_ipu_dc_ugde0_3_t DC_UGDE0_3; //!< DC User General Data Event 0 Register 3
    volatile hw_ipu_dc_ugde1_0_t DC_UGDE1_0; //!< DC User General Data Event 1Register0
    volatile hw_ipu_dc_ugde1_1_t DC_UGDE1_1; //!< DC User General Data Event 1 Register 1
    volatile hw_ipu_dc_ugde1_2_t DC_UGDE1_2; //!< DC User General Data Event 1Register 2
    volatile hw_ipu_dc_ugde1_3_t DC_UGDE1_3; //!< DC User General Data Event 1Register 3
    volatile hw_ipu_dc_ugde2_0_t DC_UGDE2_0; //!< DC User General Data Event 2 Register 0
    volatile hw_ipu_dc_ugde2_1_t DC_UGDE2_1; //!< DC User General Data Event 2 Register 1
    volatile hw_ipu_dc_ugde2_2_t DC_UGDE2_2; //!< DC User General Data Event 2Register 2
    volatile hw_ipu_dc_ugde2_3_t DC_UGDE2_3; //!< DC User General Data Event 2Register 3
    volatile hw_ipu_dc_ugde3_0_t DC_UGDE3_0; //!< DC User General Data Event 3Register 0
    volatile hw_ipu_dc_ugde3_1_t DC_UGDE3_1; //!< DC User General Data Event 3Register 1
    volatile hw_ipu_dc_ugde3_2_t DC_UGDE3_2; //!< DC User General Data Event 3Register 2
    volatile hw_ipu_dc_ugde3_3_t DC_UGDE3_3; //!< DC User General Data Event 3Register 2
    volatile hw_ipu_dc_lla0_t DC_LLA0; //!< DC Low Level Access Control Register 0
    volatile hw_ipu_dc_lla1_t DC_LLA1; //!< DC Low Level Access Control Register 1
    volatile hw_ipu_dc_r_lla0_t DC_R_LLA0; //!< DC Read Low Level Read Access Control Register 0
    volatile hw_ipu_dc_r_lla1_t DC_R_LLA1; //!< DC Read Low Level Read Access Control Register1
    volatile hw_ipu_dc_wr_ch_addr_5_alt_t DC_WR_CH_ADDR_5_ALT; //!< DC Write Channel 5 Configuration Register
    volatile hw_ipu_dc_stat_t DC_STAT; //!< DC Status Register
    reg32_t _reserved58[968];
    volatile hw_ipu_dc_disp_conf2_1_t DC_DISP_CONF2_1; //!< DC Display Configuration 2 Register 1
    reg32_t _reserved59[7108];
    volatile hw_ipu_dmfc_rd_chan_t DMFC_RD_CHAN; //!< DMFC Read Channel Register
    volatile hw_ipu_dmfc_wr_chan_t DMFC_WR_CHAN; //!< DMFC Write Channel Register
    volatile hw_ipu_dmfc_wr_chan_def_t DMFC_WR_CHAN_DEF; //!< DMFC Write Channel Definition Register
    volatile hw_ipu_dmfc_dp_chan_t DMFC_DP_CHAN; //!< DMFC Display Processor Channel Register
    volatile hw_ipu_dmfc_dp_chan_def_t DMFC_DP_CHAN_DEF; //!< DMFC Display Processor Channel Definition Register
    volatile hw_ipu_dmfc_general_1_t DMFC_GENERAL_1; //!< DMFC General 1 Register
    volatile hw_ipu_dmfc_general_2_t DMFC_GENERAL_2; //!< DMFC General 2 Register
    volatile hw_ipu_dmfc_ic_ctrl_t DMFC_IC_CTRL; //!< DMFC IC Interface Control Register
    volatile hw_ipu_dmfc_wr_chan_alt_t DMFC_WR_CHAN_ALT; //!< DMFC Write Channel Alternate Register
    volatile hw_ipu_dmfc_wr_chan_def_alt_t DMFC_WR_CHAN_DEF_ALT; //!< DMFC Write Channel Definition Alternate Register
    volatile hw_ipu_dmfc_dp_chan_alt_t DMFC_DP_CHAN_ALT; //!< DMFC MFC Display Processor Channel Alternate Register
    volatile hw_ipu_dmfc_dp_chan_def_alt_t DMFC_DP_CHAN_DEF_ALT; //!< DMFC Display Channel Definition Alternate Register
    volatile hw_ipu_dmfc_general1_alt_t DMFC_GENERAL1_ALT; //!< DMFC General 1 Alternate Register
    volatile hw_ipu_dmfc_stat_t DMFC_STAT; //!< DMFC Status Register
    reg32_t _reserved60[8178];
    volatile hw_ipu_vdi_fsize_t VDI_FSIZE; //!< VDI Field Size Register
    volatile hw_ipu_vdi_c_t VDI_C; //!< VDI Control Register
    volatile hw_ipu_vdi_c2__t VDI_C2_; //!< VDI Control Register 2
    volatile hw_ipu_vdi_cmdp_1_t VDI_CMDP_1; //!< VDI Combining Parameters Register 1
    volatile hw_ipu_vdi_cmdp_2_t VDI_CMDP_2; //!< VDI Combining Parameters Register 2
    volatile hw_ipu_vdi_ps_1_t VDI_PS_1; //!< VDI Plane Size Register 1
    volatile hw_ipu_vdi_ps_2_t VDI_PS_2; //!< VDI Plane Size Register 2
    volatile hw_ipu_vdi_ps_3_t VDI_PS_3; //!< VDI Plane Size Register 3
    volatile hw_ipu_vdi_ps_4_t VDI_PS_4; //!< VDI Plane Size Register 4
    reg32_t _reserved61[24730];
    volatile hw_ipu_idmac_sub_addr_0_t IDMAC_SUB_ADDR_0; //!< IDMAC Channel Alternate Address 0 Register
    reg32_t _reserved62[31];
    volatile hw_ipu_idmac_sub_addr_4_t IDMAC_SUB_ADDR_4; //!< IDMAC Channel Alternate Address 4 Register
    reg32_t _reserved63[1968712];
    volatile hw_ipu_idmac_sub_addr_1_t IDMAC_SUB_ADDR_1; //!< IDMAC Channel Alternate Address 1 Register
    reg32_t _reserved64[2159859];
    volatile hw_ipu_dp_com_conf_sync_t DP_COM_CONF_SYNC; //!< DP Common Configuration Sync Flow Register
    volatile hw_ipu_dp_graph_wind_ctrl_sync_t DP_GRAPH_WIND_CTRL_SYNC; //!< DP Graphic Window Control Sync Flow Register
    volatile hw_ipu_dp_fg_pos_sync_t DP_FG_POS_SYNC; //!< DP Partial Plane Window Position Sync Flow Register
    volatile hw_ipu_dp_cur_pos_sync_t DP_CUR_POS_SYNC; //!< DP Cursor Position and Size Sync Flow Register
    volatile hw_ipu_dp_cur_map_sync_t DP_CUR_MAP_SYNC; //!< DP Color Cursor Mapping Sync Flow Register
    volatile hw_ipu_dp_gamma_c_sync_i_t DP_GAMMA_C_SYNC_I; //!< DP Gamma Constants Sync Flow Register i
    reg32_t _reserved65[7];
    volatile hw_ipu_dp_gamma_s_sync_i_t DP_GAMMA_S_SYNC_I; //!< DP Gamma Correction Slope Sync Flow Register i
    reg32_t _reserved66[3];
    volatile hw_ipu_dp_csca_sync_i_t DP_CSCA_SYNC_I; //!< DP Color Space Conversion Control Sync Flow Registers
    reg32_t _reserved67[3];
    volatile hw_ipu_dp_scs_sync_0_t DP_SCS_SYNC_0; //!< DP Color Conversion Control Sync Flow Register 0
    volatile hw_ipu_dp_scs_sync_1_t DP_SCS_SYNC_1; //!< DP Color Conversion Control Sync Flow Register 1
    volatile hw_ipu_dp_cur_pos_alt_t DP_CUR_POS_ALT; //!< DP Cursor Position and Size Alternate Register
    volatile hw_ipu_dp_com_conf_async0_t DP_COM_CONF_ASYNC0; //!< DP Common Configuration Async 0 Flow Register
    volatile hw_ipu_dp_graph_wind_ctrl_async0_t DP_GRAPH_WIND_CTRL_ASYNC0; //!< DP Graphic Window Control Async 0 Flow Register
    volatile hw_ipu_dp_fg_pos_async0_t DP_FG_POS_ASYNC0; //!< DP Partial Plane Window Position Async 0 Flow Register
    volatile hw_ipu_dp_cur_pos_async0_t DP_CUR_POS_ASYNC0; //!< DP Cursor Position and Size Async 0 Flow Register
    volatile hw_ipu_dp_cur_map_async0_t DP_CUR_MAP_ASYNC0; //!< DP Color Cursor Mapping Async 0 Flow Register
    volatile hw_ipu_dp_gamma_c_async0_i_t DP_GAMMA_C_ASYNC0_I; //!< DP Gamma Constant Async 0 Flow Register i
    reg32_t _reserved68[7];
    volatile hw_ipu_dp_gamma_s_async0_i_t DP_GAMMA_S_ASYNC0_I; //!< DP Gamma Correction Slope Async 0 Flow Register i
    reg32_t _reserved69[3];
    volatile hw_ipu_dp_csca_async0_i_t DP_CSCA_ASYNC0_I; //!< DP Color Space Conversion Control Async 0 Flow Register i
    reg32_t _reserved70[3];
    volatile hw_ipu_dp_csc_async0_0_t DP_CSC_ASYNC0_0; //!< DP Color Conversion Control Async 0 Flow Register 0
    volatile hw_ipu_dp_csc_async_1_t DP_CSC_ASYNC_1; //!< DP Color Conversion Control Async 1 Flow Register
    volatile hw_ipu_dp_com_conf_async1_t DP_COM_CONF_ASYNC1; //!< DP Common Configuration Async 1 Flow Register
    volatile hw_ipu_dp_graph_wind_ctrl_async1_t DP_GRAPH_WIND_CTRL_ASYNC1; //!< DP Graphic Window Control Async 1 Flow Register
    volatile hw_ipu_dp_fg_pos_async1_t DP_FG_POS_ASYNC1; //!< DP Partial Plane Window Position Async 1 Flow Register
    volatile hw_ipu_dp_cur_pos_async1_t DP_CUR_POS_ASYNC1; //!< DP Cursor Postion and Size Async 1 Flow Register
    volatile hw_ipu_dp_cur_map_async1_t DP_CUR_MAP_ASYNC1; //!< DP Color Cursor Mapping Async 1 Flow Register
    volatile hw_ipu_dp_gamma_c_async1_i_t DP_GAMMA_C_ASYNC1_I; //!< DP Gamma Constants Async 1 Flow Register i
    reg32_t _reserved71[7];
    volatile hw_ipu_dp_gamma_s_asyn1_i_t DP_GAMMA_S_ASYN1_I; //!< DP Gamma Correction Slope Async 1 Flow Register i
    reg32_t _reserved72[3];
    volatile hw_ipu_dp_csca_async1_i_t DP_CSCA_ASYNC1_I; //!< DP Color Space Converstion Control Async 1 Flow Register i
    reg32_t _reserved73[3];
    volatile hw_ipu_dp_csc_async1_0_t DP_CSC_ASYNC1_0; //!< DP Color Conversion Control Async 1 Flow Register 0
    volatile hw_ipu_dp_csc_async1_1_t DP_CSC_ASYNC1_1; //!< DP Color Conversion Control Async 1 Flow Register 1
    reg32_t _reserved74[15836201];
    volatile hw_ipu_idmac_bndm_en_2_t IDMAC_BNDM_EN_2; //!< IDMAC Band Mode Enable 2 Register
    reg32_t _reserved75[517762466];
    volatile hw_ipu_idmac_sc_cord_t IDMAC_SC_CORD; //!< IDMAC Scroll Coordinations Register
} hw_ipu_t
#endif

//! @brief Macro to access all IPU registers.
//! @param x IPU instance number.
//! @return Reference (not a pointer) to the registers struct. To get a pointer to the struct,
//!     use the '&' operator, like <code>&HW_IPU(0)</code>.
#define HW_IPU(x)     (*(volatile hw_ipu_t *) REGS_IPU_BASE(x))


#endif // _IPU_H
